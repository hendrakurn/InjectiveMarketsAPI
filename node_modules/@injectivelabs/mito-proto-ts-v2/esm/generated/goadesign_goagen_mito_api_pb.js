import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
class GetVaultsRequest$Type extends MessageType {
  constructor() {
    super("mito_api.GetVaultsRequest", [
      {
        no: 1,
        name: "limit",
        kind: "scalar",
        opt: true,
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 2,
        name: "page_index",
        kind: "scalar",
        opt: true,
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 3,
        name: "code_id",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 limit */
        1:
          message.limit = reader.uint32();
          break;
        case /* optional uint32 page_index */
        2:
          message.pageIndex = reader.uint32();
          break;
        case /* optional uint64 code_id */
        3:
          message.codeId = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.limit !== void 0)
      writer.tag(1, WireType.Varint).uint32(message.limit);
    if (message.pageIndex !== void 0)
      writer.tag(2, WireType.Varint).uint32(message.pageIndex);
    if (message.codeId !== void 0)
      writer.tag(3, WireType.Varint).uint64(message.codeId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetVaultsRequest = new GetVaultsRequest$Type();
class GetVaultsResponse$Type extends MessageType {
  constructor() {
    super("mito_api.GetVaultsResponse", [
      { no: 1, name: "vaults", kind: "message", repeat: 2, T: () => Vault },
      { no: 2, name: "pagination", kind: "message", T: () => Pagination }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.vaults = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated mito_api.Vault vaults */
        1:
          message.vaults.push(Vault.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* mito_api.Pagination pagination */
        2:
          message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.vaults.length; i++)
      Vault.internalBinaryWrite(message.vaults[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.pagination)
      Pagination.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetVaultsResponse = new GetVaultsResponse$Type();
class Vault$Type extends MessageType {
  constructor() {
    super("mito_api.Vault", [
      {
        no: 1,
        name: "contract_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "code_id",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "vault_name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "current_tvl",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      { no: 6, name: "profits", kind: "message", T: () => Changes },
      {
        no: 7,
        name: "updated_at",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 8,
        name: "vault_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "lp_token_price",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      { no: 10, name: "subaccount_info", kind: "message", T: () => SubaccountBalance },
      {
        no: 11,
        name: "master_contract_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 12,
        name: "total_lp_amount",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 13,
        name: "slug",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 14,
        name: "created_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 15,
        name: "notional_value_cap",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 16, name: "tvl_changes", kind: "message", T: () => Changes },
      {
        no: 17,
        name: "apy",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 18,
        name: "apy7_d",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 19,
        name: "apy7_d_fq",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 20,
        name: "apyue",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 21,
        name: "apy_v3",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 22,
        name: "registration_mode",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.contractAddress = "";
    message.codeId = 0n;
    message.vaultName = "";
    message.marketId = "";
    message.currentTvl = 0;
    message.updatedAt = 0n;
    message.vaultType = "";
    message.lpTokenPrice = 0;
    message.masterContractAddress = "";
    message.totalLpAmount = "";
    message.slug = "";
    message.createdAt = 0n;
    message.notionalValueCap = "";
    message.apy = 0;
    message.apy7D = 0;
    message.apy7DFq = 0;
    message.apyue = 0;
    message.apyV3 = 0;
    message.registrationMode = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string contract_address */
        1:
          message.contractAddress = reader.string();
          break;
        case /* uint64 code_id */
        2:
          message.codeId = reader.uint64().toBigInt();
          break;
        case /* string vault_name */
        3:
          message.vaultName = reader.string();
          break;
        case /* string market_id */
        4:
          message.marketId = reader.string();
          break;
        case /* double current_tvl */
        5:
          message.currentTvl = reader.double();
          break;
        case /* mito_api.Changes profits */
        6:
          message.profits = Changes.internalBinaryRead(reader, reader.uint32(), options, message.profits);
          break;
        case /* uint64 updated_at */
        7:
          message.updatedAt = reader.uint64().toBigInt();
          break;
        case /* string vault_type */
        8:
          message.vaultType = reader.string();
          break;
        case /* double lp_token_price */
        9:
          message.lpTokenPrice = reader.double();
          break;
        case /* mito_api.SubaccountBalance subaccount_info */
        10:
          message.subaccountInfo = SubaccountBalance.internalBinaryRead(reader, reader.uint32(), options, message.subaccountInfo);
          break;
        case /* string master_contract_address */
        11:
          message.masterContractAddress = reader.string();
          break;
        case /* string total_lp_amount */
        12:
          message.totalLpAmount = reader.string();
          break;
        case /* string slug */
        13:
          message.slug = reader.string();
          break;
        case /* sint64 created_at */
        14:
          message.createdAt = reader.sint64().toBigInt();
          break;
        case /* string notional_value_cap */
        15:
          message.notionalValueCap = reader.string();
          break;
        case /* mito_api.Changes tvl_changes */
        16:
          message.tvlChanges = Changes.internalBinaryRead(reader, reader.uint32(), options, message.tvlChanges);
          break;
        case /* double apy */
        17:
          message.apy = reader.double();
          break;
        case /* double apy7_d */
        18:
          message.apy7D = reader.double();
          break;
        case /* double apy7_d_fq */
        19:
          message.apy7DFq = reader.double();
          break;
        case /* double apyue */
        20:
          message.apyue = reader.double();
          break;
        case /* double apy_v3 */
        21:
          message.apyV3 = reader.double();
          break;
        case /* string registration_mode */
        22:
          message.registrationMode = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.contractAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.contractAddress);
    if (message.codeId !== 0n)
      writer.tag(2, WireType.Varint).uint64(message.codeId);
    if (message.vaultName !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.vaultName);
    if (message.marketId !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.marketId);
    if (message.currentTvl !== 0)
      writer.tag(5, WireType.Bit64).double(message.currentTvl);
    if (message.profits)
      Changes.internalBinaryWrite(message.profits, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
    if (message.updatedAt !== 0n)
      writer.tag(7, WireType.Varint).uint64(message.updatedAt);
    if (message.vaultType !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.vaultType);
    if (message.lpTokenPrice !== 0)
      writer.tag(9, WireType.Bit64).double(message.lpTokenPrice);
    if (message.subaccountInfo)
      SubaccountBalance.internalBinaryWrite(message.subaccountInfo, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
    if (message.masterContractAddress !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.masterContractAddress);
    if (message.totalLpAmount !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.totalLpAmount);
    if (message.slug !== "")
      writer.tag(13, WireType.LengthDelimited).string(message.slug);
    if (message.createdAt !== 0n)
      writer.tag(14, WireType.Varint).sint64(message.createdAt);
    if (message.notionalValueCap !== "")
      writer.tag(15, WireType.LengthDelimited).string(message.notionalValueCap);
    if (message.tvlChanges)
      Changes.internalBinaryWrite(message.tvlChanges, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
    if (message.apy !== 0)
      writer.tag(17, WireType.Bit64).double(message.apy);
    if (message.apy7D !== 0)
      writer.tag(18, WireType.Bit64).double(message.apy7D);
    if (message.apy7DFq !== 0)
      writer.tag(19, WireType.Bit64).double(message.apy7DFq);
    if (message.apyue !== 0)
      writer.tag(20, WireType.Bit64).double(message.apyue);
    if (message.apyV3 !== 0)
      writer.tag(21, WireType.Bit64).double(message.apyV3);
    if (message.registrationMode !== "")
      writer.tag(22, WireType.LengthDelimited).string(message.registrationMode);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Vault = new Vault$Type();
class Changes$Type extends MessageType {
  constructor() {
    super("mito_api.Changes", [
      {
        no: 1,
        name: "all_time_change",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 2,
        name: "three_months_change",
        kind: "scalar",
        opt: true,
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 3,
        name: "one_month_change",
        kind: "scalar",
        opt: true,
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 4,
        name: "one_day_change",
        kind: "scalar",
        opt: true,
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 5,
        name: "one_week_change",
        kind: "scalar",
        opt: true,
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 6,
        name: "one_year_change",
        kind: "scalar",
        opt: true,
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 7,
        name: "three_years_change",
        kind: "scalar",
        opt: true,
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 8,
        name: "six_months_change",
        kind: "scalar",
        opt: true,
        T: 1
        /*ScalarType.DOUBLE*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.allTimeChange = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* double all_time_change */
        1:
          message.allTimeChange = reader.double();
          break;
        case /* optional double three_months_change */
        2:
          message.threeMonthsChange = reader.double();
          break;
        case /* optional double one_month_change */
        3:
          message.oneMonthChange = reader.double();
          break;
        case /* optional double one_day_change */
        4:
          message.oneDayChange = reader.double();
          break;
        case /* optional double one_week_change */
        5:
          message.oneWeekChange = reader.double();
          break;
        case /* optional double one_year_change */
        6:
          message.oneYearChange = reader.double();
          break;
        case /* optional double three_years_change */
        7:
          message.threeYearsChange = reader.double();
          break;
        case /* optional double six_months_change */
        8:
          message.sixMonthsChange = reader.double();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.allTimeChange !== 0)
      writer.tag(1, WireType.Bit64).double(message.allTimeChange);
    if (message.threeMonthsChange !== void 0)
      writer.tag(2, WireType.Bit64).double(message.threeMonthsChange);
    if (message.oneMonthChange !== void 0)
      writer.tag(3, WireType.Bit64).double(message.oneMonthChange);
    if (message.oneDayChange !== void 0)
      writer.tag(4, WireType.Bit64).double(message.oneDayChange);
    if (message.oneWeekChange !== void 0)
      writer.tag(5, WireType.Bit64).double(message.oneWeekChange);
    if (message.oneYearChange !== void 0)
      writer.tag(6, WireType.Bit64).double(message.oneYearChange);
    if (message.threeYearsChange !== void 0)
      writer.tag(7, WireType.Bit64).double(message.threeYearsChange);
    if (message.sixMonthsChange !== void 0)
      writer.tag(8, WireType.Bit64).double(message.sixMonthsChange);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Changes = new Changes$Type();
class SubaccountBalance$Type extends MessageType {
  constructor() {
    super("mito_api.SubaccountBalance", [
      {
        no: 1,
        name: "subaccount_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "balances", kind: "message", repeat: 2, T: () => DenomBalance }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subaccountId = "";
    message.balances = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string subaccount_id */
        1:
          message.subaccountId = reader.string();
          break;
        case /* repeated mito_api.DenomBalance balances */
        2:
          message.balances.push(DenomBalance.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subaccountId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.subaccountId);
    for (let i = 0; i < message.balances.length; i++)
      DenomBalance.internalBinaryWrite(message.balances[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SubaccountBalance = new SubaccountBalance$Type();
class DenomBalance$Type extends MessageType {
  constructor() {
    super("mito_api.DenomBalance", [
      {
        no: 1,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "total_balance",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "price",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "updated_at",
        kind: "scalar",
        opt: true,
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "source",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.denom = "";
    message.totalBalance = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string denom */
        1:
          message.denom = reader.string();
          break;
        case /* string total_balance */
        2:
          message.totalBalance = reader.string();
          break;
        case /* optional string price */
        3:
          message.price = reader.string();
          break;
        case /* optional sint64 updated_at */
        4:
          message.updatedAt = reader.sint64().toBigInt();
          break;
        case /* optional string source */
        5:
          message.source = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.denom !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.denom);
    if (message.totalBalance !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.totalBalance);
    if (message.price !== void 0)
      writer.tag(3, WireType.LengthDelimited).string(message.price);
    if (message.updatedAt !== void 0)
      writer.tag(4, WireType.Varint).sint64(message.updatedAt);
    if (message.source !== void 0)
      writer.tag(5, WireType.LengthDelimited).string(message.source);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const DenomBalance = new DenomBalance$Type();
class Pagination$Type extends MessageType {
  constructor() {
    super("mito_api.Pagination", [
      {
        no: 1,
        name: "total",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.total = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint32 total */
        1:
          message.total = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.total !== 0)
      writer.tag(1, WireType.Varint).uint32(message.total);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Pagination = new Pagination$Type();
class GetVaultRequest$Type extends MessageType {
  constructor() {
    super("mito_api.GetVaultRequest", [
      {
        no: 1,
        name: "contract_address",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "slug",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string contract_address */
        1:
          message.contractAddress = reader.string();
          break;
        case /* optional string slug */
        2:
          message.slug = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.contractAddress !== void 0)
      writer.tag(1, WireType.LengthDelimited).string(message.contractAddress);
    if (message.slug !== void 0)
      writer.tag(2, WireType.LengthDelimited).string(message.slug);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetVaultRequest = new GetVaultRequest$Type();
class GetVaultResponse$Type extends MessageType {
  constructor() {
    super("mito_api.GetVaultResponse", [
      { no: 1, name: "vault", kind: "message", repeat: 2, T: () => Vault }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.vault = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated mito_api.Vault vault */
        1:
          message.vault.push(Vault.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.vault.length; i++)
      Vault.internalBinaryWrite(message.vault[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetVaultResponse = new GetVaultResponse$Type();
class LPTokenPriceChartRequest$Type extends MessageType {
  constructor() {
    super("mito_api.LPTokenPriceChartRequest", [
      {
        no: 1,
        name: "vault_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "from_time",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "to_time",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.vaultAddress = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string vault_address */
        1:
          message.vaultAddress = reader.string();
          break;
        case /* optional uint64 from_time */
        2:
          message.fromTime = reader.uint64().toBigInt();
          break;
        case /* optional uint64 to_time */
        3:
          message.toTime = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.vaultAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.vaultAddress);
    if (message.fromTime !== void 0)
      writer.tag(2, WireType.Varint).uint64(message.fromTime);
    if (message.toTime !== void 0)
      writer.tag(3, WireType.Varint).uint64(message.toTime);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const LPTokenPriceChartRequest = new LPTokenPriceChartRequest$Type();
class LPTokenPriceChartResponse$Type extends MessageType {
  constructor() {
    super("mito_api.LPTokenPriceChartResponse", [
      { no: 1, name: "prices", kind: "message", repeat: 2, T: () => PriceSnapshot }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.prices = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated mito_api.PriceSnapshot prices */
        1:
          message.prices.push(PriceSnapshot.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.prices.length; i++)
      PriceSnapshot.internalBinaryWrite(message.prices[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const LPTokenPriceChartResponse = new LPTokenPriceChartResponse$Type();
class PriceSnapshot$Type extends MessageType {
  constructor() {
    super("mito_api.PriceSnapshot", [
      {
        no: 1,
        name: "price",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 2,
        name: "updated_at",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.price = 0;
    message.updatedAt = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* double price */
        1:
          message.price = reader.double();
          break;
        case /* uint64 updated_at */
        2:
          message.updatedAt = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.price !== 0)
      writer.tag(1, WireType.Bit64).double(message.price);
    if (message.updatedAt !== 0n)
      writer.tag(2, WireType.Varint).uint64(message.updatedAt);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PriceSnapshot = new PriceSnapshot$Type();
class TVLChartRequest$Type extends MessageType {
  constructor() {
    super("mito_api.TVLChartRequest", [
      {
        no: 1,
        name: "vault_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "from_time",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "to_time",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.vaultAddress = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string vault_address */
        1:
          message.vaultAddress = reader.string();
          break;
        case /* optional uint64 from_time */
        2:
          message.fromTime = reader.uint64().toBigInt();
          break;
        case /* optional uint64 to_time */
        3:
          message.toTime = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.vaultAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.vaultAddress);
    if (message.fromTime !== void 0)
      writer.tag(2, WireType.Varint).uint64(message.fromTime);
    if (message.toTime !== void 0)
      writer.tag(3, WireType.Varint).uint64(message.toTime);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TVLChartRequest = new TVLChartRequest$Type();
class TVLChartResponse$Type extends MessageType {
  constructor() {
    super("mito_api.TVLChartResponse", [
      { no: 1, name: "prices", kind: "message", repeat: 2, T: () => PriceSnapshot }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.prices = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated mito_api.PriceSnapshot prices */
        1:
          message.prices.push(PriceSnapshot.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.prices.length; i++)
      PriceSnapshot.internalBinaryWrite(message.prices[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TVLChartResponse = new TVLChartResponse$Type();
class VaultsByHolderAddressRequest$Type extends MessageType {
  constructor() {
    super("mito_api.VaultsByHolderAddressRequest", [
      {
        no: 1,
        name: "limit",
        kind: "scalar",
        opt: true,
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 2,
        name: "page_index",
        kind: "scalar",
        opt: true,
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 3,
        name: "holder_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "vault_address",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "skip",
        kind: "scalar",
        opt: true,
        T: 17
        /*ScalarType.SINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.holderAddress = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 limit */
        1:
          message.limit = reader.uint32();
          break;
        case /* optional uint32 page_index */
        2:
          message.pageIndex = reader.uint32();
          break;
        case /* string holder_address */
        3:
          message.holderAddress = reader.string();
          break;
        case /* optional string vault_address */
        4:
          message.vaultAddress = reader.string();
          break;
        case /* optional sint32 skip */
        5:
          message.skip = reader.sint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.limit !== void 0)
      writer.tag(1, WireType.Varint).uint32(message.limit);
    if (message.pageIndex !== void 0)
      writer.tag(2, WireType.Varint).uint32(message.pageIndex);
    if (message.holderAddress !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.holderAddress);
    if (message.vaultAddress !== void 0)
      writer.tag(4, WireType.LengthDelimited).string(message.vaultAddress);
    if (message.skip !== void 0)
      writer.tag(5, WireType.Varint).sint32(message.skip);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const VaultsByHolderAddressRequest = new VaultsByHolderAddressRequest$Type();
class VaultsByHolderAddressResponse$Type extends MessageType {
  constructor() {
    super("mito_api.VaultsByHolderAddressResponse", [
      { no: 1, name: "subscriptions", kind: "message", repeat: 2, T: () => Subscription },
      { no: 2, name: "pagination", kind: "message", T: () => Pagination }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subscriptions = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated mito_api.Subscription subscriptions */
        1:
          message.subscriptions.push(Subscription.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* mito_api.Pagination pagination */
        2:
          message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.subscriptions.length; i++)
      Subscription.internalBinaryWrite(message.subscriptions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.pagination)
      Pagination.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const VaultsByHolderAddressResponse = new VaultsByHolderAddressResponse$Type();
class Subscription$Type extends MessageType {
  constructor() {
    super("mito_api.Subscription", [
      { no: 1, name: "vault_info", kind: "message", T: () => Vault },
      {
        no: 2,
        name: "lp_amount",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "holder_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "lp_amount_percentage",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.lpAmount = "";
    message.holderAddress = "";
    message.lpAmountPercentage = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* mito_api.Vault vault_info */
        1:
          message.vaultInfo = Vault.internalBinaryRead(reader, reader.uint32(), options, message.vaultInfo);
          break;
        case /* string lp_amount */
        2:
          message.lpAmount = reader.string();
          break;
        case /* string holder_address */
        3:
          message.holderAddress = reader.string();
          break;
        case /* double lp_amount_percentage */
        4:
          message.lpAmountPercentage = reader.double();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.vaultInfo)
      Vault.internalBinaryWrite(message.vaultInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.lpAmount !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.lpAmount);
    if (message.holderAddress !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.holderAddress);
    if (message.lpAmountPercentage !== 0)
      writer.tag(4, WireType.Bit64).double(message.lpAmountPercentage);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Subscription = new Subscription$Type();
class LPHoldersRequest$Type extends MessageType {
  constructor() {
    super("mito_api.LPHoldersRequest", [
      {
        no: 1,
        name: "limit",
        kind: "scalar",
        opt: true,
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 2,
        name: "page_index",
        kind: "scalar",
        opt: true,
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 3,
        name: "vault_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "staking_contract_address",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "skip",
        kind: "scalar",
        opt: true,
        T: 17
        /*ScalarType.SINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.vaultAddress = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 limit */
        1:
          message.limit = reader.uint32();
          break;
        case /* optional uint32 page_index */
        2:
          message.pageIndex = reader.uint32();
          break;
        case /* string vault_address */
        3:
          message.vaultAddress = reader.string();
          break;
        case /* optional string staking_contract_address */
        4:
          message.stakingContractAddress = reader.string();
          break;
        case /* optional sint32 skip */
        5:
          message.skip = reader.sint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.limit !== void 0)
      writer.tag(1, WireType.Varint).uint32(message.limit);
    if (message.pageIndex !== void 0)
      writer.tag(2, WireType.Varint).uint32(message.pageIndex);
    if (message.vaultAddress !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.vaultAddress);
    if (message.stakingContractAddress !== void 0)
      writer.tag(4, WireType.LengthDelimited).string(message.stakingContractAddress);
    if (message.skip !== void 0)
      writer.tag(5, WireType.Varint).sint32(message.skip);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const LPHoldersRequest = new LPHoldersRequest$Type();
class LPHoldersResponse$Type extends MessageType {
  constructor() {
    super("mito_api.LPHoldersResponse", [
      { no: 1, name: "holders", kind: "message", repeat: 2, T: () => Holders },
      { no: 2, name: "pagination", kind: "message", T: () => Pagination }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.holders = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated mito_api.Holders holders */
        1:
          message.holders.push(Holders.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* mito_api.Pagination pagination */
        2:
          message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.holders.length; i++)
      Holders.internalBinaryWrite(message.holders[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.pagination)
      Pagination.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const LPHoldersResponse = new LPHoldersResponse$Type();
class Holders$Type extends MessageType {
  constructor() {
    super("mito_api.Holders", [
      {
        no: 1,
        name: "holder_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "vault_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "amount",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "updated_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "lp_amount_percentage",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 6,
        name: "redemption_lock_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 7,
        name: "staked_amount",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.holderAddress = "";
    message.vaultAddress = "";
    message.amount = "";
    message.updatedAt = 0n;
    message.lpAmountPercentage = 0;
    message.redemptionLockTime = 0n;
    message.stakedAmount = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string holder_address */
        1:
          message.holderAddress = reader.string();
          break;
        case /* string vault_address */
        2:
          message.vaultAddress = reader.string();
          break;
        case /* string amount */
        3:
          message.amount = reader.string();
          break;
        case /* sint64 updated_at */
        4:
          message.updatedAt = reader.sint64().toBigInt();
          break;
        case /* double lp_amount_percentage */
        5:
          message.lpAmountPercentage = reader.double();
          break;
        case /* sint64 redemption_lock_time */
        6:
          message.redemptionLockTime = reader.sint64().toBigInt();
          break;
        case /* string staked_amount */
        7:
          message.stakedAmount = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.holderAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.holderAddress);
    if (message.vaultAddress !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.vaultAddress);
    if (message.amount !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.amount);
    if (message.updatedAt !== 0n)
      writer.tag(4, WireType.Varint).sint64(message.updatedAt);
    if (message.lpAmountPercentage !== 0)
      writer.tag(5, WireType.Bit64).double(message.lpAmountPercentage);
    if (message.redemptionLockTime !== 0n)
      writer.tag(6, WireType.Varint).sint64(message.redemptionLockTime);
    if (message.stakedAmount !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.stakedAmount);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Holders = new Holders$Type();
class PortfolioRequest$Type extends MessageType {
  constructor() {
    super("mito_api.PortfolioRequest", [
      {
        no: 1,
        name: "holder_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "staking_contract_address",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.holderAddress = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string holder_address */
        1:
          message.holderAddress = reader.string();
          break;
        case /* optional string staking_contract_address */
        2:
          message.stakingContractAddress = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.holderAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.holderAddress);
    if (message.stakingContractAddress !== void 0)
      writer.tag(2, WireType.LengthDelimited).string(message.stakingContractAddress);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PortfolioRequest = new PortfolioRequest$Type();
class PortfolioResponse$Type extends MessageType {
  constructor() {
    super("mito_api.PortfolioResponse", [
      {
        no: 1,
        name: "total_value",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 2,
        name: "pnl",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      { no: 3, name: "total_value_chart", kind: "message", repeat: 2, T: () => PriceSnapshot },
      { no: 4, name: "pnl_chart", kind: "message", repeat: 2, T: () => PriceSnapshot },
      {
        no: 5,
        name: "pnl_updated_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.totalValue = 0;
    message.pnl = 0;
    message.totalValueChart = [];
    message.pnlChart = [];
    message.pnlUpdatedAt = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* double total_value */
        1:
          message.totalValue = reader.double();
          break;
        case /* double pnl */
        2:
          message.pnl = reader.double();
          break;
        case /* repeated mito_api.PriceSnapshot total_value_chart */
        3:
          message.totalValueChart.push(PriceSnapshot.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated mito_api.PriceSnapshot pnl_chart */
        4:
          message.pnlChart.push(PriceSnapshot.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* sint64 pnl_updated_at */
        5:
          message.pnlUpdatedAt = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.totalValue !== 0)
      writer.tag(1, WireType.Bit64).double(message.totalValue);
    if (message.pnl !== 0)
      writer.tag(2, WireType.Bit64).double(message.pnl);
    for (let i = 0; i < message.totalValueChart.length; i++)
      PriceSnapshot.internalBinaryWrite(message.totalValueChart[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.pnlChart.length; i++)
      PriceSnapshot.internalBinaryWrite(message.pnlChart[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    if (message.pnlUpdatedAt !== 0n)
      writer.tag(5, WireType.Varint).sint64(message.pnlUpdatedAt);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PortfolioResponse = new PortfolioResponse$Type();
class LeaderboardRequest$Type extends MessageType {
  constructor() {
    super("mito_api.LeaderboardRequest", [
      {
        no: 1,
        name: "epoch_id",
        kind: "scalar",
        opt: true,
        T: 13
        /*ScalarType.UINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 epoch_id */
        1:
          message.epochId = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.epochId !== void 0)
      writer.tag(1, WireType.Varint).uint32(message.epochId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const LeaderboardRequest = new LeaderboardRequest$Type();
class LeaderboardResponse$Type extends MessageType {
  constructor() {
    super("mito_api.LeaderboardResponse", [
      { no: 1, name: "entries", kind: "message", repeat: 2, T: () => LeaderboardEntry },
      {
        no: 2,
        name: "snapshot_block",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "updated_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "epoch_id",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.entries = [];
    message.snapshotBlock = 0n;
    message.updatedAt = 0n;
    message.epochId = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated mito_api.LeaderboardEntry entries */
        1:
          message.entries.push(LeaderboardEntry.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* sint64 snapshot_block */
        2:
          message.snapshotBlock = reader.sint64().toBigInt();
          break;
        case /* sint64 updated_at */
        3:
          message.updatedAt = reader.sint64().toBigInt();
          break;
        case /* uint32 epoch_id */
        4:
          message.epochId = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.entries.length; i++)
      LeaderboardEntry.internalBinaryWrite(message.entries[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.snapshotBlock !== 0n)
      writer.tag(2, WireType.Varint).sint64(message.snapshotBlock);
    if (message.updatedAt !== 0n)
      writer.tag(3, WireType.Varint).sint64(message.updatedAt);
    if (message.epochId !== 0)
      writer.tag(4, WireType.Varint).uint32(message.epochId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const LeaderboardResponse = new LeaderboardResponse$Type();
class LeaderboardEntry$Type extends MessageType {
  constructor() {
    super("mito_api.LeaderboardEntry", [
      {
        no: 1,
        name: "address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "pnl",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.address = "";
    message.pnl = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string address */
        1:
          message.address = reader.string();
          break;
        case /* double pnl */
        2:
          message.pnl = reader.double();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.address !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.address);
    if (message.pnl !== 0)
      writer.tag(2, WireType.Bit64).double(message.pnl);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const LeaderboardEntry = new LeaderboardEntry$Type();
class LeaderboardEpochsRequest$Type extends MessageType {
  constructor() {
    super("mito_api.LeaderboardEpochsRequest", [
      {
        no: 1,
        name: "from_epoch_id",
        kind: "scalar",
        opt: true,
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 2,
        name: "to_epoch_id",
        kind: "scalar",
        opt: true,
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 3,
        name: "limit",
        kind: "scalar",
        opt: true,
        T: 13
        /*ScalarType.UINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 from_epoch_id */
        1:
          message.fromEpochId = reader.uint32();
          break;
        case /* optional uint32 to_epoch_id */
        2:
          message.toEpochId = reader.uint32();
          break;
        case /* optional uint32 limit */
        3:
          message.limit = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.fromEpochId !== void 0)
      writer.tag(1, WireType.Varint).uint32(message.fromEpochId);
    if (message.toEpochId !== void 0)
      writer.tag(2, WireType.Varint).uint32(message.toEpochId);
    if (message.limit !== void 0)
      writer.tag(3, WireType.Varint).uint32(message.limit);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const LeaderboardEpochsRequest = new LeaderboardEpochsRequest$Type();
class LeaderboardEpochsResponse$Type extends MessageType {
  constructor() {
    super("mito_api.LeaderboardEpochsResponse", [
      { no: 1, name: "epochs", kind: "message", repeat: 2, T: () => LeaderboardEpoch },
      { no: 2, name: "pagination", kind: "message", T: () => Pagination }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.epochs = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated mito_api.LeaderboardEpoch epochs */
        1:
          message.epochs.push(LeaderboardEpoch.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* mito_api.Pagination pagination */
        2:
          message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.epochs.length; i++)
      LeaderboardEpoch.internalBinaryWrite(message.epochs[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.pagination)
      Pagination.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const LeaderboardEpochsResponse = new LeaderboardEpochsResponse$Type();
class LeaderboardEpoch$Type extends MessageType {
  constructor() {
    super("mito_api.LeaderboardEpoch", [
      {
        no: 1,
        name: "epoch_id",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 2,
        name: "start_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "end_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "is_live",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.epochId = 0;
    message.startAt = 0n;
    message.endAt = 0n;
    message.isLive = false;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint32 epoch_id */
        1:
          message.epochId = reader.uint32();
          break;
        case /* sint64 start_at */
        2:
          message.startAt = reader.sint64().toBigInt();
          break;
        case /* sint64 end_at */
        3:
          message.endAt = reader.sint64().toBigInt();
          break;
        case /* bool is_live */
        4:
          message.isLive = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.epochId !== 0)
      writer.tag(1, WireType.Varint).uint32(message.epochId);
    if (message.startAt !== 0n)
      writer.tag(2, WireType.Varint).sint64(message.startAt);
    if (message.endAt !== 0n)
      writer.tag(3, WireType.Varint).sint64(message.endAt);
    if (message.isLive !== false)
      writer.tag(4, WireType.Varint).bool(message.isLive);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const LeaderboardEpoch = new LeaderboardEpoch$Type();
class TransfersHistoryRequest$Type extends MessageType {
  constructor() {
    super("mito_api.TransfersHistoryRequest", [
      {
        no: 1,
        name: "vault",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "account",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "limit",
        kind: "scalar",
        opt: true,
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 4,
        name: "from_number",
        kind: "scalar",
        opt: true,
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 5,
        name: "to_number",
        kind: "scalar",
        opt: true,
        T: 13
        /*ScalarType.UINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string vault */
        1:
          message.vault = reader.string();
          break;
        case /* optional string account */
        2:
          message.account = reader.string();
          break;
        case /* optional uint32 limit */
        3:
          message.limit = reader.uint32();
          break;
        case /* optional uint32 from_number */
        4:
          message.fromNumber = reader.uint32();
          break;
        case /* optional uint32 to_number */
        5:
          message.toNumber = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.vault !== void 0)
      writer.tag(1, WireType.LengthDelimited).string(message.vault);
    if (message.account !== void 0)
      writer.tag(2, WireType.LengthDelimited).string(message.account);
    if (message.limit !== void 0)
      writer.tag(3, WireType.Varint).uint32(message.limit);
    if (message.fromNumber !== void 0)
      writer.tag(4, WireType.Varint).uint32(message.fromNumber);
    if (message.toNumber !== void 0)
      writer.tag(5, WireType.Varint).uint32(message.toNumber);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TransfersHistoryRequest = new TransfersHistoryRequest$Type();
class TransfersHistoryResponse$Type extends MessageType {
  constructor() {
    super("mito_api.TransfersHistoryResponse", [
      { no: 1, name: "transfers", kind: "message", repeat: 2, T: () => Transfer },
      { no: 2, name: "pagination", kind: "message", T: () => Pagination }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.transfers = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated mito_api.Transfer transfers */
        1:
          message.transfers.push(Transfer.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* mito_api.Pagination pagination */
        2:
          message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.transfers.length; i++)
      Transfer.internalBinaryWrite(message.transfers[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.pagination)
      Pagination.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TransfersHistoryResponse = new TransfersHistoryResponse$Type();
class Transfer$Type extends MessageType {
  constructor() {
    super("mito_api.Transfer", [
      {
        no: 1,
        name: "lp_amount",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "coins", kind: "message", repeat: 2, T: () => Coin },
      {
        no: 3,
        name: "usd_value",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "is_deposit",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 5,
        name: "executed_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 6,
        name: "account",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "vault",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: "tx_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "tid_by_vault",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 10,
        name: "tid_by_account",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.lpAmount = "";
    message.coins = [];
    message.usdValue = "";
    message.isDeposit = false;
    message.executedAt = 0n;
    message.account = "";
    message.vault = "";
    message.txHash = "";
    message.tidByVault = 0;
    message.tidByAccount = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string lp_amount */
        1:
          message.lpAmount = reader.string();
          break;
        case /* repeated mito_api.Coin coins */
        2:
          message.coins.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* string usd_value */
        3:
          message.usdValue = reader.string();
          break;
        case /* bool is_deposit */
        4:
          message.isDeposit = reader.bool();
          break;
        case /* sint64 executed_at */
        5:
          message.executedAt = reader.sint64().toBigInt();
          break;
        case /* string account */
        6:
          message.account = reader.string();
          break;
        case /* string vault */
        7:
          message.vault = reader.string();
          break;
        case /* string tx_hash */
        8:
          message.txHash = reader.string();
          break;
        case /* uint32 tid_by_vault */
        9:
          message.tidByVault = reader.uint32();
          break;
        case /* uint32 tid_by_account */
        10:
          message.tidByAccount = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.lpAmount !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.lpAmount);
    for (let i = 0; i < message.coins.length; i++)
      Coin.internalBinaryWrite(message.coins[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.usdValue !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.usdValue);
    if (message.isDeposit !== false)
      writer.tag(4, WireType.Varint).bool(message.isDeposit);
    if (message.executedAt !== 0n)
      writer.tag(5, WireType.Varint).sint64(message.executedAt);
    if (message.account !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.account);
    if (message.vault !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.vault);
    if (message.txHash !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.txHash);
    if (message.tidByVault !== 0)
      writer.tag(9, WireType.Varint).uint32(message.tidByVault);
    if (message.tidByAccount !== 0)
      writer.tag(10, WireType.Varint).uint32(message.tidByAccount);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Transfer = new Transfer$Type();
class Coin$Type extends MessageType {
  constructor() {
    super("mito_api.Coin", [
      {
        no: 1,
        name: "amount",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.amount = "";
    message.denom = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string amount */
        1:
          message.amount = reader.string();
          break;
        case /* string denom */
        2:
          message.denom = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.amount !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.amount);
    if (message.denom !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.denom);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Coin = new Coin$Type();
class GetStakingPoolsRequest$Type extends MessageType {
  constructor() {
    super("mito_api.GetStakingPoolsRequest", [
      {
        no: 1,
        name: "staker",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "staking_contract_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.stakingContractAddress = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string staker */
        1:
          message.staker = reader.string();
          break;
        case /* string staking_contract_address */
        2:
          message.stakingContractAddress = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.staker !== void 0)
      writer.tag(1, WireType.LengthDelimited).string(message.staker);
    if (message.stakingContractAddress !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.stakingContractAddress);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetStakingPoolsRequest = new GetStakingPoolsRequest$Type();
class GetStakingPoolsResponse$Type extends MessageType {
  constructor() {
    super("mito_api.GetStakingPoolsResponse", [
      { no: 1, name: "pools", kind: "message", repeat: 2, T: () => StakingPool },
      { no: 2, name: "pagination", kind: "message", T: () => Pagination }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.pools = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated mito_api.StakingPool pools */
        1:
          message.pools.push(StakingPool.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* mito_api.Pagination pagination */
        2:
          message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.pools.length; i++)
      StakingPool.internalBinaryWrite(message.pools[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.pagination)
      Pagination.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetStakingPoolsResponse = new GetStakingPoolsResponse$Type();
class StakingPool$Type extends MessageType {
  constructor() {
    super("mito_api.StakingPool", [
      {
        no: 1,
        name: "vault_name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "vault_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "stake_denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 4, name: "gauges", kind: "message", repeat: 2, T: () => Gauge },
      {
        no: 5,
        name: "apr",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 6,
        name: "total_liquidity",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 7,
        name: "staking_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 8, name: "apr_breakdown", kind: "map", K: 9, V: {
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.vaultName = "";
    message.vaultAddress = "";
    message.stakeDenom = "";
    message.gauges = [];
    message.apr = 0;
    message.totalLiquidity = 0;
    message.stakingAddress = "";
    message.aprBreakdown = {};
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string vault_name */
        1:
          message.vaultName = reader.string();
          break;
        case /* string vault_address */
        2:
          message.vaultAddress = reader.string();
          break;
        case /* string stake_denom */
        3:
          message.stakeDenom = reader.string();
          break;
        case /* repeated mito_api.Gauge gauges */
        4:
          message.gauges.push(Gauge.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* double apr */
        5:
          message.apr = reader.double();
          break;
        case /* double total_liquidity */
        6:
          message.totalLiquidity = reader.double();
          break;
        case /* string staking_address */
        7:
          message.stakingAddress = reader.string();
          break;
        case /* map<string, double> apr_breakdown */
        8:
          this.binaryReadMap8(message.aprBreakdown, reader, options);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  binaryReadMap8(map, reader, options) {
    let len = reader.uint32(), end = reader.pos + len, key, val;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case 1:
          key = reader.string();
          break;
        case 2:
          val = reader.double();
          break;
        default:
          throw new globalThis.Error("unknown map entry field for mito_api.StakingPool.apr_breakdown");
      }
    }
    map[key ?? ""] = val ?? 0;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.vaultName !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.vaultName);
    if (message.vaultAddress !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.vaultAddress);
    if (message.stakeDenom !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.stakeDenom);
    for (let i = 0; i < message.gauges.length; i++)
      Gauge.internalBinaryWrite(message.gauges[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    if (message.apr !== 0)
      writer.tag(5, WireType.Bit64).double(message.apr);
    if (message.totalLiquidity !== 0)
      writer.tag(6, WireType.Bit64).double(message.totalLiquidity);
    if (message.stakingAddress !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.stakingAddress);
    for (let k of globalThis.Object.keys(message.aprBreakdown))
      writer.tag(8, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Bit64).double(message.aprBreakdown[k]).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StakingPool = new StakingPool$Type();
class Gauge$Type extends MessageType {
  constructor() {
    super("mito_api.Gauge", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "owner",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "start_timestamp",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "end_timestamp",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 5, name: "reward_tokens", kind: "message", repeat: 2, T: () => Coin },
      {
        no: 6,
        name: "last_distribution",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 7,
        name: "status",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.id = "";
    message.owner = "";
    message.startTimestamp = 0n;
    message.endTimestamp = 0n;
    message.rewardTokens = [];
    message.lastDistribution = 0;
    message.status = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */
        1:
          message.id = reader.string();
          break;
        case /* string owner */
        2:
          message.owner = reader.string();
          break;
        case /* sint64 start_timestamp */
        3:
          message.startTimestamp = reader.sint64().toBigInt();
          break;
        case /* sint64 end_timestamp */
        4:
          message.endTimestamp = reader.sint64().toBigInt();
          break;
        case /* repeated mito_api.Coin reward_tokens */
        5:
          message.rewardTokens.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* uint32 last_distribution */
        6:
          message.lastDistribution = reader.uint32();
          break;
        case /* string status */
        7:
          message.status = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.id !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    if (message.owner !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.owner);
    if (message.startTimestamp !== 0n)
      writer.tag(3, WireType.Varint).sint64(message.startTimestamp);
    if (message.endTimestamp !== 0n)
      writer.tag(4, WireType.Varint).sint64(message.endTimestamp);
    for (let i = 0; i < message.rewardTokens.length; i++)
      Coin.internalBinaryWrite(message.rewardTokens[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
    if (message.lastDistribution !== 0)
      writer.tag(6, WireType.Varint).uint32(message.lastDistribution);
    if (message.status !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.status);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Gauge = new Gauge$Type();
class StakingRewardByAccountRequest$Type extends MessageType {
  constructor() {
    super("mito_api.StakingRewardByAccountRequest", [
      {
        no: 1,
        name: "staker",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "staking_contract_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.staker = "";
    message.stakingContractAddress = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string staker */
        1:
          message.staker = reader.string();
          break;
        case /* string staking_contract_address */
        2:
          message.stakingContractAddress = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.staker !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.staker);
    if (message.stakingContractAddress !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.stakingContractAddress);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StakingRewardByAccountRequest = new StakingRewardByAccountRequest$Type();
class StakingRewardByAccountResponse$Type extends MessageType {
  constructor() {
    super("mito_api.StakingRewardByAccountResponse", [
      { no: 1, name: "rewards", kind: "message", repeat: 2, T: () => StakingReward },
      { no: 2, name: "pagination", kind: "message", T: () => Pagination }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.rewards = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated mito_api.StakingReward rewards */
        1:
          message.rewards.push(StakingReward.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* mito_api.Pagination pagination */
        2:
          message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.rewards.length; i++)
      StakingReward.internalBinaryWrite(message.rewards[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.pagination)
      Pagination.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StakingRewardByAccountResponse = new StakingRewardByAccountResponse$Type();
class StakingReward$Type extends MessageType {
  constructor() {
    super("mito_api.StakingReward", [
      {
        no: 1,
        name: "vault_name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "vault_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "staked_amount", kind: "message", T: () => Coin },
      {
        no: 4,
        name: "apr",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      { no: 5, name: "claimable_rewards", kind: "message", repeat: 2, T: () => Coin },
      {
        no: 6,
        name: "lock_timestamp",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 7, name: "locked_amount", kind: "message", T: () => Coin }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.vaultName = "";
    message.vaultAddress = "";
    message.apr = 0;
    message.claimableRewards = [];
    message.lockTimestamp = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string vault_name */
        1:
          message.vaultName = reader.string();
          break;
        case /* string vault_address */
        2:
          message.vaultAddress = reader.string();
          break;
        case /* mito_api.Coin staked_amount */
        3:
          message.stakedAmount = Coin.internalBinaryRead(reader, reader.uint32(), options, message.stakedAmount);
          break;
        case /* double apr */
        4:
          message.apr = reader.double();
          break;
        case /* repeated mito_api.Coin claimable_rewards */
        5:
          message.claimableRewards.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* sint64 lock_timestamp */
        6:
          message.lockTimestamp = reader.sint64().toBigInt();
          break;
        case /* mito_api.Coin locked_amount */
        7:
          message.lockedAmount = Coin.internalBinaryRead(reader, reader.uint32(), options, message.lockedAmount);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.vaultName !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.vaultName);
    if (message.vaultAddress !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.vaultAddress);
    if (message.stakedAmount)
      Coin.internalBinaryWrite(message.stakedAmount, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    if (message.apr !== 0)
      writer.tag(4, WireType.Bit64).double(message.apr);
    for (let i = 0; i < message.claimableRewards.length; i++)
      Coin.internalBinaryWrite(message.claimableRewards[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
    if (message.lockTimestamp !== 0n)
      writer.tag(6, WireType.Varint).sint64(message.lockTimestamp);
    if (message.lockedAmount)
      Coin.internalBinaryWrite(message.lockedAmount, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StakingReward = new StakingReward$Type();
class StakingHistoryRequest$Type extends MessageType {
  constructor() {
    super("mito_api.StakingHistoryRequest", [
      {
        no: 1,
        name: "from_number",
        kind: "scalar",
        opt: true,
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 2,
        name: "to_number",
        kind: "scalar",
        opt: true,
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 3,
        name: "limit",
        kind: "scalar",
        opt: true,
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 4,
        name: "staker",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 from_number */
        1:
          message.fromNumber = reader.uint32();
          break;
        case /* optional uint32 to_number */
        2:
          message.toNumber = reader.uint32();
          break;
        case /* optional uint32 limit */
        3:
          message.limit = reader.uint32();
          break;
        case /* optional string staker */
        4:
          message.staker = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.fromNumber !== void 0)
      writer.tag(1, WireType.Varint).uint32(message.fromNumber);
    if (message.toNumber !== void 0)
      writer.tag(2, WireType.Varint).uint32(message.toNumber);
    if (message.limit !== void 0)
      writer.tag(3, WireType.Varint).uint32(message.limit);
    if (message.staker !== void 0)
      writer.tag(4, WireType.LengthDelimited).string(message.staker);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StakingHistoryRequest = new StakingHistoryRequest$Type();
class StakingHistoryResponse$Type extends MessageType {
  constructor() {
    super("mito_api.StakingHistoryResponse", [
      { no: 1, name: "activities", kind: "message", repeat: 2, T: () => StakingActivity },
      { no: 2, name: "pagination", kind: "message", T: () => Pagination }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.activities = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated mito_api.StakingActivity activities */
        1:
          message.activities.push(StakingActivity.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* mito_api.Pagination pagination */
        2:
          message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.activities.length; i++)
      StakingActivity.internalBinaryWrite(message.activities[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.pagination)
      Pagination.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StakingHistoryResponse = new StakingHistoryResponse$Type();
class StakingActivity$Type extends MessageType {
  constructor() {
    super("mito_api.StakingActivity", [
      { no: 1, name: "stake_amount", kind: "message", T: () => Coin },
      {
        no: 2,
        name: "vault_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "action",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "tx_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 5, name: "rewarded_tokens", kind: "message", repeat: 2, T: () => Coin },
      {
        no: 6,
        name: "timestamp",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 7,
        name: "staker",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: "number_by_account",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.vaultAddress = "";
    message.action = "";
    message.txHash = "";
    message.rewardedTokens = [];
    message.timestamp = 0n;
    message.staker = "";
    message.numberByAccount = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* mito_api.Coin stake_amount */
        1:
          message.stakeAmount = Coin.internalBinaryRead(reader, reader.uint32(), options, message.stakeAmount);
          break;
        case /* string vault_address */
        2:
          message.vaultAddress = reader.string();
          break;
        case /* string action */
        3:
          message.action = reader.string();
          break;
        case /* string tx_hash */
        4:
          message.txHash = reader.string();
          break;
        case /* repeated mito_api.Coin rewarded_tokens */
        5:
          message.rewardedTokens.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* sint64 timestamp */
        6:
          message.timestamp = reader.sint64().toBigInt();
          break;
        case /* string staker */
        7:
          message.staker = reader.string();
          break;
        case /* uint32 number_by_account */
        8:
          message.numberByAccount = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.stakeAmount)
      Coin.internalBinaryWrite(message.stakeAmount, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.vaultAddress !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.vaultAddress);
    if (message.action !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.action);
    if (message.txHash !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.txHash);
    for (let i = 0; i < message.rewardedTokens.length; i++)
      Coin.internalBinaryWrite(message.rewardedTokens[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
    if (message.timestamp !== 0n)
      writer.tag(6, WireType.Varint).sint64(message.timestamp);
    if (message.staker !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.staker);
    if (message.numberByAccount !== 0)
      writer.tag(8, WireType.Varint).uint32(message.numberByAccount);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StakingActivity = new StakingActivity$Type();
class StakingAmountAtHeightRequest$Type extends MessageType {
  constructor() {
    super("mito_api.StakingAmountAtHeightRequest", [
      {
        no: 1,
        name: "staking_contract_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "height",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "staker",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "skip",
        kind: "scalar",
        opt: true,
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 6,
        name: "limit",
        kind: "scalar",
        opt: true,
        T: 13
        /*ScalarType.UINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.stakingContractAddress = "";
    message.denom = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string staking_contract_address */
        1:
          message.stakingContractAddress = reader.string();
          break;
        case /* string denom */
        2:
          message.denom = reader.string();
          break;
        case /* optional uint64 height */
        3:
          message.height = reader.uint64().toBigInt();
          break;
        case /* optional string staker */
        4:
          message.staker = reader.string();
          break;
        case /* optional sint32 skip */
        5:
          message.skip = reader.sint32();
          break;
        case /* optional uint32 limit */
        6:
          message.limit = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.stakingContractAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.stakingContractAddress);
    if (message.denom !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.denom);
    if (message.height !== void 0)
      writer.tag(3, WireType.Varint).uint64(message.height);
    if (message.staker !== void 0)
      writer.tag(4, WireType.LengthDelimited).string(message.staker);
    if (message.skip !== void 0)
      writer.tag(5, WireType.Varint).sint32(message.skip);
    if (message.limit !== void 0)
      writer.tag(6, WireType.Varint).uint32(message.limit);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StakingAmountAtHeightRequest = new StakingAmountAtHeightRequest$Type();
class StakingAmountAtHeightResponse$Type extends MessageType {
  constructor() {
    super("mito_api.StakingAmountAtHeightResponse", [
      { no: 1, name: "stakers", kind: "message", repeat: 2, T: () => StakingAmount }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.stakers = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated mito_api.StakingAmount stakers */
        1:
          message.stakers.push(StakingAmount.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.stakers.length; i++)
      StakingAmount.internalBinaryWrite(message.stakers[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StakingAmountAtHeightResponse = new StakingAmountAtHeightResponse$Type();
class StakingAmount$Type extends MessageType {
  constructor() {
    super("mito_api.StakingAmount", [
      {
        no: 1,
        name: "staker",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "amount", kind: "message", T: () => Coin },
      {
        no: 3,
        name: "latest_height",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.staker = "";
    message.latestHeight = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string staker */
        1:
          message.staker = reader.string();
          break;
        case /* mito_api.Coin amount */
        2:
          message.amount = Coin.internalBinaryRead(reader, reader.uint32(), options, message.amount);
          break;
        case /* uint64 latest_height */
        3:
          message.latestHeight = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.staker !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.staker);
    if (message.amount)
      Coin.internalBinaryWrite(message.amount, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.latestHeight !== 0n)
      writer.tag(3, WireType.Varint).uint64(message.latestHeight);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StakingAmount = new StakingAmount$Type();
class StreamTransfersRequest$Type extends MessageType {
  constructor() {
    super("mito_api.StreamTransfersRequest", [
      {
        no: 1,
        name: "vault",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "account",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string vault */
        1:
          message.vault = reader.string();
          break;
        case /* optional string account */
        2:
          message.account = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.vault !== void 0)
      writer.tag(1, WireType.LengthDelimited).string(message.vault);
    if (message.account !== void 0)
      writer.tag(2, WireType.LengthDelimited).string(message.account);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamTransfersRequest = new StreamTransfersRequest$Type();
class StreamTransfersResponse$Type extends MessageType {
  constructor() {
    super("mito_api.StreamTransfersResponse", [
      { no: 1, name: "data", kind: "message", T: () => Transfer },
      {
        no: 2,
        name: "op_type",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* mito_api.Transfer data */
        1:
          message.data = Transfer.internalBinaryRead(reader, reader.uint32(), options, message.data);
          break;
        case /* optional string op_type */
        2:
          message.opType = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.data)
      Transfer.internalBinaryWrite(message.data, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.opType !== void 0)
      writer.tag(2, WireType.LengthDelimited).string(message.opType);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamTransfersResponse = new StreamTransfersResponse$Type();
class StreamVaultRequest$Type extends MessageType {
  constructor() {
    super("mito_api.StreamVaultRequest", [
      {
        no: 1,
        name: "vault",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.vault = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string vault */
        1:
          message.vault = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.vault !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.vault);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamVaultRequest = new StreamVaultRequest$Type();
class StreamVaultResponse$Type extends MessageType {
  constructor() {
    super("mito_api.StreamVaultResponse", [
      { no: 1, name: "data", kind: "message", T: () => Vault },
      {
        no: 2,
        name: "op_type",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* mito_api.Vault data */
        1:
          message.data = Vault.internalBinaryRead(reader, reader.uint32(), options, message.data);
          break;
        case /* optional string op_type */
        2:
          message.opType = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.data)
      Vault.internalBinaryWrite(message.data, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.opType !== void 0)
      writer.tag(2, WireType.LengthDelimited).string(message.opType);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamVaultResponse = new StreamVaultResponse$Type();
class StreamHolderSubscriptionRequest$Type extends MessageType {
  constructor() {
    super("mito_api.StreamHolderSubscriptionRequest", [
      {
        no: 1,
        name: "holder_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "vault_address",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "staking_contract_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.holderAddress = "";
    message.stakingContractAddress = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string holder_address */
        1:
          message.holderAddress = reader.string();
          break;
        case /* optional string vault_address */
        2:
          message.vaultAddress = reader.string();
          break;
        case /* string staking_contract_address */
        3:
          message.stakingContractAddress = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.holderAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.holderAddress);
    if (message.vaultAddress !== void 0)
      writer.tag(2, WireType.LengthDelimited).string(message.vaultAddress);
    if (message.stakingContractAddress !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.stakingContractAddress);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamHolderSubscriptionRequest = new StreamHolderSubscriptionRequest$Type();
class StreamHolderSubscriptionResponse$Type extends MessageType {
  constructor() {
    super("mito_api.StreamHolderSubscriptionResponse", [
      { no: 1, name: "data", kind: "message", T: () => Subscription },
      {
        no: 2,
        name: "op_type",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* mito_api.Subscription data */
        1:
          message.data = Subscription.internalBinaryRead(reader, reader.uint32(), options, message.data);
          break;
        case /* optional string op_type */
        2:
          message.opType = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.data)
      Subscription.internalBinaryWrite(message.data, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.opType !== void 0)
      writer.tag(2, WireType.LengthDelimited).string(message.opType);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamHolderSubscriptionResponse = new StreamHolderSubscriptionResponse$Type();
class StreamStakingRewardByAccountRequest$Type extends MessageType {
  constructor() {
    super("mito_api.StreamStakingRewardByAccountRequest", [
      {
        no: 1,
        name: "staker",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "staking_contract_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.staker = "";
    message.stakingContractAddress = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string staker */
        1:
          message.staker = reader.string();
          break;
        case /* string staking_contract_address */
        2:
          message.stakingContractAddress = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.staker !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.staker);
    if (message.stakingContractAddress !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.stakingContractAddress);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamStakingRewardByAccountRequest = new StreamStakingRewardByAccountRequest$Type();
class StreamStakingRewardByAccountResponse$Type extends MessageType {
  constructor() {
    super("mito_api.StreamStakingRewardByAccountResponse", [
      { no: 1, name: "data", kind: "message", T: () => StakingReward },
      {
        no: 2,
        name: "op_type",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* mito_api.StakingReward data */
        1:
          message.data = StakingReward.internalBinaryRead(reader, reader.uint32(), options, message.data);
          break;
        case /* optional string op_type */
        2:
          message.opType = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.data)
      StakingReward.internalBinaryWrite(message.data, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.opType !== void 0)
      writer.tag(2, WireType.LengthDelimited).string(message.opType);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamStakingRewardByAccountResponse = new StreamStakingRewardByAccountResponse$Type();
class StreamHistoricalStakingRequest$Type extends MessageType {
  constructor() {
    super("mito_api.StreamHistoricalStakingRequest", [
      {
        no: 1,
        name: "staker",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "staking_contract_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.staker = "";
    message.stakingContractAddress = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string staker */
        1:
          message.staker = reader.string();
          break;
        case /* string staking_contract_address */
        2:
          message.stakingContractAddress = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.staker !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.staker);
    if (message.stakingContractAddress !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.stakingContractAddress);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamHistoricalStakingRequest = new StreamHistoricalStakingRequest$Type();
class StreamHistoricalStakingResponse$Type extends MessageType {
  constructor() {
    super("mito_api.StreamHistoricalStakingResponse", [
      { no: 1, name: "data", kind: "message", T: () => StakingActivity },
      {
        no: 2,
        name: "op_type",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* mito_api.StakingActivity data */
        1:
          message.data = StakingActivity.internalBinaryRead(reader, reader.uint32(), options, message.data);
          break;
        case /* optional string op_type */
        2:
          message.opType = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.data)
      StakingActivity.internalBinaryWrite(message.data, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.opType !== void 0)
      writer.tag(2, WireType.LengthDelimited).string(message.opType);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamHistoricalStakingResponse = new StreamHistoricalStakingResponse$Type();
class HealthRequest$Type extends MessageType {
  constructor() {
    super("mito_api.HealthRequest", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const HealthRequest = new HealthRequest$Type();
class HealthResponse$Type extends MessageType {
  constructor() {
    super("mito_api.HealthResponse", [
      {
        no: 1,
        name: "version",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "commit",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "lastest_synced_block",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "chain_height",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "status",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "block_diff_threshold",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.version = "";
    message.commit = "";
    message.lastestSyncedBlock = 0n;
    message.chainHeight = 0n;
    message.status = "";
    message.blockDiffThreshold = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string version */
        1:
          message.version = reader.string();
          break;
        case /* string commit */
        2:
          message.commit = reader.string();
          break;
        case /* sint64 lastest_synced_block */
        3:
          message.lastestSyncedBlock = reader.sint64().toBigInt();
          break;
        case /* sint64 chain_height */
        4:
          message.chainHeight = reader.sint64().toBigInt();
          break;
        case /* string status */
        5:
          message.status = reader.string();
          break;
        case /* sint32 block_diff_threshold */
        6:
          message.blockDiffThreshold = reader.sint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.version !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.version);
    if (message.commit !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.commit);
    if (message.lastestSyncedBlock !== 0n)
      writer.tag(3, WireType.Varint).sint64(message.lastestSyncedBlock);
    if (message.chainHeight !== 0n)
      writer.tag(4, WireType.Varint).sint64(message.chainHeight);
    if (message.status !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.status);
    if (message.blockDiffThreshold !== 0)
      writer.tag(6, WireType.Varint).sint32(message.blockDiffThreshold);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const HealthResponse = new HealthResponse$Type();
class ExecutionRequest$Type extends MessageType {
  constructor() {
    super("mito_api.ExecutionRequest", [
      {
        no: 1,
        name: "contract_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.contractAddress = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string contract_address */
        1:
          message.contractAddress = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.contractAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.contractAddress);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ExecutionRequest = new ExecutionRequest$Type();
class ExecutionResponse$Type extends MessageType {
  constructor() {
    super("mito_api.ExecutionResponse", [
      {
        no: 1,
        name: "contract_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "current_block",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "last_executed_block",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "last_error_block",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 5, name: "execution_logs", kind: "message", repeat: 2, T: () => ExecutionLog },
      { no: 6, name: "last_error_log", kind: "message", T: () => ExecutionLog }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.contractAddress = "";
    message.currentBlock = 0n;
    message.lastExecutedBlock = 0n;
    message.lastErrorBlock = 0n;
    message.executionLogs = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string contract_address */
        1:
          message.contractAddress = reader.string();
          break;
        case /* sint64 current_block */
        2:
          message.currentBlock = reader.sint64().toBigInt();
          break;
        case /* sint64 last_executed_block */
        3:
          message.lastExecutedBlock = reader.sint64().toBigInt();
          break;
        case /* sint64 last_error_block */
        4:
          message.lastErrorBlock = reader.sint64().toBigInt();
          break;
        case /* repeated mito_api.ExecutionLog execution_logs */
        5:
          message.executionLogs.push(ExecutionLog.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* mito_api.ExecutionLog last_error_log */
        6:
          message.lastErrorLog = ExecutionLog.internalBinaryRead(reader, reader.uint32(), options, message.lastErrorLog);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.contractAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.contractAddress);
    if (message.currentBlock !== 0n)
      writer.tag(2, WireType.Varint).sint64(message.currentBlock);
    if (message.lastExecutedBlock !== 0n)
      writer.tag(3, WireType.Varint).sint64(message.lastExecutedBlock);
    if (message.lastErrorBlock !== 0n)
      writer.tag(4, WireType.Varint).sint64(message.lastErrorBlock);
    for (let i = 0; i < message.executionLogs.length; i++)
      ExecutionLog.internalBinaryWrite(message.executionLogs[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
    if (message.lastErrorLog)
      ExecutionLog.internalBinaryWrite(message.lastErrorLog, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ExecutionResponse = new ExecutionResponse$Type();
class ExecutionLog$Type extends MessageType {
  constructor() {
    super("mito_api.ExecutionLog", [
      {
        no: 1,
        name: "block",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "response",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "error",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.block = 0n;
    message.response = "";
    message.error = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* sint64 block */
        1:
          message.block = reader.sint64().toBigInt();
          break;
        case /* string response */
        2:
          message.response = reader.string();
          break;
        case /* string error */
        3:
          message.error = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.block !== 0n)
      writer.tag(1, WireType.Varint).sint64(message.block);
    if (message.response !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.response);
    if (message.error !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.error);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ExecutionLog = new ExecutionLog$Type();
class MissionsRequest$Type extends MessageType {
  constructor() {
    super("mito_api.MissionsRequest", [
      {
        no: 1,
        name: "account_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.accountAddress = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string account_address */
        1:
          message.accountAddress = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.accountAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.accountAddress);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MissionsRequest = new MissionsRequest$Type();
class MissionsResponse$Type extends MessageType {
  constructor() {
    super("mito_api.MissionsResponse", [
      { no: 1, name: "data", kind: "message", repeat: 2, T: () => Mission },
      {
        no: 2,
        name: "rank",
        kind: "scalar",
        opt: true,
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.data = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated mito_api.Mission data */
        1:
          message.data.push(Mission.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* optional sint64 rank */
        2:
          message.rank = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.data.length; i++)
      Mission.internalBinaryWrite(message.data[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.rank !== void 0)
      writer.tag(2, WireType.Varint).sint64(message.rank);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MissionsResponse = new MissionsResponse$Type();
class Mission$Type extends MessageType {
  constructor() {
    super("mito_api.Mission", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "points",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "completed",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 4,
        name: "accrued_points",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "updated_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 6,
        name: "progress",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 7,
        name: "expected",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.id = "";
    message.points = 0n;
    message.completed = false;
    message.accruedPoints = 0n;
    message.updatedAt = 0n;
    message.progress = 0;
    message.expected = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */
        1:
          message.id = reader.string();
          break;
        case /* sint64 points */
        2:
          message.points = reader.sint64().toBigInt();
          break;
        case /* bool completed */
        3:
          message.completed = reader.bool();
          break;
        case /* sint64 accrued_points */
        4:
          message.accruedPoints = reader.sint64().toBigInt();
          break;
        case /* sint64 updated_at */
        5:
          message.updatedAt = reader.sint64().toBigInt();
          break;
        case /* double progress */
        6:
          message.progress = reader.double();
          break;
        case /* double expected */
        7:
          message.expected = reader.double();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.id !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    if (message.points !== 0n)
      writer.tag(2, WireType.Varint).sint64(message.points);
    if (message.completed !== false)
      writer.tag(3, WireType.Varint).bool(message.completed);
    if (message.accruedPoints !== 0n)
      writer.tag(4, WireType.Varint).sint64(message.accruedPoints);
    if (message.updatedAt !== 0n)
      writer.tag(5, WireType.Varint).sint64(message.updatedAt);
    if (message.progress !== 0)
      writer.tag(6, WireType.Bit64).double(message.progress);
    if (message.expected !== 0)
      writer.tag(7, WireType.Bit64).double(message.expected);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Mission = new Mission$Type();
class MissionLeaderboardRequest$Type extends MessageType {
  constructor() {
    super("mito_api.MissionLeaderboardRequest", [
      {
        no: 1,
        name: "user_address",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string user_address */
        1:
          message.userAddress = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.userAddress !== void 0)
      writer.tag(1, WireType.LengthDelimited).string(message.userAddress);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MissionLeaderboardRequest = new MissionLeaderboardRequest$Type();
class MissionLeaderboardResponse$Type extends MessageType {
  constructor() {
    super("mito_api.MissionLeaderboardResponse", [
      { no: 1, name: "data", kind: "message", repeat: 2, T: () => MissionLeaderboardEntry },
      {
        no: 2,
        name: "updated_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "user_rank",
        kind: "scalar",
        opt: true,
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.data = [];
    message.updatedAt = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated mito_api.MissionLeaderboardEntry data */
        1:
          message.data.push(MissionLeaderboardEntry.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* sint64 updated_at */
        2:
          message.updatedAt = reader.sint64().toBigInt();
          break;
        case /* optional sint64 user_rank */
        3:
          message.userRank = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.data.length; i++)
      MissionLeaderboardEntry.internalBinaryWrite(message.data[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.updatedAt !== 0n)
      writer.tag(2, WireType.Varint).sint64(message.updatedAt);
    if (message.userRank !== void 0)
      writer.tag(3, WireType.Varint).sint64(message.userRank);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MissionLeaderboardResponse = new MissionLeaderboardResponse$Type();
class MissionLeaderboardEntry$Type extends MessageType {
  constructor() {
    super("mito_api.MissionLeaderboardEntry", [
      {
        no: 1,
        name: "address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "accrued_points",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.address = "";
    message.accruedPoints = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string address */
        1:
          message.address = reader.string();
          break;
        case /* sint64 accrued_points */
        2:
          message.accruedPoints = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.address !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.address);
    if (message.accruedPoints !== 0n)
      writer.tag(2, WireType.Varint).sint64(message.accruedPoints);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MissionLeaderboardEntry = new MissionLeaderboardEntry$Type();
class ListIDOsRequest$Type extends MessageType {
  constructor() {
    super("mito_api.ListIDOsRequest", [
      {
        no: 1,
        name: "status",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "limit",
        kind: "scalar",
        opt: true,
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 3,
        name: "to_number",
        kind: "scalar",
        opt: true,
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 4,
        name: "account_address",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "owner_address",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string status */
        1:
          message.status = reader.string();
          break;
        case /* optional sint32 limit */
        2:
          message.limit = reader.sint32();
          break;
        case /* optional sint32 to_number */
        3:
          message.toNumber = reader.sint32();
          break;
        case /* optional string account_address */
        4:
          message.accountAddress = reader.string();
          break;
        case /* optional string owner_address */
        5:
          message.ownerAddress = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.status !== void 0)
      writer.tag(1, WireType.LengthDelimited).string(message.status);
    if (message.limit !== void 0)
      writer.tag(2, WireType.Varint).sint32(message.limit);
    if (message.toNumber !== void 0)
      writer.tag(3, WireType.Varint).sint32(message.toNumber);
    if (message.accountAddress !== void 0)
      writer.tag(4, WireType.LengthDelimited).string(message.accountAddress);
    if (message.ownerAddress !== void 0)
      writer.tag(5, WireType.LengthDelimited).string(message.ownerAddress);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ListIDOsRequest = new ListIDOsRequest$Type();
class ListIDOsResponse$Type extends MessageType {
  constructor() {
    super("mito_api.ListIDOsResponse", [
      { no: 1, name: "idos", kind: "message", repeat: 2, T: () => IDO },
      { no: 2, name: "pagination", kind: "message", T: () => Pagination }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.idos = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated mito_api.IDO idos */
        1:
          message.idos.push(IDO.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* mito_api.Pagination pagination */
        2:
          message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.idos.length; i++)
      IDO.internalBinaryWrite(message.idos[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.pagination)
      Pagination.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ListIDOsResponse = new ListIDOsResponse$Type();
class IDO$Type extends MessageType {
  constructor() {
    super("mito_api.IDO", [
      {
        no: 1,
        name: "start_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "end_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "owner",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "status",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 5, name: "token_info", kind: "message", T: () => TokenInfo },
      {
        no: 6,
        name: "project_token_amount",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "quote_denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: "target_amount_in_quote_denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "target_amount_in_usd",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 10,
        name: "cap_per_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 11,
        name: "contract_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 12,
        name: "subscribed_amount",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 13,
        name: "token_price",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 14,
        name: "is_account_white_listed",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 15,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 16, name: "progress", kind: "message", repeat: 2, T: () => IDOProgress },
      { no: 17, name: "stake_to_subscription", kind: "message", repeat: 2, T: () => ArrayOfString },
      {
        no: 18,
        name: "second_before_start_to_set_quote_price",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 19,
        name: "use_whitelist",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 20,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 21,
        name: "vault_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 22,
        name: "is_launch_with_vault",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 23,
        name: "is_vesting_schedule_enabled",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      { no: 24, name: "init_params", kind: "message", T: () => InitParams },
      {
        no: 25,
        name: "project_description",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 26,
        name: "is_permissionless",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.startTime = 0n;
    message.endTime = 0n;
    message.owner = "";
    message.status = "";
    message.projectTokenAmount = "";
    message.quoteDenom = "";
    message.targetAmountInQuoteDenom = "";
    message.targetAmountInUsd = "";
    message.capPerAddress = "";
    message.contractAddress = "";
    message.subscribedAmount = "";
    message.tokenPrice = 0;
    message.isAccountWhiteListed = false;
    message.name = "";
    message.progress = [];
    message.stakeToSubscription = [];
    message.secondBeforeStartToSetQuotePrice = 0n;
    message.useWhitelist = false;
    message.marketId = "";
    message.vaultAddress = "";
    message.isLaunchWithVault = false;
    message.isVestingScheduleEnabled = false;
    message.projectDescription = "";
    message.isPermissionless = false;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* sint64 start_time */
        1:
          message.startTime = reader.sint64().toBigInt();
          break;
        case /* sint64 end_time */
        2:
          message.endTime = reader.sint64().toBigInt();
          break;
        case /* string owner */
        3:
          message.owner = reader.string();
          break;
        case /* string status */
        4:
          message.status = reader.string();
          break;
        case /* mito_api.TokenInfo token_info */
        5:
          message.tokenInfo = TokenInfo.internalBinaryRead(reader, reader.uint32(), options, message.tokenInfo);
          break;
        case /* string project_token_amount */
        6:
          message.projectTokenAmount = reader.string();
          break;
        case /* string quote_denom */
        7:
          message.quoteDenom = reader.string();
          break;
        case /* string target_amount_in_quote_denom */
        8:
          message.targetAmountInQuoteDenom = reader.string();
          break;
        case /* string target_amount_in_usd */
        9:
          message.targetAmountInUsd = reader.string();
          break;
        case /* string cap_per_address */
        10:
          message.capPerAddress = reader.string();
          break;
        case /* string contract_address */
        11:
          message.contractAddress = reader.string();
          break;
        case /* string subscribed_amount */
        12:
          message.subscribedAmount = reader.string();
          break;
        case /* double token_price */
        13:
          message.tokenPrice = reader.double();
          break;
        case /* bool is_account_white_listed */
        14:
          message.isAccountWhiteListed = reader.bool();
          break;
        case /* string name */
        15:
          message.name = reader.string();
          break;
        case /* repeated mito_api.IDOProgress progress */
        16:
          message.progress.push(IDOProgress.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated mito_api.ArrayOfString stake_to_subscription */
        17:
          message.stakeToSubscription.push(ArrayOfString.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* sint64 second_before_start_to_set_quote_price */
        18:
          message.secondBeforeStartToSetQuotePrice = reader.sint64().toBigInt();
          break;
        case /* bool use_whitelist */
        19:
          message.useWhitelist = reader.bool();
          break;
        case /* string market_id */
        20:
          message.marketId = reader.string();
          break;
        case /* string vault_address */
        21:
          message.vaultAddress = reader.string();
          break;
        case /* bool is_launch_with_vault */
        22:
          message.isLaunchWithVault = reader.bool();
          break;
        case /* bool is_vesting_schedule_enabled */
        23:
          message.isVestingScheduleEnabled = reader.bool();
          break;
        case /* mito_api.InitParams init_params */
        24:
          message.initParams = InitParams.internalBinaryRead(reader, reader.uint32(), options, message.initParams);
          break;
        case /* string project_description */
        25:
          message.projectDescription = reader.string();
          break;
        case /* bool is_permissionless */
        26:
          message.isPermissionless = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.startTime !== 0n)
      writer.tag(1, WireType.Varint).sint64(message.startTime);
    if (message.endTime !== 0n)
      writer.tag(2, WireType.Varint).sint64(message.endTime);
    if (message.owner !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.owner);
    if (message.status !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.status);
    if (message.tokenInfo)
      TokenInfo.internalBinaryWrite(message.tokenInfo, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
    if (message.projectTokenAmount !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.projectTokenAmount);
    if (message.quoteDenom !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.quoteDenom);
    if (message.targetAmountInQuoteDenom !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.targetAmountInQuoteDenom);
    if (message.targetAmountInUsd !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.targetAmountInUsd);
    if (message.capPerAddress !== "")
      writer.tag(10, WireType.LengthDelimited).string(message.capPerAddress);
    if (message.contractAddress !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.contractAddress);
    if (message.subscribedAmount !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.subscribedAmount);
    if (message.tokenPrice !== 0)
      writer.tag(13, WireType.Bit64).double(message.tokenPrice);
    if (message.isAccountWhiteListed !== false)
      writer.tag(14, WireType.Varint).bool(message.isAccountWhiteListed);
    if (message.name !== "")
      writer.tag(15, WireType.LengthDelimited).string(message.name);
    for (let i = 0; i < message.progress.length; i++)
      IDOProgress.internalBinaryWrite(message.progress[i], writer.tag(16, WireType.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.stakeToSubscription.length; i++)
      ArrayOfString.internalBinaryWrite(message.stakeToSubscription[i], writer.tag(17, WireType.LengthDelimited).fork(), options).join();
    if (message.secondBeforeStartToSetQuotePrice !== 0n)
      writer.tag(18, WireType.Varint).sint64(message.secondBeforeStartToSetQuotePrice);
    if (message.useWhitelist !== false)
      writer.tag(19, WireType.Varint).bool(message.useWhitelist);
    if (message.marketId !== "")
      writer.tag(20, WireType.LengthDelimited).string(message.marketId);
    if (message.vaultAddress !== "")
      writer.tag(21, WireType.LengthDelimited).string(message.vaultAddress);
    if (message.isLaunchWithVault !== false)
      writer.tag(22, WireType.Varint).bool(message.isLaunchWithVault);
    if (message.isVestingScheduleEnabled !== false)
      writer.tag(23, WireType.Varint).bool(message.isVestingScheduleEnabled);
    if (message.initParams)
      InitParams.internalBinaryWrite(message.initParams, writer.tag(24, WireType.LengthDelimited).fork(), options).join();
    if (message.projectDescription !== "")
      writer.tag(25, WireType.LengthDelimited).string(message.projectDescription);
    if (message.isPermissionless !== false)
      writer.tag(26, WireType.Varint).bool(message.isPermissionless);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const IDO = new IDO$Type();
class TokenInfo$Type extends MessageType {
  constructor() {
    super("mito_api.TokenInfo", [
      {
        no: 1,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "supply",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "symbol",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "decimal",
        kind: "scalar",
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 5,
        name: "logo_url",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.denom = "";
    message.supply = "";
    message.symbol = "";
    message.decimal = 0;
    message.logoUrl = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string denom */
        1:
          message.denom = reader.string();
          break;
        case /* string supply */
        2:
          message.supply = reader.string();
          break;
        case /* string symbol */
        3:
          message.symbol = reader.string();
          break;
        case /* sint32 decimal */
        4:
          message.decimal = reader.sint32();
          break;
        case /* string logo_url */
        5:
          message.logoUrl = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.denom !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.denom);
    if (message.supply !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.supply);
    if (message.symbol !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.symbol);
    if (message.decimal !== 0)
      writer.tag(4, WireType.Varint).sint32(message.decimal);
    if (message.logoUrl !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.logoUrl);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TokenInfo = new TokenInfo$Type();
class IDOProgress$Type extends MessageType {
  constructor() {
    super("mito_api.IDOProgress", [
      {
        no: 1,
        name: "status",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "timestamp",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.status = "";
    message.timestamp = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string status */
        1:
          message.status = reader.string();
          break;
        case /* sint64 timestamp */
        2:
          message.timestamp = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.status !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.status);
    if (message.timestamp !== 0n)
      writer.tag(2, WireType.Varint).sint64(message.timestamp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const IDOProgress = new IDOProgress$Type();
class ArrayOfString$Type extends MessageType {
  constructor() {
    super("mito_api.ArrayOfString", [
      {
        no: 1,
        name: "field",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.field = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string field */
        1:
          message.field.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.field.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.field[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ArrayOfString = new ArrayOfString$Type();
class InitParams$Type extends MessageType {
  constructor() {
    super("mito_api.InitParams", [
      { no: 1, name: "vesting_config", kind: "message", T: () => VestingConfigMap }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* mito_api.VestingConfigMap vesting_config */
        1:
          message.vestingConfig = VestingConfigMap.internalBinaryRead(reader, reader.uint32(), options, message.vestingConfig);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.vestingConfig)
      VestingConfigMap.internalBinaryWrite(message.vestingConfig, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const InitParams = new InitParams$Type();
class VestingConfigMap$Type extends MessageType {
  constructor() {
    super("mito_api.VestingConfigMap", [
      { no: 1, name: "project_owner_quote", kind: "message", T: () => VestingConfig },
      { no: 2, name: "project_owner_lp_tokens", kind: "message", T: () => VestingConfig },
      { no: 3, name: "users_project_token", kind: "message", T: () => VestingConfig }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* mito_api.VestingConfig project_owner_quote */
        1:
          message.projectOwnerQuote = VestingConfig.internalBinaryRead(reader, reader.uint32(), options, message.projectOwnerQuote);
          break;
        case /* mito_api.VestingConfig project_owner_lp_tokens */
        2:
          message.projectOwnerLpTokens = VestingConfig.internalBinaryRead(reader, reader.uint32(), options, message.projectOwnerLpTokens);
          break;
        case /* mito_api.VestingConfig users_project_token */
        3:
          message.usersProjectToken = VestingConfig.internalBinaryRead(reader, reader.uint32(), options, message.usersProjectToken);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.projectOwnerQuote)
      VestingConfig.internalBinaryWrite(message.projectOwnerQuote, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.projectOwnerLpTokens)
      VestingConfig.internalBinaryWrite(message.projectOwnerLpTokens, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.usersProjectToken)
      VestingConfig.internalBinaryWrite(message.usersProjectToken, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const VestingConfigMap = new VestingConfigMap$Type();
class VestingConfig$Type extends MessageType {
  constructor() {
    super("mito_api.VestingConfig", [
      {
        no: 1,
        name: "vesting_duration_seconds",
        kind: "scalar",
        opt: true,
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "vesting_start_delay_seconds",
        kind: "scalar",
        opt: true,
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "schedule",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional sint64 vesting_duration_seconds */
        1:
          message.vestingDurationSeconds = reader.sint64().toBigInt();
          break;
        case /* optional sint64 vesting_start_delay_seconds */
        2:
          message.vestingStartDelaySeconds = reader.sint64().toBigInt();
          break;
        case /* optional string schedule */
        3:
          message.schedule = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.vestingDurationSeconds !== void 0)
      writer.tag(1, WireType.Varint).sint64(message.vestingDurationSeconds);
    if (message.vestingStartDelaySeconds !== void 0)
      writer.tag(2, WireType.Varint).sint64(message.vestingStartDelaySeconds);
    if (message.schedule !== void 0)
      writer.tag(3, WireType.LengthDelimited).string(message.schedule);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const VestingConfig = new VestingConfig$Type();
class GetIDORequest$Type extends MessageType {
  constructor() {
    super("mito_api.GetIDORequest", [
      {
        no: 1,
        name: "contract_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "account_address",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.contractAddress = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string contract_address */
        1:
          message.contractAddress = reader.string();
          break;
        case /* optional string account_address */
        2:
          message.accountAddress = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.contractAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.contractAddress);
    if (message.accountAddress !== void 0)
      writer.tag(2, WireType.LengthDelimited).string(message.accountAddress);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetIDORequest = new GetIDORequest$Type();
class GetIDOResponse$Type extends MessageType {
  constructor() {
    super("mito_api.GetIDOResponse", [
      { no: 1, name: "ido", kind: "message", T: () => IDO }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* mito_api.IDO ido */
        1:
          message.ido = IDO.internalBinaryRead(reader, reader.uint32(), options, message.ido);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.ido)
      IDO.internalBinaryWrite(message.ido, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetIDOResponse = new GetIDOResponse$Type();
class GetIDOSubscribersRequest$Type extends MessageType {
  constructor() {
    super("mito_api.GetIDOSubscribersRequest", [
      {
        no: 1,
        name: "contract_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "limit",
        kind: "scalar",
        opt: true,
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 3,
        name: "skip",
        kind: "scalar",
        opt: true,
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 4,
        name: "sort_by",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.contractAddress = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string contract_address */
        1:
          message.contractAddress = reader.string();
          break;
        case /* optional sint32 limit */
        2:
          message.limit = reader.sint32();
          break;
        case /* optional sint32 skip */
        3:
          message.skip = reader.sint32();
          break;
        case /* optional string sort_by */
        4:
          message.sortBy = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.contractAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.contractAddress);
    if (message.limit !== void 0)
      writer.tag(2, WireType.Varint).sint32(message.limit);
    if (message.skip !== void 0)
      writer.tag(3, WireType.Varint).sint32(message.skip);
    if (message.sortBy !== void 0)
      writer.tag(4, WireType.LengthDelimited).string(message.sortBy);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetIDOSubscribersRequest = new GetIDOSubscribersRequest$Type();
class GetIDOSubscribersResponse$Type extends MessageType {
  constructor() {
    super("mito_api.GetIDOSubscribersResponse", [
      { no: 1, name: "subscribers", kind: "message", repeat: 2, T: () => IDOSubscriber },
      { no: 2, name: "pagination", kind: "message", T: () => Pagination },
      { no: 3, name: "token_info", kind: "message", T: () => TokenInfo },
      {
        no: 4,
        name: "quote_denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subscribers = [];
    message.quoteDenom = "";
    message.marketId = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated mito_api.IDOSubscriber subscribers */
        1:
          message.subscribers.push(IDOSubscriber.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* mito_api.Pagination pagination */
        2:
          message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        case /* mito_api.TokenInfo token_info */
        3:
          message.tokenInfo = TokenInfo.internalBinaryRead(reader, reader.uint32(), options, message.tokenInfo);
          break;
        case /* string quote_denom */
        4:
          message.quoteDenom = reader.string();
          break;
        case /* string market_id */
        5:
          message.marketId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.subscribers.length; i++)
      IDOSubscriber.internalBinaryWrite(message.subscribers[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.pagination)
      Pagination.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.tokenInfo)
      TokenInfo.internalBinaryWrite(message.tokenInfo, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    if (message.quoteDenom !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.quoteDenom);
    if (message.marketId !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.marketId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetIDOSubscribersResponse = new GetIDOSubscribersResponse$Type();
class IDOSubscriber$Type extends MessageType {
  constructor() {
    super("mito_api.IDOSubscriber", [
      {
        no: 1,
        name: "address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "subscribed_coin", kind: "message", T: () => Coin },
      {
        no: 3,
        name: "last_subscribe_time",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 4, name: "estimate_token_received", kind: "message", T: () => Coin },
      { no: 5, name: "estimate_lp_amount", kind: "message", T: () => Coin },
      { no: 6, name: "estimate_refund_amount", kind: "message", T: () => Coin },
      {
        no: 7,
        name: "created_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.address = "";
    message.lastSubscribeTime = 0n;
    message.createdAt = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string address */
        1:
          message.address = reader.string();
          break;
        case /* mito_api.Coin subscribed_coin */
        2:
          message.subscribedCoin = Coin.internalBinaryRead(reader, reader.uint32(), options, message.subscribedCoin);
          break;
        case /* sint64 last_subscribe_time */
        3:
          message.lastSubscribeTime = reader.sint64().toBigInt();
          break;
        case /* mito_api.Coin estimate_token_received */
        4:
          message.estimateTokenReceived = Coin.internalBinaryRead(reader, reader.uint32(), options, message.estimateTokenReceived);
          break;
        case /* mito_api.Coin estimate_lp_amount */
        5:
          message.estimateLpAmount = Coin.internalBinaryRead(reader, reader.uint32(), options, message.estimateLpAmount);
          break;
        case /* mito_api.Coin estimate_refund_amount */
        6:
          message.estimateRefundAmount = Coin.internalBinaryRead(reader, reader.uint32(), options, message.estimateRefundAmount);
          break;
        case /* sint64 created_at */
        7:
          message.createdAt = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.address !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.address);
    if (message.subscribedCoin)
      Coin.internalBinaryWrite(message.subscribedCoin, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.lastSubscribeTime !== 0n)
      writer.tag(3, WireType.Varint).sint64(message.lastSubscribeTime);
    if (message.estimateTokenReceived)
      Coin.internalBinaryWrite(message.estimateTokenReceived, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    if (message.estimateLpAmount)
      Coin.internalBinaryWrite(message.estimateLpAmount, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
    if (message.estimateRefundAmount)
      Coin.internalBinaryWrite(message.estimateRefundAmount, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
    if (message.createdAt !== 0n)
      writer.tag(7, WireType.Varint).sint64(message.createdAt);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const IDOSubscriber = new IDOSubscriber$Type();
class GetIDOSubscriptionRequest$Type extends MessageType {
  constructor() {
    super("mito_api.GetIDOSubscriptionRequest", [
      {
        no: 1,
        name: "contract_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "account_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.contractAddress = "";
    message.accountAddress = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string contract_address */
        1:
          message.contractAddress = reader.string();
          break;
        case /* string account_address */
        2:
          message.accountAddress = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.contractAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.contractAddress);
    if (message.accountAddress !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.accountAddress);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetIDOSubscriptionRequest = new GetIDOSubscriptionRequest$Type();
class GetIDOSubscriptionResponse$Type extends MessageType {
  constructor() {
    super("mito_api.GetIDOSubscriptionResponse", [
      { no: 1, name: "subscription", kind: "message", T: () => IDOSubscription }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* mito_api.IDOSubscription subscription */
        1:
          message.subscription = IDOSubscription.internalBinaryRead(reader, reader.uint32(), options, message.subscription);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subscription)
      IDOSubscription.internalBinaryWrite(message.subscription, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetIDOSubscriptionResponse = new GetIDOSubscriptionResponse$Type();
class IDOSubscription$Type extends MessageType {
  constructor() {
    super("mito_api.IDOSubscription", [
      { no: 1, name: "max_subscription_coin", kind: "message", T: () => Coin },
      {
        no: 2,
        name: "committed_amount",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "price",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      { no: 4, name: "claimable_coins", kind: "message", repeat: 2, T: () => Coin },
      {
        no: 5,
        name: "updated_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 6,
        name: "reward_claimed",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      { no: 7, name: "token_info", kind: "message", T: () => TokenInfo },
      {
        no: 8,
        name: "quote_denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "staked_amount",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 10,
        name: "claim_tx_hash",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 11, name: "owner_claimable_coins", kind: "message", repeat: 2, T: () => Coin },
      {
        no: 12,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 13,
        name: "weight",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 14, name: "claimed_coins", kind: "message", T: () => IDOClaimedCoins }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.committedAmount = "";
    message.price = 0;
    message.claimableCoins = [];
    message.updatedAt = 0n;
    message.rewardClaimed = false;
    message.quoteDenom = "";
    message.stakedAmount = "";
    message.ownerClaimableCoins = [];
    message.marketId = "";
    message.weight = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* mito_api.Coin max_subscription_coin */
        1:
          message.maxSubscriptionCoin = Coin.internalBinaryRead(reader, reader.uint32(), options, message.maxSubscriptionCoin);
          break;
        case /* string committed_amount */
        2:
          message.committedAmount = reader.string();
          break;
        case /* double price */
        3:
          message.price = reader.double();
          break;
        case /* repeated mito_api.Coin claimable_coins */
        4:
          message.claimableCoins.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* sint64 updated_at */
        5:
          message.updatedAt = reader.sint64().toBigInt();
          break;
        case /* bool reward_claimed */
        6:
          message.rewardClaimed = reader.bool();
          break;
        case /* mito_api.TokenInfo token_info */
        7:
          message.tokenInfo = TokenInfo.internalBinaryRead(reader, reader.uint32(), options, message.tokenInfo);
          break;
        case /* string quote_denom */
        8:
          message.quoteDenom = reader.string();
          break;
        case /* string staked_amount */
        9:
          message.stakedAmount = reader.string();
          break;
        case /* optional string claim_tx_hash */
        10:
          message.claimTxHash = reader.string();
          break;
        case /* repeated mito_api.Coin owner_claimable_coins */
        11:
          message.ownerClaimableCoins.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* string market_id */
        12:
          message.marketId = reader.string();
          break;
        case /* string weight */
        13:
          message.weight = reader.string();
          break;
        case /* mito_api.IDOClaimedCoins claimed_coins */
        14:
          message.claimedCoins = IDOClaimedCoins.internalBinaryRead(reader, reader.uint32(), options, message.claimedCoins);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.maxSubscriptionCoin)
      Coin.internalBinaryWrite(message.maxSubscriptionCoin, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.committedAmount !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.committedAmount);
    if (message.price !== 0)
      writer.tag(3, WireType.Bit64).double(message.price);
    for (let i = 0; i < message.claimableCoins.length; i++)
      Coin.internalBinaryWrite(message.claimableCoins[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    if (message.updatedAt !== 0n)
      writer.tag(5, WireType.Varint).sint64(message.updatedAt);
    if (message.rewardClaimed !== false)
      writer.tag(6, WireType.Varint).bool(message.rewardClaimed);
    if (message.tokenInfo)
      TokenInfo.internalBinaryWrite(message.tokenInfo, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
    if (message.quoteDenom !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.quoteDenom);
    if (message.stakedAmount !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.stakedAmount);
    if (message.claimTxHash !== void 0)
      writer.tag(10, WireType.LengthDelimited).string(message.claimTxHash);
    for (let i = 0; i < message.ownerClaimableCoins.length; i++)
      Coin.internalBinaryWrite(message.ownerClaimableCoins[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
    if (message.marketId !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.marketId);
    if (message.weight !== "")
      writer.tag(13, WireType.LengthDelimited).string(message.weight);
    if (message.claimedCoins)
      IDOClaimedCoins.internalBinaryWrite(message.claimedCoins, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const IDOSubscription = new IDOSubscription$Type();
class IDOClaimedCoins$Type extends MessageType {
  constructor() {
    super("mito_api.IDOClaimedCoins", [
      { no: 1, name: "claimed_coins", kind: "message", repeat: 2, T: () => Coin },
      {
        no: 2,
        name: "updated_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.claimedCoins = [];
    message.updatedAt = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated mito_api.Coin claimed_coins */
        1:
          message.claimedCoins.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* sint64 updated_at */
        2:
          message.updatedAt = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.claimedCoins.length; i++)
      Coin.internalBinaryWrite(message.claimedCoins[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.updatedAt !== 0n)
      writer.tag(2, WireType.Varint).sint64(message.updatedAt);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const IDOClaimedCoins = new IDOClaimedCoins$Type();
class GetIDOActivitiesRequest$Type extends MessageType {
  constructor() {
    super("mito_api.GetIDOActivitiesRequest", [
      {
        no: 1,
        name: "contract_address",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "account_address",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "limit",
        kind: "scalar",
        opt: true,
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 4,
        name: "to_number",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string contract_address */
        1:
          message.contractAddress = reader.string();
          break;
        case /* optional string account_address */
        2:
          message.accountAddress = reader.string();
          break;
        case /* optional sint32 limit */
        3:
          message.limit = reader.sint32();
          break;
        case /* optional string to_number */
        4:
          message.toNumber = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.contractAddress !== void 0)
      writer.tag(1, WireType.LengthDelimited).string(message.contractAddress);
    if (message.accountAddress !== void 0)
      writer.tag(2, WireType.LengthDelimited).string(message.accountAddress);
    if (message.limit !== void 0)
      writer.tag(3, WireType.Varint).sint32(message.limit);
    if (message.toNumber !== void 0)
      writer.tag(4, WireType.LengthDelimited).string(message.toNumber);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetIDOActivitiesRequest = new GetIDOActivitiesRequest$Type();
class GetIDOActivitiesResponse$Type extends MessageType {
  constructor() {
    super("mito_api.GetIDOActivitiesResponse", [
      { no: 1, name: "activities", kind: "message", repeat: 2, T: () => IDOSubscriptionActivity },
      { no: 2, name: "pagination", kind: "message", T: () => Pagination }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.activities = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated mito_api.IDOSubscriptionActivity activities */
        1:
          message.activities.push(IDOSubscriptionActivity.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* mito_api.Pagination pagination */
        2:
          message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.activities.length; i++)
      IDOSubscriptionActivity.internalBinaryWrite(message.activities[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.pagination)
      Pagination.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetIDOActivitiesResponse = new GetIDOActivitiesResponse$Type();
class IDOSubscriptionActivity$Type extends MessageType {
  constructor() {
    super("mito_api.IDOSubscriptionActivity", [
      {
        no: 1,
        name: "address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "subscribed_coin", kind: "message", T: () => Coin },
      {
        no: 3,
        name: "usd_value",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 4,
        name: "timestamp",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "tx_hash",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.address = "";
    message.usdValue = 0;
    message.timestamp = 0n;
    message.txHash = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string address */
        1:
          message.address = reader.string();
          break;
        case /* mito_api.Coin subscribed_coin */
        2:
          message.subscribedCoin = Coin.internalBinaryRead(reader, reader.uint32(), options, message.subscribedCoin);
          break;
        case /* double usd_value */
        3:
          message.usdValue = reader.double();
          break;
        case /* sint64 timestamp */
        4:
          message.timestamp = reader.sint64().toBigInt();
          break;
        case /* string tx_hash */
        5:
          message.txHash = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.address !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.address);
    if (message.subscribedCoin)
      Coin.internalBinaryWrite(message.subscribedCoin, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.usdValue !== 0)
      writer.tag(3, WireType.Bit64).double(message.usdValue);
    if (message.timestamp !== 0n)
      writer.tag(4, WireType.Varint).sint64(message.timestamp);
    if (message.txHash !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.txHash);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const IDOSubscriptionActivity = new IDOSubscriptionActivity$Type();
class GetWhitelistRequest$Type extends MessageType {
  constructor() {
    super("mito_api.GetWhitelistRequest", [
      {
        no: 1,
        name: "ido_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "skip",
        kind: "scalar",
        opt: true,
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 3,
        name: "limit",
        kind: "scalar",
        opt: true,
        T: 17
        /*ScalarType.SINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.idoAddress = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string ido_address */
        1:
          message.idoAddress = reader.string();
          break;
        case /* optional sint32 skip */
        2:
          message.skip = reader.sint32();
          break;
        case /* optional sint32 limit */
        3:
          message.limit = reader.sint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.idoAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.idoAddress);
    if (message.skip !== void 0)
      writer.tag(2, WireType.Varint).sint32(message.skip);
    if (message.limit !== void 0)
      writer.tag(3, WireType.Varint).sint32(message.limit);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetWhitelistRequest = new GetWhitelistRequest$Type();
class GetWhitelistResponse$Type extends MessageType {
  constructor() {
    super("mito_api.GetWhitelistResponse", [
      {
        no: 1,
        name: "ido_address",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "accounts", kind: "message", repeat: 2, T: () => WhitelistAccount },
      { no: 3, name: "pagination", kind: "message", T: () => Pagination }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.accounts = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string ido_address */
        1:
          message.idoAddress = reader.string();
          break;
        case /* repeated mito_api.WhitelistAccount accounts */
        2:
          message.accounts.push(WhitelistAccount.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* mito_api.Pagination pagination */
        3:
          message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.idoAddress !== void 0)
      writer.tag(1, WireType.LengthDelimited).string(message.idoAddress);
    for (let i = 0; i < message.accounts.length; i++)
      WhitelistAccount.internalBinaryWrite(message.accounts[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.pagination)
      Pagination.internalBinaryWrite(message.pagination, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetWhitelistResponse = new GetWhitelistResponse$Type();
class WhitelistAccount$Type extends MessageType {
  constructor() {
    super("mito_api.WhitelistAccount", [
      {
        no: 1,
        name: "account_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "updated_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "weight",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.accountAddress = "";
    message.updatedAt = 0n;
    message.weight = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string account_address */
        1:
          message.accountAddress = reader.string();
          break;
        case /* sint64 updated_at */
        2:
          message.updatedAt = reader.sint64().toBigInt();
          break;
        case /* string weight */
        3:
          message.weight = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.accountAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.accountAddress);
    if (message.updatedAt !== 0n)
      writer.tag(2, WireType.Varint).sint64(message.updatedAt);
    if (message.weight !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.weight);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const WhitelistAccount = new WhitelistAccount$Type();
class TokenMetadataRequest$Type extends MessageType {
  constructor() {
    super("mito_api.TokenMetadataRequest", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TokenMetadataRequest = new TokenMetadataRequest$Type();
class TokenMetadataResponse$Type extends MessageType {
  constructor() {
    super("mito_api.TokenMetadataResponse", [
      {
        no: 1,
        name: "data",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.data = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string data */
        1:
          message.data = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.data !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.data);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TokenMetadataResponse = new TokenMetadataResponse$Type();
class GetClaimReferencesRequest$Type extends MessageType {
  constructor() {
    super("mito_api.GetClaimReferencesRequest", [
      {
        no: 1,
        name: "account_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "ido_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "skip",
        kind: "scalar",
        opt: true,
        T: 17
        /*ScalarType.SINT32*/
      },
      {
        no: 4,
        name: "limit",
        kind: "scalar",
        opt: true,
        T: 17
        /*ScalarType.SINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.accountAddress = "";
    message.idoAddress = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string account_address */
        1:
          message.accountAddress = reader.string();
          break;
        case /* string ido_address */
        2:
          message.idoAddress = reader.string();
          break;
        case /* optional sint32 skip */
        3:
          message.skip = reader.sint32();
          break;
        case /* optional sint32 limit */
        4:
          message.limit = reader.sint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.accountAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.accountAddress);
    if (message.idoAddress !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.idoAddress);
    if (message.skip !== void 0)
      writer.tag(3, WireType.Varint).sint32(message.skip);
    if (message.limit !== void 0)
      writer.tag(4, WireType.Varint).sint32(message.limit);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetClaimReferencesRequest = new GetClaimReferencesRequest$Type();
class GetClaimReferencesResponse$Type extends MessageType {
  constructor() {
    super("mito_api.GetClaimReferencesResponse", [
      { no: 1, name: "claim_references", kind: "message", repeat: 2, T: () => ClaimReference },
      { no: 2, name: "pagination", kind: "message", T: () => Pagination }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.claimReferences = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated mito_api.ClaimReference claim_references */
        1:
          message.claimReferences.push(ClaimReference.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* mito_api.Pagination pagination */
        2:
          message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.claimReferences.length; i++)
      ClaimReference.internalBinaryWrite(message.claimReferences[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.pagination)
      Pagination.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetClaimReferencesResponse = new GetClaimReferencesResponse$Type();
class ClaimReference$Type extends MessageType {
  constructor() {
    super("mito_api.ClaimReference", [
      {
        no: 1,
        name: "account_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "cw_contract_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "ido_contract_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "start_vesting_time",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "vesting_duration_seconds",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 6,
        name: "updated_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 7,
        name: "claimed_amount",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: "claimable_amount",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "denom",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.accountAddress = "";
    message.cwContractAddress = "";
    message.idoContractAddress = "";
    message.startVestingTime = "";
    message.vestingDurationSeconds = 0n;
    message.updatedAt = 0n;
    message.claimedAmount = "";
    message.claimableAmount = "";
    message.denom = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string account_address */
        1:
          message.accountAddress = reader.string();
          break;
        case /* string cw_contract_address */
        2:
          message.cwContractAddress = reader.string();
          break;
        case /* string ido_contract_address */
        3:
          message.idoContractAddress = reader.string();
          break;
        case /* string start_vesting_time */
        4:
          message.startVestingTime = reader.string();
          break;
        case /* sint64 vesting_duration_seconds */
        5:
          message.vestingDurationSeconds = reader.sint64().toBigInt();
          break;
        case /* sint64 updated_at */
        6:
          message.updatedAt = reader.sint64().toBigInt();
          break;
        case /* string claimed_amount */
        7:
          message.claimedAmount = reader.string();
          break;
        case /* string claimable_amount */
        8:
          message.claimableAmount = reader.string();
          break;
        case /* string denom */
        9:
          message.denom = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.accountAddress !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.accountAddress);
    if (message.cwContractAddress !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.cwContractAddress);
    if (message.idoContractAddress !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.idoContractAddress);
    if (message.startVestingTime !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.startVestingTime);
    if (message.vestingDurationSeconds !== 0n)
      writer.tag(5, WireType.Varint).sint64(message.vestingDurationSeconds);
    if (message.updatedAt !== 0n)
      writer.tag(6, WireType.Varint).sint64(message.updatedAt);
    if (message.claimedAmount !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.claimedAmount);
    if (message.claimableAmount !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.claimableAmount);
    if (message.denom !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.denom);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ClaimReference = new ClaimReference$Type();
const MitoAPI = new ServiceType("mito_api.MitoAPI", [
  { name: "GetVaults", options: {}, I: GetVaultsRequest, O: GetVaultsResponse },
  { name: "GetVault", options: {}, I: GetVaultRequest, O: GetVaultResponse },
  { name: "LPTokenPriceChart", options: {}, I: LPTokenPriceChartRequest, O: LPTokenPriceChartResponse },
  { name: "TVLChart", options: {}, I: TVLChartRequest, O: TVLChartResponse },
  { name: "VaultsByHolderAddress", options: {}, I: VaultsByHolderAddressRequest, O: VaultsByHolderAddressResponse },
  { name: "LPHolders", options: {}, I: LPHoldersRequest, O: LPHoldersResponse },
  { name: "Portfolio", options: {}, I: PortfolioRequest, O: PortfolioResponse },
  { name: "Leaderboard", options: {}, I: LeaderboardRequest, O: LeaderboardResponse },
  { name: "LeaderboardEpochs", options: {}, I: LeaderboardEpochsRequest, O: LeaderboardEpochsResponse },
  { name: "TransfersHistory", options: {}, I: TransfersHistoryRequest, O: TransfersHistoryResponse },
  { name: "GetStakingPools", options: {}, I: GetStakingPoolsRequest, O: GetStakingPoolsResponse },
  { name: "StakingRewardByAccount", options: {}, I: StakingRewardByAccountRequest, O: StakingRewardByAccountResponse },
  { name: "StakingHistory", options: {}, I: StakingHistoryRequest, O: StakingHistoryResponse },
  { name: "StakingAmountAtHeight", options: {}, I: StakingAmountAtHeightRequest, O: StakingAmountAtHeightResponse },
  { name: "StreamTransfers", serverStreaming: true, options: {}, I: StreamTransfersRequest, O: StreamTransfersResponse },
  { name: "StreamVault", serverStreaming: true, options: {}, I: StreamVaultRequest, O: StreamVaultResponse },
  { name: "StreamHolderSubscription", serverStreaming: true, options: {}, I: StreamHolderSubscriptionRequest, O: StreamHolderSubscriptionResponse },
  { name: "StreamStakingRewardByAccount", serverStreaming: true, options: {}, I: StreamStakingRewardByAccountRequest, O: StreamStakingRewardByAccountResponse },
  { name: "StreamHistoricalStaking", serverStreaming: true, options: {}, I: StreamHistoricalStakingRequest, O: StreamHistoricalStakingResponse },
  { name: "Health", options: {}, I: HealthRequest, O: HealthResponse },
  { name: "Execution", options: {}, I: ExecutionRequest, O: ExecutionResponse },
  { name: "Missions", options: {}, I: MissionsRequest, O: MissionsResponse },
  { name: "MissionLeaderboard", options: {}, I: MissionLeaderboardRequest, O: MissionLeaderboardResponse },
  { name: "ListIDOs", options: {}, I: ListIDOsRequest, O: ListIDOsResponse },
  { name: "GetIDO", options: {}, I: GetIDORequest, O: GetIDOResponse },
  { name: "GetIDOSubscribers", options: {}, I: GetIDOSubscribersRequest, O: GetIDOSubscribersResponse },
  { name: "GetIDOSubscription", options: {}, I: GetIDOSubscriptionRequest, O: GetIDOSubscriptionResponse },
  { name: "GetIDOActivities", options: {}, I: GetIDOActivitiesRequest, O: GetIDOActivitiesResponse },
  { name: "GetWhitelist", options: {}, I: GetWhitelistRequest, O: GetWhitelistResponse },
  { name: "TokenMetadata", options: {}, I: TokenMetadataRequest, O: TokenMetadataResponse },
  { name: "GetClaimReferences", options: {}, I: GetClaimReferencesRequest, O: GetClaimReferencesResponse }
]);
export {
  ArrayOfString,
  Changes,
  ClaimReference,
  Coin,
  DenomBalance,
  ExecutionLog,
  ExecutionRequest,
  ExecutionResponse,
  Gauge,
  GetClaimReferencesRequest,
  GetClaimReferencesResponse,
  GetIDOActivitiesRequest,
  GetIDOActivitiesResponse,
  GetIDORequest,
  GetIDOResponse,
  GetIDOSubscribersRequest,
  GetIDOSubscribersResponse,
  GetIDOSubscriptionRequest,
  GetIDOSubscriptionResponse,
  GetStakingPoolsRequest,
  GetStakingPoolsResponse,
  GetVaultRequest,
  GetVaultResponse,
  GetVaultsRequest,
  GetVaultsResponse,
  GetWhitelistRequest,
  GetWhitelistResponse,
  HealthRequest,
  HealthResponse,
  Holders,
  IDO,
  IDOClaimedCoins,
  IDOProgress,
  IDOSubscriber,
  IDOSubscription,
  IDOSubscriptionActivity,
  InitParams,
  LPHoldersRequest,
  LPHoldersResponse,
  LPTokenPriceChartRequest,
  LPTokenPriceChartResponse,
  LeaderboardEntry,
  LeaderboardEpoch,
  LeaderboardEpochsRequest,
  LeaderboardEpochsResponse,
  LeaderboardRequest,
  LeaderboardResponse,
  ListIDOsRequest,
  ListIDOsResponse,
  Mission,
  MissionLeaderboardEntry,
  MissionLeaderboardRequest,
  MissionLeaderboardResponse,
  MissionsRequest,
  MissionsResponse,
  MitoAPI,
  Pagination,
  PortfolioRequest,
  PortfolioResponse,
  PriceSnapshot,
  StakingActivity,
  StakingAmount,
  StakingAmountAtHeightRequest,
  StakingAmountAtHeightResponse,
  StakingHistoryRequest,
  StakingHistoryResponse,
  StakingPool,
  StakingReward,
  StakingRewardByAccountRequest,
  StakingRewardByAccountResponse,
  StreamHistoricalStakingRequest,
  StreamHistoricalStakingResponse,
  StreamHolderSubscriptionRequest,
  StreamHolderSubscriptionResponse,
  StreamStakingRewardByAccountRequest,
  StreamStakingRewardByAccountResponse,
  StreamTransfersRequest,
  StreamTransfersResponse,
  StreamVaultRequest,
  StreamVaultResponse,
  SubaccountBalance,
  Subscription,
  TVLChartRequest,
  TVLChartResponse,
  TokenInfo,
  TokenMetadataRequest,
  TokenMetadataResponse,
  Transfer,
  TransfersHistoryRequest,
  TransfersHistoryResponse,
  Vault,
  VaultsByHolderAddressRequest,
  VaultsByHolderAddressResponse,
  VestingConfig,
  VestingConfigMap,
  WhitelistAccount
};
