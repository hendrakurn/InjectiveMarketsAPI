// @generated by protobuf-ts 2.11.1 with parameter add_pb_suffix
// @generated from protobuf file "goagen_olp_injective_dmm_v2.proto" (package "injective_dmm_v2", syntax proto3)
// tslint:disable
//
// Code generated with goa v3.23.4, DO NOT EDIT.
//
// InjectiveDmmV2 protocol buffer definition
//
// Command:
// $ goa gen github.com/InjectiveLabs/injective-dmm-be/api/design/olp -o
// ../../gen/olp
//
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message injective_dmm_v2.GetEpochsRequest
 */
export interface GetEpochsRequest {
    /**
     * Filter by status (e.g., 'running')
     *
     * @generated from protobuf field: optional string status = 1
     */
    status?: string;
}
/**
 * @generated from protobuf message injective_dmm_v2.GetEpochsResponse
 */
export interface GetEpochsResponse {
    /**
     * List of epochs
     *
     * @generated from protobuf field: repeated injective_dmm_v2.EpochV2 epochs = 1
     */
    epochs: EpochV2[];
}
/**
 * Epoch data
 *
 * @generated from protobuf message injective_dmm_v2.EpochV2
 */
export interface EpochV2 {
    /**
     * Unique epoch identifier
     *
     * @generated from protobuf field: string epoch_id = 1
     */
    epochId: string;
    /**
     * Epoch status (e.g., 'running', 'completed')
     *
     * @generated from protobuf field: string status = 2
     */
    status: string;
    /**
     * Starting block height
     *
     * @generated from protobuf field: sint64 start_height = 3
     */
    startHeight: bigint;
    /**
     * Ending block height
     *
     * @generated from protobuf field: sint64 end_height = 4
     */
    endHeight: bigint;
    /**
     * Number of snapshots taken
     *
     * @generated from protobuf field: sint32 snapshot_count = 5
     */
    snapshotCount: number;
    /**
     * Number of results
     *
     * @generated from protobuf field: sint32 result_count = 6
     */
    resultCount: number;
    /**
     * Epoch configuration
     *
     * @generated from protobuf field: injective_dmm_v2.EpochConfigV2 config = 7
     */
    config?: EpochConfigV2;
    /**
     * Creation timestamp
     *
     * @generated from protobuf field: string created_at = 8
     */
    createdAt: string;
    /**
     * Last update timestamp
     *
     * @generated from protobuf field: string updated_at = 9
     */
    updatedAt: string;
}
/**
 * Epoch configuration settings
 *
 * @generated from protobuf message injective_dmm_v2.EpochConfigV2
 */
export interface EpochConfigV2 {
    /**
     * Epoch start date
     *
     * @generated from protobuf field: string start_date = 1
     */
    startDate: string;
    /**
     * Epoch end date
     *
     * @generated from protobuf field: string end_date = 2
     */
    endDate: string;
    /**
     * Total INJ reward for the epoch
     *
     * @generated from protobuf field: string reward_inj = 3
     */
    rewardInj: string;
    /**
     * Markets included in the epoch
     *
     * @generated from protobuf field: repeated injective_dmm_v2.Market markets = 4
     */
    markets: Market[];
    /**
     * Exponent for liquidity score calculation
     *
     * @generated from protobuf field: string liquidity_score_exponent = 5
     */
    liquidityScoreExponent: string;
    /**
     * Exponent for uptime score calculation
     *
     * @generated from protobuf field: string uptime_exponent = 6
     */
    uptimeExponent: string;
    /**
     * Exponent for volume score calculation
     *
     * @generated from protobuf field: string volume_exponent = 7
     */
    volumeExponent: string;
    /**
     * Volume threshold for permanence qualification
     *
     * @generated from protobuf field: optional string permanence_volume_threshold = 8
     */
    permanenceVolumeThreshold?: string;
    /**
     * Volume threshold for reward qualification
     *
     * @generated from protobuf field: optional string qualifying_volume_threshold = 9
     */
    qualifyingVolumeThreshold?: string;
    /**
     * Epoch number
     *
     * @generated from protobuf field: sint32 number = 10
     */
    number: number;
    /**
     * Whether this is a mini epoch
     *
     * @generated from protobuf field: bool is_mini_epoch = 11
     */
    isMiniEpoch: boolean;
}
/**
 * Market information
 *
 * @generated from protobuf message injective_dmm_v2.Market
 */
export interface Market {
    /**
     * Market identifier
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * Market ticker symbol
     *
     * @generated from protobuf field: string ticker = 2
     */
    ticker: string;
    /**
     * Market start date
     *
     * @generated from protobuf field: optional string start_date = 3
     */
    startDate?: string;
    /**
     * Pre-allocated reward amount
     *
     * @generated from protobuf field: optional string pre_allocated_reward = 4
     */
    preAllocatedReward?: string;
}
/**
 * @generated from protobuf message injective_dmm_v2.GetTotalScoresRequest
 */
export interface GetTotalScoresRequest {
    /**
     * Epoch identifier
     *
     * @generated from protobuf field: string epoch_id = 1
     */
    epochId: string;
    /**
     * Market identifier
     *
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
    /**
     * Pagination parameters
     *
     * @generated from protobuf field: injective_dmm_v2.Pagination page = 3
     */
    page?: Pagination;
}
/**
 * Pagination parameters for paginated requests and responses
 *
 * @generated from protobuf message injective_dmm_v2.Pagination
 */
export interface Pagination {
    /**
     * Starting offset
     *
     * @generated from protobuf field: optional sint32 from = 1
     */
    from?: number;
    /**
     * Block height
     *
     * @generated from protobuf field: optional sint32 height = 2
     */
    height?: number;
    /**
     * Items per page
     *
     * @generated from protobuf field: optional sint32 per_page = 3
     */
    perPage?: number;
    /**
     * Total count
     *
     * @generated from protobuf field: optional sint32 total = 4
     */
    total?: number;
}
/**
 * @generated from protobuf message injective_dmm_v2.GetTotalScoresResponse
 */
export interface GetTotalScoresResponse {
    /**
     * List of total scores
     *
     * @generated from protobuf field: repeated injective_dmm_v2.TotalScore scores = 1
     */
    scores: TotalScore[];
    /**
     * Next page pagination info
     *
     * @generated from protobuf field: injective_dmm_v2.Pagination next = 2
     */
    next?: Pagination;
}
/**
 * Total score for a market/account in an epoch
 *
 * @generated from protobuf message injective_dmm_v2.TotalScore
 */
export interface TotalScore {
    /**
     * Epoch identifier
     *
     * @generated from protobuf field: string epoch_id = 1
     */
    epochId: string;
    /**
     * Market identifier
     *
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
    /**
     * Account address
     *
     * @generated from protobuf field: string account_address = 3
     */
    accountAddress: string;
    /**
     * Block height
     *
     * @generated from protobuf field: sint64 height = 4
     */
    height: bigint;
    /**
     * Starting block height
     *
     * @generated from protobuf field: sint64 start_height = 5
     */
    startHeight: bigint;
    /**
     * Block timestamp
     *
     * @generated from protobuf field: string block_time = 6
     */
    blockTime: string;
    /**
     * Bid amount
     *
     * @generated from protobuf field: string bid = 7
     */
    bid: string;
    /**
     * Ask amount
     *
     * @generated from protobuf field: string ask = 8
     */
    ask: string;
    /**
     * Order book depth
     *
     * @generated from protobuf field: string depth = 9
     */
    depth: string;
    /**
     * Liquidity score
     *
     * @generated from protobuf field: string liquidity_score = 10
     */
    liquidityScore: string;
    /**
     * Weighted liquidity score
     *
     * @generated from protobuf field: string liquidity_score_ponderated = 11
     */
    liquidityScorePonderated: string;
    /**
     * Uptime score
     *
     * @generated from protobuf field: string uptime_score = 12
     */
    uptimeScore: string;
    /**
     * Weighted uptime score
     *
     * @generated from protobuf field: string uptime_score_ponderated = 13
     */
    uptimeScorePonderated: string;
    /**
     * Uptime percentage
     *
     * @generated from protobuf field: string uptime_percentage = 14
     */
    uptimePercentage: string;
    /**
     * Starting volume
     *
     * @generated from protobuf field: string start_volume = 15
     */
    startVolume: string;
    /**
     * Current volume
     *
     * @generated from protobuf field: string current_volume = 16
     */
    currentVolume: string;
    /**
     * Volume score
     *
     * @generated from protobuf field: string volume_score = 17
     */
    volumeScore: string;
    /**
     * Weighted volume score
     *
     * @generated from protobuf field: string volume_score_ponderated = 18
     */
    volumeScorePonderated: string;
    /**
     * Total combined score
     *
     * @generated from protobuf field: string total_score = 22
     */
    totalScore: string;
    /**
     * Calculated reward amount
     *
     * @generated from protobuf field: string reward = 23
     */
    reward: string;
    /**
     * Reward percentage
     *
     * @generated from protobuf field: string reward_percentage = 24
     */
    rewardPercentage: string;
    /**
     * Creation timestamp
     *
     * @generated from protobuf field: string created_at = 26
     */
    createdAt: string;
    /**
     * Last update timestamp
     *
     * @generated from protobuf field: string updated_at = 27
     */
    updatedAt: string;
    /**
     * Number of snapshots
     *
     * @generated from protobuf field: sint32 snapshot_count = 28
     */
    snapshotCount: number;
    /**
     * Total volume
     *
     * @generated from protobuf field: string volume = 29
     */
    volume: string;
    /**
     * Starting taker volume
     *
     * @generated from protobuf field: string taker_start_volume = 30
     */
    takerStartVolume: string;
    /**
     * Current taker volume
     *
     * @generated from protobuf field: string taker_current_volume = 31
     */
    takerCurrentVolume: string;
    /**
     * Total taker volume
     *
     * @generated from protobuf field: string taker_volume = 32
     */
    takerVolume: string;
    /**
     * Starting maker volume
     *
     * @generated from protobuf field: string maker_start_volume = 33
     */
    makerStartVolume: string;
    /**
     * Current maker volume
     *
     * @generated from protobuf field: string maker_current_volume = 34
     */
    makerCurrentVolume: string;
    /**
     * Total maker volume
     *
     * @generated from protobuf field: string maker_volume = 35
     */
    makerVolume: string;
    /**
     * Bid snapshot value
     *
     * @generated from protobuf field: string bid_snapshot = 36
     */
    bidSnapshot: string;
    /**
     * Ask snapshot value
     *
     * @generated from protobuf field: string ask_snapshot = 37
     */
    askSnapshot: string;
    /**
     * Depth snapshot value
     *
     * @generated from protobuf field: string depth_snapshot = 38
     */
    depthSnapshot: string;
    /**
     * Liquidity score snapshot
     *
     * @generated from protobuf field: string liquidity_score_snapshot = 39
     */
    liquidityScoreSnapshot: string;
    /**
     * Uptime score snapshot
     *
     * @generated from protobuf field: string uptime_score_snapshot = 40
     */
    uptimeScoreSnapshot: string;
    /**
     * Whether to skip this score
     *
     * @generated from protobuf field: bool skip = 41
     */
    skip: boolean;
}
/**
 * @generated from protobuf message injective_dmm_v2.GetTotalScoresHistoryRequest
 */
export interface GetTotalScoresHistoryRequest {
    /**
     * Epoch identifier
     *
     * @generated from protobuf field: string epoch_id = 1
     */
    epochId: string;
    /**
     * Market identifier
     *
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
    /**
     * Account address
     *
     * @generated from protobuf field: string account_address = 3
     */
    accountAddress: string;
    /**
     * Pagination parameters
     *
     * @generated from protobuf field: injective_dmm_v2.Pagination page = 4
     */
    page?: Pagination;
}
/**
 * @generated from protobuf message injective_dmm_v2.GetTotalScoresHistoryResponse
 */
export interface GetTotalScoresHistoryResponse {
    /**
     * List of total scores
     *
     * @generated from protobuf field: repeated injective_dmm_v2.TotalScore scores = 1
     */
    scores: TotalScore[];
    /**
     * Next page pagination info
     *
     * @generated from protobuf field: injective_dmm_v2.Pagination next = 2
     */
    next?: Pagination;
}
/**
 * @generated from protobuf message injective_dmm_v2.GetEpochScoresRequest
 */
export interface GetEpochScoresRequest {
    /**
     * Epoch identifier
     *
     * @generated from protobuf field: string epoch_id = 1
     */
    epochId: string;
    /**
     * Pagination parameters
     *
     * @generated from protobuf field: injective_dmm_v2.Pagination page = 2
     */
    page?: Pagination;
}
/**
 * @generated from protobuf message injective_dmm_v2.GetEpochScoresResponse
 */
export interface GetEpochScoresResponse {
    /**
     * List of epoch scores
     *
     * @generated from protobuf field: repeated injective_dmm_v2.EpochScore scores = 1
     */
    scores: EpochScore[];
    /**
     * Next page pagination info
     *
     * @generated from protobuf field: injective_dmm_v2.Pagination next = 2
     */
    next?: Pagination;
}
/**
 * Epoch score for an account
 *
 * @generated from protobuf message injective_dmm_v2.EpochScore
 */
export interface EpochScore {
    /**
     * Epoch identifier
     *
     * @generated from protobuf field: string epoch_id = 1
     */
    epochId: string;
    /**
     * Account address
     *
     * @generated from protobuf field: string account_address = 2
     */
    accountAddress: string;
    /**
     * Block height
     *
     * @generated from protobuf field: sint64 height = 3
     */
    height: bigint;
    /**
     * Block timestamp
     *
     * @generated from protobuf field: string block_time = 4
     */
    blockTime: string;
    /**
     * Starting block height
     *
     * @generated from protobuf field: sint64 start_height = 5
     */
    startHeight: bigint;
    /**
     * Liquidity score
     *
     * @generated from protobuf field: string liquidity_score = 6
     */
    liquidityScore: string;
    /**
     * Weighted liquidity score
     *
     * @generated from protobuf field: string liquidity_score_ponderated = 7
     */
    liquidityScorePonderated: string;
    /**
     * Uptime score
     *
     * @generated from protobuf field: string uptime_score = 8
     */
    uptimeScore: string;
    /**
     * Weighted uptime score
     *
     * @generated from protobuf field: string uptime_score_ponderated = 9
     */
    uptimeScorePonderated: string;
    /**
     * Volume score
     *
     * @generated from protobuf field: string volume_score = 10
     */
    volumeScore: string;
    /**
     * Weighted volume score
     *
     * @generated from protobuf field: string volume_score_ponderated = 11
     */
    volumeScorePonderated: string;
    /**
     * Total combined score
     *
     * @generated from protobuf field: string total_score = 12
     */
    totalScore: string;
    /**
     * Total volume
     *
     * @generated from protobuf field: string volume = 13
     */
    volume: string;
    /**
     * Maker volume
     *
     * @generated from protobuf field: string maker_volume = 14
     */
    makerVolume: string;
    /**
     * Taker volume
     *
     * @generated from protobuf field: string taker_volume = 15
     */
    takerVolume: string;
    /**
     * Calculated reward amount
     *
     * @generated from protobuf field: string reward = 16
     */
    reward: string;
    /**
     * Reward percentage
     *
     * @generated from protobuf field: string reward_percentage = 17
     */
    rewardPercentage: string;
    /**
     * Whether account qualifies for rewards
     *
     * @generated from protobuf field: bool qualifies = 18
     */
    qualifies: boolean;
    /**
     * Volume percentage
     *
     * @generated from protobuf field: string volume_percentage = 19
     */
    volumePercentage: string;
    /**
     * Creation timestamp
     *
     * @generated from protobuf field: string created_at = 20
     */
    createdAt: string;
    /**
     * Last update timestamp
     *
     * @generated from protobuf field: string updated_at = 21
     */
    updatedAt: string;
    /**
     * Uptime percentage
     *
     * @generated from protobuf field: string uptime_percentage = 22
     */
    uptimePercentage: string;
    /**
     * Order book depth
     *
     * @generated from protobuf field: optional string depth = 23
     */
    depth?: string;
}
/**
 * @generated from protobuf message injective_dmm_v2.GetEpochScoresHistoryRequest
 */
export interface GetEpochScoresHistoryRequest {
    /**
     * Epoch identifier
     *
     * @generated from protobuf field: string epoch_id = 1
     */
    epochId: string;
    /**
     * Account address
     *
     * @generated from protobuf field: string account_address = 2
     */
    accountAddress: string;
    /**
     * Pagination parameters
     *
     * @generated from protobuf field: injective_dmm_v2.Pagination page = 3
     */
    page?: Pagination;
}
/**
 * @generated from protobuf message injective_dmm_v2.GetEpochScoresHistoryResponse
 */
export interface GetEpochScoresHistoryResponse {
    /**
     * List of epoch scores
     *
     * @generated from protobuf field: repeated injective_dmm_v2.EpochScore scores = 1
     */
    scores: EpochScore[];
    /**
     * Next page pagination info
     *
     * @generated from protobuf field: injective_dmm_v2.Pagination next = 2
     */
    next?: Pagination;
}
/**
 * @generated from protobuf message injective_dmm_v2.GetMarketRewardsRequest
 */
export interface GetMarketRewardsRequest {
    /**
     * Epoch identifier
     *
     * @generated from protobuf field: string epoch_id = 1
     */
    epochId: string;
}
/**
 * @generated from protobuf message injective_dmm_v2.GetMarketRewardsResponse
 */
export interface GetMarketRewardsResponse {
    /**
     * List of market rewards
     *
     * @generated from protobuf field: repeated injective_dmm_v2.MarketReward rewards = 1
     */
    rewards: MarketReward[];
}
/**
 * Market reward information
 *
 * @generated from protobuf message injective_dmm_v2.MarketReward
 */
export interface MarketReward {
    /**
     * Epoch identifier
     *
     * @generated from protobuf field: string epoch_id = 1
     */
    epochId: string;
    /**
     * Market identifier
     *
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
    /**
     * Reward amount
     *
     * @generated from protobuf field: string reward = 3
     */
    reward: string;
    /**
     * Reward percentage
     *
     * @generated from protobuf field: string reward_percentage = 4
     */
    rewardPercentage: string;
    /**
     * Start date
     *
     * @generated from protobuf field: string start_date = 5
     */
    startDate: string;
    /**
     * End date
     *
     * @generated from protobuf field: string end_date = 6
     */
    endDate: string;
    /**
     * Total score
     *
     * @generated from protobuf field: string total_score = 9
     */
    totalScore: string;
    /**
     * Creation timestamp
     *
     * @generated from protobuf field: string created_at = 10
     */
    createdAt: string;
    /**
     * Last update timestamp
     *
     * @generated from protobuf field: string updated_at = 11
     */
    updatedAt: string;
    /**
     * Block height
     *
     * @generated from protobuf field: sint64 height = 12
     */
    height: bigint;
    /**
     * Market liquidity
     *
     * @generated from protobuf field: string liquidity = 13
     */
    liquidity: string;
    /**
     * Mini epochs reward
     *
     * @generated from protobuf field: string mini_epochs_reward = 14
     */
    miniEpochsReward: string;
}
/**
 * @generated from protobuf message injective_dmm_v2.GetEligibleAddressesRequest
 */
export interface GetEligibleAddressesRequest {
    /**
     * Epoch identifier
     *
     * @generated from protobuf field: string epoch_id = 1
     */
    epochId: string;
    /**
     * Pagination parameters
     *
     * @generated from protobuf field: injective_dmm_v2.Pagination page = 3
     */
    page?: Pagination;
}
/**
 * @generated from protobuf message injective_dmm_v2.GetEligibleAddressesResponse
 */
export interface GetEligibleAddressesResponse {
    /**
     * List of eligible addresses
     *
     * @generated from protobuf field: repeated injective_dmm_v2.EligibleAddress addresses = 1
     */
    addresses: EligibleAddress[];
    /**
     * Next page pagination info
     *
     * @generated from protobuf field: injective_dmm_v2.Pagination next = 2
     */
    next?: Pagination;
}
/**
 * Eligible address for rewards
 *
 * @generated from protobuf message injective_dmm_v2.EligibleAddress
 */
export interface EligibleAddress {
    /**
     * Epoch identifier
     *
     * @generated from protobuf field: string epoch_id = 1
     */
    epochId: string;
    /**
     * Account address
     *
     * @generated from protobuf field: string account_address = 2
     */
    accountAddress: string;
    /**
     * Block height
     *
     * @generated from protobuf field: sint64 height = 3
     */
    height: bigint;
    /**
     * Source of eligibility
     *
     * @generated from protobuf field: string source = 4
     */
    source: string;
    /**
     * Creation timestamp
     *
     * @generated from protobuf field: string created_at = 5
     */
    createdAt: string;
    /**
     * Last update timestamp
     *
     * @generated from protobuf field: string updated_at = 6
     */
    updatedAt: string;
}
/**
 * @generated from protobuf message injective_dmm_v2.GetRewardsDistributionRequest
 */
export interface GetRewardsDistributionRequest {
    /**
     * Epoch identifier
     *
     * @generated from protobuf field: string epoch_id = 1
     */
    epochId: string;
    /**
     * Pagination parameters
     *
     * @generated from protobuf field: injective_dmm_v2.Pagination page = 2
     */
    page?: Pagination;
    /**
     * Block height filter
     *
     * @generated from protobuf field: optional sint64 height = 3
     */
    height?: bigint;
}
/**
 * @generated from protobuf message injective_dmm_v2.GetRewardsDistributionResponse
 */
export interface GetRewardsDistributionResponse {
    /**
     * List of reward distributions
     *
     * @generated from protobuf field: repeated injective_dmm_v2.RewardDistribution rewards = 1
     */
    rewards: RewardDistribution[];
    /**
     * Next page pagination info
     *
     * @generated from protobuf field: injective_dmm_v2.Pagination next = 2
     */
    next?: Pagination;
}
/**
 * Reward distribution record
 *
 * @generated from protobuf message injective_dmm_v2.RewardDistribution
 */
export interface RewardDistribution {
    /**
     * Epoch identifier
     *
     * @generated from protobuf field: string epoch_id = 1
     */
    epochId: string;
    /**
     * Account address
     *
     * @generated from protobuf field: string account_address = 2
     */
    accountAddress: string;
    /**
     * Block height
     *
     * @generated from protobuf field: sint64 height = 3
     */
    height: bigint;
    /**
     * Starting block height
     *
     * @generated from protobuf field: sint64 start_height = 4
     */
    startHeight: bigint;
    /**
     * Block timestamp
     *
     * @generated from protobuf field: string block_time = 5
     */
    blockTime: string;
    /**
     * Order book depth
     *
     * @generated from protobuf field: string depth = 6
     */
    depth: string;
    /**
     * Reward amount
     *
     * @generated from protobuf field: string reward = 7
     */
    reward: string;
    /**
     * Mini epoch rewards aggregated
     *
     * @generated from protobuf field: optional string mini_epochs_reward = 8
     */
    miniEpochsReward?: string;
    /**
     * Creation timestamp
     *
     * @generated from protobuf field: string created_at = 9
     */
    createdAt: string;
    /**
     * Last update timestamp
     *
     * @generated from protobuf field: string updated_at = 10
     */
    updatedAt: string;
}
/**
 * @generated from protobuf message injective_dmm_v2.GetAccountVolumesRequest
 */
export interface GetAccountVolumesRequest {
    /**
     * Epoch identifier
     *
     * @generated from protobuf field: string epoch_id = 1
     */
    epochId: string;
    /**
     * Account address
     *
     * @generated from protobuf field: string account_address = 2
     */
    accountAddress: string;
}
/**
 * @generated from protobuf message injective_dmm_v2.GetAccountVolumesResponse
 */
export interface GetAccountVolumesResponse {
    /**
     * List of account volumes
     *
     * @generated from protobuf field: repeated injective_dmm_v2.AccountVolume volumes = 1
     */
    volumes: AccountVolume[];
}
/**
 * Account volume data
 *
 * @generated from protobuf message injective_dmm_v2.AccountVolume
 */
export interface AccountVolume {
    /**
     * Epoch identifier
     *
     * @generated from protobuf field: string epoch_id = 1
     */
    epochId: string;
    /**
     * Account address
     *
     * @generated from protobuf field: string account_address = 2
     */
    accountAddress: string;
    /**
     * Block height
     *
     * @generated from protobuf field: sint64 height = 3
     */
    height: bigint;
    /**
     * Block timestamp
     *
     * @generated from protobuf field: string block_time = 4
     */
    blockTime: string;
    /**
     * Date string
     *
     * @generated from protobuf field: string date = 6
     */
    date: string;
    /**
     * Total volume
     *
     * @generated from protobuf field: string volume = 7
     */
    volume: string;
    /**
     * Taker volume
     *
     * @generated from protobuf field: string taker_volume = 8
     */
    takerVolume: string;
    /**
     * Maker volume
     *
     * @generated from protobuf field: string maker_volume = 9
     */
    makerVolume: string;
    /**
     * Volume percentage
     *
     * @generated from protobuf field: string volume_percentage = 10
     */
    volumePercentage: string;
    /**
     * Maker volume percentage
     *
     * @generated from protobuf field: string maker_volume_percentage = 11
     */
    makerVolumePercentage: string;
    /**
     * Taker volume percentage
     *
     * @generated from protobuf field: string taker_volume_percentage = 12
     */
    takerVolumePercentage: string;
    /**
     * Creation timestamp
     *
     * @generated from protobuf field: string created_at = 13
     */
    createdAt: string;
    /**
     * Last update timestamp
     *
     * @generated from protobuf field: string updated_at = 14
     */
    updatedAt: string;
    /**
     * Date as timestamp
     *
     * @generated from protobuf field: string date_timestamp = 15
     */
    dateTimestamp: string;
    /**
     * Daily volume
     *
     * @generated from protobuf field: string daily_volume = 16
     */
    dailyVolume: string;
    /**
     * Daily maker volume
     *
     * @generated from protobuf field: string daily_maker_volume = 17
     */
    dailyMakerVolume: string;
    /**
     * Daily taker volume
     *
     * @generated from protobuf field: string daily_taker_volume = 18
     */
    dailyTakerVolume: string;
    /**
     * Daily volume percentage
     *
     * @generated from protobuf field: string daily_volume_percentage = 19
     */
    dailyVolumePercentage: string;
    /**
     * Daily maker volume percentage
     *
     * @generated from protobuf field: string daily_maker_volume_percentage = 20
     */
    dailyMakerVolumePercentage: string;
    /**
     * Daily taker volume percentage
     *
     * @generated from protobuf field: string daily_taker_volume_percentage = 21
     */
    dailyTakerVolumePercentage: string;
    /**
     * Whether qualified for daily rewards
     *
     * @generated from protobuf field: bool daily_qualified = 22
     */
    dailyQualified: boolean;
}
/**
 * @generated from protobuf message injective_dmm_v2.GetRewardsEligibilityRequest
 */
export interface GetRewardsEligibilityRequest {
    /**
     * Epoch identifier
     *
     * @generated from protobuf field: string epoch_id = 1
     */
    epochId: string;
    /**
     * Account address
     *
     * @generated from protobuf field: string account_address = 2
     */
    accountAddress: string;
}
/**
 * @generated from protobuf message injective_dmm_v2.GetRewardsEligibilityResponse
 */
export interface GetRewardsEligibilityResponse {
    /**
     * Account volume data
     *
     * @generated from protobuf field: repeated injective_dmm_v2.AccountVolume volumes = 1
     */
    volumes: AccountVolume[];
    /**
     * Current maker volume percentage
     *
     * @generated from protobuf field: string current_maker_volume_percentage = 2
     */
    currentMakerVolumePercentage: string;
    /**
     * Average daily maker volume percentage
     *
     * @generated from protobuf field: optional string average_daily_maker_volume_percentage = 3
     */
    averageDailyMakerVolumePercentage?: string;
    /**
     * Whether eligible for next epoch
     *
     * @generated from protobuf field: bool eligible_for_next_epoch = 4
     */
    eligibleForNextEpoch: boolean;
    /**
     * Estimated reward amount
     *
     * @generated from protobuf field: string estimated_reward = 5
     */
    estimatedReward: string;
    /**
     * Whether eligible for current epoch
     *
     * @generated from protobuf field: bool eligible_for_current_epoch = 6
     */
    eligibleForCurrentEpoch: boolean;
    /**
     * Last update timestamp
     *
     * @generated from protobuf field: string updated_at = 7
     */
    updatedAt: string;
}
/**
 * @generated from protobuf message injective_dmm_v2.GetHealthStatusRequest
 */
export interface GetHealthStatusRequest {
}
/**
 * @generated from protobuf message injective_dmm_v2.GetHealthStatusResponse
 */
export interface GetHealthStatusResponse {
    /**
     * Current epoch identifier
     *
     * @generated from protobuf field: string epoch_id = 1
     */
    epochId: string;
    /**
     * Last snapshot block time
     *
     * @generated from protobuf field: string last_snapshot_block_time = 2
     */
    lastSnapshotBlockTime: string;
    /**
     * Last snapshot block height
     *
     * @generated from protobuf field: sint64 last_snapshot_block_height = 3
     */
    lastSnapshotBlockHeight: bigint;
    /**
     * Last update timestamp
     *
     * @generated from protobuf field: string updated_at = 4
     */
    updatedAt: string;
    /**
     * Service status
     *
     * @generated from protobuf field: string status = 5
     */
    status: string;
}
/**
 * @generated from protobuf message injective_dmm_v2.GetMarketRewardsRangeRequest
 */
export interface GetMarketRewardsRangeRequest {
    /**
     * Epoch identifier
     *
     * @generated from protobuf field: string epoch_id = 1
     */
    epochId: string;
    /**
     * Optional market identifier filter
     *
     * @generated from protobuf field: optional string market_id = 2
     */
    marketId?: string;
}
/**
 * @generated from protobuf message injective_dmm_v2.GetMarketRewardsRangeResponse
 */
export interface GetMarketRewardsRangeResponse {
    /**
     * List of market reward ranges
     *
     * @generated from protobuf field: repeated injective_dmm_v2.MarketRewardRange ranges = 1
     */
    ranges: MarketRewardRange[];
}
/**
 * Market reward range
 *
 * @generated from protobuf message injective_dmm_v2.MarketRewardRange
 */
export interface MarketRewardRange {
    /**
     * Market identifier
     *
     * @generated from protobuf field: string market_id = 1
     */
    marketId: string;
    /**
     * Maximum reward
     *
     * @generated from protobuf field: string max = 2
     */
    max: string;
    /**
     * Minimum reward
     *
     * @generated from protobuf field: string min = 3
     */
    min: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class GetEpochsRequest$Type extends MessageType<GetEpochsRequest> {
    constructor() {
        super("injective_dmm_v2.GetEpochsRequest", [
            { no: 1, name: "status", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetEpochsRequest>): GetEpochsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetEpochsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetEpochsRequest): GetEpochsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string status */ 1:
                    message.status = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetEpochsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string status = 1; */
        if (message.status !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_dmm_v2.GetEpochsRequest
 */
export const GetEpochsRequest = new GetEpochsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetEpochsResponse$Type extends MessageType<GetEpochsResponse> {
    constructor() {
        super("injective_dmm_v2.GetEpochsResponse", [
            { no: 1, name: "epochs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => EpochV2 }
        ]);
    }
    create(value?: PartialMessage<GetEpochsResponse>): GetEpochsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.epochs = [];
        if (value !== undefined)
            reflectionMergePartial<GetEpochsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetEpochsResponse): GetEpochsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_dmm_v2.EpochV2 epochs */ 1:
                    message.epochs.push(EpochV2.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetEpochsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_dmm_v2.EpochV2 epochs = 1; */
        for (let i = 0; i < message.epochs.length; i++)
            EpochV2.internalBinaryWrite(message.epochs[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_dmm_v2.GetEpochsResponse
 */
export const GetEpochsResponse = new GetEpochsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EpochV2$Type extends MessageType<EpochV2> {
    constructor() {
        super("injective_dmm_v2.EpochV2", [
            { no: 1, name: "epoch_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "start_height", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "end_height", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "snapshot_count", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 6, name: "result_count", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 7, name: "config", kind: "message", T: () => EpochConfigV2 },
            { no: 8, name: "created_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "updated_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EpochV2>): EpochV2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.epochId = "";
        message.status = "";
        message.startHeight = 0n;
        message.endHeight = 0n;
        message.snapshotCount = 0;
        message.resultCount = 0;
        message.createdAt = "";
        message.updatedAt = "";
        if (value !== undefined)
            reflectionMergePartial<EpochV2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EpochV2): EpochV2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string epoch_id */ 1:
                    message.epochId = reader.string();
                    break;
                case /* string status */ 2:
                    message.status = reader.string();
                    break;
                case /* sint64 start_height */ 3:
                    message.startHeight = reader.sint64().toBigInt();
                    break;
                case /* sint64 end_height */ 4:
                    message.endHeight = reader.sint64().toBigInt();
                    break;
                case /* sint32 snapshot_count */ 5:
                    message.snapshotCount = reader.sint32();
                    break;
                case /* sint32 result_count */ 6:
                    message.resultCount = reader.sint32();
                    break;
                case /* injective_dmm_v2.EpochConfigV2 config */ 7:
                    message.config = EpochConfigV2.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                case /* string created_at */ 8:
                    message.createdAt = reader.string();
                    break;
                case /* string updated_at */ 9:
                    message.updatedAt = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EpochV2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string epoch_id = 1; */
        if (message.epochId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.epochId);
        /* string status = 2; */
        if (message.status !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.status);
        /* sint64 start_height = 3; */
        if (message.startHeight !== 0n)
            writer.tag(3, WireType.Varint).sint64(message.startHeight);
        /* sint64 end_height = 4; */
        if (message.endHeight !== 0n)
            writer.tag(4, WireType.Varint).sint64(message.endHeight);
        /* sint32 snapshot_count = 5; */
        if (message.snapshotCount !== 0)
            writer.tag(5, WireType.Varint).sint32(message.snapshotCount);
        /* sint32 result_count = 6; */
        if (message.resultCount !== 0)
            writer.tag(6, WireType.Varint).sint32(message.resultCount);
        /* injective_dmm_v2.EpochConfigV2 config = 7; */
        if (message.config)
            EpochConfigV2.internalBinaryWrite(message.config, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* string created_at = 8; */
        if (message.createdAt !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.createdAt);
        /* string updated_at = 9; */
        if (message.updatedAt !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.updatedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_dmm_v2.EpochV2
 */
export const EpochV2 = new EpochV2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EpochConfigV2$Type extends MessageType<EpochConfigV2> {
    constructor() {
        super("injective_dmm_v2.EpochConfigV2", [
            { no: 1, name: "start_date", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "end_date", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "reward_inj", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "markets", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Market },
            { no: 5, name: "liquidity_score_exponent", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "uptime_exponent", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "volume_exponent", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "permanence_volume_threshold", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "qualifying_volume_threshold", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "number", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 11, name: "is_mini_epoch", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<EpochConfigV2>): EpochConfigV2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.startDate = "";
        message.endDate = "";
        message.rewardInj = "";
        message.markets = [];
        message.liquidityScoreExponent = "";
        message.uptimeExponent = "";
        message.volumeExponent = "";
        message.number = 0;
        message.isMiniEpoch = false;
        if (value !== undefined)
            reflectionMergePartial<EpochConfigV2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EpochConfigV2): EpochConfigV2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string start_date */ 1:
                    message.startDate = reader.string();
                    break;
                case /* string end_date */ 2:
                    message.endDate = reader.string();
                    break;
                case /* string reward_inj */ 3:
                    message.rewardInj = reader.string();
                    break;
                case /* repeated injective_dmm_v2.Market markets */ 4:
                    message.markets.push(Market.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string liquidity_score_exponent */ 5:
                    message.liquidityScoreExponent = reader.string();
                    break;
                case /* string uptime_exponent */ 6:
                    message.uptimeExponent = reader.string();
                    break;
                case /* string volume_exponent */ 7:
                    message.volumeExponent = reader.string();
                    break;
                case /* optional string permanence_volume_threshold */ 8:
                    message.permanenceVolumeThreshold = reader.string();
                    break;
                case /* optional string qualifying_volume_threshold */ 9:
                    message.qualifyingVolumeThreshold = reader.string();
                    break;
                case /* sint32 number */ 10:
                    message.number = reader.sint32();
                    break;
                case /* bool is_mini_epoch */ 11:
                    message.isMiniEpoch = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EpochConfigV2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string start_date = 1; */
        if (message.startDate !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.startDate);
        /* string end_date = 2; */
        if (message.endDate !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.endDate);
        /* string reward_inj = 3; */
        if (message.rewardInj !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.rewardInj);
        /* repeated injective_dmm_v2.Market markets = 4; */
        for (let i = 0; i < message.markets.length; i++)
            Market.internalBinaryWrite(message.markets[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string liquidity_score_exponent = 5; */
        if (message.liquidityScoreExponent !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.liquidityScoreExponent);
        /* string uptime_exponent = 6; */
        if (message.uptimeExponent !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.uptimeExponent);
        /* string volume_exponent = 7; */
        if (message.volumeExponent !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.volumeExponent);
        /* optional string permanence_volume_threshold = 8; */
        if (message.permanenceVolumeThreshold !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.permanenceVolumeThreshold);
        /* optional string qualifying_volume_threshold = 9; */
        if (message.qualifyingVolumeThreshold !== undefined)
            writer.tag(9, WireType.LengthDelimited).string(message.qualifyingVolumeThreshold);
        /* sint32 number = 10; */
        if (message.number !== 0)
            writer.tag(10, WireType.Varint).sint32(message.number);
        /* bool is_mini_epoch = 11; */
        if (message.isMiniEpoch !== false)
            writer.tag(11, WireType.Varint).bool(message.isMiniEpoch);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_dmm_v2.EpochConfigV2
 */
export const EpochConfigV2 = new EpochConfigV2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Market$Type extends MessageType<Market> {
    constructor() {
        super("injective_dmm_v2.Market", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ticker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "start_date", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "pre_allocated_reward", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Market>): Market {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.ticker = "";
        if (value !== undefined)
            reflectionMergePartial<Market>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Market): Market {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* string ticker */ 2:
                    message.ticker = reader.string();
                    break;
                case /* optional string start_date */ 3:
                    message.startDate = reader.string();
                    break;
                case /* optional string pre_allocated_reward */ 4:
                    message.preAllocatedReward = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Market, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* string ticker = 2; */
        if (message.ticker !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.ticker);
        /* optional string start_date = 3; */
        if (message.startDate !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.startDate);
        /* optional string pre_allocated_reward = 4; */
        if (message.preAllocatedReward !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.preAllocatedReward);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_dmm_v2.Market
 */
export const Market = new Market$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTotalScoresRequest$Type extends MessageType<GetTotalScoresRequest> {
    constructor() {
        super("injective_dmm_v2.GetTotalScoresRequest", [
            { no: 1, name: "epoch_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "page", kind: "message", T: () => Pagination }
        ]);
    }
    create(value?: PartialMessage<GetTotalScoresRequest>): GetTotalScoresRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.epochId = "";
        message.marketId = "";
        if (value !== undefined)
            reflectionMergePartial<GetTotalScoresRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTotalScoresRequest): GetTotalScoresRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string epoch_id */ 1:
                    message.epochId = reader.string();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                case /* injective_dmm_v2.Pagination page */ 3:
                    message.page = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.page);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTotalScoresRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string epoch_id = 1; */
        if (message.epochId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.epochId);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        /* injective_dmm_v2.Pagination page = 3; */
        if (message.page)
            Pagination.internalBinaryWrite(message.page, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_dmm_v2.GetTotalScoresRequest
 */
export const GetTotalScoresRequest = new GetTotalScoresRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Pagination$Type extends MessageType<Pagination> {
    constructor() {
        super("injective_dmm_v2.Pagination", [
            { no: 1, name: "from", kind: "scalar", opt: true, T: 17 /*ScalarType.SINT32*/ },
            { no: 2, name: "height", kind: "scalar", opt: true, T: 17 /*ScalarType.SINT32*/ },
            { no: 3, name: "per_page", kind: "scalar", opt: true, T: 17 /*ScalarType.SINT32*/ },
            { no: 4, name: "total", kind: "scalar", opt: true, T: 17 /*ScalarType.SINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Pagination>): Pagination {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Pagination>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Pagination): Pagination {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional sint32 from */ 1:
                    message.from = reader.sint32();
                    break;
                case /* optional sint32 height */ 2:
                    message.height = reader.sint32();
                    break;
                case /* optional sint32 per_page */ 3:
                    message.perPage = reader.sint32();
                    break;
                case /* optional sint32 total */ 4:
                    message.total = reader.sint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Pagination, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional sint32 from = 1; */
        if (message.from !== undefined)
            writer.tag(1, WireType.Varint).sint32(message.from);
        /* optional sint32 height = 2; */
        if (message.height !== undefined)
            writer.tag(2, WireType.Varint).sint32(message.height);
        /* optional sint32 per_page = 3; */
        if (message.perPage !== undefined)
            writer.tag(3, WireType.Varint).sint32(message.perPage);
        /* optional sint32 total = 4; */
        if (message.total !== undefined)
            writer.tag(4, WireType.Varint).sint32(message.total);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_dmm_v2.Pagination
 */
export const Pagination = new Pagination$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTotalScoresResponse$Type extends MessageType<GetTotalScoresResponse> {
    constructor() {
        super("injective_dmm_v2.GetTotalScoresResponse", [
            { no: 1, name: "scores", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TotalScore },
            { no: 2, name: "next", kind: "message", T: () => Pagination }
        ]);
    }
    create(value?: PartialMessage<GetTotalScoresResponse>): GetTotalScoresResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.scores = [];
        if (value !== undefined)
            reflectionMergePartial<GetTotalScoresResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTotalScoresResponse): GetTotalScoresResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_dmm_v2.TotalScore scores */ 1:
                    message.scores.push(TotalScore.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* injective_dmm_v2.Pagination next */ 2:
                    message.next = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.next);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTotalScoresResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_dmm_v2.TotalScore scores = 1; */
        for (let i = 0; i < message.scores.length; i++)
            TotalScore.internalBinaryWrite(message.scores[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* injective_dmm_v2.Pagination next = 2; */
        if (message.next)
            Pagination.internalBinaryWrite(message.next, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_dmm_v2.GetTotalScoresResponse
 */
export const GetTotalScoresResponse = new GetTotalScoresResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TotalScore$Type extends MessageType<TotalScore> {
    constructor() {
        super("injective_dmm_v2.TotalScore", [
            { no: 1, name: "epoch_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "height", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "start_height", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "block_time", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "bid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "ask", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "depth", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "liquidity_score", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "liquidity_score_ponderated", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "uptime_score", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "uptime_score_ponderated", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "uptime_percentage", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "start_volume", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "current_volume", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "volume_score", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 18, name: "volume_score_ponderated", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 22, name: "total_score", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 23, name: "reward", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 24, name: "reward_percentage", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 26, name: "created_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 27, name: "updated_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 28, name: "snapshot_count", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 29, name: "volume", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 30, name: "taker_start_volume", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 31, name: "taker_current_volume", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 32, name: "taker_volume", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 33, name: "maker_start_volume", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 34, name: "maker_current_volume", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 35, name: "maker_volume", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 36, name: "bid_snapshot", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 37, name: "ask_snapshot", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 38, name: "depth_snapshot", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 39, name: "liquidity_score_snapshot", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 40, name: "uptime_score_snapshot", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 41, name: "skip", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<TotalScore>): TotalScore {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.epochId = "";
        message.marketId = "";
        message.accountAddress = "";
        message.height = 0n;
        message.startHeight = 0n;
        message.blockTime = "";
        message.bid = "";
        message.ask = "";
        message.depth = "";
        message.liquidityScore = "";
        message.liquidityScorePonderated = "";
        message.uptimeScore = "";
        message.uptimeScorePonderated = "";
        message.uptimePercentage = "";
        message.startVolume = "";
        message.currentVolume = "";
        message.volumeScore = "";
        message.volumeScorePonderated = "";
        message.totalScore = "";
        message.reward = "";
        message.rewardPercentage = "";
        message.createdAt = "";
        message.updatedAt = "";
        message.snapshotCount = 0;
        message.volume = "";
        message.takerStartVolume = "";
        message.takerCurrentVolume = "";
        message.takerVolume = "";
        message.makerStartVolume = "";
        message.makerCurrentVolume = "";
        message.makerVolume = "";
        message.bidSnapshot = "";
        message.askSnapshot = "";
        message.depthSnapshot = "";
        message.liquidityScoreSnapshot = "";
        message.uptimeScoreSnapshot = "";
        message.skip = false;
        if (value !== undefined)
            reflectionMergePartial<TotalScore>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TotalScore): TotalScore {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string epoch_id */ 1:
                    message.epochId = reader.string();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                case /* string account_address */ 3:
                    message.accountAddress = reader.string();
                    break;
                case /* sint64 height */ 4:
                    message.height = reader.sint64().toBigInt();
                    break;
                case /* sint64 start_height */ 5:
                    message.startHeight = reader.sint64().toBigInt();
                    break;
                case /* string block_time */ 6:
                    message.blockTime = reader.string();
                    break;
                case /* string bid */ 7:
                    message.bid = reader.string();
                    break;
                case /* string ask */ 8:
                    message.ask = reader.string();
                    break;
                case /* string depth */ 9:
                    message.depth = reader.string();
                    break;
                case /* string liquidity_score */ 10:
                    message.liquidityScore = reader.string();
                    break;
                case /* string liquidity_score_ponderated */ 11:
                    message.liquidityScorePonderated = reader.string();
                    break;
                case /* string uptime_score */ 12:
                    message.uptimeScore = reader.string();
                    break;
                case /* string uptime_score_ponderated */ 13:
                    message.uptimeScorePonderated = reader.string();
                    break;
                case /* string uptime_percentage */ 14:
                    message.uptimePercentage = reader.string();
                    break;
                case /* string start_volume */ 15:
                    message.startVolume = reader.string();
                    break;
                case /* string current_volume */ 16:
                    message.currentVolume = reader.string();
                    break;
                case /* string volume_score */ 17:
                    message.volumeScore = reader.string();
                    break;
                case /* string volume_score_ponderated */ 18:
                    message.volumeScorePonderated = reader.string();
                    break;
                case /* string total_score */ 22:
                    message.totalScore = reader.string();
                    break;
                case /* string reward */ 23:
                    message.reward = reader.string();
                    break;
                case /* string reward_percentage */ 24:
                    message.rewardPercentage = reader.string();
                    break;
                case /* string created_at */ 26:
                    message.createdAt = reader.string();
                    break;
                case /* string updated_at */ 27:
                    message.updatedAt = reader.string();
                    break;
                case /* sint32 snapshot_count */ 28:
                    message.snapshotCount = reader.sint32();
                    break;
                case /* string volume */ 29:
                    message.volume = reader.string();
                    break;
                case /* string taker_start_volume */ 30:
                    message.takerStartVolume = reader.string();
                    break;
                case /* string taker_current_volume */ 31:
                    message.takerCurrentVolume = reader.string();
                    break;
                case /* string taker_volume */ 32:
                    message.takerVolume = reader.string();
                    break;
                case /* string maker_start_volume */ 33:
                    message.makerStartVolume = reader.string();
                    break;
                case /* string maker_current_volume */ 34:
                    message.makerCurrentVolume = reader.string();
                    break;
                case /* string maker_volume */ 35:
                    message.makerVolume = reader.string();
                    break;
                case /* string bid_snapshot */ 36:
                    message.bidSnapshot = reader.string();
                    break;
                case /* string ask_snapshot */ 37:
                    message.askSnapshot = reader.string();
                    break;
                case /* string depth_snapshot */ 38:
                    message.depthSnapshot = reader.string();
                    break;
                case /* string liquidity_score_snapshot */ 39:
                    message.liquidityScoreSnapshot = reader.string();
                    break;
                case /* string uptime_score_snapshot */ 40:
                    message.uptimeScoreSnapshot = reader.string();
                    break;
                case /* bool skip */ 41:
                    message.skip = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TotalScore, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string epoch_id = 1; */
        if (message.epochId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.epochId);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        /* string account_address = 3; */
        if (message.accountAddress !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.accountAddress);
        /* sint64 height = 4; */
        if (message.height !== 0n)
            writer.tag(4, WireType.Varint).sint64(message.height);
        /* sint64 start_height = 5; */
        if (message.startHeight !== 0n)
            writer.tag(5, WireType.Varint).sint64(message.startHeight);
        /* string block_time = 6; */
        if (message.blockTime !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.blockTime);
        /* string bid = 7; */
        if (message.bid !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.bid);
        /* string ask = 8; */
        if (message.ask !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.ask);
        /* string depth = 9; */
        if (message.depth !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.depth);
        /* string liquidity_score = 10; */
        if (message.liquidityScore !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.liquidityScore);
        /* string liquidity_score_ponderated = 11; */
        if (message.liquidityScorePonderated !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.liquidityScorePonderated);
        /* string uptime_score = 12; */
        if (message.uptimeScore !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.uptimeScore);
        /* string uptime_score_ponderated = 13; */
        if (message.uptimeScorePonderated !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.uptimeScorePonderated);
        /* string uptime_percentage = 14; */
        if (message.uptimePercentage !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.uptimePercentage);
        /* string start_volume = 15; */
        if (message.startVolume !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.startVolume);
        /* string current_volume = 16; */
        if (message.currentVolume !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.currentVolume);
        /* string volume_score = 17; */
        if (message.volumeScore !== "")
            writer.tag(17, WireType.LengthDelimited).string(message.volumeScore);
        /* string volume_score_ponderated = 18; */
        if (message.volumeScorePonderated !== "")
            writer.tag(18, WireType.LengthDelimited).string(message.volumeScorePonderated);
        /* string total_score = 22; */
        if (message.totalScore !== "")
            writer.tag(22, WireType.LengthDelimited).string(message.totalScore);
        /* string reward = 23; */
        if (message.reward !== "")
            writer.tag(23, WireType.LengthDelimited).string(message.reward);
        /* string reward_percentage = 24; */
        if (message.rewardPercentage !== "")
            writer.tag(24, WireType.LengthDelimited).string(message.rewardPercentage);
        /* string created_at = 26; */
        if (message.createdAt !== "")
            writer.tag(26, WireType.LengthDelimited).string(message.createdAt);
        /* string updated_at = 27; */
        if (message.updatedAt !== "")
            writer.tag(27, WireType.LengthDelimited).string(message.updatedAt);
        /* sint32 snapshot_count = 28; */
        if (message.snapshotCount !== 0)
            writer.tag(28, WireType.Varint).sint32(message.snapshotCount);
        /* string volume = 29; */
        if (message.volume !== "")
            writer.tag(29, WireType.LengthDelimited).string(message.volume);
        /* string taker_start_volume = 30; */
        if (message.takerStartVolume !== "")
            writer.tag(30, WireType.LengthDelimited).string(message.takerStartVolume);
        /* string taker_current_volume = 31; */
        if (message.takerCurrentVolume !== "")
            writer.tag(31, WireType.LengthDelimited).string(message.takerCurrentVolume);
        /* string taker_volume = 32; */
        if (message.takerVolume !== "")
            writer.tag(32, WireType.LengthDelimited).string(message.takerVolume);
        /* string maker_start_volume = 33; */
        if (message.makerStartVolume !== "")
            writer.tag(33, WireType.LengthDelimited).string(message.makerStartVolume);
        /* string maker_current_volume = 34; */
        if (message.makerCurrentVolume !== "")
            writer.tag(34, WireType.LengthDelimited).string(message.makerCurrentVolume);
        /* string maker_volume = 35; */
        if (message.makerVolume !== "")
            writer.tag(35, WireType.LengthDelimited).string(message.makerVolume);
        /* string bid_snapshot = 36; */
        if (message.bidSnapshot !== "")
            writer.tag(36, WireType.LengthDelimited).string(message.bidSnapshot);
        /* string ask_snapshot = 37; */
        if (message.askSnapshot !== "")
            writer.tag(37, WireType.LengthDelimited).string(message.askSnapshot);
        /* string depth_snapshot = 38; */
        if (message.depthSnapshot !== "")
            writer.tag(38, WireType.LengthDelimited).string(message.depthSnapshot);
        /* string liquidity_score_snapshot = 39; */
        if (message.liquidityScoreSnapshot !== "")
            writer.tag(39, WireType.LengthDelimited).string(message.liquidityScoreSnapshot);
        /* string uptime_score_snapshot = 40; */
        if (message.uptimeScoreSnapshot !== "")
            writer.tag(40, WireType.LengthDelimited).string(message.uptimeScoreSnapshot);
        /* bool skip = 41; */
        if (message.skip !== false)
            writer.tag(41, WireType.Varint).bool(message.skip);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_dmm_v2.TotalScore
 */
export const TotalScore = new TotalScore$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTotalScoresHistoryRequest$Type extends MessageType<GetTotalScoresHistoryRequest> {
    constructor() {
        super("injective_dmm_v2.GetTotalScoresHistoryRequest", [
            { no: 1, name: "epoch_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "page", kind: "message", T: () => Pagination }
        ]);
    }
    create(value?: PartialMessage<GetTotalScoresHistoryRequest>): GetTotalScoresHistoryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.epochId = "";
        message.marketId = "";
        message.accountAddress = "";
        if (value !== undefined)
            reflectionMergePartial<GetTotalScoresHistoryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTotalScoresHistoryRequest): GetTotalScoresHistoryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string epoch_id */ 1:
                    message.epochId = reader.string();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                case /* string account_address */ 3:
                    message.accountAddress = reader.string();
                    break;
                case /* injective_dmm_v2.Pagination page */ 4:
                    message.page = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.page);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTotalScoresHistoryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string epoch_id = 1; */
        if (message.epochId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.epochId);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        /* string account_address = 3; */
        if (message.accountAddress !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.accountAddress);
        /* injective_dmm_v2.Pagination page = 4; */
        if (message.page)
            Pagination.internalBinaryWrite(message.page, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_dmm_v2.GetTotalScoresHistoryRequest
 */
export const GetTotalScoresHistoryRequest = new GetTotalScoresHistoryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTotalScoresHistoryResponse$Type extends MessageType<GetTotalScoresHistoryResponse> {
    constructor() {
        super("injective_dmm_v2.GetTotalScoresHistoryResponse", [
            { no: 1, name: "scores", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TotalScore },
            { no: 2, name: "next", kind: "message", T: () => Pagination }
        ]);
    }
    create(value?: PartialMessage<GetTotalScoresHistoryResponse>): GetTotalScoresHistoryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.scores = [];
        if (value !== undefined)
            reflectionMergePartial<GetTotalScoresHistoryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTotalScoresHistoryResponse): GetTotalScoresHistoryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_dmm_v2.TotalScore scores */ 1:
                    message.scores.push(TotalScore.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* injective_dmm_v2.Pagination next */ 2:
                    message.next = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.next);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTotalScoresHistoryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_dmm_v2.TotalScore scores = 1; */
        for (let i = 0; i < message.scores.length; i++)
            TotalScore.internalBinaryWrite(message.scores[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* injective_dmm_v2.Pagination next = 2; */
        if (message.next)
            Pagination.internalBinaryWrite(message.next, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_dmm_v2.GetTotalScoresHistoryResponse
 */
export const GetTotalScoresHistoryResponse = new GetTotalScoresHistoryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetEpochScoresRequest$Type extends MessageType<GetEpochScoresRequest> {
    constructor() {
        super("injective_dmm_v2.GetEpochScoresRequest", [
            { no: 1, name: "epoch_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "page", kind: "message", T: () => Pagination }
        ]);
    }
    create(value?: PartialMessage<GetEpochScoresRequest>): GetEpochScoresRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.epochId = "";
        if (value !== undefined)
            reflectionMergePartial<GetEpochScoresRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetEpochScoresRequest): GetEpochScoresRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string epoch_id */ 1:
                    message.epochId = reader.string();
                    break;
                case /* injective_dmm_v2.Pagination page */ 2:
                    message.page = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.page);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetEpochScoresRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string epoch_id = 1; */
        if (message.epochId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.epochId);
        /* injective_dmm_v2.Pagination page = 2; */
        if (message.page)
            Pagination.internalBinaryWrite(message.page, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_dmm_v2.GetEpochScoresRequest
 */
export const GetEpochScoresRequest = new GetEpochScoresRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetEpochScoresResponse$Type extends MessageType<GetEpochScoresResponse> {
    constructor() {
        super("injective_dmm_v2.GetEpochScoresResponse", [
            { no: 1, name: "scores", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => EpochScore },
            { no: 2, name: "next", kind: "message", T: () => Pagination }
        ]);
    }
    create(value?: PartialMessage<GetEpochScoresResponse>): GetEpochScoresResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.scores = [];
        if (value !== undefined)
            reflectionMergePartial<GetEpochScoresResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetEpochScoresResponse): GetEpochScoresResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_dmm_v2.EpochScore scores */ 1:
                    message.scores.push(EpochScore.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* injective_dmm_v2.Pagination next */ 2:
                    message.next = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.next);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetEpochScoresResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_dmm_v2.EpochScore scores = 1; */
        for (let i = 0; i < message.scores.length; i++)
            EpochScore.internalBinaryWrite(message.scores[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* injective_dmm_v2.Pagination next = 2; */
        if (message.next)
            Pagination.internalBinaryWrite(message.next, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_dmm_v2.GetEpochScoresResponse
 */
export const GetEpochScoresResponse = new GetEpochScoresResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EpochScore$Type extends MessageType<EpochScore> {
    constructor() {
        super("injective_dmm_v2.EpochScore", [
            { no: 1, name: "epoch_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "height", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "block_time", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "start_height", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "liquidity_score", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "liquidity_score_ponderated", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "uptime_score", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "uptime_score_ponderated", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "volume_score", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "volume_score_ponderated", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "total_score", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "volume", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "maker_volume", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "taker_volume", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "reward", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "reward_percentage", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 18, name: "qualifies", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 19, name: "volume_percentage", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 20, name: "created_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 21, name: "updated_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 22, name: "uptime_percentage", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 23, name: "depth", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EpochScore>): EpochScore {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.epochId = "";
        message.accountAddress = "";
        message.height = 0n;
        message.blockTime = "";
        message.startHeight = 0n;
        message.liquidityScore = "";
        message.liquidityScorePonderated = "";
        message.uptimeScore = "";
        message.uptimeScorePonderated = "";
        message.volumeScore = "";
        message.volumeScorePonderated = "";
        message.totalScore = "";
        message.volume = "";
        message.makerVolume = "";
        message.takerVolume = "";
        message.reward = "";
        message.rewardPercentage = "";
        message.qualifies = false;
        message.volumePercentage = "";
        message.createdAt = "";
        message.updatedAt = "";
        message.uptimePercentage = "";
        if (value !== undefined)
            reflectionMergePartial<EpochScore>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EpochScore): EpochScore {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string epoch_id */ 1:
                    message.epochId = reader.string();
                    break;
                case /* string account_address */ 2:
                    message.accountAddress = reader.string();
                    break;
                case /* sint64 height */ 3:
                    message.height = reader.sint64().toBigInt();
                    break;
                case /* string block_time */ 4:
                    message.blockTime = reader.string();
                    break;
                case /* sint64 start_height */ 5:
                    message.startHeight = reader.sint64().toBigInt();
                    break;
                case /* string liquidity_score */ 6:
                    message.liquidityScore = reader.string();
                    break;
                case /* string liquidity_score_ponderated */ 7:
                    message.liquidityScorePonderated = reader.string();
                    break;
                case /* string uptime_score */ 8:
                    message.uptimeScore = reader.string();
                    break;
                case /* string uptime_score_ponderated */ 9:
                    message.uptimeScorePonderated = reader.string();
                    break;
                case /* string volume_score */ 10:
                    message.volumeScore = reader.string();
                    break;
                case /* string volume_score_ponderated */ 11:
                    message.volumeScorePonderated = reader.string();
                    break;
                case /* string total_score */ 12:
                    message.totalScore = reader.string();
                    break;
                case /* string volume */ 13:
                    message.volume = reader.string();
                    break;
                case /* string maker_volume */ 14:
                    message.makerVolume = reader.string();
                    break;
                case /* string taker_volume */ 15:
                    message.takerVolume = reader.string();
                    break;
                case /* string reward */ 16:
                    message.reward = reader.string();
                    break;
                case /* string reward_percentage */ 17:
                    message.rewardPercentage = reader.string();
                    break;
                case /* bool qualifies */ 18:
                    message.qualifies = reader.bool();
                    break;
                case /* string volume_percentage */ 19:
                    message.volumePercentage = reader.string();
                    break;
                case /* string created_at */ 20:
                    message.createdAt = reader.string();
                    break;
                case /* string updated_at */ 21:
                    message.updatedAt = reader.string();
                    break;
                case /* string uptime_percentage */ 22:
                    message.uptimePercentage = reader.string();
                    break;
                case /* optional string depth */ 23:
                    message.depth = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EpochScore, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string epoch_id = 1; */
        if (message.epochId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.epochId);
        /* string account_address = 2; */
        if (message.accountAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.accountAddress);
        /* sint64 height = 3; */
        if (message.height !== 0n)
            writer.tag(3, WireType.Varint).sint64(message.height);
        /* string block_time = 4; */
        if (message.blockTime !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.blockTime);
        /* sint64 start_height = 5; */
        if (message.startHeight !== 0n)
            writer.tag(5, WireType.Varint).sint64(message.startHeight);
        /* string liquidity_score = 6; */
        if (message.liquidityScore !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.liquidityScore);
        /* string liquidity_score_ponderated = 7; */
        if (message.liquidityScorePonderated !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.liquidityScorePonderated);
        /* string uptime_score = 8; */
        if (message.uptimeScore !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.uptimeScore);
        /* string uptime_score_ponderated = 9; */
        if (message.uptimeScorePonderated !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.uptimeScorePonderated);
        /* string volume_score = 10; */
        if (message.volumeScore !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.volumeScore);
        /* string volume_score_ponderated = 11; */
        if (message.volumeScorePonderated !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.volumeScorePonderated);
        /* string total_score = 12; */
        if (message.totalScore !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.totalScore);
        /* string volume = 13; */
        if (message.volume !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.volume);
        /* string maker_volume = 14; */
        if (message.makerVolume !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.makerVolume);
        /* string taker_volume = 15; */
        if (message.takerVolume !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.takerVolume);
        /* string reward = 16; */
        if (message.reward !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.reward);
        /* string reward_percentage = 17; */
        if (message.rewardPercentage !== "")
            writer.tag(17, WireType.LengthDelimited).string(message.rewardPercentage);
        /* bool qualifies = 18; */
        if (message.qualifies !== false)
            writer.tag(18, WireType.Varint).bool(message.qualifies);
        /* string volume_percentage = 19; */
        if (message.volumePercentage !== "")
            writer.tag(19, WireType.LengthDelimited).string(message.volumePercentage);
        /* string created_at = 20; */
        if (message.createdAt !== "")
            writer.tag(20, WireType.LengthDelimited).string(message.createdAt);
        /* string updated_at = 21; */
        if (message.updatedAt !== "")
            writer.tag(21, WireType.LengthDelimited).string(message.updatedAt);
        /* string uptime_percentage = 22; */
        if (message.uptimePercentage !== "")
            writer.tag(22, WireType.LengthDelimited).string(message.uptimePercentage);
        /* optional string depth = 23; */
        if (message.depth !== undefined)
            writer.tag(23, WireType.LengthDelimited).string(message.depth);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_dmm_v2.EpochScore
 */
export const EpochScore = new EpochScore$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetEpochScoresHistoryRequest$Type extends MessageType<GetEpochScoresHistoryRequest> {
    constructor() {
        super("injective_dmm_v2.GetEpochScoresHistoryRequest", [
            { no: 1, name: "epoch_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "page", kind: "message", T: () => Pagination }
        ]);
    }
    create(value?: PartialMessage<GetEpochScoresHistoryRequest>): GetEpochScoresHistoryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.epochId = "";
        message.accountAddress = "";
        if (value !== undefined)
            reflectionMergePartial<GetEpochScoresHistoryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetEpochScoresHistoryRequest): GetEpochScoresHistoryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string epoch_id */ 1:
                    message.epochId = reader.string();
                    break;
                case /* string account_address */ 2:
                    message.accountAddress = reader.string();
                    break;
                case /* injective_dmm_v2.Pagination page */ 3:
                    message.page = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.page);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetEpochScoresHistoryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string epoch_id = 1; */
        if (message.epochId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.epochId);
        /* string account_address = 2; */
        if (message.accountAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.accountAddress);
        /* injective_dmm_v2.Pagination page = 3; */
        if (message.page)
            Pagination.internalBinaryWrite(message.page, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_dmm_v2.GetEpochScoresHistoryRequest
 */
export const GetEpochScoresHistoryRequest = new GetEpochScoresHistoryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetEpochScoresHistoryResponse$Type extends MessageType<GetEpochScoresHistoryResponse> {
    constructor() {
        super("injective_dmm_v2.GetEpochScoresHistoryResponse", [
            { no: 1, name: "scores", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => EpochScore },
            { no: 2, name: "next", kind: "message", T: () => Pagination }
        ]);
    }
    create(value?: PartialMessage<GetEpochScoresHistoryResponse>): GetEpochScoresHistoryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.scores = [];
        if (value !== undefined)
            reflectionMergePartial<GetEpochScoresHistoryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetEpochScoresHistoryResponse): GetEpochScoresHistoryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_dmm_v2.EpochScore scores */ 1:
                    message.scores.push(EpochScore.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* injective_dmm_v2.Pagination next */ 2:
                    message.next = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.next);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetEpochScoresHistoryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_dmm_v2.EpochScore scores = 1; */
        for (let i = 0; i < message.scores.length; i++)
            EpochScore.internalBinaryWrite(message.scores[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* injective_dmm_v2.Pagination next = 2; */
        if (message.next)
            Pagination.internalBinaryWrite(message.next, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_dmm_v2.GetEpochScoresHistoryResponse
 */
export const GetEpochScoresHistoryResponse = new GetEpochScoresHistoryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMarketRewardsRequest$Type extends MessageType<GetMarketRewardsRequest> {
    constructor() {
        super("injective_dmm_v2.GetMarketRewardsRequest", [
            { no: 1, name: "epoch_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetMarketRewardsRequest>): GetMarketRewardsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.epochId = "";
        if (value !== undefined)
            reflectionMergePartial<GetMarketRewardsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMarketRewardsRequest): GetMarketRewardsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string epoch_id */ 1:
                    message.epochId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMarketRewardsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string epoch_id = 1; */
        if (message.epochId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.epochId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_dmm_v2.GetMarketRewardsRequest
 */
export const GetMarketRewardsRequest = new GetMarketRewardsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMarketRewardsResponse$Type extends MessageType<GetMarketRewardsResponse> {
    constructor() {
        super("injective_dmm_v2.GetMarketRewardsResponse", [
            { no: 1, name: "rewards", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => MarketReward }
        ]);
    }
    create(value?: PartialMessage<GetMarketRewardsResponse>): GetMarketRewardsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rewards = [];
        if (value !== undefined)
            reflectionMergePartial<GetMarketRewardsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMarketRewardsResponse): GetMarketRewardsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_dmm_v2.MarketReward rewards */ 1:
                    message.rewards.push(MarketReward.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMarketRewardsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_dmm_v2.MarketReward rewards = 1; */
        for (let i = 0; i < message.rewards.length; i++)
            MarketReward.internalBinaryWrite(message.rewards[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_dmm_v2.GetMarketRewardsResponse
 */
export const GetMarketRewardsResponse = new GetMarketRewardsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarketReward$Type extends MessageType<MarketReward> {
    constructor() {
        super("injective_dmm_v2.MarketReward", [
            { no: 1, name: "epoch_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "reward", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "reward_percentage", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "start_date", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "end_date", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "total_score", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "created_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "updated_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "height", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 13, name: "liquidity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "mini_epochs_reward", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MarketReward>): MarketReward {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.epochId = "";
        message.marketId = "";
        message.reward = "";
        message.rewardPercentage = "";
        message.startDate = "";
        message.endDate = "";
        message.totalScore = "";
        message.createdAt = "";
        message.updatedAt = "";
        message.height = 0n;
        message.liquidity = "";
        message.miniEpochsReward = "";
        if (value !== undefined)
            reflectionMergePartial<MarketReward>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarketReward): MarketReward {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string epoch_id */ 1:
                    message.epochId = reader.string();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                case /* string reward */ 3:
                    message.reward = reader.string();
                    break;
                case /* string reward_percentage */ 4:
                    message.rewardPercentage = reader.string();
                    break;
                case /* string start_date */ 5:
                    message.startDate = reader.string();
                    break;
                case /* string end_date */ 6:
                    message.endDate = reader.string();
                    break;
                case /* string total_score */ 9:
                    message.totalScore = reader.string();
                    break;
                case /* string created_at */ 10:
                    message.createdAt = reader.string();
                    break;
                case /* string updated_at */ 11:
                    message.updatedAt = reader.string();
                    break;
                case /* sint64 height */ 12:
                    message.height = reader.sint64().toBigInt();
                    break;
                case /* string liquidity */ 13:
                    message.liquidity = reader.string();
                    break;
                case /* string mini_epochs_reward */ 14:
                    message.miniEpochsReward = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarketReward, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string epoch_id = 1; */
        if (message.epochId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.epochId);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        /* string reward = 3; */
        if (message.reward !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.reward);
        /* string reward_percentage = 4; */
        if (message.rewardPercentage !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.rewardPercentage);
        /* string start_date = 5; */
        if (message.startDate !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.startDate);
        /* string end_date = 6; */
        if (message.endDate !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.endDate);
        /* string total_score = 9; */
        if (message.totalScore !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.totalScore);
        /* string created_at = 10; */
        if (message.createdAt !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.createdAt);
        /* string updated_at = 11; */
        if (message.updatedAt !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.updatedAt);
        /* sint64 height = 12; */
        if (message.height !== 0n)
            writer.tag(12, WireType.Varint).sint64(message.height);
        /* string liquidity = 13; */
        if (message.liquidity !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.liquidity);
        /* string mini_epochs_reward = 14; */
        if (message.miniEpochsReward !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.miniEpochsReward);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_dmm_v2.MarketReward
 */
export const MarketReward = new MarketReward$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetEligibleAddressesRequest$Type extends MessageType<GetEligibleAddressesRequest> {
    constructor() {
        super("injective_dmm_v2.GetEligibleAddressesRequest", [
            { no: 1, name: "epoch_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "page", kind: "message", T: () => Pagination }
        ]);
    }
    create(value?: PartialMessage<GetEligibleAddressesRequest>): GetEligibleAddressesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.epochId = "";
        if (value !== undefined)
            reflectionMergePartial<GetEligibleAddressesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetEligibleAddressesRequest): GetEligibleAddressesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string epoch_id */ 1:
                    message.epochId = reader.string();
                    break;
                case /* injective_dmm_v2.Pagination page */ 3:
                    message.page = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.page);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetEligibleAddressesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string epoch_id = 1; */
        if (message.epochId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.epochId);
        /* injective_dmm_v2.Pagination page = 3; */
        if (message.page)
            Pagination.internalBinaryWrite(message.page, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_dmm_v2.GetEligibleAddressesRequest
 */
export const GetEligibleAddressesRequest = new GetEligibleAddressesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetEligibleAddressesResponse$Type extends MessageType<GetEligibleAddressesResponse> {
    constructor() {
        super("injective_dmm_v2.GetEligibleAddressesResponse", [
            { no: 1, name: "addresses", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => EligibleAddress },
            { no: 2, name: "next", kind: "message", T: () => Pagination }
        ]);
    }
    create(value?: PartialMessage<GetEligibleAddressesResponse>): GetEligibleAddressesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.addresses = [];
        if (value !== undefined)
            reflectionMergePartial<GetEligibleAddressesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetEligibleAddressesResponse): GetEligibleAddressesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_dmm_v2.EligibleAddress addresses */ 1:
                    message.addresses.push(EligibleAddress.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* injective_dmm_v2.Pagination next */ 2:
                    message.next = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.next);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetEligibleAddressesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_dmm_v2.EligibleAddress addresses = 1; */
        for (let i = 0; i < message.addresses.length; i++)
            EligibleAddress.internalBinaryWrite(message.addresses[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* injective_dmm_v2.Pagination next = 2; */
        if (message.next)
            Pagination.internalBinaryWrite(message.next, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_dmm_v2.GetEligibleAddressesResponse
 */
export const GetEligibleAddressesResponse = new GetEligibleAddressesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EligibleAddress$Type extends MessageType<EligibleAddress> {
    constructor() {
        super("injective_dmm_v2.EligibleAddress", [
            { no: 1, name: "epoch_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "height", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "source", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "created_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "updated_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EligibleAddress>): EligibleAddress {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.epochId = "";
        message.accountAddress = "";
        message.height = 0n;
        message.source = "";
        message.createdAt = "";
        message.updatedAt = "";
        if (value !== undefined)
            reflectionMergePartial<EligibleAddress>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EligibleAddress): EligibleAddress {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string epoch_id */ 1:
                    message.epochId = reader.string();
                    break;
                case /* string account_address */ 2:
                    message.accountAddress = reader.string();
                    break;
                case /* sint64 height */ 3:
                    message.height = reader.sint64().toBigInt();
                    break;
                case /* string source */ 4:
                    message.source = reader.string();
                    break;
                case /* string created_at */ 5:
                    message.createdAt = reader.string();
                    break;
                case /* string updated_at */ 6:
                    message.updatedAt = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EligibleAddress, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string epoch_id = 1; */
        if (message.epochId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.epochId);
        /* string account_address = 2; */
        if (message.accountAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.accountAddress);
        /* sint64 height = 3; */
        if (message.height !== 0n)
            writer.tag(3, WireType.Varint).sint64(message.height);
        /* string source = 4; */
        if (message.source !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.source);
        /* string created_at = 5; */
        if (message.createdAt !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.createdAt);
        /* string updated_at = 6; */
        if (message.updatedAt !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.updatedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_dmm_v2.EligibleAddress
 */
export const EligibleAddress = new EligibleAddress$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetRewardsDistributionRequest$Type extends MessageType<GetRewardsDistributionRequest> {
    constructor() {
        super("injective_dmm_v2.GetRewardsDistributionRequest", [
            { no: 1, name: "epoch_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "page", kind: "message", T: () => Pagination },
            { no: 3, name: "height", kind: "scalar", opt: true, T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<GetRewardsDistributionRequest>): GetRewardsDistributionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.epochId = "";
        if (value !== undefined)
            reflectionMergePartial<GetRewardsDistributionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetRewardsDistributionRequest): GetRewardsDistributionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string epoch_id */ 1:
                    message.epochId = reader.string();
                    break;
                case /* injective_dmm_v2.Pagination page */ 2:
                    message.page = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.page);
                    break;
                case /* optional sint64 height */ 3:
                    message.height = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetRewardsDistributionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string epoch_id = 1; */
        if (message.epochId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.epochId);
        /* injective_dmm_v2.Pagination page = 2; */
        if (message.page)
            Pagination.internalBinaryWrite(message.page, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional sint64 height = 3; */
        if (message.height !== undefined)
            writer.tag(3, WireType.Varint).sint64(message.height);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_dmm_v2.GetRewardsDistributionRequest
 */
export const GetRewardsDistributionRequest = new GetRewardsDistributionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetRewardsDistributionResponse$Type extends MessageType<GetRewardsDistributionResponse> {
    constructor() {
        super("injective_dmm_v2.GetRewardsDistributionResponse", [
            { no: 1, name: "rewards", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RewardDistribution },
            { no: 2, name: "next", kind: "message", T: () => Pagination }
        ]);
    }
    create(value?: PartialMessage<GetRewardsDistributionResponse>): GetRewardsDistributionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rewards = [];
        if (value !== undefined)
            reflectionMergePartial<GetRewardsDistributionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetRewardsDistributionResponse): GetRewardsDistributionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_dmm_v2.RewardDistribution rewards */ 1:
                    message.rewards.push(RewardDistribution.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* injective_dmm_v2.Pagination next */ 2:
                    message.next = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.next);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetRewardsDistributionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_dmm_v2.RewardDistribution rewards = 1; */
        for (let i = 0; i < message.rewards.length; i++)
            RewardDistribution.internalBinaryWrite(message.rewards[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* injective_dmm_v2.Pagination next = 2; */
        if (message.next)
            Pagination.internalBinaryWrite(message.next, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_dmm_v2.GetRewardsDistributionResponse
 */
export const GetRewardsDistributionResponse = new GetRewardsDistributionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RewardDistribution$Type extends MessageType<RewardDistribution> {
    constructor() {
        super("injective_dmm_v2.RewardDistribution", [
            { no: 1, name: "epoch_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "height", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "start_height", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "block_time", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "depth", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "reward", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "mini_epochs_reward", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "created_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "updated_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RewardDistribution>): RewardDistribution {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.epochId = "";
        message.accountAddress = "";
        message.height = 0n;
        message.startHeight = 0n;
        message.blockTime = "";
        message.depth = "";
        message.reward = "";
        message.createdAt = "";
        message.updatedAt = "";
        if (value !== undefined)
            reflectionMergePartial<RewardDistribution>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RewardDistribution): RewardDistribution {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string epoch_id */ 1:
                    message.epochId = reader.string();
                    break;
                case /* string account_address */ 2:
                    message.accountAddress = reader.string();
                    break;
                case /* sint64 height */ 3:
                    message.height = reader.sint64().toBigInt();
                    break;
                case /* sint64 start_height */ 4:
                    message.startHeight = reader.sint64().toBigInt();
                    break;
                case /* string block_time */ 5:
                    message.blockTime = reader.string();
                    break;
                case /* string depth */ 6:
                    message.depth = reader.string();
                    break;
                case /* string reward */ 7:
                    message.reward = reader.string();
                    break;
                case /* optional string mini_epochs_reward */ 8:
                    message.miniEpochsReward = reader.string();
                    break;
                case /* string created_at */ 9:
                    message.createdAt = reader.string();
                    break;
                case /* string updated_at */ 10:
                    message.updatedAt = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RewardDistribution, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string epoch_id = 1; */
        if (message.epochId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.epochId);
        /* string account_address = 2; */
        if (message.accountAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.accountAddress);
        /* sint64 height = 3; */
        if (message.height !== 0n)
            writer.tag(3, WireType.Varint).sint64(message.height);
        /* sint64 start_height = 4; */
        if (message.startHeight !== 0n)
            writer.tag(4, WireType.Varint).sint64(message.startHeight);
        /* string block_time = 5; */
        if (message.blockTime !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.blockTime);
        /* string depth = 6; */
        if (message.depth !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.depth);
        /* string reward = 7; */
        if (message.reward !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.reward);
        /* optional string mini_epochs_reward = 8; */
        if (message.miniEpochsReward !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.miniEpochsReward);
        /* string created_at = 9; */
        if (message.createdAt !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.createdAt);
        /* string updated_at = 10; */
        if (message.updatedAt !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.updatedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_dmm_v2.RewardDistribution
 */
export const RewardDistribution = new RewardDistribution$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAccountVolumesRequest$Type extends MessageType<GetAccountVolumesRequest> {
    constructor() {
        super("injective_dmm_v2.GetAccountVolumesRequest", [
            { no: 1, name: "epoch_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetAccountVolumesRequest>): GetAccountVolumesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.epochId = "";
        message.accountAddress = "";
        if (value !== undefined)
            reflectionMergePartial<GetAccountVolumesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAccountVolumesRequest): GetAccountVolumesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string epoch_id */ 1:
                    message.epochId = reader.string();
                    break;
                case /* string account_address */ 2:
                    message.accountAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAccountVolumesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string epoch_id = 1; */
        if (message.epochId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.epochId);
        /* string account_address = 2; */
        if (message.accountAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.accountAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_dmm_v2.GetAccountVolumesRequest
 */
export const GetAccountVolumesRequest = new GetAccountVolumesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAccountVolumesResponse$Type extends MessageType<GetAccountVolumesResponse> {
    constructor() {
        super("injective_dmm_v2.GetAccountVolumesResponse", [
            { no: 1, name: "volumes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AccountVolume }
        ]);
    }
    create(value?: PartialMessage<GetAccountVolumesResponse>): GetAccountVolumesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.volumes = [];
        if (value !== undefined)
            reflectionMergePartial<GetAccountVolumesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAccountVolumesResponse): GetAccountVolumesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_dmm_v2.AccountVolume volumes */ 1:
                    message.volumes.push(AccountVolume.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAccountVolumesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_dmm_v2.AccountVolume volumes = 1; */
        for (let i = 0; i < message.volumes.length; i++)
            AccountVolume.internalBinaryWrite(message.volumes[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_dmm_v2.GetAccountVolumesResponse
 */
export const GetAccountVolumesResponse = new GetAccountVolumesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountVolume$Type extends MessageType<AccountVolume> {
    constructor() {
        super("injective_dmm_v2.AccountVolume", [
            { no: 1, name: "epoch_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "height", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "block_time", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "date", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "volume", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "taker_volume", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "maker_volume", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "volume_percentage", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "maker_volume_percentage", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "taker_volume_percentage", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "created_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "updated_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "date_timestamp", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "daily_volume", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "daily_maker_volume", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 18, name: "daily_taker_volume", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 19, name: "daily_volume_percentage", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 20, name: "daily_maker_volume_percentage", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 21, name: "daily_taker_volume_percentage", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 22, name: "daily_qualified", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<AccountVolume>): AccountVolume {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.epochId = "";
        message.accountAddress = "";
        message.height = 0n;
        message.blockTime = "";
        message.date = "";
        message.volume = "";
        message.takerVolume = "";
        message.makerVolume = "";
        message.volumePercentage = "";
        message.makerVolumePercentage = "";
        message.takerVolumePercentage = "";
        message.createdAt = "";
        message.updatedAt = "";
        message.dateTimestamp = "";
        message.dailyVolume = "";
        message.dailyMakerVolume = "";
        message.dailyTakerVolume = "";
        message.dailyVolumePercentage = "";
        message.dailyMakerVolumePercentage = "";
        message.dailyTakerVolumePercentage = "";
        message.dailyQualified = false;
        if (value !== undefined)
            reflectionMergePartial<AccountVolume>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountVolume): AccountVolume {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string epoch_id */ 1:
                    message.epochId = reader.string();
                    break;
                case /* string account_address */ 2:
                    message.accountAddress = reader.string();
                    break;
                case /* sint64 height */ 3:
                    message.height = reader.sint64().toBigInt();
                    break;
                case /* string block_time */ 4:
                    message.blockTime = reader.string();
                    break;
                case /* string date */ 6:
                    message.date = reader.string();
                    break;
                case /* string volume */ 7:
                    message.volume = reader.string();
                    break;
                case /* string taker_volume */ 8:
                    message.takerVolume = reader.string();
                    break;
                case /* string maker_volume */ 9:
                    message.makerVolume = reader.string();
                    break;
                case /* string volume_percentage */ 10:
                    message.volumePercentage = reader.string();
                    break;
                case /* string maker_volume_percentage */ 11:
                    message.makerVolumePercentage = reader.string();
                    break;
                case /* string taker_volume_percentage */ 12:
                    message.takerVolumePercentage = reader.string();
                    break;
                case /* string created_at */ 13:
                    message.createdAt = reader.string();
                    break;
                case /* string updated_at */ 14:
                    message.updatedAt = reader.string();
                    break;
                case /* string date_timestamp */ 15:
                    message.dateTimestamp = reader.string();
                    break;
                case /* string daily_volume */ 16:
                    message.dailyVolume = reader.string();
                    break;
                case /* string daily_maker_volume */ 17:
                    message.dailyMakerVolume = reader.string();
                    break;
                case /* string daily_taker_volume */ 18:
                    message.dailyTakerVolume = reader.string();
                    break;
                case /* string daily_volume_percentage */ 19:
                    message.dailyVolumePercentage = reader.string();
                    break;
                case /* string daily_maker_volume_percentage */ 20:
                    message.dailyMakerVolumePercentage = reader.string();
                    break;
                case /* string daily_taker_volume_percentage */ 21:
                    message.dailyTakerVolumePercentage = reader.string();
                    break;
                case /* bool daily_qualified */ 22:
                    message.dailyQualified = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountVolume, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string epoch_id = 1; */
        if (message.epochId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.epochId);
        /* string account_address = 2; */
        if (message.accountAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.accountAddress);
        /* sint64 height = 3; */
        if (message.height !== 0n)
            writer.tag(3, WireType.Varint).sint64(message.height);
        /* string block_time = 4; */
        if (message.blockTime !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.blockTime);
        /* string date = 6; */
        if (message.date !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.date);
        /* string volume = 7; */
        if (message.volume !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.volume);
        /* string taker_volume = 8; */
        if (message.takerVolume !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.takerVolume);
        /* string maker_volume = 9; */
        if (message.makerVolume !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.makerVolume);
        /* string volume_percentage = 10; */
        if (message.volumePercentage !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.volumePercentage);
        /* string maker_volume_percentage = 11; */
        if (message.makerVolumePercentage !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.makerVolumePercentage);
        /* string taker_volume_percentage = 12; */
        if (message.takerVolumePercentage !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.takerVolumePercentage);
        /* string created_at = 13; */
        if (message.createdAt !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.createdAt);
        /* string updated_at = 14; */
        if (message.updatedAt !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.updatedAt);
        /* string date_timestamp = 15; */
        if (message.dateTimestamp !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.dateTimestamp);
        /* string daily_volume = 16; */
        if (message.dailyVolume !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.dailyVolume);
        /* string daily_maker_volume = 17; */
        if (message.dailyMakerVolume !== "")
            writer.tag(17, WireType.LengthDelimited).string(message.dailyMakerVolume);
        /* string daily_taker_volume = 18; */
        if (message.dailyTakerVolume !== "")
            writer.tag(18, WireType.LengthDelimited).string(message.dailyTakerVolume);
        /* string daily_volume_percentage = 19; */
        if (message.dailyVolumePercentage !== "")
            writer.tag(19, WireType.LengthDelimited).string(message.dailyVolumePercentage);
        /* string daily_maker_volume_percentage = 20; */
        if (message.dailyMakerVolumePercentage !== "")
            writer.tag(20, WireType.LengthDelimited).string(message.dailyMakerVolumePercentage);
        /* string daily_taker_volume_percentage = 21; */
        if (message.dailyTakerVolumePercentage !== "")
            writer.tag(21, WireType.LengthDelimited).string(message.dailyTakerVolumePercentage);
        /* bool daily_qualified = 22; */
        if (message.dailyQualified !== false)
            writer.tag(22, WireType.Varint).bool(message.dailyQualified);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_dmm_v2.AccountVolume
 */
export const AccountVolume = new AccountVolume$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetRewardsEligibilityRequest$Type extends MessageType<GetRewardsEligibilityRequest> {
    constructor() {
        super("injective_dmm_v2.GetRewardsEligibilityRequest", [
            { no: 1, name: "epoch_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetRewardsEligibilityRequest>): GetRewardsEligibilityRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.epochId = "";
        message.accountAddress = "";
        if (value !== undefined)
            reflectionMergePartial<GetRewardsEligibilityRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetRewardsEligibilityRequest): GetRewardsEligibilityRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string epoch_id */ 1:
                    message.epochId = reader.string();
                    break;
                case /* string account_address */ 2:
                    message.accountAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetRewardsEligibilityRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string epoch_id = 1; */
        if (message.epochId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.epochId);
        /* string account_address = 2; */
        if (message.accountAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.accountAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_dmm_v2.GetRewardsEligibilityRequest
 */
export const GetRewardsEligibilityRequest = new GetRewardsEligibilityRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetRewardsEligibilityResponse$Type extends MessageType<GetRewardsEligibilityResponse> {
    constructor() {
        super("injective_dmm_v2.GetRewardsEligibilityResponse", [
            { no: 1, name: "volumes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AccountVolume },
            { no: 2, name: "current_maker_volume_percentage", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "average_daily_maker_volume_percentage", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "eligible_for_next_epoch", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "estimated_reward", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "eligible_for_current_epoch", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "updated_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetRewardsEligibilityResponse>): GetRewardsEligibilityResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.volumes = [];
        message.currentMakerVolumePercentage = "";
        message.eligibleForNextEpoch = false;
        message.estimatedReward = "";
        message.eligibleForCurrentEpoch = false;
        message.updatedAt = "";
        if (value !== undefined)
            reflectionMergePartial<GetRewardsEligibilityResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetRewardsEligibilityResponse): GetRewardsEligibilityResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_dmm_v2.AccountVolume volumes */ 1:
                    message.volumes.push(AccountVolume.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string current_maker_volume_percentage */ 2:
                    message.currentMakerVolumePercentage = reader.string();
                    break;
                case /* optional string average_daily_maker_volume_percentage */ 3:
                    message.averageDailyMakerVolumePercentage = reader.string();
                    break;
                case /* bool eligible_for_next_epoch */ 4:
                    message.eligibleForNextEpoch = reader.bool();
                    break;
                case /* string estimated_reward */ 5:
                    message.estimatedReward = reader.string();
                    break;
                case /* bool eligible_for_current_epoch */ 6:
                    message.eligibleForCurrentEpoch = reader.bool();
                    break;
                case /* string updated_at */ 7:
                    message.updatedAt = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetRewardsEligibilityResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_dmm_v2.AccountVolume volumes = 1; */
        for (let i = 0; i < message.volumes.length; i++)
            AccountVolume.internalBinaryWrite(message.volumes[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string current_maker_volume_percentage = 2; */
        if (message.currentMakerVolumePercentage !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.currentMakerVolumePercentage);
        /* optional string average_daily_maker_volume_percentage = 3; */
        if (message.averageDailyMakerVolumePercentage !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.averageDailyMakerVolumePercentage);
        /* bool eligible_for_next_epoch = 4; */
        if (message.eligibleForNextEpoch !== false)
            writer.tag(4, WireType.Varint).bool(message.eligibleForNextEpoch);
        /* string estimated_reward = 5; */
        if (message.estimatedReward !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.estimatedReward);
        /* bool eligible_for_current_epoch = 6; */
        if (message.eligibleForCurrentEpoch !== false)
            writer.tag(6, WireType.Varint).bool(message.eligibleForCurrentEpoch);
        /* string updated_at = 7; */
        if (message.updatedAt !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.updatedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_dmm_v2.GetRewardsEligibilityResponse
 */
export const GetRewardsEligibilityResponse = new GetRewardsEligibilityResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetHealthStatusRequest$Type extends MessageType<GetHealthStatusRequest> {
    constructor() {
        super("injective_dmm_v2.GetHealthStatusRequest", []);
    }
    create(value?: PartialMessage<GetHealthStatusRequest>): GetHealthStatusRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetHealthStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetHealthStatusRequest): GetHealthStatusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetHealthStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_dmm_v2.GetHealthStatusRequest
 */
export const GetHealthStatusRequest = new GetHealthStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetHealthStatusResponse$Type extends MessageType<GetHealthStatusResponse> {
    constructor() {
        super("injective_dmm_v2.GetHealthStatusResponse", [
            { no: 1, name: "epoch_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "last_snapshot_block_time", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "last_snapshot_block_height", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "updated_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetHealthStatusResponse>): GetHealthStatusResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.epochId = "";
        message.lastSnapshotBlockTime = "";
        message.lastSnapshotBlockHeight = 0n;
        message.updatedAt = "";
        message.status = "";
        if (value !== undefined)
            reflectionMergePartial<GetHealthStatusResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetHealthStatusResponse): GetHealthStatusResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string epoch_id */ 1:
                    message.epochId = reader.string();
                    break;
                case /* string last_snapshot_block_time */ 2:
                    message.lastSnapshotBlockTime = reader.string();
                    break;
                case /* sint64 last_snapshot_block_height */ 3:
                    message.lastSnapshotBlockHeight = reader.sint64().toBigInt();
                    break;
                case /* string updated_at */ 4:
                    message.updatedAt = reader.string();
                    break;
                case /* string status */ 5:
                    message.status = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetHealthStatusResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string epoch_id = 1; */
        if (message.epochId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.epochId);
        /* string last_snapshot_block_time = 2; */
        if (message.lastSnapshotBlockTime !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.lastSnapshotBlockTime);
        /* sint64 last_snapshot_block_height = 3; */
        if (message.lastSnapshotBlockHeight !== 0n)
            writer.tag(3, WireType.Varint).sint64(message.lastSnapshotBlockHeight);
        /* string updated_at = 4; */
        if (message.updatedAt !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.updatedAt);
        /* string status = 5; */
        if (message.status !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_dmm_v2.GetHealthStatusResponse
 */
export const GetHealthStatusResponse = new GetHealthStatusResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMarketRewardsRangeRequest$Type extends MessageType<GetMarketRewardsRangeRequest> {
    constructor() {
        super("injective_dmm_v2.GetMarketRewardsRangeRequest", [
            { no: 1, name: "epoch_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "market_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetMarketRewardsRangeRequest>): GetMarketRewardsRangeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.epochId = "";
        if (value !== undefined)
            reflectionMergePartial<GetMarketRewardsRangeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMarketRewardsRangeRequest): GetMarketRewardsRangeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string epoch_id */ 1:
                    message.epochId = reader.string();
                    break;
                case /* optional string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMarketRewardsRangeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string epoch_id = 1; */
        if (message.epochId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.epochId);
        /* optional string market_id = 2; */
        if (message.marketId !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_dmm_v2.GetMarketRewardsRangeRequest
 */
export const GetMarketRewardsRangeRequest = new GetMarketRewardsRangeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMarketRewardsRangeResponse$Type extends MessageType<GetMarketRewardsRangeResponse> {
    constructor() {
        super("injective_dmm_v2.GetMarketRewardsRangeResponse", [
            { no: 1, name: "ranges", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => MarketRewardRange }
        ]);
    }
    create(value?: PartialMessage<GetMarketRewardsRangeResponse>): GetMarketRewardsRangeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ranges = [];
        if (value !== undefined)
            reflectionMergePartial<GetMarketRewardsRangeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMarketRewardsRangeResponse): GetMarketRewardsRangeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_dmm_v2.MarketRewardRange ranges */ 1:
                    message.ranges.push(MarketRewardRange.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMarketRewardsRangeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_dmm_v2.MarketRewardRange ranges = 1; */
        for (let i = 0; i < message.ranges.length; i++)
            MarketRewardRange.internalBinaryWrite(message.ranges[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_dmm_v2.GetMarketRewardsRangeResponse
 */
export const GetMarketRewardsRangeResponse = new GetMarketRewardsRangeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarketRewardRange$Type extends MessageType<MarketRewardRange> {
    constructor() {
        super("injective_dmm_v2.MarketRewardRange", [
            { no: 1, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "max", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "min", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MarketRewardRange>): MarketRewardRange {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketId = "";
        message.max = "";
        message.min = "";
        if (value !== undefined)
            reflectionMergePartial<MarketRewardRange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarketRewardRange): MarketRewardRange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string market_id */ 1:
                    message.marketId = reader.string();
                    break;
                case /* string max */ 2:
                    message.max = reader.string();
                    break;
                case /* string min */ 3:
                    message.min = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarketRewardRange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string market_id = 1; */
        if (message.marketId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.marketId);
        /* string max = 2; */
        if (message.max !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.max);
        /* string min = 3; */
        if (message.min !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.min);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_dmm_v2.MarketRewardRange
 */
export const MarketRewardRange = new MarketRewardRange$Type();
/**
 * @generated ServiceType for protobuf service injective_dmm_v2.InjectiveDmmV2
 */
export const InjectiveDmmV2 = new ServiceType("injective_dmm_v2.InjectiveDmmV2", [
    { name: "GetEpochs", options: {}, I: GetEpochsRequest, O: GetEpochsResponse },
    { name: "GetTotalScores", options: {}, I: GetTotalScoresRequest, O: GetTotalScoresResponse },
    { name: "GetTotalScoresHistory", options: {}, I: GetTotalScoresHistoryRequest, O: GetTotalScoresHistoryResponse },
    { name: "GetEpochScores", options: {}, I: GetEpochScoresRequest, O: GetEpochScoresResponse },
    { name: "GetEpochScoresHistory", options: {}, I: GetEpochScoresHistoryRequest, O: GetEpochScoresHistoryResponse },
    { name: "GetMarketRewards", options: {}, I: GetMarketRewardsRequest, O: GetMarketRewardsResponse },
    { name: "GetEligibleAddresses", options: {}, I: GetEligibleAddressesRequest, O: GetEligibleAddressesResponse },
    { name: "GetRewardsDistribution", options: {}, I: GetRewardsDistributionRequest, O: GetRewardsDistributionResponse },
    { name: "GetAccountVolumes", options: {}, I: GetAccountVolumesRequest, O: GetAccountVolumesResponse },
    { name: "GetRewardsEligibility", options: {}, I: GetRewardsEligibilityRequest, O: GetRewardsEligibilityResponse },
    { name: "GetHealthStatus", options: {}, I: GetHealthStatusRequest, O: GetHealthStatusResponse },
    { name: "GetMarketRewardsRange", options: {}, I: GetMarketRewardsRangeRequest, O: GetMarketRewardsRangeResponse }
]);
