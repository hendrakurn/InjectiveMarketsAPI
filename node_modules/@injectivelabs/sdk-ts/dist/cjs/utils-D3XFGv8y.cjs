const require_chunk = require('./chunk-CbDLau6x.cjs');
let viem = require("viem");
let __injectivelabs_utils = require("@injectivelabs/utils");
let __scure_base = require("@scure/base");
let __noble_curves_secp256k1 = require("@noble/curves/secp256k1");
let __noble_hashes_sha2 = require("@noble/hashes/sha2");
let __noble_hashes_legacy = require("@noble/hashes/legacy");
let __injectivelabs_core_proto_ts_v2_generated_cosmos_base_query_v1beta1_pagination_pb = require("@injectivelabs/core-proto-ts-v2/generated/cosmos/base/query/v1beta1/pagination_pb");
__injectivelabs_core_proto_ts_v2_generated_cosmos_base_query_v1beta1_pagination_pb = require_chunk.__toESM(__injectivelabs_core_proto_ts_v2_generated_cosmos_base_query_v1beta1_pagination_pb);

//#region src/utils/helpers.ts
const isServerSide = () => typeof window === "undefined";
const isReactNative = () => {
	return typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative";
};
const isNode = () => {
	if (typeof window === "undefined") return true;
	return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
};
const isBrowser = () => {
	if (isReactNative()) return false;
	if (isNode()) return false;
	return typeof window !== "undefined";
};
const objectToJson = (object, params) => {
	const { replacer, indentation } = params || {
		replacer: void 0,
		indentation: 2
	};
	return safeBigIntStringify(object, replacer, indentation);
};
const protoObjectToJson = (object, params) => {
	const { replacer, indentation } = params || {
		replacer: void 0,
		indentation: 2
	};
	if (object.toObject !== void 0) return safeBigIntStringify(object.toObject(), replacer, indentation);
	return objectToJson(object, {
		replacer,
		indentation
	});
};
const grpcCoinToUiCoin = (coin) => ({
	amount: coin.amount,
	denom: coin.denom
});
const sortObjectByKeysWithReduce = (obj) => {
	if (typeof obj !== "object" || obj === null) return obj;
	if (Array.isArray(obj)) return obj.map((e) => sortObjectByKeysWithReduce(e)).sort();
	return Object.keys(obj).sort().reduce((sorted, k) => {
		const key = k;
		sorted[key] = sortObjectByKeysWithReduce(obj[key]);
		return sorted;
	}, {});
};
const sortObjectByKeys = (obj) => {
	if (typeof obj !== "object" || obj === null) return obj;
	if (Array.isArray(obj)) return obj.map(sortObjectByKeys);
	const sortedKeys = Object.keys(obj).sort();
	const result = {};
	sortedKeys.forEach((key) => {
		result[key] = sortObjectByKeys(obj[key]);
	});
	return result;
};
const getErrorMessage = (error, endpoint) => {
	if (!error.response) return `The request to ${endpoint} has failed.`;
	return error.response.data ? error.response.data.message || error.response.data : error.response.statusText;
};
/**
* Converts value to it's number representation
*/
const hexToNumber = (value) => {
	const [negative, hexValue] = value.startsWith("-") ? [true, value.slice(1)] : [false, value];
	const num = BigInt(hexValue);
	if (num > Number.MAX_SAFE_INTEGER) return Number(negative ? -num : num);
	if (num < Number.MIN_SAFE_INTEGER) return Number(num);
	return negative ? -1 * Number(num) : Number(num);
};
function isJsonString(str) {
	if (typeof str !== "string") return false;
	try {
		JSON.parse(str);
	} catch (_unused) {
		return false;
	}
	return true;
}
/**
* BigInt-safe JSON replacer function.
* Converts BigInt values to strings during JSON serialization.
*/
const bigIntReplacer = (_key, value) => typeof value === "bigint" ? bigIntToString(value) : value;
/**
* Converts a potentially bigint value to a number.
* Handles bigint, string, and other number-like types.
* Returns 0 for null/undefined values.
*/
const bigIntToNumber = (value) => {
	if (value === null || value === void 0) return 0;
	if (typeof value === "bigint") return Number(value);
	if (typeof value === "string") return parseInt(value || "0", 10);
	if (typeof value === "number") return value;
	return parseInt(String(value || "0"), 10);
};
/**
* Converts a potentially bigint value to a string.
* Handles bigint, string, and other types that can be converted to string.
* Returns empty string for null/undefined values.
*/
const bigIntToString = (value) => {
	if (value === null || value === void 0) return "";
	if (typeof value === "bigint") return value.toString();
	if (typeof value === "string") return value;
	if (typeof value === "number") return value.toString();
	return String(value || "");
};
/**
* Stringify an object to JSON with BigInt support.
* Converts BigInt values to strings during serialization to prevent
* "Do not know how to serialize a BigInt" errors.
*
* @param value - The value to serialize
* @param replacer - Optional custom replacer function (BigInt handling is applied first)
* @param space - Optional indentation for pretty printing
* @returns JSON string
*/
const safeBigIntStringify = (value, replacer, space) => {
	const combinedReplacer = (key, val) => {
		const bigIntHandled = bigIntReplacer(key, val);
		return replacer ? replacer(key, bigIntHandled) : bigIntHandled;
	};
	return JSON.stringify(value, combinedReplacer, space);
};

//#endregion
//#region src/utils/encoding.ts
/**
* Encoding/decoding utilities using industry-standard libraries
*
* Uses viem for hex encoding and @scure/base for base64 encoding
* to ensure compatibility, better performance, and reduce bundle size.
*
* These libraries are already dependencies in the project and are
* battle-tested by millions of developers.
*/
/**
* Convert a hex string to Uint8Array
* @param hex - Hex string (with or without 0x prefix)
* @returns Uint8Array
* @throws Error if hex string is invalid
*/
function hexToUint8Array(hex) {
	if (typeof hex !== "string") throw new Error("Hex string must be a string");
	if (hex.trim() === "") throw new Error("Hex string cannot be empty");
	const prefixedHex = hex.startsWith("0x") ? hex : `0x${hex}`;
	try {
		return (0, viem.hexToBytes)(prefixedHex);
	} catch (_unused) {
		throw new Error(`Invalid hex string: ${hex}`);
	}
}
/**
* Convert a Uint8Array to hex string
* @param arr - Uint8Array to convert
* @returns Hex string (without 0x prefix)
*/
function uint8ArrayToHex(arr) {
	return (0, viem.bytesToHex)(arr).slice(2);
}
/**
* Convert a base64 string to Uint8Array
* @param base64String - Base64 encoded string
* @returns Uint8Array
* @throws Error if base64 string is invalid
*/
function base64ToUint8Array(base64String) {
	if (typeof base64String !== "string") throw new Error("Base64 string must be a string");
	if (base64String.trim() === "") throw new Error("Base64 string cannot be empty");
	try {
		return __scure_base.base64.decode(base64String);
	} catch (_unused2) {
		throw new Error(`Invalid base64 string: ${base64String}`);
	}
}
/**
* Convert a Uint8Array to base64 string
* @param arr - Uint8Array to convert
* @returns Base64 encoded string
*/
function uint8ArrayToBase64(arr) {
	return __scure_base.base64.encode(arr);
}
/**
* Convert a string to Uint8Array using UTF-8 encoding
* @param str - String to encode
* @returns Uint8Array
*/
function stringToUint8Array(str) {
	return new TextEncoder().encode(str);
}
/**
* Convert a hex string to Uint8Array (buffer-like)
* Handles hex strings with or without 0x prefix
* @param hex - Hex string (with or without 0x prefix)
* @returns Uint8Array
*/
function hexToBuff(hex) {
	return hexToUint8Array(hex.startsWith("0x") ? hex.slice(2) : hex);
}
/**
* Convert a hex string to base64 string
* Handles hex strings with or without 0x prefix
* @param hex - Hex string (with or without 0x prefix)
* @returns Base64 encoded string
*/
function hexToBase64(hex) {
	return uint8ArrayToBase64(hexToUint8Array(hex.startsWith("0x") ? hex.slice(2) : hex));
}
/**
* Convert a base64 string to UTF-8 string
* @param base64String - Base64 encoded string
* @returns Decoded UTF-8 string
* @throws Error if base64 string is invalid
*/
function base64ToUtf8(base64String) {
	return toUtf8(base64ToUint8Array(base64String));
}
/**
* Convert a string or Uint8Array to Uint8Array using UTF-8 encoding
* If input is already Uint8Array, returns it as-is
* @param str - String or Uint8Array to encode
* @returns Uint8Array
*/
function fromUtf8(str) {
	if (typeof str !== "string") return str;
	return stringToUint8Array(str);
}
/**
* Convert a Uint8Array or string to string using UTF-8 decoding
* If input is already a string, returns it as-is
* @param data - Uint8Array or string to decode
* @returns Decoded string
*/
function toUtf8(data) {
	if (typeof data === "string") return data;
	return new TextDecoder().decode(data);
}
/**
* Convert a Uint8Array, string, null, or undefined to string using UTF-8 decoding
* More robust version that handles null/undefined gracefully
* @param string - Uint8Array, string, null, or undefined to decode
* @returns Decoded string (empty string if input is null/undefined)
*/
function uint8ArrayToString(string) {
	if (!string) return "";
	if (string.constructor !== Uint8Array) return string;
	return new TextDecoder().decode(string);
}
/**
* Convert binary data (string or Uint8Array) to base64 string
* If input is already a string, returns it as-is
* @param data - String or Uint8Array to encode
* @returns Base64 encoded string
*/
function binaryToBase64(data) {
	return typeof data === "string" ? data : uint8ArrayToBase64(data);
}
/**
* Convert a JSON object to base64 string
* @param data - JSON object to encode
* @returns Base64 encoded string
*/
function toBase64(data) {
	return uint8ArrayToBase64(stringToUint8Array(safeBigIntStringify(data)));
}
/**
* Convert a base64 string to JSON object
* @param payload - Base64 encoded string
* @returns Decoded JSON object
* @throws Error if base64 string is invalid or contains invalid JSON
*/
function fromBase64(payload) {
	if (typeof payload !== "string") throw new Error("Base64 payload must be a string");
	if (payload.trim() === "") throw new Error("Base64 payload cannot be empty");
	try {
		const decoded = new TextDecoder().decode(base64ToUint8Array(payload));
		return JSON.parse(decoded);
	} catch (_unused3) {
		throw new Error(`Failed to decode base64 JSON: ${payload}`);
	}
}
/**
* Concatenate multiple Uint8Arrays into a single Uint8Array
* Replacement for Buffer.concat()
* @param arrays - Array of Uint8Arrays to concatenate
* @returns Concatenated Uint8Array
*/
function concatUint8Arrays(arrays) {
	if (arrays.length === 0) return new Uint8Array(0);
	const totalLength = arrays.reduce((sum, arr) => sum + arr.length, 0);
	const result = new Uint8Array(totalLength);
	let offset = 0;
	for (const arr of arrays) {
		result.set(arr, offset);
		offset += arr.length;
	}
	return result;
}

//#endregion
//#region src/utils/constants.ts
const BECH32_PUBKEY_ACC_PREFIX = "injpub";
const BECH32_PUBKEY_VAL_PREFIX = "injvaloperpub";
const BECH32_PUBKEY_CONS_PREFIX = "injvalconspub";
const BECH32_ADDR_ACC_PREFIX = "inj";
const BECH32_ADDR_VAL_PREFIX = "injvaloper";
const BECH32_ADDR_CONS_PREFIX = "injvalcons";
const DEFAULT_DERIVATION_PATH = "m/44'/60'/0'/0/0";

//#endregion
//#region src/utils/time.ts
/**
* Returns a timeout timestamp in milliseconds so its compatible
* with the way Cosmos handles transactions
*/
const makeTimeoutTimestamp = (timeoutInMs = __injectivelabs_utils.DEFAULT_TIMESTAMP_TIMEOUT_MS) => {
	const now = /* @__PURE__ */ new Date();
	return new Date(now.getTime() + timeoutInMs).getTime();
};
/**
* Returns a timeout timestamp in nanoseconds so its compatible
* with the way Cosmos handles transactions
*/
const makeTimeoutTimestampInNs = (timeoutInMs = __injectivelabs_utils.DEFAULT_TIMESTAMP_TIMEOUT_MS) => makeTimeoutTimestamp(timeoutInMs) * 1e6;
/**
* Converts a protobuf Timestamp to a JavaScript Date
* @param timestamp - Protobuf Timestamp object with seconds and nanos fields
* @returns JavaScript Date or undefined if timestamp is null/undefined
*/
const protobufTimestampToDate = (timestamp) => {
	if (!timestamp) return;
	return /* @__PURE__ */ new Date(Number(timestamp.seconds) * 1e3 + Number(timestamp.nanos) / 1e6);
};
/**
* Converts a protobuf Timestamp to Unix timestamp in seconds
* @param timestamp - Protobuf Timestamp object with seconds and nanos fields
* @returns Unix timestamp in seconds or 0 if timestamp is null/undefined
*/
const protobufTimestampToUnixSeconds = (timestamp) => {
	if (!timestamp) return 0;
	return Math.floor(Number(timestamp.seconds) + Number(timestamp.nanos) / 1e9);
};
/**
* Converts a protobuf Timestamp to Unix timestamp in milliseconds
* @param timestamp - Protobuf Timestamp object with seconds and nanos fields
* @returns Unix timestamp in milliseconds or 0 if timestamp is null/undefined
*/
const protobufTimestampToUnixMs = (timestamp) => {
	if (!timestamp) return 0;
	return Math.floor(Number(timestamp.seconds) * 1e3 + Number(timestamp.nanos) / 1e6);
};

//#endregion
//#region src/utils/msgs.ts
const getGasPriceBasedOnMessage = (msgs) => {
	const messages = Array.isArray(msgs) ? msgs : [msgs];
	const messageType = messages[0].toDirectSign().type;
	if (messageType.includes("MsgPrivilegedExecuteContract")) return (0, __injectivelabs_utils.toBigNumber)(__injectivelabs_utils.DEFAULT_GAS_LIMIT).times(6).times(messages.length).decimalPlaces(0).toNumber();
	if (messageType.includes("MsgExecuteContract")) return (0, __injectivelabs_utils.toBigNumber)(__injectivelabs_utils.DEFAULT_GAS_LIMIT).times(3).times(messages.length).decimalPlaces(0).toNumber();
	if (messageType.includes("exchange")) return (0, __injectivelabs_utils.toBigNumber)(__injectivelabs_utils.DEFAULT_EXCHANGE_LIMIT).times(messages.length).decimalPlaces(0).toNumber();
	if (messageType.includes("wasm")) return (0, __injectivelabs_utils.toBigNumber)(__injectivelabs_utils.DEFAULT_GAS_LIMIT).times(1.5).times(messages.length).decimalPlaces(0).toNumber();
	if (messageType.includes("authz")) return (0, __injectivelabs_utils.toBigNumber)(__injectivelabs_utils.DEFAULT_EXCHANGE_LIMIT).times(messages.length).decimalPlaces(0).toNumber();
	if (messageType.includes("gov") && (messageType.includes("MsgDeposit") || messageType.includes("MsgSubmitProposal"))) return (0, __injectivelabs_utils.toBigNumber)(__injectivelabs_utils.DEFAULT_GAS_LIMIT).times(15).times(messages.length).decimalPlaces(0).toNumber();
	if (messageType.includes("MsgTransfer")) return (0, __injectivelabs_utils.toBigNumber)(__injectivelabs_utils.DEFAULT_IBC_GAS_LIMIT).times(messages.length).toNumber();
	return (0, __injectivelabs_utils.toBigNumber)(__injectivelabs_utils.DEFAULT_GAS_LIMIT).times(messages.length).toNumber();
};

//#endregion
//#region src/utils/ofac.ts
const ofacList = [
	"0x04dba1194ee10112fe6c3207c0687def0e78bacf",
	"0x08723392ed15743cc38513c4925f5e6be5c17243",
	"0x08b2efdcdb8822efe5ad0eae55517cf5dc544251",
	"0x0931ca4d13bb4ba75d9b7132ab690265d749a5e7",
	"0x098b716b8aaf21512996dc57eb0615e2383e2f96",
	"0x0ee5067b06776a89ccc7dc8ee369984ad7db5e06",
	"0x12de548f79a50d2bd05481c8515c1ef5183666a9",
	"0x175d44451403edf28469df03a9280c1197adb92c",
	"0x1967d8af5bd86a497fb3dd7899a020e47560daaf",
	"0x1999ef52700c34de7ec2b68a28aafb37db0c5ade",
	"0x19aa5fe80d33a56d56c78e82ea5e50e5d80b4dff",
	"0x19f8f2b0915daa12a3f5c9cf01df9e24d53794f7",
	"0x1da5821544e25c636c1417ba96ade4cf6d2f9b5a",
	"0x21b8d56bda776bbe68655a16895afd96f5534fed",
	"0x2f389ce8bd8ff92de3402ffce4691d17fc4f6535",
	"0x308ed4b7b49797e1a98d3818bff6fe5385410370",
	"0x35fb6f6db4fb05e6a4ce86f2c93691425626d4b1",
	"0x38735f03b30fbc022ddd06abed01f0ca823c6a94",
	"0x39d908dac893cbcb53cc86e0ecc369aa4def1a29",
	"0x3ad9db589d201a710ed237c829c7860ba86510fc",
	"0x3cbded43efdaf0fc77b9c55f6fc9988fcc9b757d",
	"0x3cffd56b47b7b41c56258d9c7731abadc360e073",
	"0x3e37627deaa754090fbfbb8bd226c1ce66d255e9",
	"0x43fa21d92141ba9db43052492e0deee5aa5f0a93",
	"0x48549a34ae37b12f6a30566245176994e17c6b4a",
	"0x4f47bc496083c727c5fbe3ce9cdf2b0f6496270c",
	"0x502371699497d08d5339c870851898d6d72521dd",
	"0x530a64c0ce595026a4a556b703644228179e2d57",
	"0x532b77b33a040587e9fd1800088225f99b8b0e8a",
	"0x53b6936513e738f44fb50d2b9476730c0ab3bfc1",
	"0x5512d943ed1f7c8a43f3435c85f7ab68b30121b0",
	"0x57ec89a0c056163a0314e413320f9b3abe761259",
	"0x5a14e72060c11313e38738009254a90968f58f51",
	"0x5a7a51bfb49f190e5a6060a5bc6052ac14a3b59f",
	"0x5d5b5dafecbf31bdb08bfd3edad4f2694372d0ef",
	"0x5f48c2a71b2cc96e3f0ccae4e39318ff0dc375b2",
	"0x67d40ee1a85bf4a4bb7ffae16de985e8427b6b45",
	"0x6be0ae71e6c41f2f9d0d1a3b8d0f75e6f6a0b46e",
	"0x6f1ca141a28907f78ebaa64fb83a9088b02a8352",
	"0x72a5843cc08275c8171e582972aa4fda8c397b2a",
	"0x797d7ae72ebddcdea2a346c1834e04d1f8df102b",
	"0x7ced75026204ac29c34bea98905d4c949f27361e",
	"0x7db418b5d567a4e0e8c59ad71be1fce48f3e6107",
	"0x7f19720a857f834887fc9a7bc0a0fbe7fc7f8102",
	"0x7f367cc41522ce07553e823bf3be79a889debe1b",
	"0x7ff9cfad3877f21d41da833e2f775db0569ee3d9",
	"0x83e5bc4ffa856bb84bb88581f5dd62a433a25e0d",
	"0x8576acc5c05d6ce88f4e49bf65bdf0c62f91353c",
	"0x8dce2aac0de82bdcaf6b4373b79f94331b8e4995",
	"0x901bb9583b24d97e995513c6778dc6888ab6870e",
	"0x931546d9e66836abf687d2bc64b30407bac8c568",
	"0x961c5be54a2ffc17cf4cb021d863c42dacd47fc1",
	"0x97b1043abd9e6fc31681635166d430a458d14f9c",
	"0x983a81ca6fb1e441266d2fbcb7d8e530ac2e05a2",
	"0x9c2bc757b66f24d60f016b6237f8cdd414a879fa",
	"0x9f4cda013e354b8fc285bf4b9a60460cee7f7ea9",
	"0xa0e1c89ef1a489c9c7de96311ed5ce5d32c20e4b",
	"0xa7e5d5a720f06526557c513402f2e6b5fa20b008",
	"0xb338962b92cd818d6aef0a32a9ecd01212a71f33",
	"0xb6f5ec1a0a9cd1526536d3f0426c429529471f40",
	"0xc103b7dc095c904b92081eef0c1640081ec01c10",
	"0xc2a3829f459b3edd87791c74cd45402ba0a20be3",
	"0xc455f7fd3e0e12afd51fba5c106909934d8a0e4a",
	"0xd0975b32cea532eadddfc9c60481976e39db3472",
	"0xd5ed34b52ac4ab84d8fa8a231a3218bbf01ed510",
	"0xd8500c631dc32fa18645b7436344a99e4825e10e",
	"0xd882cfc20f52f2599d84b8e8d58c7fb62cfe344b",
	"0xdb2720ebad55399117ddb4c4a4afd9a4ccada8fe",
	"0xdcbeffbecce100cce9e4b153c4e15cb885643193",
	"0xe1d865c3d669dcc8c57c8d023140cb204e672ee4",
	"0xe1e4c5e5ed8f03ae61b581e2def126025f2b9401",
	"0xe3d35f68383732649669aa990832e017340dbca5",
	"0xe7aa314c77f4233c18c6cc84384a9247c0cf367b",
	"0xe950dc316b836e4eefb8308bf32bf7c72a1358ff",
	"0xed6e0a7e4ac94d976eebfb82ccf777a3c6bad921",
	"0xefe301d259f525ca1ba74a7977b80d5b060b3cca",
	"0xf3701f445b6bdafedbca97d1e477357839e4120d",
	"0xf4377eda661e04b6dda78969796ed31658d602d4",
	"0xf7b31119c2682c88d88d455dbb9d5932c65cf1be",
	"0xfac583c0cf07ea434052c49115a4682172ab6b4f",
	"0xfec8a60023265364d066a1212fde3930f6ae8da7",
	"0xc5801cd781d168e2d3899ad9c39d8a2541871298",
	"0x0992E2D17e0082Df8a31Bf36Bd8Cc662551de68B",
	"0x8aa07899eb940f40e514b8effdb3b6af5d1cf7bb",
	"0xb9436d76e8fe08859d042e41b4a21c85715e1176",
	"0x7bc5cb059f21553af489d2b2df3d40aaae9b44e8",
	"0x430ab3c698b3210548b6ac9f72936b43b15ebe9b"
];

//#endregion
//#region src/utils/coins.ts
const parseCoins = (input) => {
	return input.replace(/\s/g, "").split(",").filter(Boolean).map((part) => {
		const match = part.match(/^([0-9]+)([a-zA-Z][a-zA-Z0-9/]{2,127})$/);
		if (!match) throw new Error("Got an invalid coin string");
		return {
			amount: match[1].replace(/^0+/, "") || "0",
			denom: match[2]
		};
	});
};

//#endregion
//#region src/utils/crypto.ts
/**
* Hash data to hex string using SHA256
* @param data - Base64 encoded string to hash
* @returns Uppercase hex string
*/
const hashToHex = (data) => {
	return uint8ArrayToHex((0, __noble_hashes_sha2.sha256)(base64ToUint8Array(data))).toUpperCase();
};
/**
* Compute SHA256 hash of Uint8Array data
* @param data - Data to hash
* @returns SHA256 hash as Uint8Array
*/
const sha256 = (data) => {
	return (0, __noble_hashes_sha2.sha256)(data);
};
/**
* Compute RIPEMD160 hash of Uint8Array data
* @param data - Data to hash
* @returns RIPEMD160 hash as Uint8Array
*/
const ripemd160 = (data) => {
	return (0, __noble_hashes_legacy.ripemd160)(data);
};
/**
* Derive public key from private key
* @param privateKey - Private key as Uint8Array
* @returns Compressed public key (33 bytes)
*/
const privateKeyToPublicKey = (privateKey) => {
	return __noble_curves_secp256k1.secp256k1.getPublicKey(privateKey, true);
};
/**
* Derive public key from private key hash (hex string)
* @param privateKeyHash - Private key as hex string (with or without 0x prefix)
* @returns Compressed public key (33 bytes)
*/
const privateKeyHashToPublicKey = (privateKeyHash) => {
	const privateKey = privateKeyHash.startsWith("0x") ? privateKeyHash.slice(2) : privateKeyHash;
	return __noble_curves_secp256k1.secp256k1.getPublicKey(hexToUint8Array(privateKey), true);
};
/**
* Derive public key from private key and encode as base64
* @param privateKey - Private key as Uint8Array
* @returns Base64 encoded compressed public key
*/
const privateKeyToPublicKeyBase64 = (privateKey) => {
	return uint8ArrayToBase64(privateKeyToPublicKey(privateKey));
};
/**
* Derive public key from private key hash and encode as base64
* @param privateKeyHash - Private key as hex string (with or without 0x prefix)
* @returns Base64 encoded compressed public key
*/
const privateKeyHashToPublicKeyBase64 = (privateKeyHash) => {
	return uint8ArrayToBase64(privateKeyHashToPublicKey(privateKeyHash));
};
/**
* Hash only the domain portion of EIP-712 typed data
* @param message - EIP-712 typed data definition
* @returns Hash of the domain
*/
const domainHash = (message) => {
	return (0, viem.hashTypedData)({
		domain: message.domain,
		types: message.types,
		primaryType: "EIP712Domain",
		message: {}
	});
};
/**
* Hash only the message portion of EIP-712 typed data
* @param message - EIP-712 typed data definition
* @returns Hash of the message
*/
const messageHash = (message) => {
	return (0, viem.hashTypedData)({
		domain: {},
		types: message.types,
		primaryType: message.primaryType,
		message: message.message
	});
};
/**
* Decompress a compressed public key (starts with 02 or 03)
* If the key is already 64 bytes, prepends '04' to make it uncompressed
* @param startsWith02Or03 - Compressed public key hex string
* @returns Decompressed public key hex string (without 04 prefix)
*/
function decompressPubKey(startsWith02Or03) {
	if (hexToUint8Array(startsWith02Or03).length === 64) startsWith02Or03 = "04" + startsWith02Or03;
	const decompressed = __noble_curves_secp256k1.secp256k1.ProjectivePoint.fromHex(startsWith02Or03).toHex(false);
	if (!decompressed.startsWith("04")) return decompressed;
	return decompressed.slice(2);
}
/**
* Convert public key to Ethereum address using Keccak256
* @param pubKey - Public key as Uint8Array (64 bytes uncompressed or 33 bytes compressed)
* @param sanitize - If true, will decompress compressed keys before hashing
* @returns Ethereum address (20 bytes)
* @throws Error if pubKey length is not 64 after sanitization
*/
const publicKeyToAddress = function(pubKey, sanitize = false) {
	if (sanitize && pubKey.length !== 64) pubKey = __noble_curves_secp256k1.secp256k1.ProjectivePoint.fromHex(pubKey).toRawBytes(false).slice(1);
	if (pubKey.length !== 64) throw new Error("Expected pubKey to be of length 64");
	return (0, viem.keccak256)(pubKey, "bytes").subarray(-20);
};
/**
* Sanitize typed data by converting BigInt values to strings
* Recursively processes objects and arrays
* @param data - Data to sanitize (can be object, array, or primitive)
* @returns Sanitized data with BigInt values converted to strings
*/
const sanitizeTypedData = (data) => {
	switch (Object.prototype.toString.call(data)) {
		case "[object Object]": {
			const entries = Object.keys(data).map((k) => [k, sanitizeTypedData(data[k])]);
			return Object.fromEntries(entries);
		}
		case "[object Array]": return data.map((v) => sanitizeTypedData(v));
		case "[object BigInt]": return bigIntToString(data);
		default: return data;
	}
};
function hashStruct(primaryType, data, types, _version) {
	if (!data) throw new Error("Invalid data: data is empty");
	let typedData;
	if (primaryType === "EIP712Domain") typedData = {
		domain: data,
		types: { EIP712Domain: types.EIP712Domain },
		primaryType: "EIP712Domain",
		message: {}
	};
	else typedData = {
		domain: types.domain || {},
		types,
		primaryType,
		message: data
	};
	const hash = (0, viem.hashTypedData)(typedData);
	return { toString: (encoding) => {
		if (encoding === "hex") return hash.slice(2);
		return hash;
	} };
}
const TypedDataUtilsSanitizeData = sanitizeTypedData;
const TypedDataUtilsHashStruct = hashStruct;
const SignTypedDataVersionV4 = "V4";

//#endregion
//#region src/utils/numbers.ts
const $BigNumber = __injectivelabs_utils.BigNumber.clone({ ROUNDING_MODE: __injectivelabs_utils.BigNumber.ROUND_DOWN });
const isNumber = (number) => {
	if (typeof number === "number") return true;
	return !isNaN(parseFloat(number));
};
const formatNumberToAllowableDecimals = (value, allowableDecimals, roundingMode) => {
	const decimalPlacesInValue = (0, __injectivelabs_utils.toBigNumber)((0, __injectivelabs_utils.getExactDecimalsFromNumber)(value));
	const valueToString = value.toString();
	if (decimalPlacesInValue.lte(0)) return valueToString;
	return decimalPlacesInValue.gte(allowableDecimals) ? (0, __injectivelabs_utils.toBigNumber)(valueToString).toFixed(allowableDecimals, roundingMode) : valueToString;
};
const formatNumberToAllowableTensMultiplier = (value, tensMultiplier, roundingMode) => {
	const valueToBn = (0, __injectivelabs_utils.toBigNumber)(value);
	if (tensMultiplier === 0) return valueToBn.toFixed(0, roundingMode);
	const tensMul = (0, __injectivelabs_utils.toBigNumber)(10).pow(tensMultiplier);
	if (valueToBn.lte(tensMul)) return tensMul.toFixed(0, roundingMode);
	return (0, __injectivelabs_utils.toBigNumber)(valueToBn.div(tensMul).toFixed(0, roundingMode)).multipliedBy(tensMul).toFixed(0);
};
const formatAmountToAllowableAmount = (value, tensMultiplier) => {
	return tensMultiplier < 0 ? formatNumberToAllowableDecimals(value, -tensMultiplier, __injectivelabs_utils.BigNumber.ROUND_DOWN) : formatNumberToAllowableTensMultiplier(value, tensMultiplier, __injectivelabs_utils.BigNumber.ROUND_DOWN);
};
const formatPriceToAllowablePrice = (value, tensMultiplier) => {
	return tensMultiplier <= 0 ? formatNumberToAllowableDecimals(value, -tensMultiplier) : formatNumberToAllowableTensMultiplier(value, tensMultiplier);
};
/**
*
* Legacy function - use formatNumberToAllowableDecimals
*
* @param value
* @param allowableDecimals
* @returns
*/
const formatAmountToAllowableDecimals = (value, allowableDecimals) => {
	return formatNumberToAllowableDecimals(value, allowableDecimals, __injectivelabs_utils.BigNumber.ROUND_DOWN);
};
/**
*
* Legacy function - use formatNumberToAllowableDecimals
*
* @param value
* @param allowableDecimals
* @returns
*/
const formatPriceToAllowableDecimals = (value, allowableDecimals) => {
	return formatNumberToAllowableDecimals(value, allowableDecimals);
};
/**
* On chain amounts queried from a sentry using the
* gRPC API are returned with an extra decimal point
* 18 places from the beginning, so we need to remove it
* to get a workable amount
*/
const denomAmountFromGrpcChainDenomAmount = (value) => new $BigNumber(value).dividedBy(new $BigNumber(10).pow(18));
/**
* @deprecated use toChainFormat from injectivelabs/utils instead
*
* On chain amounts broadcasted to a sentry directly using the
* gRPC API should be passed with an extra decimal point
* 18 places from the beginning, so we need to add it
* to get a workable amount
*/
const denomAmountToGrpcChainDenomAmount = (value) => new $BigNumber(value).multipliedBy(new $BigNumber(10).pow(18));
/**
* @deprecated use toChainFormat from injectivelabs/utils instead
*
* On chain amounts (based on the cosmosSdk.Dec type)
* broadcasted to a sentry directly using the
* gRPC API should be passed with an extra decimal point
* 18 places from the beginning (i.e multiplied by 1e18), so we need to add it
* to get a workable amount
*/
const amountToCosmosSdkDecAmount = (value) => new $BigNumber(value).multipliedBy(new $BigNumber(10).pow(18));
/**
* * @deprecated use toChainFormat from injectivelabs/utils instead
*
* Amount that the chain requires is in the x * 10^(quoteDecimals) format
* where x is a human readable number
*/
const denomAmountToChainDenomAmount = ({ value, decimals = 18 }) => new $BigNumber(value).multipliedBy(new $BigNumber(10).pow(decimals));
/**
* Amount that the chain returns is in the x * 10^(quoteDecimals) format
* where x is a human readable number
*/
const denomAmountToChainDenomAmountToFixed = ({ value, decimals = 18, tensMultiplier, decimalPlaces = void 0, roundingMode = __injectivelabs_utils.BigNumber.ROUND_DOWN }) => {
	const valueToBn = (0, __injectivelabs_utils.toBigNumber)(value).toFixed();
	const number = denomAmountToChainDenomAmount({
		value: tensMultiplier ? formatPriceToAllowablePrice(valueToBn, tensMultiplier) : value,
		decimals
	});
	if (decimalPlaces === void 0) return number.toFixed();
	return number.toFixed((0, __injectivelabs_utils.getSignificantDecimalsFromNumber)(number), roundingMode);
};
/**
* @deprecated use toHumanReadable from injectivelabs/utils instead
*
* Amount that the chain returns is in the x * 10^(quoteDecimals) format
* where x is a human readable number
*/
const denomAmountFromChainDenomAmount = ({ value, decimals = 18 }) => new $BigNumber(value).dividedBy(new $BigNumber(10).pow(decimals));
/**
*
* Amount that the chain returns is in the x * 10^(quoteDecimals) format
* where x is a human readable number stringified
*/
const denomAmountFromChainDenomAmountToFixed = ({ value, decimals = 18, decimalPlaces = void 0, roundingMode = __injectivelabs_utils.BigNumber.ROUND_DOWN }) => {
	const number = (0, __injectivelabs_utils.toHumanReadable)(value, decimals);
	if (decimalPlaces === void 0) return number.toFixed();
	return number.toFixed((0, __injectivelabs_utils.getSignificantDecimalsFromNumber)(number), roundingMode);
};
/**
* @deprecated use toChainFormat from injectivelabs/utils instead
*
* Amount that the chain requires is in the x * 10^(quoteDecimals) format
* where x is a human readable number
*/
const derivativeMarginToChainMargin = ({ value, quoteDecimals = 18 }) => new $BigNumber(value).multipliedBy(new $BigNumber(10).pow(quoteDecimals));
/**
* Amount that the chain requires is in the x * 10^(quoteDecimals) format
* where x is a human readable number stringified
*/
const derivativeMarginToChainMarginToFixed = ({ value, quoteDecimals = 18, tensMultiplier, decimalPlaces = void 0, roundingMode = __injectivelabs_utils.BigNumber.ROUND_DOWN }) => {
	const valueToBn = (0, __injectivelabs_utils.toBigNumber)(value).toFixed();
	const number = derivativeMarginToChainMargin({
		value: tensMultiplier ? formatPriceToAllowablePrice(valueToBn, tensMultiplier) : value,
		quoteDecimals
	});
	if (decimalPlaces === void 0) return number.toFixed();
	return number.toFixed((0, __injectivelabs_utils.getSignificantDecimalsFromNumber)(number), roundingMode);
};
/**
* @deprecated use toHumanReadable from injectivelabs/utils instead
*
* Amount that the chain returns is in the x * 10^(quoteDecimals) format
* where x is a human readable number
*/
const derivativeMarginFromChainMargin = ({ value, quoteDecimals = 18 }) => new $BigNumber(value).dividedBy(new $BigNumber(10).pow(quoteDecimals));
/**
* Amount that the chain returns is in the x * 10^(quoteDecimals) format
* where x is a human readable number
*/
const derivativeMarginFromChainMarginToFixed = ({ value, quoteDecimals = 18, decimalPlaces = void 0, roundingMode = __injectivelabs_utils.BigNumber.ROUND_DOWN }) => {
	const number = (0, __injectivelabs_utils.toHumanReadable)(value, quoteDecimals);
	if (decimalPlaces === void 0) return number.toFixed();
	return number.toFixed((0, __injectivelabs_utils.getSignificantDecimalsFromNumber)(number), roundingMode);
};
/**
* @deprecated use toChainFormat from injectivelabs/utils instead
* Amount that the chain requires is in the x * 10^(quoteDecimals) format
* where x is a human readable number
*/
const derivativePriceToChainPrice = ({ value, quoteDecimals = 18 }) => new $BigNumber(value).multipliedBy(new $BigNumber(10).pow(quoteDecimals));
/**
* Amount that the chain requires is in the x * 10^(quoteDecimals) format
* where x is a human readable number stringified
*/
const derivativePriceToChainPriceToFixed = ({ value, tensMultiplier, quoteDecimals = 18, decimalPlaces = void 0, roundingMode = __injectivelabs_utils.BigNumber.ROUND_DOWN }) => {
	const valueToBn = (0, __injectivelabs_utils.toBigNumber)(value).toFixed();
	const number = (0, __injectivelabs_utils.toChainFormat)(tensMultiplier ? formatPriceToAllowablePrice(valueToBn, tensMultiplier) : value, quoteDecimals);
	if (decimalPlaces === void 0) return number.toFixed();
	return number.toFixed((0, __injectivelabs_utils.getSignificantDecimalsFromNumber)(number), roundingMode);
};
/**
* @deprecated use toHumanReadable from injectivelabs/utils instead
*
* Amount that the chain returns is in the x * 10^(quoteDecimals) format
* where x is a human readable number
*/
const derivativePriceFromChainPrice = ({ value, quoteDecimals = 18 }) => new $BigNumber(value).dividedBy(new $BigNumber(10).pow(quoteDecimals));
/**
* Amount that the chain returns is in the x * 10^(quoteDecimals) format
* where x is a human readable number stringified
*/
const derivativePriceFromChainPriceToFixed = ({ value, quoteDecimals = 18, decimalPlaces = void 0, roundingMode = __injectivelabs_utils.BigNumber.ROUND_DOWN }) => {
	const number = (0, __injectivelabs_utils.toHumanReadable)(value, quoteDecimals);
	if (decimalPlaces === void 0) return number.toFixed();
	return number.toFixed((0, __injectivelabs_utils.getSignificantDecimalsFromNumber)(number), roundingMode);
};
/**
* @deprecated use toBigNumber from injectivelabs/utils instead
* Amount that the chain requires is in the x format
* where x is a human readable number
*/
const derivativeQuantityToChainQuantity = ({ value }) => new $BigNumber(value);
/**
* Amount that the chain requires is in the x format
* where x is a human readable number stringified
*/
const derivativeQuantityToChainQuantityToFixed = ({ value, decimalPlaces = void 0, tensMultiplier, roundingMode = __injectivelabs_utils.BigNumber.ROUND_DOWN }) => {
	const valueToBn = (0, __injectivelabs_utils.toBigNumber)(value).toFixed();
	const number = derivativeQuantityToChainQuantity({ value: tensMultiplier ? formatPriceToAllowablePrice(valueToBn, tensMultiplier) : value });
	if (decimalPlaces === void 0) return number.toFixed();
	return number.toFixed((0, __injectivelabs_utils.getSignificantDecimalsFromNumber)(number), roundingMode);
};
/**
* @deprecated
* Amount that the chain requires is in the x format
* where x is a human readable number
*/
const derivativeQuantityFromChainQuantity = ({ value }) => new $BigNumber(value);
/**
* Amount that the chain requires is in the x format
* where x is a human readable number stringified
*/
const derivativeQuantityFromChainQuantityToFixed = ({ value, decimalPlaces = void 0, roundingMode = __injectivelabs_utils.BigNumber.ROUND_DOWN }) => {
	const number = new $BigNumber(value);
	if (decimalPlaces === void 0) return number.toFixed();
	return number.toFixed((0, __injectivelabs_utils.getSignificantDecimalsFromNumber)(number), roundingMode);
};
/**
* @deprecated use toChainFormat from injectivelabs/utils instead
* Amount that the chain requires is in the x / 10^(quoteDecimals - baseDecimals) format
* where x is a human readable number
*/
const spotPriceToChainPrice = ({ value, baseDecimals = 18, quoteDecimals = 6 }) => new $BigNumber(value).multipliedBy(new $BigNumber(10).pow(new $BigNumber(quoteDecimals).minus(baseDecimals)));
/**
* Amount that the chain requires is in the x / 10^(quoteDecimals - baseDecimals) format
* where x is a human readable number stringified
*/
const spotPriceToChainPriceToFixed = ({ value, baseDecimals = 18, quoteDecimals = 6, tensMultiplier, decimalPlaces = void 0, roundingMode = __injectivelabs_utils.BigNumber.ROUND_DOWN }) => {
	const valueToBn = (0, __injectivelabs_utils.toBigNumber)(value).toFixed();
	const number = (0, __injectivelabs_utils.toChainFormat)(tensMultiplier ? formatPriceToAllowablePrice(valueToBn, tensMultiplier) : value, (0, __injectivelabs_utils.toBigNumber)(quoteDecimals).minus(baseDecimals).toNumber());
	if (decimalPlaces === void 0) return number.toFixed();
	return number.toFixed((0, __injectivelabs_utils.getSignificantDecimalsFromNumber)(number), roundingMode);
};
/**
* @deprecated use toHumanReadable from injectivelabs/utils instead
*
* Amount that the chain returns is in the x / 10^(quoteDecimals - baseDecimals) format
* where x is a human readable number
*/
const spotPriceFromChainPrice = ({ value, baseDecimals = 18, quoteDecimals = 6 }) => new $BigNumber(value).dividedBy(new $BigNumber(10).pow(new $BigNumber(quoteDecimals).minus(baseDecimals)));
/**
* Amount that the chain returns is in the x / 10^(quoteDecimals - baseDecimals) format
* where x is a human readable number stringified
*/
const spotPriceFromChainPriceToFixed = ({ value, baseDecimals = 18, quoteDecimals = 6, decimalPlaces = void 0, roundingMode = __injectivelabs_utils.BigNumber.ROUND_DOWN }) => {
	const number = (0, __injectivelabs_utils.toHumanReadable)(value, quoteDecimals - baseDecimals);
	if (decimalPlaces === void 0) return number.toFixed();
	return number.toFixed((0, __injectivelabs_utils.getSignificantDecimalsFromNumber)(number), roundingMode);
};
/**
* @deprecated use toChainFormat from injectivelabs/utils instead
*
* Amount that the chain requires is in the x * 10^(baseDecimals) format
* where x is a human readable number
*/
const spotQuantityToChainQuantity = ({ value, baseDecimals = 18 }) => new $BigNumber(value).multipliedBy(new $BigNumber(10).pow(baseDecimals));
/**
* Amount that the chain requires is in the x * 10^(baseDecimals) format
* where x is a human readable number
*/
const spotQuantityToChainQuantityToFixed = ({ value, baseDecimals = 18, tensMultiplier, decimalPlaces = void 0, roundingMode = __injectivelabs_utils.BigNumber.ROUND_DOWN }) => {
	const valueToBn = (0, __injectivelabs_utils.toBigNumber)(value).toFixed();
	const number = (0, __injectivelabs_utils.toChainFormat)(tensMultiplier ? formatPriceToAllowablePrice(valueToBn, tensMultiplier) : value, baseDecimals);
	if (decimalPlaces === void 0) return number.toFixed();
	return number.toFixed((0, __injectivelabs_utils.getSignificantDecimalsFromNumber)(number), roundingMode);
};
/**
* @deprecated use toHumanReadable from injectivelabs/utils instead
*
* Amount that the chain returns is in the x * 10^(baseDecimals) format
* where x is a human readable number
*/
const spotQuantityFromChainQuantity = ({ value, baseDecimals = 18 }) => new $BigNumber(value).dividedBy(new $BigNumber(10).pow(baseDecimals));
/**
* Amount that the chain returns is in the x * 10^(baseDecimals) format
* where x is a human readable number
*/
const spotQuantityFromChainQuantityToFixed = ({ value, baseDecimals = 18, decimalPlaces = void 0, roundingMode = __injectivelabs_utils.BigNumber.ROUND_DOWN }) => {
	const number = (0, __injectivelabs_utils.toHumanReadable)(value, baseDecimals);
	if (decimalPlaces === void 0) return number.toFixed();
	return number.toFixed((0, __injectivelabs_utils.getSignificantDecimalsFromNumber)(number), roundingMode);
};
/**
* @deprecated use toHumanReadable from injectivelabs/utils instead
*/
const cosmosSdkDecToBigNumber = (number) => new __injectivelabs_utils.BigNumber(number).dividedBy(new __injectivelabs_utils.BigNumber(10).pow(18));
const numberToCosmosSdkDecString = (value) => {
	return new __injectivelabs_utils.BigNumber(value).toFixed(18);
};
/**
* This function returns a multiplier of 10
* based on the input. There are two cases:
*
* 1. If the number is less than 1, it returns a NEGATIVE
* number which is the number of decimals the number has
*
* 2. If the number is higher than 1, it returns a POSITIVE
* number which is the number of 10 multiplier the number has
*
* @param number
* @returns {number}
*/
const getTensMultiplier = (number) => {
	const numberToBn = new __injectivelabs_utils.BigNumber(number);
	if (numberToBn.eq(1)) return 0;
	if (numberToBn.lt(1)) return -1 * (0, __injectivelabs_utils.getExactDecimalsFromNumber)(numberToBn.toFixed());
	const [, zerosInTheNumber] = numberToBn.toFixed().split("1");
	return zerosInTheNumber.length;
};

//#endregion
//#region src/utils/markets.ts
const getDerivativeMarketTensMultiplier = ({ quoteDecimals, minPriceTickSize, minQuantityTickSize }) => {
	return {
		quantityTensMultiplier: getTensMultiplier(minQuantityTickSize),
		priceTensMultiplier: getTensMultiplier(new __injectivelabs_utils.BigNumber(minPriceTickSize).shiftedBy(-quoteDecimals).toFixed())
	};
};
const getSpotMarketTensMultiplier = ({ baseDecimals, quoteDecimals, minPriceTickSize, minQuantityTickSize }) => {
	return {
		priceTensMultiplier: getTensMultiplier(new __injectivelabs_utils.BigNumber(minPriceTickSize).shiftedBy(baseDecimals - quoteDecimals).toFixed()),
		quantityTensMultiplier: getTensMultiplier(new __injectivelabs_utils.BigNumber(minQuantityTickSize).shiftedBy(-baseDecimals).toFixed())
	};
};
const getDerivativeMarketDecimals = ({ minPriceTickSize, minQuantityTickSize, quoteDecimals }) => {
	return {
		quantityDecimals: (0, __injectivelabs_utils.getExactDecimalsFromNumber)(minQuantityTickSize),
		priceDecimals: (0, __injectivelabs_utils.getExactDecimalsFromNumber)(new __injectivelabs_utils.BigNumber(minPriceTickSize).shiftedBy(-quoteDecimals).toFixed())
	};
};
const getSpotMarketDecimals = ({ minPriceTickSize, minQuantityTickSize, baseDecimals, quoteDecimals }) => {
	return {
		priceDecimals: (0, __injectivelabs_utils.getExactDecimalsFromNumber)(new __injectivelabs_utils.BigNumber(minPriceTickSize).shiftedBy(baseDecimals - quoteDecimals).toFixed()),
		quantityDecimals: (0, __injectivelabs_utils.getExactDecimalsFromNumber)(new __injectivelabs_utils.BigNumber(minQuantityTickSize).shiftedBy(-baseDecimals).toFixed())
	};
};

//#endregion
//#region src/utils/address.ts
/**
* Get injective address from Ethereum hex address
*
* @param ethAddress string
* @returns string
*/
const getInjectiveAddress = (ethAddress) => {
	const addressBuffer = (0, viem.toBytes)(ethAddress.toString());
	return __scure_base.bech32.encode("inj", __scure_base.bech32.toWords(addressBuffer));
};
/**
* Get ethereum address from injective bech32 address
*
* @param injectiveAddress string
* @returns string
*/
const getEthereumAddress = (injectiveAddress) => {
	if (injectiveAddress.startsWith("0x")) return injectiveAddress;
	return `0x${uint8ArrayToHex(__scure_base.bech32.fromWords(__scure_base.bech32.decode(injectiveAddress).words))}`;
};
/**
* Get ethereum address from injective bech32 address
*
* @param injectiveAddress string
* @returns string
*/
const getInjectiveAddressFromSubaccountId = (subaccountId) => {
	return getInjectiveAddress(subaccountId.slice(0, 42));
};
/**
* Get default subaccount id from injective bech32 address
*
* @param injectiveAddress string
* @returns string
*/
const getDefaultSubaccountId = (injectiveAddress) => {
	return `0x${uint8ArrayToHex(__scure_base.bech32.fromWords(__scure_base.bech32.decode(injectiveAddress).words))}${"0".repeat(24)}`;
};
/**
* Get subaccount id from injective bech32 address and an index (defaults to 0)
* @param injectiveAddress string
* @param nonce number
* @returns string
*/
const getSubaccountId = (injectiveAddress, nonce = 0) => {
	return `0x${uint8ArrayToHex(__scure_base.bech32.fromWords(__scure_base.bech32.decode(injectiveAddress).words))}${"0".repeat(23)}${nonce}`;
};
/** @deprecated - use getEthereumAddress */
const getAddressFromInjectiveAddress = (address) => {
	if (address.startsWith("0x")) return address;
	return `0x${uint8ArrayToHex(__scure_base.bech32.fromWords(__scure_base.bech32.decode(address).words))}`;
};
/**
* Convert Ethereum address to checksummed format (EIP-55)
* @param ethAddress - Ethereum address (with or without 0x prefix)
* @returns Checksummed Ethereum address
*/
const getChecksumAddress = (ethAddress) => {
	const lowercasedAddress = ethAddress.toLowerCase().replace("0x", "");
	const addressHash = (0, viem.keccak256)(lowercasedAddress).replace("0x", "");
	return "0x" + lowercasedAddress.split("").map((char, i) => {
		return parseInt(addressHash[i], 16) > 7 ? char.toUpperCase() : char;
	}).join("");
};
/**
* Check if address is a CW20 contract address
* @param address - Address to check
* @returns True if address is a CW20 contract address
*/
const isCw20ContractAddress = (address) => address.length === 42 && address.startsWith("inj");
/**
* Add 0x prefix to hex string if not present
* @param hex - Hex string
* @returns Hex string with 0x prefix
*/
const addHexPrefix = (hex) => hex.startsWith("0x") ? hex : `0x${hex}`;
/**
* Remove 0x prefix from hex string if present
* @param hex - Hex string
* @returns Hex string without 0x prefix
*/
const removeHexPrefix = (hex) => hex.startsWith("0x") ? hex.slice(2) : hex;

//#endregion
//#region src/client/chain/transformers/ChainGrpcCommonTransformer.ts
var ChainGrpcCommonTransformer = class ChainGrpcCommonTransformer {
	static grpcCoinToCoin(coin) {
		return {
			denom: coin.denom,
			amount: coin.amount
		};
	}
	static pageRequestToGrpcPageRequestV2(pageRequest) {
		if (!pageRequest) return;
		return __injectivelabs_core_proto_ts_v2_generated_cosmos_base_query_v1beta1_pagination_pb.PageRequest.create({
			key: (pageRequest === null || pageRequest === void 0 ? void 0 : pageRequest.key) ? base64ToUint8Array(pageRequest.key) : void 0,
			limit: (pageRequest === null || pageRequest === void 0 ? void 0 : pageRequest.limit) ? BigInt(pageRequest.limit) : void 0,
			offset: (pageRequest === null || pageRequest === void 0 ? void 0 : pageRequest.offset) ? BigInt(pageRequest.offset) : void 0,
			reverse: (pageRequest === null || pageRequest === void 0 ? void 0 : pageRequest.reverse) ? pageRequest.reverse : void 0,
			countTotal: (pageRequest === null || pageRequest === void 0 ? void 0 : pageRequest.countTotal) ? pageRequest.countTotal : void 0
		});
	}
	static pageRequestToGrpcPageRequest(pageRequest) {
		if (!pageRequest) return;
		return __injectivelabs_core_proto_ts_v2_generated_cosmos_base_query_v1beta1_pagination_pb.PageRequest.create({
			key: (pageRequest === null || pageRequest === void 0 ? void 0 : pageRequest.key) ? base64ToUint8Array(pageRequest.key) : void 0,
			limit: (pageRequest === null || pageRequest === void 0 ? void 0 : pageRequest.limit) ? BigInt(pageRequest.limit) : void 0,
			offset: (pageRequest === null || pageRequest === void 0 ? void 0 : pageRequest.offset) ? BigInt(pageRequest.offset) : void 0,
			reverse: (pageRequest === null || pageRequest === void 0 ? void 0 : pageRequest.reverse) ? pageRequest.reverse : void 0,
			countTotal: (pageRequest === null || pageRequest === void 0 ? void 0 : pageRequest.countTotal) ? pageRequest.countTotal : void 0
		});
	}
	static paginationUint8ArrayToString(key) {
		if (!key) return "";
		if (key.constructor !== Uint8Array) return key;
		return uint8ArrayToBase64(key);
	}
	static grpcPaginationToPagination(pagination) {
		return {
			total: pagination ? parseInt(ChainGrpcCommonTransformer.paginationUint8ArrayToString(pagination.total.toString()), 10) : 0,
			next: pagination ? ChainGrpcCommonTransformer.paginationUint8ArrayToString(pagination.nextKey) : ""
		};
	}
	static grpcPaginationToPaginationV2(pagination) {
		return {
			total: pagination ? bigIntToNumber(pagination.total) : 0,
			next: pagination ? ChainGrpcCommonTransformer.paginationUint8ArrayToString(pagination.nextKey) : ""
		};
	}
};

//#endregion
//#region src/utils/pagination.ts
/**
* @deprecated Use ChainGrpcCommonTransformer.pageRequestToGrpcPageRequest instead
*/
const paginationRequestFromPagination = (pagination) => {
	return ChainGrpcCommonTransformer.pageRequestToGrpcPageRequest(pagination);
};
const pageRequestToGrpcPageRequestV2 = (pagination) => {
	return ChainGrpcCommonTransformer.pageRequestToGrpcPageRequestV2(pagination);
};
/**
* @deprecated Use ChainGrpcCommonTransformer.paginationUint8ArrayToString instead
*/
const paginationUint8ArrayToString = (key) => {
	return ChainGrpcCommonTransformer.paginationUint8ArrayToString(key);
};
/**
* @deprecated Use ChainGrpcCommonTransformer.grpcPaginationToPagination instead
*/
const grpcPaginationToPagination = (pagination) => {
	return ChainGrpcCommonTransformer.grpcPaginationToPagination(pagination);
};
/**
* @deprecated Use grpcPagingToPagingV2 instead (V1 proto package)
*/
const grpcPagingToPaging = (pagination) => {
	if (!pagination) return {
		to: 0,
		from: 0,
		total: 0
	};
	return {
		...pagination,
		total: bigIntToNumber(pagination.total),
		to: parseInt(pagination.to.toString() || "0", 10),
		from: parseInt(pagination.from.toString() || "0", 10),
		countBySubaccount: bigIntToNumber(pagination.countBySubaccount)
	};
};
/**
* Converts gRPC Paging to ExchangePagination for V2 proto packages.
* Handles both InjectiveAccountsRpcPb.Paging and InjectiveExplorerRpcPb.Paging types.
* Supports bigint and string types for the total and countBySubaccount fields.
*/
const grpcPagingToPagingV2 = (pagination) => {
	if (!pagination) return {
		to: 0,
		from: 0,
		total: 0
	};
	return {
		...pagination,
		total: bigIntToNumber(pagination.total),
		to: parseInt(pagination.to.toString() || "0", 10),
		from: parseInt(pagination.from.toString() || "0", 10),
		countBySubaccount: bigIntToNumber(pagination.countBySubaccount)
	};
};
const fetchAllWithPagination = async (args, method, result = []) => {
	let response = await method(args);
	if (!args) return response;
	const valueKey = Object.keys(response).find((key) => key !== "pagination");
	result.push(...response[valueKey]);
	const paginationOption = args;
	if (response.pagination.next) return fetchAllWithPagination({
		...paginationOption,
		key: response.pagination.next
	}, method, result);
	return {
		[valueKey]: result,
		pagination: response.pagination
	};
};

//#endregion
//#region src/utils/transaction.ts
const recoverTypedSignaturePubKey = async (data, signature) => {
	const publicKeyHex = await (0, viem.recoverPublicKey)({
		hash: (0, viem.hashTypedData)(data),
		signature
	});
	return `0x${uint8ArrayToHex(__noble_curves_secp256k1.secp256k1.ProjectivePoint.fromHex(publicKeyHex.slice(2)).toRawBytes(true))}`;
};

//#endregion
Object.defineProperty(exports, 'BECH32_ADDR_ACC_PREFIX', {
  enumerable: true,
  get: function () {
    return BECH32_ADDR_ACC_PREFIX;
  }
});
Object.defineProperty(exports, 'BECH32_ADDR_CONS_PREFIX', {
  enumerable: true,
  get: function () {
    return BECH32_ADDR_CONS_PREFIX;
  }
});
Object.defineProperty(exports, 'BECH32_ADDR_VAL_PREFIX', {
  enumerable: true,
  get: function () {
    return BECH32_ADDR_VAL_PREFIX;
  }
});
Object.defineProperty(exports, 'BECH32_PUBKEY_ACC_PREFIX', {
  enumerable: true,
  get: function () {
    return BECH32_PUBKEY_ACC_PREFIX;
  }
});
Object.defineProperty(exports, 'BECH32_PUBKEY_CONS_PREFIX', {
  enumerable: true,
  get: function () {
    return BECH32_PUBKEY_CONS_PREFIX;
  }
});
Object.defineProperty(exports, 'BECH32_PUBKEY_VAL_PREFIX', {
  enumerable: true,
  get: function () {
    return BECH32_PUBKEY_VAL_PREFIX;
  }
});
Object.defineProperty(exports, 'ChainGrpcCommonTransformer', {
  enumerable: true,
  get: function () {
    return ChainGrpcCommonTransformer;
  }
});
Object.defineProperty(exports, 'DEFAULT_DERIVATION_PATH', {
  enumerable: true,
  get: function () {
    return DEFAULT_DERIVATION_PATH;
  }
});
Object.defineProperty(exports, 'SignTypedDataVersionV4', {
  enumerable: true,
  get: function () {
    return SignTypedDataVersionV4;
  }
});
Object.defineProperty(exports, 'TypedDataUtilsHashStruct', {
  enumerable: true,
  get: function () {
    return TypedDataUtilsHashStruct;
  }
});
Object.defineProperty(exports, 'TypedDataUtilsSanitizeData', {
  enumerable: true,
  get: function () {
    return TypedDataUtilsSanitizeData;
  }
});
Object.defineProperty(exports, 'addHexPrefix', {
  enumerable: true,
  get: function () {
    return addHexPrefix;
  }
});
Object.defineProperty(exports, 'amountToCosmosSdkDecAmount', {
  enumerable: true,
  get: function () {
    return amountToCosmosSdkDecAmount;
  }
});
Object.defineProperty(exports, 'base64ToUint8Array', {
  enumerable: true,
  get: function () {
    return base64ToUint8Array;
  }
});
Object.defineProperty(exports, 'base64ToUtf8', {
  enumerable: true,
  get: function () {
    return base64ToUtf8;
  }
});
Object.defineProperty(exports, 'bigIntReplacer', {
  enumerable: true,
  get: function () {
    return bigIntReplacer;
  }
});
Object.defineProperty(exports, 'bigIntToNumber', {
  enumerable: true,
  get: function () {
    return bigIntToNumber;
  }
});
Object.defineProperty(exports, 'bigIntToString', {
  enumerable: true,
  get: function () {
    return bigIntToString;
  }
});
Object.defineProperty(exports, 'binaryToBase64', {
  enumerable: true,
  get: function () {
    return binaryToBase64;
  }
});
Object.defineProperty(exports, 'concatUint8Arrays', {
  enumerable: true,
  get: function () {
    return concatUint8Arrays;
  }
});
Object.defineProperty(exports, 'cosmosSdkDecToBigNumber', {
  enumerable: true,
  get: function () {
    return cosmosSdkDecToBigNumber;
  }
});
Object.defineProperty(exports, 'decompressPubKey', {
  enumerable: true,
  get: function () {
    return decompressPubKey;
  }
});
Object.defineProperty(exports, 'denomAmountFromChainDenomAmount', {
  enumerable: true,
  get: function () {
    return denomAmountFromChainDenomAmount;
  }
});
Object.defineProperty(exports, 'denomAmountFromChainDenomAmountToFixed', {
  enumerable: true,
  get: function () {
    return denomAmountFromChainDenomAmountToFixed;
  }
});
Object.defineProperty(exports, 'denomAmountFromGrpcChainDenomAmount', {
  enumerable: true,
  get: function () {
    return denomAmountFromGrpcChainDenomAmount;
  }
});
Object.defineProperty(exports, 'denomAmountToChainDenomAmount', {
  enumerable: true,
  get: function () {
    return denomAmountToChainDenomAmount;
  }
});
Object.defineProperty(exports, 'denomAmountToChainDenomAmountToFixed', {
  enumerable: true,
  get: function () {
    return denomAmountToChainDenomAmountToFixed;
  }
});
Object.defineProperty(exports, 'denomAmountToGrpcChainDenomAmount', {
  enumerable: true,
  get: function () {
    return denomAmountToGrpcChainDenomAmount;
  }
});
Object.defineProperty(exports, 'derivativeMarginFromChainMargin', {
  enumerable: true,
  get: function () {
    return derivativeMarginFromChainMargin;
  }
});
Object.defineProperty(exports, 'derivativeMarginFromChainMarginToFixed', {
  enumerable: true,
  get: function () {
    return derivativeMarginFromChainMarginToFixed;
  }
});
Object.defineProperty(exports, 'derivativeMarginToChainMargin', {
  enumerable: true,
  get: function () {
    return derivativeMarginToChainMargin;
  }
});
Object.defineProperty(exports, 'derivativeMarginToChainMarginToFixed', {
  enumerable: true,
  get: function () {
    return derivativeMarginToChainMarginToFixed;
  }
});
Object.defineProperty(exports, 'derivativePriceFromChainPrice', {
  enumerable: true,
  get: function () {
    return derivativePriceFromChainPrice;
  }
});
Object.defineProperty(exports, 'derivativePriceFromChainPriceToFixed', {
  enumerable: true,
  get: function () {
    return derivativePriceFromChainPriceToFixed;
  }
});
Object.defineProperty(exports, 'derivativePriceToChainPrice', {
  enumerable: true,
  get: function () {
    return derivativePriceToChainPrice;
  }
});
Object.defineProperty(exports, 'derivativePriceToChainPriceToFixed', {
  enumerable: true,
  get: function () {
    return derivativePriceToChainPriceToFixed;
  }
});
Object.defineProperty(exports, 'derivativeQuantityFromChainQuantity', {
  enumerable: true,
  get: function () {
    return derivativeQuantityFromChainQuantity;
  }
});
Object.defineProperty(exports, 'derivativeQuantityFromChainQuantityToFixed', {
  enumerable: true,
  get: function () {
    return derivativeQuantityFromChainQuantityToFixed;
  }
});
Object.defineProperty(exports, 'derivativeQuantityToChainQuantity', {
  enumerable: true,
  get: function () {
    return derivativeQuantityToChainQuantity;
  }
});
Object.defineProperty(exports, 'derivativeQuantityToChainQuantityToFixed', {
  enumerable: true,
  get: function () {
    return derivativeQuantityToChainQuantityToFixed;
  }
});
Object.defineProperty(exports, 'domainHash', {
  enumerable: true,
  get: function () {
    return domainHash;
  }
});
Object.defineProperty(exports, 'fetchAllWithPagination', {
  enumerable: true,
  get: function () {
    return fetchAllWithPagination;
  }
});
Object.defineProperty(exports, 'formatAmountToAllowableAmount', {
  enumerable: true,
  get: function () {
    return formatAmountToAllowableAmount;
  }
});
Object.defineProperty(exports, 'formatAmountToAllowableDecimals', {
  enumerable: true,
  get: function () {
    return formatAmountToAllowableDecimals;
  }
});
Object.defineProperty(exports, 'formatNumberToAllowableDecimals', {
  enumerable: true,
  get: function () {
    return formatNumberToAllowableDecimals;
  }
});
Object.defineProperty(exports, 'formatNumberToAllowableTensMultiplier', {
  enumerable: true,
  get: function () {
    return formatNumberToAllowableTensMultiplier;
  }
});
Object.defineProperty(exports, 'formatPriceToAllowableDecimals', {
  enumerable: true,
  get: function () {
    return formatPriceToAllowableDecimals;
  }
});
Object.defineProperty(exports, 'formatPriceToAllowablePrice', {
  enumerable: true,
  get: function () {
    return formatPriceToAllowablePrice;
  }
});
Object.defineProperty(exports, 'fromBase64', {
  enumerable: true,
  get: function () {
    return fromBase64;
  }
});
Object.defineProperty(exports, 'fromUtf8', {
  enumerable: true,
  get: function () {
    return fromUtf8;
  }
});
Object.defineProperty(exports, 'getAddressFromInjectiveAddress', {
  enumerable: true,
  get: function () {
    return getAddressFromInjectiveAddress;
  }
});
Object.defineProperty(exports, 'getChecksumAddress', {
  enumerable: true,
  get: function () {
    return getChecksumAddress;
  }
});
Object.defineProperty(exports, 'getDefaultSubaccountId', {
  enumerable: true,
  get: function () {
    return getDefaultSubaccountId;
  }
});
Object.defineProperty(exports, 'getDerivativeMarketDecimals', {
  enumerable: true,
  get: function () {
    return getDerivativeMarketDecimals;
  }
});
Object.defineProperty(exports, 'getDerivativeMarketTensMultiplier', {
  enumerable: true,
  get: function () {
    return getDerivativeMarketTensMultiplier;
  }
});
Object.defineProperty(exports, 'getErrorMessage', {
  enumerable: true,
  get: function () {
    return getErrorMessage;
  }
});
Object.defineProperty(exports, 'getEthereumAddress', {
  enumerable: true,
  get: function () {
    return getEthereumAddress;
  }
});
Object.defineProperty(exports, 'getGasPriceBasedOnMessage', {
  enumerable: true,
  get: function () {
    return getGasPriceBasedOnMessage;
  }
});
Object.defineProperty(exports, 'getInjectiveAddress', {
  enumerable: true,
  get: function () {
    return getInjectiveAddress;
  }
});
Object.defineProperty(exports, 'getInjectiveAddressFromSubaccountId', {
  enumerable: true,
  get: function () {
    return getInjectiveAddressFromSubaccountId;
  }
});
Object.defineProperty(exports, 'getSpotMarketDecimals', {
  enumerable: true,
  get: function () {
    return getSpotMarketDecimals;
  }
});
Object.defineProperty(exports, 'getSpotMarketTensMultiplier', {
  enumerable: true,
  get: function () {
    return getSpotMarketTensMultiplier;
  }
});
Object.defineProperty(exports, 'getSubaccountId', {
  enumerable: true,
  get: function () {
    return getSubaccountId;
  }
});
Object.defineProperty(exports, 'getTensMultiplier', {
  enumerable: true,
  get: function () {
    return getTensMultiplier;
  }
});
Object.defineProperty(exports, 'grpcCoinToUiCoin', {
  enumerable: true,
  get: function () {
    return grpcCoinToUiCoin;
  }
});
Object.defineProperty(exports, 'grpcPaginationToPagination', {
  enumerable: true,
  get: function () {
    return grpcPaginationToPagination;
  }
});
Object.defineProperty(exports, 'grpcPagingToPaging', {
  enumerable: true,
  get: function () {
    return grpcPagingToPaging;
  }
});
Object.defineProperty(exports, 'grpcPagingToPagingV2', {
  enumerable: true,
  get: function () {
    return grpcPagingToPagingV2;
  }
});
Object.defineProperty(exports, 'hashToHex', {
  enumerable: true,
  get: function () {
    return hashToHex;
  }
});
Object.defineProperty(exports, 'hexToBase64', {
  enumerable: true,
  get: function () {
    return hexToBase64;
  }
});
Object.defineProperty(exports, 'hexToBuff', {
  enumerable: true,
  get: function () {
    return hexToBuff;
  }
});
Object.defineProperty(exports, 'hexToNumber', {
  enumerable: true,
  get: function () {
    return hexToNumber;
  }
});
Object.defineProperty(exports, 'hexToUint8Array', {
  enumerable: true,
  get: function () {
    return hexToUint8Array;
  }
});
Object.defineProperty(exports, 'isBrowser', {
  enumerable: true,
  get: function () {
    return isBrowser;
  }
});
Object.defineProperty(exports, 'isCw20ContractAddress', {
  enumerable: true,
  get: function () {
    return isCw20ContractAddress;
  }
});
Object.defineProperty(exports, 'isJsonString', {
  enumerable: true,
  get: function () {
    return isJsonString;
  }
});
Object.defineProperty(exports, 'isNode', {
  enumerable: true,
  get: function () {
    return isNode;
  }
});
Object.defineProperty(exports, 'isNumber', {
  enumerable: true,
  get: function () {
    return isNumber;
  }
});
Object.defineProperty(exports, 'isReactNative', {
  enumerable: true,
  get: function () {
    return isReactNative;
  }
});
Object.defineProperty(exports, 'isServerSide', {
  enumerable: true,
  get: function () {
    return isServerSide;
  }
});
Object.defineProperty(exports, 'makeTimeoutTimestamp', {
  enumerable: true,
  get: function () {
    return makeTimeoutTimestamp;
  }
});
Object.defineProperty(exports, 'makeTimeoutTimestampInNs', {
  enumerable: true,
  get: function () {
    return makeTimeoutTimestampInNs;
  }
});
Object.defineProperty(exports, 'messageHash', {
  enumerable: true,
  get: function () {
    return messageHash;
  }
});
Object.defineProperty(exports, 'numberToCosmosSdkDecString', {
  enumerable: true,
  get: function () {
    return numberToCosmosSdkDecString;
  }
});
Object.defineProperty(exports, 'objectToJson', {
  enumerable: true,
  get: function () {
    return objectToJson;
  }
});
Object.defineProperty(exports, 'ofacList', {
  enumerable: true,
  get: function () {
    return ofacList;
  }
});
Object.defineProperty(exports, 'pageRequestToGrpcPageRequestV2', {
  enumerable: true,
  get: function () {
    return pageRequestToGrpcPageRequestV2;
  }
});
Object.defineProperty(exports, 'paginationRequestFromPagination', {
  enumerable: true,
  get: function () {
    return paginationRequestFromPagination;
  }
});
Object.defineProperty(exports, 'paginationUint8ArrayToString', {
  enumerable: true,
  get: function () {
    return paginationUint8ArrayToString;
  }
});
Object.defineProperty(exports, 'parseCoins', {
  enumerable: true,
  get: function () {
    return parseCoins;
  }
});
Object.defineProperty(exports, 'privateKeyHashToPublicKey', {
  enumerable: true,
  get: function () {
    return privateKeyHashToPublicKey;
  }
});
Object.defineProperty(exports, 'privateKeyHashToPublicKeyBase64', {
  enumerable: true,
  get: function () {
    return privateKeyHashToPublicKeyBase64;
  }
});
Object.defineProperty(exports, 'privateKeyToPublicKey', {
  enumerable: true,
  get: function () {
    return privateKeyToPublicKey;
  }
});
Object.defineProperty(exports, 'privateKeyToPublicKeyBase64', {
  enumerable: true,
  get: function () {
    return privateKeyToPublicKeyBase64;
  }
});
Object.defineProperty(exports, 'protoObjectToJson', {
  enumerable: true,
  get: function () {
    return protoObjectToJson;
  }
});
Object.defineProperty(exports, 'protobufTimestampToDate', {
  enumerable: true,
  get: function () {
    return protobufTimestampToDate;
  }
});
Object.defineProperty(exports, 'protobufTimestampToUnixMs', {
  enumerable: true,
  get: function () {
    return protobufTimestampToUnixMs;
  }
});
Object.defineProperty(exports, 'protobufTimestampToUnixSeconds', {
  enumerable: true,
  get: function () {
    return protobufTimestampToUnixSeconds;
  }
});
Object.defineProperty(exports, 'publicKeyToAddress', {
  enumerable: true,
  get: function () {
    return publicKeyToAddress;
  }
});
Object.defineProperty(exports, 'recoverTypedSignaturePubKey', {
  enumerable: true,
  get: function () {
    return recoverTypedSignaturePubKey;
  }
});
Object.defineProperty(exports, 'removeHexPrefix', {
  enumerable: true,
  get: function () {
    return removeHexPrefix;
  }
});
Object.defineProperty(exports, 'ripemd160', {
  enumerable: true,
  get: function () {
    return ripemd160;
  }
});
Object.defineProperty(exports, 'safeBigIntStringify', {
  enumerable: true,
  get: function () {
    return safeBigIntStringify;
  }
});
Object.defineProperty(exports, 'sanitizeTypedData', {
  enumerable: true,
  get: function () {
    return sanitizeTypedData;
  }
});
Object.defineProperty(exports, 'sha256', {
  enumerable: true,
  get: function () {
    return sha256;
  }
});
Object.defineProperty(exports, 'sortObjectByKeys', {
  enumerable: true,
  get: function () {
    return sortObjectByKeys;
  }
});
Object.defineProperty(exports, 'sortObjectByKeysWithReduce', {
  enumerable: true,
  get: function () {
    return sortObjectByKeysWithReduce;
  }
});
Object.defineProperty(exports, 'spotPriceFromChainPrice', {
  enumerable: true,
  get: function () {
    return spotPriceFromChainPrice;
  }
});
Object.defineProperty(exports, 'spotPriceFromChainPriceToFixed', {
  enumerable: true,
  get: function () {
    return spotPriceFromChainPriceToFixed;
  }
});
Object.defineProperty(exports, 'spotPriceToChainPrice', {
  enumerable: true,
  get: function () {
    return spotPriceToChainPrice;
  }
});
Object.defineProperty(exports, 'spotPriceToChainPriceToFixed', {
  enumerable: true,
  get: function () {
    return spotPriceToChainPriceToFixed;
  }
});
Object.defineProperty(exports, 'spotQuantityFromChainQuantity', {
  enumerable: true,
  get: function () {
    return spotQuantityFromChainQuantity;
  }
});
Object.defineProperty(exports, 'spotQuantityFromChainQuantityToFixed', {
  enumerable: true,
  get: function () {
    return spotQuantityFromChainQuantityToFixed;
  }
});
Object.defineProperty(exports, 'spotQuantityToChainQuantity', {
  enumerable: true,
  get: function () {
    return spotQuantityToChainQuantity;
  }
});
Object.defineProperty(exports, 'spotQuantityToChainQuantityToFixed', {
  enumerable: true,
  get: function () {
    return spotQuantityToChainQuantityToFixed;
  }
});
Object.defineProperty(exports, 'stringToUint8Array', {
  enumerable: true,
  get: function () {
    return stringToUint8Array;
  }
});
Object.defineProperty(exports, 'toBase64', {
  enumerable: true,
  get: function () {
    return toBase64;
  }
});
Object.defineProperty(exports, 'toUtf8', {
  enumerable: true,
  get: function () {
    return toUtf8;
  }
});
Object.defineProperty(exports, 'uint8ArrayToBase64', {
  enumerable: true,
  get: function () {
    return uint8ArrayToBase64;
  }
});
Object.defineProperty(exports, 'uint8ArrayToHex', {
  enumerable: true,
  get: function () {
    return uint8ArrayToHex;
  }
});
Object.defineProperty(exports, 'uint8ArrayToString', {
  enumerable: true,
  get: function () {
    return uint8ArrayToString;
  }
});