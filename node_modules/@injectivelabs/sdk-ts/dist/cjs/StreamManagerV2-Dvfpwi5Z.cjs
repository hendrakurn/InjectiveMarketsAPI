const require_chunk = require('./chunk-CbDLau6x.cjs');
const require_utils = require('./utils-D3XFGv8y.cjs');
const require_defineProperty = require('./defineProperty-dyr5BsvG.cjs');
const require_BaseGrpcConsumer = require('./BaseGrpcConsumer-Db3sCC6b.cjs');
const require_BaseIndexerGrpcConsumer = require('./BaseIndexerGrpcConsumer-BBXxg_BR.cjs');
const require_BaseRestConsumer = require('./BaseRestConsumer-CRkyjiSo.cjs');
const require_IndexerGrpcWeb3GwApi = require('./IndexerGrpcWeb3GwApi-BxJoq1-k.cjs');
const require_types = require('./types-BSrt7JzM.cjs');
let __injectivelabs_utils = require("@injectivelabs/utils");
let __injectivelabs_exceptions = require("@injectivelabs/exceptions");
let __injectivelabs_mito_proto_ts_v2_generated_goadesign_goagen_mito_api_pb_client = require("@injectivelabs/mito-proto-ts-v2/generated/goadesign_goagen_mito_api_pb.client");
let __injectivelabs_mito_proto_ts_v2_generated_goadesign_goagen_mito_api_pb = require("@injectivelabs/mito-proto-ts-v2/generated/goadesign_goagen_mito_api_pb");
__injectivelabs_mito_proto_ts_v2_generated_goadesign_goagen_mito_api_pb = require_chunk.__toESM(__injectivelabs_mito_proto_ts_v2_generated_goadesign_goagen_mito_api_pb);
let __injectivelabs_indexer_proto_ts_v2_generated_injective_meta_rpc_pb = require("@injectivelabs/indexer-proto-ts-v2/generated/injective_meta_rpc_pb");
__injectivelabs_indexer_proto_ts_v2_generated_injective_meta_rpc_pb = require_chunk.__toESM(__injectivelabs_indexer_proto_ts_v2_generated_injective_meta_rpc_pb);
let __injectivelabs_indexer_proto_ts_v2_generated_injective_meta_rpc_pb_client = require("@injectivelabs/indexer-proto-ts-v2/generated/injective_meta_rpc_pb.client");
let __injectivelabs_indexer_proto_ts_v2_generated_injective_spot_exchange_rpc_pb = require("@injectivelabs/indexer-proto-ts-v2/generated/injective_spot_exchange_rpc_pb");
__injectivelabs_indexer_proto_ts_v2_generated_injective_spot_exchange_rpc_pb = require_chunk.__toESM(__injectivelabs_indexer_proto_ts_v2_generated_injective_spot_exchange_rpc_pb);
let __injectivelabs_indexer_proto_ts_v2_generated_injective_spot_exchange_rpc_pb_client = require("@injectivelabs/indexer-proto-ts-v2/generated/injective_spot_exchange_rpc_pb.client");
let __injectivelabs_indexer_proto_ts_v2_generated_injective_oracle_rpc_pb = require("@injectivelabs/indexer-proto-ts-v2/generated/injective_oracle_rpc_pb");
__injectivelabs_indexer_proto_ts_v2_generated_injective_oracle_rpc_pb = require_chunk.__toESM(__injectivelabs_indexer_proto_ts_v2_generated_injective_oracle_rpc_pb);
let __injectivelabs_indexer_proto_ts_v2_generated_injective_oracle_rpc_pb_client = require("@injectivelabs/indexer-proto-ts-v2/generated/injective_oracle_rpc_pb.client");
let __injectivelabs_indexer_proto_ts_v2_generated_injective_accounts_rpc_pb = require("@injectivelabs/indexer-proto-ts-v2/generated/injective_accounts_rpc_pb");
__injectivelabs_indexer_proto_ts_v2_generated_injective_accounts_rpc_pb = require_chunk.__toESM(__injectivelabs_indexer_proto_ts_v2_generated_injective_accounts_rpc_pb);
let __injectivelabs_indexer_proto_ts_v2_generated_injective_accounts_rpc_pb_client = require("@injectivelabs/indexer-proto-ts-v2/generated/injective_accounts_rpc_pb.client");
let __injectivelabs_indexer_proto_ts_v2_generated_injective_auction_rpc_pb = require("@injectivelabs/indexer-proto-ts-v2/generated/injective_auction_rpc_pb");
__injectivelabs_indexer_proto_ts_v2_generated_injective_auction_rpc_pb = require_chunk.__toESM(__injectivelabs_indexer_proto_ts_v2_generated_injective_auction_rpc_pb);
let __injectivelabs_indexer_proto_ts_v2_generated_injective_auction_rpc_pb_client = require("@injectivelabs/indexer-proto-ts-v2/generated/injective_auction_rpc_pb.client");
let __injectivelabs_indexer_proto_ts_v2_generated_injective_trading_rpc_pb = require("@injectivelabs/indexer-proto-ts-v2/generated/injective_trading_rpc_pb");
__injectivelabs_indexer_proto_ts_v2_generated_injective_trading_rpc_pb = require_chunk.__toESM(__injectivelabs_indexer_proto_ts_v2_generated_injective_trading_rpc_pb);
let __injectivelabs_indexer_proto_ts_v2_generated_injective_trading_rpc_pb_client = require("@injectivelabs/indexer-proto-ts-v2/generated/injective_trading_rpc_pb.client");
let __injectivelabs_indexer_proto_ts_v2_generated_injective_explorer_rpc_pb = require("@injectivelabs/indexer-proto-ts-v2/generated/injective_explorer_rpc_pb");
__injectivelabs_indexer_proto_ts_v2_generated_injective_explorer_rpc_pb = require_chunk.__toESM(__injectivelabs_indexer_proto_ts_v2_generated_injective_explorer_rpc_pb);
let __injectivelabs_indexer_proto_ts_v2_generated_injective_explorer_rpc_pb_client = require("@injectivelabs/indexer-proto-ts-v2/generated/injective_explorer_rpc_pb.client");
let __injectivelabs_indexer_proto_ts_v2_generated_injective_campaign_rpc_pb = require("@injectivelabs/indexer-proto-ts-v2/generated/injective_campaign_rpc_pb");
__injectivelabs_indexer_proto_ts_v2_generated_injective_campaign_rpc_pb = require_chunk.__toESM(__injectivelabs_indexer_proto_ts_v2_generated_injective_campaign_rpc_pb);
let __injectivelabs_indexer_proto_ts_v2_generated_injective_campaign_rpc_pb_client = require("@injectivelabs/indexer-proto-ts-v2/generated/injective_campaign_rpc_pb.client");
let __injectivelabs_indexer_proto_ts_v2_generated_injective_archiver_rpc_pb = require("@injectivelabs/indexer-proto-ts-v2/generated/injective_archiver_rpc_pb");
__injectivelabs_indexer_proto_ts_v2_generated_injective_archiver_rpc_pb = require_chunk.__toESM(__injectivelabs_indexer_proto_ts_v2_generated_injective_archiver_rpc_pb);
let __injectivelabs_indexer_proto_ts_v2_generated_injective_archiver_rpc_pb_client = require("@injectivelabs/indexer-proto-ts-v2/generated/injective_archiver_rpc_pb.client");
let __injectivelabs_indexer_proto_ts_v2_generated_injective_referral_rpc_pb = require("@injectivelabs/indexer-proto-ts-v2/generated/injective_referral_rpc_pb");
__injectivelabs_indexer_proto_ts_v2_generated_injective_referral_rpc_pb = require_chunk.__toESM(__injectivelabs_indexer_proto_ts_v2_generated_injective_referral_rpc_pb);
let __injectivelabs_indexer_proto_ts_v2_generated_injective_referral_rpc_pb_client = require("@injectivelabs/indexer-proto-ts-v2/generated/injective_referral_rpc_pb.client");
let __injectivelabs_indexer_proto_ts_v2_generated_injective_megavault_rpc_pb = require("@injectivelabs/indexer-proto-ts-v2/generated/injective_megavault_rpc_pb");
__injectivelabs_indexer_proto_ts_v2_generated_injective_megavault_rpc_pb = require_chunk.__toESM(__injectivelabs_indexer_proto_ts_v2_generated_injective_megavault_rpc_pb);
let __injectivelabs_indexer_proto_ts_v2_generated_injective_megavault_rpc_pb_client = require("@injectivelabs/indexer-proto-ts-v2/generated/injective_megavault_rpc_pb.client");
let __injectivelabs_indexer_proto_ts_v2_generated_injective_derivative_exchange_rpc_pb = require("@injectivelabs/indexer-proto-ts-v2/generated/injective_derivative_exchange_rpc_pb");
__injectivelabs_indexer_proto_ts_v2_generated_injective_derivative_exchange_rpc_pb = require_chunk.__toESM(__injectivelabs_indexer_proto_ts_v2_generated_injective_derivative_exchange_rpc_pb);
let __injectivelabs_indexer_proto_ts_v2_generated_injective_derivative_exchange_rpc_pb_client = require("@injectivelabs/indexer-proto-ts-v2/generated/injective_derivative_exchange_rpc_pb.client");
let __injectivelabs_indexer_proto_ts_v2_generated_injective_portfolio_rpc_pb = require("@injectivelabs/indexer-proto-ts-v2/generated/injective_portfolio_rpc_pb");
__injectivelabs_indexer_proto_ts_v2_generated_injective_portfolio_rpc_pb = require_chunk.__toESM(__injectivelabs_indexer_proto_ts_v2_generated_injective_portfolio_rpc_pb);
let __injectivelabs_indexer_proto_ts_v2_generated_injective_portfolio_rpc_pb_client = require("@injectivelabs/indexer-proto-ts-v2/generated/injective_portfolio_rpc_pb.client");
let __injectivelabs_indexer_proto_ts_v2_generated_injective_insurance_rpc_pb = require("@injectivelabs/indexer-proto-ts-v2/generated/injective_insurance_rpc_pb");
__injectivelabs_indexer_proto_ts_v2_generated_injective_insurance_rpc_pb = require_chunk.__toESM(__injectivelabs_indexer_proto_ts_v2_generated_injective_insurance_rpc_pb);
let __injectivelabs_indexer_proto_ts_v2_generated_injective_insurance_rpc_pb_client = require("@injectivelabs/indexer-proto-ts-v2/generated/injective_insurance_rpc_pb.client");
let eventemitter3 = require("eventemitter3");

//#region src/client/indexer/transformers/IndexerCommonTransformer.ts
var IndexerCommonTransformer = class {
	static grpcCoinToCoin(coin) {
		return {
			denom: coin.denom,
			amount: coin.amount
		};
	}
};

//#endregion
//#region src/client/indexer/transformers/IndexerGrpcMitoTransformer.ts
/**
* @category Indexer Grpc Transformer
*/
var IndexerGrpcMitoTransformer = class IndexerGrpcMitoTransformer {
	static grpcTokenInfoToTokenInfo(tokenInfo) {
		return {
			denom: tokenInfo.denom,
			supply: tokenInfo.supply,
			symbol: tokenInfo.symbol,
			decimal: tokenInfo.decimal,
			logoUrl: tokenInfo.logoUrl
		};
	}
	static mitoPaginationToPagination(pagination) {
		if (!pagination) return;
		return { total: pagination.total };
	}
	static mitoDenomBalanceToDenomBalance(denomBalance) {
		return {
			denom: denomBalance.denom,
			totalBalance: denomBalance.totalBalance
		};
	}
	static changesResponseToChanges(changes) {
		if (!changes) return;
		return {
			allTimeChange: changes.allTimeChange,
			threeMonthsChange: changes.threeMonthsChange,
			oneMonthChange: changes.oneMonthChange,
			oneDayChange: changes.oneDayChange,
			oneWeekChange: changes.oneWeekChange,
			oneYearChange: changes.oneYearChange,
			threeYearsChange: changes.threeYearsChange,
			sixMonthsChange: changes.sixMonthsChange
		};
	}
	static mitoSubaccountInfoToSubaccountInfo(mitoSubaccountInfo) {
		if (!mitoSubaccountInfo) return;
		return {
			subaccountId: mitoSubaccountInfo.subaccountId,
			balancesList: mitoSubaccountInfo.balances.map(IndexerGrpcMitoTransformer.mitoDenomBalanceToDenomBalance)
		};
	}
	static mitoVaultToVault(vault) {
		return {
			slug: vault.slug,
			codeId: vault.codeId.toString(),
			marketId: vault.marketId,
			vaultName: vault.vaultName,
			vaultType: vault.vaultType,
			currentTvl: vault.currentTvl,
			lpTokenPrice: vault.lpTokenPrice,
			totalLpAmount: vault.totalLpAmount,
			contractAddress: vault.contractAddress,
			notionalValueCap: vault.notionalValueCap,
			masterContractAddress: vault.masterContractAddress,
			updatedAt: Number(vault.updatedAt),
			createdAt: Number(vault.createdAt),
			apy: vault.apy,
			apyue: vault.apyue,
			apy7D: vault.apy7D,
			apy7DFq: vault.apy7DFq,
			apyV3: vault.apyV3,
			registrationMode: vault.registrationMode,
			profits: IndexerGrpcMitoTransformer.changesResponseToChanges(vault.profits),
			tvlChanges: IndexerGrpcMitoTransformer.changesResponseToChanges(vault.tvlChanges),
			subaccountInfo: IndexerGrpcMitoTransformer.mitoSubaccountInfoToSubaccountInfo(vault.subaccountInfo)
		};
	}
	static mitoPriceSnapshotToPriceSnapshot(snapshot) {
		return {
			price: snapshot.price,
			updatedAt: Number(snapshot.updatedAt)
		};
	}
	static portfolioResponseToPortfolio(portfolio) {
		return {
			pnl: portfolio.pnl,
			totalValue: require_utils.bigIntToNumber(portfolio.totalValue),
			updatedAt: Number(portfolio.pnlUpdatedAt),
			totalValueChartList: portfolio.totalValueChart.map(IndexerGrpcMitoTransformer.mitoPriceSnapshotToPriceSnapshot),
			pnlChartList: portfolio.pnlChart.map(IndexerGrpcMitoTransformer.mitoPriceSnapshotToPriceSnapshot)
		};
	}
	static leaderboardResponseToLeaderboard(leaderboard) {
		return {
			epochId: leaderboard.epochId,
			snapshotBlock: require_utils.bigIntToString(leaderboard.snapshotBlock),
			updatedAt: Number(leaderboard.updatedAt),
			entriesList: leaderboard.entries.map((entry) => ({
				address: entry.address,
				pnl: entry.pnl
			}))
		};
	}
	static mitoTransferHistoryToTransferHistory(transfer) {
		return {
			vault: transfer.vault,
			txHash: transfer.txHash,
			account: transfer.account,
			lpAmount: transfer.lpAmount,
			usdValue: transfer.usdValue,
			isDeposit: transfer.isDeposit,
			tidByVault: transfer.tidByVault,
			tidByAccount: transfer.tidByAccount,
			executedAt: Number(transfer.executedAt),
			coins: transfer.coins.map(IndexerCommonTransformer.grpcCoinToCoin)
		};
	}
	static mitoLeaderboardEpochToLeaderboardEpoch(leaderboardEpoch) {
		return {
			isLive: leaderboardEpoch.isLive,
			epochId: leaderboardEpoch.epochId,
			startAt: Number(leaderboardEpoch.startAt),
			endAt: Number(leaderboardEpoch.endAt)
		};
	}
	static mitoStakingRewardToStakingReward(stakingReward) {
		return {
			apr: stakingReward.apr,
			vaultName: stakingReward.vaultName,
			vaultAddress: stakingReward.vaultAddress,
			lockTimestamp: Number(stakingReward.lockTimestamp),
			claimableRewards: stakingReward.claimableRewards.map(IndexerCommonTransformer.grpcCoinToCoin),
			stakedAmount: stakingReward.stakedAmount ? IndexerCommonTransformer.grpcCoinToCoin(stakingReward.stakedAmount) : void 0,
			lockedAmount: stakingReward.lockedAmount ? IndexerCommonTransformer.grpcCoinToCoin(stakingReward.lockedAmount) : void 0
		};
	}
	static mitoGaugeToGauge(gauge) {
		return {
			id: gauge.id,
			owner: gauge.owner,
			status: gauge.status,
			lastDistribution: gauge.lastDistribution,
			endTimestamp: Number(gauge.endTimestamp),
			startTimestamp: Number(gauge.startTimestamp),
			rewardTokens: gauge.rewardTokens.map(IndexerCommonTransformer.grpcCoinToCoin)
		};
	}
	static mitoStakingPoolToStakingPool(stakingPool) {
		return {
			apr: stakingPool.apr,
			vaultName: stakingPool.vaultName,
			stakeDenom: stakingPool.stakeDenom,
			vaultAddress: stakingPool.vaultAddress,
			aprBreakdown: stakingPool.aprBreakdown,
			totalLiquidity: stakingPool.totalLiquidity,
			stakingAddress: stakingPool.stakingAddress,
			gauges: stakingPool.gauges.map(IndexerGrpcMitoTransformer.mitoGaugeToGauge)
		};
	}
	static mitoStakingActivityToStakingActivity(stakingActivity) {
		return {
			action: stakingActivity.action,
			txHash: stakingActivity.txHash,
			staker: stakingActivity.staker,
			vaultAddress: stakingActivity.vaultAddress,
			numberByAccount: stakingActivity.numberByAccount,
			timestamp: Number(stakingActivity.timestamp),
			rewardedTokens: stakingActivity.rewardedTokens.map(IndexerCommonTransformer.grpcCoinToCoin),
			stakeAmount: stakingActivity.stakeAmount ? IndexerCommonTransformer.grpcCoinToCoin(stakingActivity.stakeAmount) : void 0
		};
	}
	static mitoSubscriptionToSubscription(subscription) {
		return {
			vaultInfo: subscription.vaultInfo ? IndexerGrpcMitoTransformer.mitoVaultToVault(subscription.vaultInfo) : void 0,
			lpAmount: subscription.lpAmount,
			holderAddress: subscription.holderAddress,
			lpAmountPercentage: subscription.lpAmountPercentage
		};
	}
	static mitoLpHolderToLPHolder(holder) {
		return {
			amount: holder.amount,
			vaultAddress: holder.vaultAddress,
			stakedAmount: holder.stakedAmount,
			holderAddress: holder.holderAddress,
			lpAmountPercentage: holder.lpAmountPercentage,
			redemptionLockTime: require_utils.bigIntToString(holder.redemptionLockTime),
			updatedAt: Number(holder.updatedAt)
		};
	}
	static mitoMissionToMission(mission) {
		return {
			id: mission.id,
			points: require_utils.bigIntToString(mission.points),
			progress: mission.progress,
			expected: mission.expected,
			completed: mission.completed,
			accruedPoints: require_utils.bigIntToString(mission.accruedPoints),
			updatedAt: Number(mission.updatedAt)
		};
	}
	static mitoMissionLeaderboardEntryToMissionLeaderboardEntry(entry) {
		return {
			address: entry.address,
			accruedPoints: require_utils.bigIntToString(entry.accruedPoints)
		};
	}
	static mitoIDOProgressToIDOProgress(progress) {
		return {
			status: progress.status,
			timestamp: Number(progress.timestamp)
		};
	}
	static mitoStakedToSubscriptionToStakedToSubscription(data) {
		return {
			stakedAmount: data.field[0],
			subscribableAmount: data.field[1]
		};
	}
	static mitoIDOToIDO(IDO) {
		return {
			name: IDO.name,
			owner: IDO.owner,
			status: IDO.status,
			marketId: IDO.marketId,
			tokenPrice: IDO.tokenPrice,
			quoteDenom: IDO.quoteDenom,
			useWhitelist: IDO.useWhitelist,
			vaultAddress: IDO.vaultAddress,
			capPerAddress: IDO.capPerAddress,
			contractAddress: IDO.contractAddress,
			subscribedAmount: IDO.subscribedAmount,
			isPermissionless: IDO.isPermissionless,
			isLaunchWithVault: IDO.isLaunchWithVault,
			targetAmountInUsd: IDO.targetAmountInUsd,
			projectTokenAmount: IDO.projectTokenAmount,
			projectDescription: IDO.projectDescription,
			isAccountWhiteListed: IDO.isAccountWhiteListed,
			isVestingScheduleEnabled: IDO.isVestingScheduleEnabled,
			targetAmountInQuoteDenom: IDO.targetAmountInQuoteDenom,
			endTime: Number(IDO.endTime),
			startTime: Number(IDO.startTime),
			secondBeforeStartToSetQuotePrice: Number(IDO.secondBeforeStartToSetQuotePrice),
			progress: IDO.progress.map(IndexerGrpcMitoTransformer.mitoIDOProgressToIDOProgress),
			tokenInfo: IDO.tokenInfo ? IndexerGrpcMitoTransformer.grpcTokenInfoToTokenInfo(IDO.tokenInfo) : void 0,
			stakeToSubscription: IDO.stakeToSubscription.map(IndexerGrpcMitoTransformer.mitoStakedToSubscriptionToStakedToSubscription),
			vestingConfig: IndexerGrpcMitoTransformer.mitoIDOInitParamsToIDOVestingConfig(IDO.initParams)
		};
	}
	static mitoIDOSubscriberToIDOSubscriber(IDOSubscriber) {
		return {
			address: IDOSubscriber.address,
			lastSubscribeTime: Number(IDOSubscriber.lastSubscribeTime),
			subscribedCoin: IDOSubscriber.subscribedCoin ? IndexerCommonTransformer.grpcCoinToCoin(IDOSubscriber.subscribedCoin) : void 0,
			estimateLpAmount: IDOSubscriber.estimateLpAmount ? IndexerCommonTransformer.grpcCoinToCoin(IDOSubscriber.estimateLpAmount) : void 0,
			estimateRefundAmount: IDOSubscriber.estimateRefundAmount ? IndexerCommonTransformer.grpcCoinToCoin(IDOSubscriber.estimateRefundAmount) : void 0,
			estimateTokenReceived: IDOSubscriber.estimateTokenReceived ? IndexerCommonTransformer.grpcCoinToCoin(IDOSubscriber.estimateTokenReceived) : void 0,
			createdAt: Number(IDOSubscriber.createdAt)
		};
	}
	static mitoIDOClaimedCoinsToIDOClaimedCoins(claimedCoins) {
		return {
			claimedCoins: claimedCoins.claimedCoins.map(IndexerCommonTransformer.grpcCoinToCoin),
			updatedAt: Number(claimedCoins.updatedAt)
		};
	}
	static mitoIDOSubscriptionToIDOSubscription(subscription) {
		return {
			price: subscription.price,
			marketId: subscription.marketId,
			quoteDenom: subscription.quoteDenom,
			stakedAmount: subscription.stakedAmount,
			rewardClaimed: subscription.rewardClaimed,
			committedAmount: subscription.committedAmount,
			updatedAt: Number(subscription.updatedAt),
			claimableCoins: subscription.claimableCoins.map(IndexerCommonTransformer.grpcCoinToCoin),
			ownerClaimableCoins: subscription.ownerClaimableCoins.map(IndexerCommonTransformer.grpcCoinToCoin),
			claimTxHash: subscription.claimTxHash,
			maxSubscriptionCoin: subscription.maxSubscriptionCoin ? IndexerCommonTransformer.grpcCoinToCoin(subscription.maxSubscriptionCoin) : void 0,
			tokenInfo: subscription.tokenInfo ? IndexerGrpcMitoTransformer.grpcTokenInfoToTokenInfo(subscription.tokenInfo) : void 0,
			claimedCoins: subscription.claimedCoins ? IndexerGrpcMitoTransformer.mitoIDOClaimedCoinsToIDOClaimedCoins(subscription.claimedCoins) : void 0
		};
	}
	static mitoIDOSubscriptionActivityToIDOSubscriptionActivity(IDOSubscriptionActivity) {
		return {
			txHash: IDOSubscriptionActivity.txHash,
			address: IDOSubscriptionActivity.address,
			usdValue: IDOSubscriptionActivity.usdValue,
			timestamp: Number(IDOSubscriptionActivity.timestamp),
			subscribedCoin: IDOSubscriptionActivity.subscribedCoin ? IndexerCommonTransformer.grpcCoinToCoin(IDOSubscriptionActivity.subscribedCoin) : void 0
		};
	}
	static mitoWhitelistAccountToWhitelistAccount(account) {
		return {
			weight: account.weight,
			accountAddress: account.accountAddress,
			updatedAt: Number(account.updatedAt)
		};
	}
	static mitoClaimReferenceToClaimReference(claimReference) {
		return {
			denom: claimReference.denom,
			claimedAmount: claimReference.claimedAmount,
			accountAddress: claimReference.accountAddress,
			claimableAmount: claimReference.claimableAmount,
			cwContractAddress: claimReference.cwContractAddress,
			idoContractAddress: claimReference.idoContractAddress,
			vestingDurationSeconds: Number(claimReference.vestingDurationSeconds),
			updatedAt: Number(claimReference.updatedAt),
			startVestingTime: Number(claimReference.startVestingTime)
		};
	}
	static mitoVestingCOonfigToVestingConfig(config) {
		return {
			schedule: (config === null || config === void 0 ? void 0 : config.schedule) || "",
			vestingDurationSeconds: Number((config === null || config === void 0 ? void 0 : config.vestingDurationSeconds) || 0n),
			vestingStartDelaySeconds: Number((config === null || config === void 0 ? void 0 : config.vestingStartDelaySeconds) || 0n)
		};
	}
	static mitoIDOInitParamsToIDOVestingConfig(initParams) {
		if (!initParams || !initParams.vestingConfig) return;
		return {
			projectOwnerQuote: IndexerGrpcMitoTransformer.mitoVestingCOonfigToVestingConfig(initParams.vestingConfig.projectOwnerQuote),
			usersProjectToken: IndexerGrpcMitoTransformer.mitoVestingCOonfigToVestingConfig(initParams.vestingConfig.usersProjectToken)
		};
	}
	static vaultResponseToVault(response) {
		const [vault] = response.vault;
		return IndexerGrpcMitoTransformer.mitoVaultToVault(vault);
	}
	static vaultsResponseToVaults(response) {
		return {
			vaults: response.vaults.map(IndexerGrpcMitoTransformer.mitoVaultToVault),
			pagination: IndexerGrpcMitoTransformer.mitoPaginationToPagination(response.pagination)
		};
	}
	static lpTokenPriceChartResponseToLPTokenPriceChart(response) {
		return response.prices.map(IndexerGrpcMitoTransformer.mitoPriceSnapshotToPriceSnapshot);
	}
	static vaultsByHolderAddressResponseToVaultsByHolderAddress(response) {
		return {
			subscriptions: response.subscriptions.map(IndexerGrpcMitoTransformer.mitoSubscriptionToSubscription),
			pagination: IndexerGrpcMitoTransformer.mitoPaginationToPagination(response.pagination)
		};
	}
	static lpHoldersResponseToLPHolders(response) {
		return {
			holders: response.holders.map(IndexerGrpcMitoTransformer.mitoLpHolderToLPHolder),
			pagination: IndexerGrpcMitoTransformer.mitoPaginationToPagination(response.pagination)
		};
	}
	static transferHistoryResponseToTransfer(response) {
		return {
			transfers: response.transfers.map(IndexerGrpcMitoTransformer.mitoTransferHistoryToTransferHistory),
			pagination: IndexerGrpcMitoTransformer.mitoPaginationToPagination(response.pagination)
		};
	}
	static leaderboardEpochsResponseToLeaderboardEpochs(response) {
		return {
			epochs: response.epochs.map(IndexerGrpcMitoTransformer.mitoLeaderboardEpochToLeaderboardEpoch),
			pagination: IndexerGrpcMitoTransformer.mitoPaginationToPagination(response.pagination)
		};
	}
	static stakingPoolsResponseToStakingPools(response) {
		return {
			pools: response.pools.map(IndexerGrpcMitoTransformer.mitoStakingPoolToStakingPool),
			pagination: IndexerGrpcMitoTransformer.mitoPaginationToPagination(response.pagination)
		};
	}
	static stakingRewardByAccountResponseToStakingRewardByAccount(response) {
		return {
			rewards: response.rewards.map(IndexerGrpcMitoTransformer.mitoStakingRewardToStakingReward),
			pagination: IndexerGrpcMitoTransformer.mitoPaginationToPagination(response.pagination)
		};
	}
	static mitoStakingHistoryResponseTpStakingHistory(response) {
		return {
			activities: response.activities.map(IndexerGrpcMitoTransformer.mitoStakingActivityToStakingActivity),
			pagination: IndexerGrpcMitoTransformer.mitoPaginationToPagination(response.pagination)
		};
	}
	static mitoMissionsResponseMissions(response) {
		return response.data.map(IndexerGrpcMitoTransformer.mitoMissionToMission);
	}
	static mitoMissionLeaderboardResponseToMissionLeaderboard(response) {
		var _response$userRank;
		return {
			entries: response.data.map(IndexerGrpcMitoTransformer.mitoMissionLeaderboardEntryToMissionLeaderboardEntry),
			updatedAt: Number(response.updatedAt),
			rank: (_response$userRank = response.userRank) === null || _response$userRank === void 0 ? void 0 : _response$userRank.toString()
		};
	}
	static mitoListIDOsResponseToIDOs(response) {
		return {
			idos: response.idos.map(IndexerGrpcMitoTransformer.mitoIDOToIDO),
			pagination: IndexerGrpcMitoTransformer.mitoPaginationToPagination(response.pagination)
		};
	}
	static mitoIDOResponseToIDO(response) {
		return { ido: response.ido ? IndexerGrpcMitoTransformer.mitoIDOToIDO(response.ido) : void 0 };
	}
	static mitoIDOSubscribersResponseToIDOSubscribers(response) {
		return {
			marketId: response.marketId,
			quoteDenom: response.quoteDenom,
			subscribers: response.subscribers.map(IndexerGrpcMitoTransformer.mitoIDOSubscriberToIDOSubscriber),
			pagination: IndexerGrpcMitoTransformer.mitoPaginationToPagination(response.pagination),
			tokenInfo: response.tokenInfo ? IndexerGrpcMitoTransformer.grpcTokenInfoToTokenInfo(response.tokenInfo) : void 0
		};
	}
	static mitoIDOSubscriptionResponseToIDOSubscription(response) {
		return { subscription: response.subscription ? IndexerGrpcMitoTransformer.mitoIDOSubscriptionToIDOSubscription(response.subscription) : void 0 };
	}
	static mitoIDOActivitiesResponseToIDOActivities(response) {
		return {
			activities: response.activities.map(IndexerGrpcMitoTransformer.mitoIDOSubscriptionActivityToIDOSubscriptionActivity),
			pagination: IndexerGrpcMitoTransformer.mitoPaginationToPagination(response.pagination)
		};
	}
	static mitoWhitelistAccountResponseToWhitelistAccount(response) {
		return {
			idoAddress: response.idoAddress,
			accounts: response.accounts.map(IndexerGrpcMitoTransformer.mitoWhitelistAccountToWhitelistAccount),
			pagination: IndexerGrpcMitoTransformer.mitoPaginationToPagination(response.pagination)
		};
	}
	static claimReferencesResponseToClaimReferences(response) {
		return {
			claimReferences: response.claimReferences ? response.claimReferences.map(IndexerGrpcMitoTransformer.mitoClaimReferenceToClaimReference) : [],
			pagination: IndexerGrpcMitoTransformer.mitoPaginationToPagination(response.pagination)
		};
	}
};

//#endregion
//#region src/client/indexer/transformers/IndexerGrpcSpotTransformer.ts
const zeroPriceLevel = () => ({
	price: "0",
	quantity: "0",
	timestamp: 0
});
/**
* @category Indexer Grpc Transformer
*/
var IndexerGrpcSpotTransformer = class IndexerGrpcSpotTransformer {
	static grpcTokenMetaToTokenMeta(tokenMeta) {
		if (!tokenMeta) return;
		return {
			name: tokenMeta.name,
			address: tokenMeta.address,
			symbol: tokenMeta.symbol,
			logo: tokenMeta.logo,
			decimals: tokenMeta.decimals,
			updatedAt: Number(tokenMeta.updatedAt),
			coinGeckoId: "",
			tokenType: require_types.TokenType.Unknown
		};
	}
	static marketResponseToMarket(response) {
		const market = response.market;
		return IndexerGrpcSpotTransformer.grpcMarketToMarket(market);
	}
	static marketsResponseToMarkets(response) {
		const markets = response.markets;
		return IndexerGrpcSpotTransformer.grpcMarketsToMarkets(markets);
	}
	static ordersResponseToOrders(response) {
		const orders = response.orders;
		const pagination = response.paging;
		return {
			orders: IndexerGrpcSpotTransformer.grpcOrdersToOrders(orders),
			pagination: require_utils.grpcPagingToPagingV2(pagination)
		};
	}
	static orderHistoryResponseToOrderHistory(response) {
		const orderHistory = response.orders;
		const pagination = response.paging;
		return {
			orderHistory: IndexerGrpcSpotTransformer.grpcOrderHistoryListToOrderHistoryList(orderHistory),
			pagination: require_utils.grpcPagingToPagingV2(pagination)
		};
	}
	static tradesResponseToTrades(response) {
		const trades = response.trades;
		const pagination = response.paging;
		return {
			trades: IndexerGrpcSpotTransformer.grpcTradesToTrades(trades),
			pagination: require_utils.grpcPagingToPagingV2(pagination)
		};
	}
	static subaccountTradesListResponseToTradesList(response) {
		const tradesList = response.trades;
		return IndexerGrpcSpotTransformer.grpcTradesToTrades(tradesList);
	}
	static orderbookV2ResponseToOrderbookV2(response) {
		const orderbook = response.orderbook;
		return IndexerGrpcSpotTransformer.grpcOrderbookV2ToOrderbookV2({
			sequence: Number(orderbook.sequence),
			buys: orderbook === null || orderbook === void 0 ? void 0 : orderbook.buys,
			sells: orderbook === null || orderbook === void 0 ? void 0 : orderbook.sells
		});
	}
	static orderbooksV2ResponseToOrderbooksV2(response) {
		return response.orderbooks.map((o) => {
			const orderbook = o.orderbook;
			return {
				marketId: o.marketId,
				orderbook: IndexerGrpcSpotTransformer.grpcOrderbookV2ToOrderbookV2({
					sequence: Number(orderbook.sequence),
					buys: orderbook.buys,
					sells: orderbook.sells
				})
			};
		});
	}
	static grpcMarketToMarket(market) {
		return {
			marketId: market.marketId,
			marketStatus: market.marketStatus,
			ticker: market.ticker,
			baseDenom: market.baseDenom,
			quoteDenom: market.quoteDenom,
			quoteToken: IndexerGrpcSpotTransformer.grpcTokenMetaToTokenMeta(market.quoteTokenMeta),
			baseToken: IndexerGrpcSpotTransformer.grpcTokenMetaToTokenMeta(market.baseTokenMeta),
			makerFeeRate: market.makerFeeRate,
			takerFeeRate: market.takerFeeRate,
			serviceProviderFee: market.serviceProviderFee,
			minPriceTickSize: new __injectivelabs_utils.BigNumber(market.minPriceTickSize).toNumber(),
			minQuantityTickSize: new __injectivelabs_utils.BigNumber(market.minQuantityTickSize).toNumber(),
			minNotional: new __injectivelabs_utils.BigNumber(market.minNotional).toNumber()
		};
	}
	static grpcMarketsToMarkets(markets) {
		return markets.map((market) => IndexerGrpcSpotTransformer.grpcMarketToMarket(market));
	}
	static grpcPriceLevelToPriceLevel(priceLevel) {
		return {
			price: priceLevel.price,
			quantity: priceLevel.quantity,
			timestamp: Number(priceLevel.timestamp)
		};
	}
	static grpcPriceLevelsToPriceLevels(priceLevels) {
		return priceLevels.map((priceLevel) => IndexerGrpcSpotTransformer.grpcPriceLevelToPriceLevel(priceLevel));
	}
	static grpcOrderbookToOrderbook({ buys, sells }) {
		return {
			buys: IndexerGrpcSpotTransformer.grpcPriceLevelsToPriceLevels(buys),
			sells: IndexerGrpcSpotTransformer.grpcPriceLevelsToPriceLevels(sells)
		};
	}
	static grpcOrderbookV2ToOrderbookV2({ buys, sells, sequence }) {
		return {
			sequence,
			buys: IndexerGrpcSpotTransformer.grpcPriceLevelsToPriceLevels(buys),
			sells: IndexerGrpcSpotTransformer.grpcPriceLevelsToPriceLevels(sells)
		};
	}
	static grpcOrderToOrder(order) {
		return {
			orderHash: order.orderHash,
			orderSide: order.orderSide,
			marketId: order.marketId,
			cid: order.cid,
			subaccountId: order.subaccountId,
			price: order.price,
			state: order.state,
			quantity: order.quantity,
			unfilledQuantity: order.unfilledQuantity,
			triggerPrice: order.triggerPrice,
			feeRecipient: order.feeRecipient,
			createdAt: Number(order.createdAt),
			updatedAt: Number(order.updatedAt)
		};
	}
	static grpcOrdersToOrders(orders) {
		return orders.map((order) => IndexerGrpcSpotTransformer.grpcOrderToOrder(order));
	}
	static grpcOrderHistoryToOrderHistory(orderHistory) {
		return {
			orderHash: orderHistory.orderHash,
			marketId: orderHistory.marketId,
			cid: orderHistory.cid,
			active: orderHistory.isActive,
			subaccountId: orderHistory.subaccountId,
			executionType: orderHistory.executionType,
			orderType: orderHistory.orderType,
			price: orderHistory.price,
			triggerPrice: orderHistory.triggerPrice,
			quantity: orderHistory.quantity,
			filledQuantity: orderHistory.filledQuantity,
			state: orderHistory.state,
			createdAt: Number(orderHistory.createdAt),
			updatedAt: Number(orderHistory.updatedAt),
			direction: orderHistory.direction
		};
	}
	static grpcOrderHistoryListToOrderHistoryList(orderHistory) {
		return orderHistory.map((orderHistory$1) => IndexerGrpcSpotTransformer.grpcOrderHistoryToOrderHistory(orderHistory$1));
	}
	static grpcTradeToTrade(trade) {
		const price = trade.price;
		const mappedPrice = price ? {
			price: price.price,
			quantity: price.quantity,
			timestamp: Number(price.timestamp)
		} : zeroPriceLevel();
		return {
			orderHash: trade.orderHash,
			subaccountId: trade.subaccountId,
			marketId: trade.marketId,
			tradeId: trade.tradeId,
			cid: trade.cid,
			executedAt: Number(trade.executedAt),
			feeRecipient: trade.feeRecipient,
			tradeExecutionType: trade.tradeExecutionType,
			executionSide: trade.executionSide,
			tradeDirection: trade.tradeDirection,
			fee: trade.fee,
			price: mappedPrice.price,
			quantity: mappedPrice.quantity,
			timestamp: mappedPrice.timestamp
		};
	}
	static grpcTradesToTrades(trades) {
		return trades.map((trade) => IndexerGrpcSpotTransformer.grpcTradeToTrade(trade));
	}
	static grpcAtomicSwapHistoryListToAtomicSwapHistoryList(response) {
		const swapHistory = response.data;
		const pagination = response.paging;
		return {
			swapHistory: swapHistory.map(IndexerGrpcSpotTransformer.grpcAtomicSwapHistoryToAtomicSwapHistory),
			pagination: require_utils.grpcPagingToPagingV2(pagination)
		};
	}
	static grpcAtomicSwapHistoryToAtomicSwapHistory(swapHistory) {
		return {
			sender: swapHistory.sender,
			route: swapHistory.route,
			sourceCoin: swapHistory.sourceCoin || void 0,
			destinationCoin: swapHistory.destCoin || void 0,
			fees: swapHistory.fees,
			contractAddress: swapHistory.contractAddress,
			indexBySender: swapHistory.indexBySender,
			indexBySenderContract: swapHistory.indexBySenderContract,
			txHash: swapHistory.txHash,
			executedAt: Number(swapHistory.executedAt)
		};
	}
};

//#endregion
//#region src/client/indexer/transformers/IndexerCampaignTransformer.ts
var IndexerCampaignTransformer = class IndexerCampaignTransformer {
	static GrpcCampaignUserToCampaignUser(campaignUser) {
		return {
			campaignId: campaignUser.campaignId,
			marketId: campaignUser.marketId,
			accountAddress: campaignUser.accountAddress,
			score: campaignUser.score,
			contractUpdated: campaignUser.contractUpdated,
			blockHeight: campaignUser.blockHeight.toString(),
			blockTime: Number(campaignUser.blockTime),
			purchasedAmount: campaignUser.purchasedAmount,
			galxeUpdated: campaignUser.galxeUpdated
		};
	}
	static GrpcCampaignToCampaign(campaign) {
		return {
			campaignId: campaign.campaignId,
			marketId: campaign.marketId,
			totalScore: campaign.totalScore,
			lastUpdated: Number(campaign.lastUpdated),
			startDate: Number(campaign.startDate),
			endDate: Number(campaign.endDate),
			isClaimable: campaign.isClaimable,
			rewards: campaign.rewards,
			roundId: campaign.roundId,
			userClaimed: campaign.userClaimed,
			userScore: campaign.userScore,
			rewardContract: campaign.rewardContract,
			version: campaign.version
		};
	}
	static GrpcGuildToGuild(guild) {
		return {
			campaignContract: guild.campaignContract,
			guildId: guild.guildId,
			masterAddress: guild.masterAddress,
			createdAt: Number(guild.createdAt),
			tvlScore: guild.tvlScore,
			volumeScore: guild.volumeScore,
			rankByVolume: guild.rankByVolume,
			rankByTvl: guild.rankByTvl,
			logo: guild.logo,
			totalTvl: guild.totalTvl,
			updatedAt: Number(guild.updatedAt),
			name: guild.name,
			isActive: guild.isActive,
			masterBalance: guild.masterBalance,
			description: guild.description
		};
	}
	static GrpcGuildMemberToGuildMember(member) {
		return {
			campaignContract: member.campaignContract,
			guildId: member.guildId,
			address: member.address,
			joinedAt: Number(member.joinedAt),
			tvlScore: member.tvlScore,
			volumeScore: member.volumeScore,
			totalTvl: member.totalTvl,
			volumeScorePercentage: member.volumeScorePercentage,
			tvlScorePercentage: member.tvlScorePercentage,
			tvlReward: member.tvlReward.map(IndexerCommonTransformer.grpcCoinToCoin),
			volumeReward: member.volumeReward.map(IndexerCommonTransformer.grpcCoinToCoin)
		};
	}
	static GrpcGuildCampaignSummaryToGuildCampaignSummary(campaignSummary) {
		return {
			campaignId: campaignSummary.campaignId,
			campaignContract: campaignSummary.campaignContract,
			totalGuildsCount: campaignSummary.totalGuildsCount,
			totalTvl: campaignSummary.totalTvl,
			totalAverageTvl: campaignSummary.totalAverageTvl,
			totalVolume: campaignSummary.totalVolume,
			updatedAt: Number(campaignSummary.updatedAt),
			totalMembersCount: campaignSummary.totalMembersCount,
			startTime: Number(campaignSummary.startTime),
			endTime: Number(campaignSummary.endTime)
		};
	}
	static CampaignResponseToCampaign(response) {
		return {
			campaign: response.campaign ? IndexerCampaignTransformer.GrpcCampaignToCampaign(response.campaign) : void 0,
			users: response.users.map(IndexerCampaignTransformer.GrpcCampaignUserToCampaignUser),
			paging: require_utils.grpcPagingToPagingV2(response.paging)
		};
	}
	static RoundsResponseToRounds(response) {
		return {
			campaigns: response.campaigns.map((campaign) => IndexerCampaignTransformer.GrpcCampaignToCampaign(campaign)),
			accumulatedRewards: response.accumulatedRewards,
			rewardCount: response.rewardCount
		};
	}
	static GuildsResponseToGuilds(response) {
		return {
			guilds: response.guilds.map(IndexerCampaignTransformer.GrpcGuildToGuild),
			paging: require_utils.grpcPagingToPagingV2(response.paging),
			updatedAt: Number(response.updatedAt),
			summary: response.campaignSummary ? IndexerCampaignTransformer.GrpcGuildCampaignSummaryToGuildCampaignSummary(response.campaignSummary) : void 0
		};
	}
	static GuildMemberResponseToGuildMember(response) {
		return { info: response.info ? IndexerCampaignTransformer.GrpcGuildMemberToGuildMember(response.info) : void 0 };
	}
	static GuildMembersResponseToGuildMembers(response) {
		return {
			members: response.members.map(IndexerCampaignTransformer.GrpcGuildMemberToGuildMember),
			paging: require_utils.grpcPagingToPagingV2(response.paging),
			guildInfo: response.guildInfo ? IndexerCampaignTransformer.GrpcGuildToGuild(response.guildInfo) : void 0
		};
	}
	static GrpcCampaignV2ToCampaignV2(campaign) {
		return {
			campaignId: campaign.campaignId,
			marketId: campaign.marketId,
			totalScore: campaign.totalScore,
			createdAt: Number(campaign.createdAt),
			updatedAt: Number(campaign.updatedAt),
			startDate: Number(campaign.startDate),
			endDate: Number(campaign.endDate),
			isClaimable: campaign.isClaimable,
			roundId: campaign.roundId,
			managerContract: campaign.managerContract,
			rewards: campaign.rewards.map(IndexerCommonTransformer.grpcCoinToCoin),
			subaccountIdSuffix: campaign.subaccountIdSuffix,
			rewardContract: campaign.rewardContract,
			type: campaign.type,
			version: campaign.version,
			name: campaign.name,
			description: campaign.description
		};
	}
	static CampaignsV2ResponseToCampaigns(response) {
		return {
			campaigns: response.campaigns.map(IndexerCampaignTransformer.GrpcCampaignV2ToCampaignV2),
			cursor: response.cursor
		};
	}
};

//#endregion
//#region src/client/indexer/transformers/IndexerGrpcOracleTransformer.ts
var IndexerGrpcOracleTransformer = class IndexerGrpcOracleTransformer {
	static oraclesResponseToOracles(response) {
		return response.oracles.map((o) => IndexerGrpcOracleTransformer.grpcOracleToOracle(o));
	}
	static grpcOracleToOracle(grpcOracle) {
		return grpcOracle;
	}
};

//#endregion
//#region src/client/indexer/transformers/IndexerSpotStreamTransformer.ts
/**
* @category Indexer Stream Transformer
*/
var IndexerSpotStreamTransformer = class {};
require_defineProperty._defineProperty(IndexerSpotStreamTransformer, "tradesStreamCallback", (response) => {
	const trade = response.trade;
	return {
		trade: trade ? IndexerGrpcSpotTransformer.grpcTradeToTrade(trade) : void 0,
		operation: response.operationType,
		timestamp: response.timestamp
	};
});
require_defineProperty._defineProperty(IndexerSpotStreamTransformer, "ordersStreamCallback", (response) => {
	const order = response.order;
	return {
		order: order ? IndexerGrpcSpotTransformer.grpcOrderToOrder(order) : void 0,
		operation: response.operationType,
		timestamp: response.timestamp
	};
});
require_defineProperty._defineProperty(IndexerSpotStreamTransformer, "orderHistoryStreamCallback", (response) => {
	const order = response.order;
	return {
		order: order ? IndexerGrpcSpotTransformer.grpcOrderHistoryToOrderHistory(order) : void 0,
		operation: response.operationType,
		timestamp: response.timestamp
	};
});
require_defineProperty._defineProperty(IndexerSpotStreamTransformer, "orderbookV2StreamCallback", (response) => {
	const orderbook = response.orderbook;
	return {
		orderbook: orderbook ? IndexerGrpcSpotTransformer.grpcOrderbookV2ToOrderbookV2({
			sequence: Number(orderbook.sequence),
			buys: orderbook.buys,
			sells: orderbook.sells
		}) : void 0,
		operation: response.operationType,
		marketId: response.marketId,
		timestamp: response.timestamp
	};
});
require_defineProperty._defineProperty(IndexerSpotStreamTransformer, "orderbookUpdateStreamCallback", (response) => {
	const orderbook = response.orderbookLevelUpdates;
	return {
		orderbook: orderbook ? IndexerGrpcSpotTransformer.grpcOrderbookV2ToOrderbookV2({
			sequence: Number(orderbook.sequence),
			buys: orderbook.buys,
			sells: orderbook.sells
		}) : void 0,
		operation: response.operationType,
		marketId: response.marketId,
		timestamp: response.timestamp
	};
});

//#endregion
//#region src/client/indexer/transformers/IndexerGrpcAccountTransformer.ts
/**
* @category Indexer Grpc Transformer
*
*/
var IndexerGrpcAccountTransformer = class IndexerGrpcAccountTransformer {
	/**
	*
	* @deprecated - use IndexerGrpcAccountPortfolioApi.accountPortfolioResponseToAccountPortfolio
	*/
	static accountPortfolioResponseToAccountPortfolio(response) {
		const portfolio = response.portfolio;
		const subaccounts = portfolio.subaccounts || [];
		return {
			portfolioValue: portfolio.portfolioValue,
			availableBalance: portfolio.availableBalance,
			lockedBalance: portfolio.lockedBalance,
			unrealizedPnl: portfolio.unrealizedPnl,
			subaccountsList: subaccounts.map(IndexerGrpcAccountTransformer.grpcSubaccountPortfolioToSubaccountPortfolio)
		};
	}
	static grpcSubaccountPortfolioToSubaccountPortfolio(subaccountPortfolio) {
		return {
			subaccountId: subaccountPortfolio.subaccountId,
			availableBalance: subaccountPortfolio.availableBalance,
			lockedBalance: subaccountPortfolio.lockedBalance,
			unrealizedPnl: subaccountPortfolio.unrealizedPnl
		};
	}
	static grpcAccountPortfolioToAccountPortfolio(portfolio) {
		return {
			portfolioValue: portfolio.portfolioValue,
			availableBalance: portfolio.availableBalance,
			lockedBalance: portfolio.lockedBalance,
			unrealizedPnl: portfolio.unrealizedPnl,
			subaccountsList: portfolio.subaccounts.map(IndexerGrpcAccountTransformer.grpcSubaccountPortfolioToSubaccountPortfolio)
		};
	}
	static grpcAmountToAmount(amount) {
		return {
			amount: amount.amount,
			denom: amount.denom
		};
	}
	static grpcDepositToDeposit(deposit) {
		return {
			totalBalance: deposit.totalBalance,
			availableBalance: deposit.availableBalance
		};
	}
	static balancesResponseToBalances(response) {
		return response.balances.map((b) => IndexerGrpcAccountTransformer.grpcBalanceToBalance(b));
	}
	static balanceResponseToBalance(response) {
		return IndexerGrpcAccountTransformer.grpcBalanceToBalance(response.balance);
	}
	static grpcBalanceToBalance(balance) {
		const deposit = balance.deposit;
		return {
			subaccountId: balance.subaccountId,
			accountAddress: balance.accountAddress,
			denom: balance.denom,
			deposit: deposit ? IndexerGrpcAccountTransformer.grpcDepositToDeposit(deposit) : void 0
		};
	}
	static grpcBalancesToBalances(balances) {
		return balances.map((balance) => IndexerGrpcAccountTransformer.grpcBalanceToBalance(balance));
	}
	static grpcTransferHistoryEntryToTransferHistoryEntry(transfer) {
		const amount = transfer.amount;
		return {
			transferType: transfer.transferType,
			srcSubaccountId: transfer.srcSubaccountId,
			srcSubaccountAddress: transfer.srcAccountAddress,
			dstSubaccountId: transfer.dstSubaccountId,
			dstSubaccountAddress: transfer.dstAccountAddress,
			executedAt: Number(transfer.executedAt),
			amount: amount ? IndexerGrpcAccountTransformer.grpcAmountToAmount(amount) : void 0
		};
	}
	static tradingRewardsResponseToTradingRewards(response) {
		return response.rewards.map(IndexerGrpcAccountTransformer.grpcTradingRewardToTradingReward);
	}
	static grpcTradingRewardsToTradingRewards(rewards) {
		return rewards.map(IndexerGrpcAccountTransformer.grpcTradingRewardToTradingReward);
	}
	static grpcTradingRewardToTradingReward(reward) {
		return {
			accountAddress: reward.accountAddress,
			rewards: reward.rewards.map((r) => ({
				amount: r.amount,
				denom: r.denom
			})),
			distributedAt: Number(reward.distributedAt)
		};
	}
	static transferHistoryResponseToTransferHistory(response) {
		const transfers = response.transfers;
		const pagination = response.paging;
		return {
			transfers: transfers.map((transfer) => IndexerGrpcAccountTransformer.grpcTransferHistoryEntryToTransferHistoryEntry(transfer)),
			pagination: require_utils.grpcPagingToPagingV2(pagination)
		};
	}
	static grpcTransferHistoryToTransferHistory(transfers) {
		return transfers.map((transfer) => IndexerGrpcAccountTransformer.grpcTransferHistoryEntryToTransferHistoryEntry(transfer));
	}
};

//#endregion
//#region src/client/indexer/transformers/IndexerGrpcAuctionTransformer.ts
/**
* @category Indexer Grpc Transformer
*/
var IndexerGrpcAuctionTransformer = class IndexerGrpcAuctionTransformer {
	static grpcAuctionCoinToAuctionCoin(grpcCoin) {
		return {
			denom: grpcCoin.denom,
			amount: grpcCoin.amount,
			usdValue: grpcCoin.usdValue
		};
	}
	static grpcAuctionCoinPricesToAuctionCoinPrices(grpcCoinPrices) {
		return {
			denom: grpcCoinPrices.denom,
			amount: grpcCoinPrices.amount,
			prices: grpcCoinPrices.prices
		};
	}
	static grpcBidToBid(grpcBid) {
		return {
			bidder: grpcBid.bidder,
			bidAmount: grpcBid.amount,
			bidTimestamp: Number(grpcBid.timestamp)
		};
	}
	static grpcAuctionToAuction(grpcAuction) {
		return {
			winner: grpcAuction.winner,
			basket: grpcAuction.basket.map(IndexerGrpcAuctionTransformer.grpcAuctionCoinToAuctionCoin),
			winningBidAmount: grpcAuction.winningBidAmount,
			round: Number(grpcAuction.round),
			endTimestamp: Number(grpcAuction.endTimestamp),
			updatedAt: Number(grpcAuction.updatedAt)
		};
	}
	static grpcAuctionV2ToAuctionV2(grpcAuction) {
		return {
			winner: grpcAuction.winner,
			basket: grpcAuction.basket.map(IndexerGrpcAuctionTransformer.grpcAuctionCoinPricesToAuctionCoinPrices),
			contract: grpcAuction.contract ? {
				id: grpcAuction.contract.id.toString(),
				bidTarget: grpcAuction.contract.bidTarget,
				isBidPlaced: grpcAuction.contract.isBidPlaced,
				currentSlots: grpcAuction.contract.currentSlots.toString(),
				totalSlots: grpcAuction.contract.totalSlots.toString(),
				maxUserAllocation: grpcAuction.contract.maxUserAllocation,
				totalCommitted: grpcAuction.contract.totalCommitted,
				whitelistAddresses: grpcAuction.contract.whitelistAddresses,
				startTimestamp: grpcAuction.contract.startTimestamp.toString(),
				endTimestamp: grpcAuction.contract.endTimestamp.toString(),
				maxRoundAllocation: grpcAuction.contract.maxRoundAllocation
			} : void 0,
			winningBidAmount: grpcAuction.winningBidAmount,
			winningBidAmountUsd: grpcAuction.winningBidAmountUsd,
			round: Number(grpcAuction.round),
			endTimestamp: Number(grpcAuction.endTimestamp),
			updatedAt: Number(grpcAuction.updatedAt)
		};
	}
	static grpcAccountAuctionV2ToAccountAuctionV2(grpcAccountAuction) {
		return {
			id: grpcAccountAuction.id.toString(),
			round: Number(grpcAccountAuction.round),
			amountDeposited: grpcAccountAuction.amountDeposited,
			isClaimable: grpcAccountAuction.isClaimable,
			claimedAssets: grpcAccountAuction.claimedAssets.map(IndexerGrpcAuctionTransformer.grpcAuctionCoinPricesToAuctionCoinPrices)
		};
	}
	static auctionsResponseToAuctions(response) {
		return response.auctions.map((a) => IndexerGrpcAuctionTransformer.grpcAuctionToAuction(a));
	}
	static auctionsHistoryV2ResponseToAuctionHistory(response) {
		return {
			auctions: response.auctions.map(IndexerGrpcAuctionTransformer.grpcAuctionV2ToAuctionV2),
			next: response.next
		};
	}
	static accountAuctionsV2ResponseToAccountAuctionsV2(response) {
		return {
			auctions: response.auctions.map(IndexerGrpcAuctionTransformer.grpcAccountAuctionV2ToAccountAuctionV2),
			next: response.next,
			total: response.total
		};
	}
	static auctionResponseToAuction(response) {
		return {
			auction: IndexerGrpcAuctionTransformer.grpcAuctionToAuction(response.auction),
			bids: response.bids.map(IndexerGrpcAuctionTransformer.grpcBidToBid)
		};
	}
	static auctionStatsResponseToAuctionStats(response) {
		return {
			totalBurnt: response.totalBurnt,
			totalBurntInUsd: response.totalUsdValue
		};
	}
	static auctionAccountStatusResponseToAuctionAccountStatus(response) {
		return { status: response.status };
	}
};

//#endregion
//#region src/client/indexer/transformers/IndexerGrpcArchiverTransformer.ts
/**
* @category Indexer Grpc Transformer
*/
var IndexerGrpcArchiverTransformer = class IndexerGrpcArchiverTransformer {
	static grpcHistoricalBalanceToHistoricalBalance(historicalBalance) {
		return {
			t: historicalBalance.t,
			v: historicalBalance.v
		};
	}
	static grpcHistoricalRPNLToHistoricalRPNL(historicalRPNL) {
		return {
			t: historicalRPNL.t,
			v: historicalRPNL.v
		};
	}
	static grpcHistoricalVolumesToHistoricalVolumes(historicalVolumes) {
		return {
			t: historicalVolumes.t,
			v: historicalVolumes.v
		};
	}
	static grpcLeaderboardRowToLeaderboardRow(leaderboardRow) {
		return {
			account: leaderboardRow.account,
			pnl: leaderboardRow.pnl,
			volume: leaderboardRow.volume,
			rank: leaderboardRow.rank
		};
	}
	static grpcHistoricalBalanceResponseToHistoricalBalances(response) {
		if (!response.historicalBalance) return {
			t: [],
			v: []
		};
		return IndexerGrpcArchiverTransformer.grpcHistoricalBalanceToHistoricalBalance(response.historicalBalance);
	}
	static grpcHistoricalRPNLResponseToHistoricalRPNL(response) {
		if (!response.historicalRpnl) return {
			t: [],
			v: []
		};
		return IndexerGrpcArchiverTransformer.grpcHistoricalRPNLToHistoricalRPNL(response.historicalRpnl);
	}
	static grpcHistoricalVolumesResponseToHistoricalVolumes(response) {
		if (!response.historicalVolumes) return {
			t: [],
			v: []
		};
		return IndexerGrpcArchiverTransformer.grpcHistoricalVolumesToHistoricalVolumes(response.historicalVolumes);
	}
	static grpcPnlLeaderboardResponseToPnlLeaderboard(response) {
		return {
			firstDate: response.firstDate,
			lastDate: response.lastDate,
			leaders: response.leaders.map(IndexerGrpcArchiverTransformer.grpcLeaderboardRowToLeaderboardRow),
			accountRow: response.accountRow ? IndexerGrpcArchiverTransformer.grpcLeaderboardRowToLeaderboardRow(response.accountRow) : void 0
		};
	}
	static grpcVolLeaderboardResponseToVolLeaderboard(response) {
		return {
			firstDate: response.firstDate,
			lastDate: response.lastDate,
			leaders: response.leaders.map(IndexerGrpcArchiverTransformer.grpcLeaderboardRowToLeaderboardRow),
			accountRow: response.accountRow ? IndexerGrpcArchiverTransformer.grpcLeaderboardRowToLeaderboardRow(response.accountRow) : void 0
		};
	}
	static grpcPnlLeaderboardFixedResolutionResponseToPnlLeaderboard(response) {
		return {
			firstDate: response.firstDate,
			lastDate: response.lastDate,
			leaders: response.leaders.map(IndexerGrpcArchiverTransformer.grpcLeaderboardRowToLeaderboardRow),
			accountRow: response.accountRow ? IndexerGrpcArchiverTransformer.grpcLeaderboardRowToLeaderboardRow(response.accountRow) : void 0
		};
	}
	static grpcVolLeaderboardFixedResolutionResponseToVolLeaderboard(response) {
		return {
			firstDate: response.firstDate,
			lastDate: response.lastDate,
			leaders: response.leaders.map(IndexerGrpcArchiverTransformer.grpcLeaderboardRowToLeaderboardRow),
			accountRow: response.accountRow ? IndexerGrpcArchiverTransformer.grpcLeaderboardRowToLeaderboardRow(response.accountRow) : void 0
		};
	}
	static grpcDenomHoldersResponseToDenomHolders(response) {
		return {
			holders: response.holders.map((holder) => ({
				accountAddress: holder.accountAddress,
				balance: holder.balance
			})),
			next: response.next,
			total: response.total
		};
	}
	static grpcAccountStatsResponseToAccountStats(response) {
		return {
			pnl: response.pnl,
			stake: response.stake,
			volume: response.volume
		};
	}
	static grpcSpotAverageEntryToSpotAverageEntry(averageEntry) {
		return {
			marketId: averageEntry.marketId,
			averageEntryPrice: averageEntry.averageEntryPrice,
			quantity: averageEntry.quantity,
			usdValue: averageEntry.usdValue
		};
	}
};

//#endregion
//#region src/client/indexer/transformers/IndexerGrpcExplorerTransformer.ts
const ZERO_IN_BASE$1 = (0, __injectivelabs_utils.toBigNumber)(0);
const getContractTransactionV2Amount = (ApiTransaction) => {
	const { type, value } = JSON.parse(require_utils.uint8ArrayToString(ApiTransaction.messages))[0];
	const { msg } = value;
	if (!type.includes("MsgExecuteContract")) return ZERO_IN_BASE$1;
	if (typeof msg === "string" && !require_utils.isJsonString(msg)) return ZERO_IN_BASE$1;
	const msgObj = typeof msg === "string" ? JSON.parse(msg) : msg;
	if (!msgObj.transfer) return ZERO_IN_BASE$1;
	return (0, __injectivelabs_utils.toHumanReadable)(msgObj.transfer.amount);
};
const parseStringToObjectLikeNoThrow = (object, defaultValue = []) => {
	if (!object) return defaultValue;
	if (typeof object === "string") try {
		return JSON.parse(object);
	} catch (_unused) {
		return defaultValue;
	}
	try {
		return JSON.parse(require_utils.uint8ArrayToString(object));
	} catch (_unused2) {
		return defaultValue;
	}
};
const transactionV2MessagesToMessagesNoThrow = (messages) => {
	return parseStringToObjectLikeNoThrow(messages).filter((msg) => !!msg).map((msg) => ({
		type: msg.type,
		message: msg.value
	}));
};
/**
* @category Indexer Grpc Transformer
*/
var IndexerGrpcExplorerTransformer = class IndexerGrpcExplorerTransformer {
	static getTxByTxHashResponseToTx(tx) {
		return IndexerGrpcExplorerTransformer.grpcTransactionToTransaction(tx);
	}
	static getAccountTxsResponseToAccountTxs(response) {
		const txs = response.data;
		const pagination = response.paging;
		return {
			txs: IndexerGrpcExplorerTransformer.grpcTransactionsToTransactionsFromDetail(txs),
			pagination: require_utils.grpcPagingToPagingV2(pagination)
		};
	}
	static getValidatorUptimeResponseToValidatorUptime(response) {
		return response.data.map((field) => IndexerGrpcExplorerTransformer.grpcValidatorUptimeToValidatorUptime(field));
	}
	static getPeggyDepositTxsResponseToPeggyDepositTxs(response) {
		return response.field.map((field) => IndexerGrpcExplorerTransformer.grpcPeggyDepositTx(field));
	}
	static getPeggyWithdrawalTxsResponseToPeggyWithdrawalTxs(response) {
		return response.field.map((field) => IndexerGrpcExplorerTransformer.grpcPeggyWithdrawalTx(field));
	}
	static getIBCTransferTxsResponseToIBCTransferTxs(response) {
		return response.field.map((field) => IndexerGrpcExplorerTransformer.grpcIBCTransferTxToIBCTransferTx(field));
	}
	static validatorResponseToValidator(validator) {
		const data = validator.data;
		return {
			id: data.id,
			moniker: data.moniker,
			operatorAddress: data.operatorAddress,
			consensusAddress: data.consensusAddress,
			jailed: data.jailed,
			status: data.status,
			tokens: data.tokens,
			delegatorShares: data.delegatorShares,
			description: IndexerGrpcExplorerTransformer.grpcValidatorDescriptionToValidatorDescription(data.description),
			unbondingHeight: require_utils.bigIntToNumber(data.unbondingHeight),
			unbondingTime: data.unbondingTime,
			commissionRate: data.commissionRate,
			commissionMaxRate: data.commissionMaxRate,
			commissionMaxChangeRate: data.commissionMaxChangeRate,
			commissionUpdateTime: data.commissionUpdateTime,
			signed: require_utils.bigIntToNumber(data.signed),
			missed: require_utils.bigIntToNumber(data.missed),
			proposed: require_utils.bigIntToNumber(data.proposed),
			uptimePercentage: data.uptimePercentage,
			imageUrl: data.imageUrl,
			timestamp: data.timestamp,
			uptimesList: data.uptimes.map(IndexerGrpcExplorerTransformer.grpcValidatorUptimeToValidatorUptime),
			slashingEventsList: data.slashingEvents.map(IndexerGrpcExplorerTransformer.grpcValidatorSlashingEventToValidatorSlashingEvent)
		};
	}
	static streamTxResponseToTxs(response) {
		return {
			id: response.id,
			hash: response.hash,
			code: response.code,
			messages: response.messages,
			errorLog: response.errorLog,
			codespace: response.codespace,
			blockTimestamp: response.blockTimestamp,
			txNumber: require_utils.bigIntToNumber(response.txNumber),
			blockNumber: require_utils.bigIntToNumber(response.blockNumber)
		};
	}
	static grpcGasFeeToGasFee(gasFee) {
		return {
			amounts: gasFee.amount.map((amount) => ({
				amount: amount.amount,
				denom: amount.denom
			})),
			payer: gasFee.payer,
			granter: gasFee.granter,
			gasLimit: require_utils.bigIntToNumber(gasFee.gasLimit)
		};
	}
	static grpcTransactionToBankMsgSendTransaction(tx) {
		const data = tx.data;
		const [message] = JSON.parse(require_utils.uint8ArrayToString(data.messages));
		return {
			hash: data.hash,
			sender: message.value.from_address,
			receiver: message.value.to_address,
			blockTimestamp: data.blockTimestamp,
			denom: message.value.amount[0].denom,
			amount: message.value.amount[0].amount,
			blockNumber: require_utils.bigIntToNumber(data.blockNumber)
		};
	}
	static grpcTransactionToTransaction(tx) {
		const data = tx.data;
		return {
			id: data.id,
			hash: data.hash,
			code: data.code,
			info: data.info,
			data: data.data,
			txType: data.txType,
			codespace: data.codespace,
			blockTimestamp: data.blockTimestamp,
			gasUsed: require_utils.bigIntToNumber(data.gasUsed),
			gasWanted: require_utils.bigIntToNumber(data.gasWanted),
			blockNumber: require_utils.bigIntToNumber(data.blockNumber),
			gasFee: IndexerGrpcExplorerTransformer.grpcGasFeeToGasFee(data.gasFee),
			signatures: data.signatures.map((signature) => ({
				pubkey: signature.pubkey,
				address: signature.address,
				sequence: require_utils.bigIntToNumber(signature.sequence),
				signature: signature.signature
			})),
			events: data.events.map((event) => ({
				type: event.type,
				attributes: event.attributes
			})),
			messages: JSON.parse(require_utils.uint8ArrayToString(data.messages))
		};
	}
	static grpcTransactionsToTransactions(txs) {
		return txs.map((tx) => IndexerGrpcExplorerTransformer.grpcTransactionToTransaction(tx));
	}
	static grpcTransactionToTransactionFromDetail(tx) {
		const messages = JSON.parse(require_utils.uint8ArrayToString(tx.messages));
		return {
			...tx,
			gasUsed: require_utils.bigIntToNumber(tx.gasUsed),
			gasWanted: require_utils.bigIntToNumber(tx.gasWanted),
			blockNumber: require_utils.bigIntToNumber(tx.blockNumber),
			signatures: tx.signatures.map((signature) => ({
				pubkey: signature.pubkey,
				address: signature.address,
				signature: signature.signature,
				sequence: require_utils.bigIntToNumber(signature.sequence)
			})),
			gasFee: tx.gasFee ? IndexerGrpcExplorerTransformer.grpcGasFeeToGasFee(tx.gasFee) : {
				gasLimit: 0,
				payer: "",
				granter: "",
				amounts: []
			},
			events: tx.events.map((event) => ({
				type: event.type,
				attributes: event.attributes
			})),
			messages
		};
	}
	static grpcTransactionsToTransactionsFromDetail(txs) {
		return txs.map(IndexerGrpcExplorerTransformer.grpcTransactionToTransactionFromDetail);
	}
	static grpcBlockToBlock(block) {
		return {
			moniker: block.moniker,
			proposer: block.proposer,
			blockHash: block.blockHash,
			timestamp: block.timestamp,
			parentHash: block.parentHash,
			height: require_utils.bigIntToNumber(block.height),
			numTxs: require_utils.bigIntToNumber(block.numTxs),
			numPreCommits: require_utils.bigIntToNumber(block.numPreCommits)
		};
	}
	static grpcBlockToBlockWithTxs(block) {
		return {
			moniker: block.moniker,
			proposer: block.proposer,
			blockHash: block.blockHash,
			timestamp: block.timestamp,
			parentHash: block.parentHash,
			height: require_utils.bigIntToNumber(block.height),
			numTxs: require_utils.bigIntToNumber(block.numTxs),
			numPreCommits: require_utils.bigIntToNumber(block.numPreCommits)
		};
	}
	static grpcBlocksToBlocks(blocks) {
		return blocks.map((block) => IndexerGrpcExplorerTransformer.grpcBlockToBlock(block));
	}
	static grpcBlocksToBlocksWithTxs(blocks) {
		return blocks.map((block) => IndexerGrpcExplorerTransformer.grpcBlockToBlockWithTxs(block));
	}
	static grpcValidatorDescriptionToValidatorDescription(validatorDescription) {
		return {
			moniker: validatorDescription.moniker,
			identity: validatorDescription.identity,
			website: validatorDescription.website,
			securityContact: validatorDescription.securityContact,
			details: validatorDescription.details
		};
	}
	static grpcValidatorUptimeToValidatorUptime(validatorUptime) {
		return {
			status: validatorUptime.status,
			blockNumber: require_utils.bigIntToNumber(validatorUptime.blockNumber)
		};
	}
	static grpcValidatorSlashingEventToValidatorSlashingEvent(validatorUptime) {
		return {
			reason: validatorUptime.reason,
			jailed: validatorUptime.jailed,
			address: validatorUptime.address,
			power: require_utils.bigIntToNumber(validatorUptime.power),
			blockTimestamp: validatorUptime.blockTimestamp,
			blockNumber: require_utils.bigIntToNumber(validatorUptime.blockNumber),
			missedBlocks: require_utils.bigIntToNumber(validatorUptime.missedBlocks)
		};
	}
	static grpcIBCTransferTxToIBCTransferTx(grpcIBCTransferTx) {
		return {
			denom: grpcIBCTransferTx.denom,
			state: grpcIBCTransferTx.state,
			sender: grpcIBCTransferTx.sender,
			amount: grpcIBCTransferTx.amount,
			dataHex: grpcIBCTransferTx.dataHex,
			receiver: grpcIBCTransferTx.receiver,
			createdAt: grpcIBCTransferTx.createdAt,
			updatedAt: grpcIBCTransferTx.updatedAt,
			sourcePort: grpcIBCTransferTx.sourcePort,
			txHashesList: grpcIBCTransferTx.txHashes,
			sourceChannel: grpcIBCTransferTx.sourceChannel,
			timeoutHeight: grpcIBCTransferTx.timeoutHeight,
			destinationPort: grpcIBCTransferTx.destinationPort,
			destinationChannel: grpcIBCTransferTx.destinationChannel,
			packetSequence: require_utils.bigIntToNumber(grpcIBCTransferTx.packetSequence),
			timeoutTimestamp: require_utils.bigIntToNumber(grpcIBCTransferTx.timeoutTimestamp)
		};
	}
	static grpcPeggyDepositTx(grpcPeggyDepositTx) {
		return {
			denom: grpcPeggyDepositTx.denom,
			state: grpcPeggyDepositTx.state,
			sender: grpcPeggyDepositTx.sender,
			amount: grpcPeggyDepositTx.amount,
			receiver: grpcPeggyDepositTx.receiver,
			claimType: grpcPeggyDepositTx.claimType,
			createdAt: grpcPeggyDepositTx.createdAt,
			updatedAt: grpcPeggyDepositTx.updatedAt,
			txHashesList: grpcPeggyDepositTx.txHashes,
			eventNonce: require_utils.bigIntToNumber(grpcPeggyDepositTx.eventNonce),
			eventHeight: require_utils.bigIntToNumber(grpcPeggyDepositTx.eventHeight),
			orchestratorAddress: grpcPeggyDepositTx.orchestratorAddress
		};
	}
	static grpcPeggyWithdrawalTx(grpcPeggyWithdrawalTx) {
		return {
			denom: grpcPeggyWithdrawalTx.denom,
			state: grpcPeggyWithdrawalTx.state,
			sender: grpcPeggyWithdrawalTx.sender,
			amount: grpcPeggyWithdrawalTx.amount,
			receiver: grpcPeggyWithdrawalTx.receiver,
			bridgeFee: grpcPeggyWithdrawalTx.bridgeFee,
			claimType: grpcPeggyWithdrawalTx.claimType,
			createdAt: grpcPeggyWithdrawalTx.createdAt,
			updatedAt: grpcPeggyWithdrawalTx.updatedAt,
			txHashesList: grpcPeggyWithdrawalTx.txHashes,
			batchNonce: require_utils.bigIntToNumber(grpcPeggyWithdrawalTx.batchNonce),
			eventNonce: require_utils.bigIntToNumber(grpcPeggyWithdrawalTx.eventNonce),
			eventHeight: require_utils.bigIntToNumber(grpcPeggyWithdrawalTx.eventHeight),
			orchestratorAddress: grpcPeggyWithdrawalTx.orchestratorAddress,
			outgoingTxId: require_utils.bigIntToNumber(grpcPeggyWithdrawalTx.outgoingTxId),
			batchTimeout: require_utils.bigIntToNumber(grpcPeggyWithdrawalTx.batchTimeout)
		};
	}
	static getExplorerStatsResponseToExplorerStats(response) {
		return {
			assets: require_utils.bigIntToString(response.assets),
			txsTotal: require_utils.bigIntToString(response.txsTotal),
			addresses: require_utils.bigIntToString(response.addresses),
			injSupply: require_utils.bigIntToString(response.injSupply),
			txsInPast30Days: require_utils.bigIntToString(response.txs30D),
			txsInPast24Hours: require_utils.bigIntToString(response.txs24H),
			txsPerSecondInPast24Hours: require_utils.bigIntToString(response.txsPs24H),
			blockCountInPast24Hours: require_utils.bigIntToString(response.blockCount24H),
			txsPerSecondInPast100Blocks: require_utils.bigIntToString(response.txsPs100B)
		};
	}
	static getTxsV2ResponseToTxs(response) {
		return {
			data: response.data.map((tx) => IndexerGrpcExplorerTransformer.grpcTxV2ToTransaction(tx)),
			paging: response.paging
		};
	}
	static grpcTxV2ToTransaction(tx) {
		const logs = parseStringToObjectLikeNoThrow(tx.logs);
		const txType = parseStringToObjectLikeNoThrow(tx.txMsgTypes);
		const messages = transactionV2MessagesToMessagesNoThrow(tx.messages);
		const signatures = tx.signatures.map((signature) => ({
			address: signature.address,
			pubkey: signature.pubkey,
			signature: signature.signature,
			sequence: (() => {
				try {
					return require_utils.bigIntToNumber(signature.sequence);
				} catch (_unused3) {
					return 0;
				}
			})()
		}));
		const claimIds = tx.claimIds.map((claimId) => {
			try {
				return require_utils.bigIntToNumber(claimId);
			} catch (_unused4) {
				return 0;
			}
		});
		const blockNumber = require_utils.bigIntToNumber(tx.blockNumber);
		return {
			logs,
			info: "",
			memo: "",
			claimIds,
			messages,
			id: tx.id,
			signatures,
			blockNumber,
			gasUsed: 0,
			gasWanted: 0,
			hash: tx.hash,
			code: tx.code,
			errorLog: tx.errorLog,
			codespace: tx.codespace,
			blockTimestamp: tx.blockTimestamp,
			txType: Array.isArray(txType) ? txType.join(",") : txType,
			gasFee: {
				amounts: [],
				gasLimit: 0,
				granter: "",
				payer: ""
			}
		};
	}
	static getAccountTxsV2ResponseToAccountTxs(response) {
		return {
			data: response.data.map((tx) => IndexerGrpcExplorerTransformer.grpcAccountTxV2ToTransaction(tx)),
			paging: response.paging
		};
	}
	static grpcAccountTxV2ToTransaction(tx) {
		var _tx$gasFee, _tx$gasFee2, _tx$gasFee$granter, _tx$gasFee3, _tx$gasFee$payer, _tx$gasFee4;
		return {
			id: tx.id,
			hash: tx.hash,
			code: tx.code,
			info: tx.info,
			memo: tx.memo,
			txType: tx.txType,
			gasFee: {
				amounts: (((_tx$gasFee = tx.gasFee) === null || _tx$gasFee === void 0 ? void 0 : _tx$gasFee.amount) || []).map((amount) => ({
					amount: amount.amount,
					denom: amount.denom
				})),
				gasLimit: require_utils.bigIntToNumber((_tx$gasFee2 = tx.gasFee) === null || _tx$gasFee2 === void 0 ? void 0 : _tx$gasFee2.gasLimit),
				granter: (_tx$gasFee$granter = (_tx$gasFee3 = tx.gasFee) === null || _tx$gasFee3 === void 0 ? void 0 : _tx$gasFee3.granter) !== null && _tx$gasFee$granter !== void 0 ? _tx$gasFee$granter : "",
				payer: (_tx$gasFee$payer = (_tx$gasFee4 = tx.gasFee) === null || _tx$gasFee4 === void 0 ? void 0 : _tx$gasFee4.payer) !== null && _tx$gasFee$payer !== void 0 ? _tx$gasFee$payer : ""
			},
			events: tx.events,
			errorLog: tx.errorLog,
			codespace: tx.codespace,
			gasUsed: require_utils.bigIntToNumber(tx.gasUsed),
			blockTimestamp: tx.blockTimestamp,
			gasWanted: require_utils.bigIntToNumber(tx.gasWanted),
			blockNumber: require_utils.bigIntToNumber(tx.blockNumber),
			signatures: tx.signatures.map((signature) => ({
				address: signature.address,
				pubkey: signature.pubkey,
				signature: signature.signature,
				sequence: require_utils.bigIntToNumber(signature.sequence)
			})),
			messages: transactionV2MessagesToMessagesNoThrow(tx.messages),
			logs: parseStringToObjectLikeNoThrow(tx.logs),
			data: "/" + require_utils.uint8ArrayToString(tx.data).split("/").pop(),
			claimIds: tx.claimIds.map((claimId) => require_utils.bigIntToNumber(claimId))
		};
	}
	static getBlocksV2ResponseToBlocks(response) {
		return {
			paging: response.paging,
			data: response.data.map((block) => IndexerGrpcExplorerTransformer.grpcBlockV2ToBlock(block))
		};
	}
	static grpcBlockV2ToBlock(block) {
		return {
			moniker: block.moniker,
			proposer: block.proposer,
			blockHash: block.blockHash,
			timestamp: block.timestamp,
			parentHash: block.parentHash,
			height: require_utils.bigIntToNumber(block.height),
			numTxs: require_utils.bigIntToNumber(block.numTxs),
			numPreCommits: require_utils.bigIntToNumber(block.numPreCommits)
		};
	}
	static getContractTxsV2ResponseToContractTxs(response) {
		return {
			data: response.data.map((tx) => IndexerGrpcExplorerTransformer.grpcContractTxV2ToTransaction(tx)),
			paging: response.paging
		};
	}
	static grpcContractTxV2ToTransaction(tx) {
		var _tx$gasFee5;
		return {
			messages: transactionV2MessagesToMessagesNoThrow(tx.messages),
			code: tx.code,
			memo: tx.memo,
			type: tx.txType,
			txHash: tx.hash,
			error_log: tx.errorLog,
			height: require_utils.bigIntToNumber(tx.blockNumber),
			tx_number: require_utils.bigIntToNumber(tx.txNumber),
			time: require_utils.bigIntToNumber(tx.blockUnixTimestamp),
			amount: getContractTransactionV2Amount(tx),
			logs: JSON.parse(require_utils.uint8ArrayToString(tx.logs)),
			data: "/" + require_utils.uint8ArrayToString(tx.data).split("/").pop(),
			fee: (0, __injectivelabs_utils.toHumanReadable)(((_tx$gasFee5 = tx.gasFee) === null || _tx$gasFee5 === void 0 || (_tx$gasFee5 = _tx$gasFee5.amount[0]) === null || _tx$gasFee5 === void 0 ? void 0 : _tx$gasFee5.amount) || "0"),
			signatures: tx.signatures.map((signature) => ({
				address: signature.address,
				pubkey: signature.pubkey,
				signature: signature.signature,
				sequence: require_utils.bigIntToNumber(signature.sequence)
			}))
		};
	}
};

//#endregion
//#region src/client/indexer/transformers/IndexerGrpcReferralTransformer.ts
var IndexerGrpcReferralTransformer = class {
	static referrerDetailsResponseToReferrerDetails(address, response) {
		return {
			referrerAddress: address,
			invitees: response.invitees,
			referrerCode: response.referrerCode,
			totalCommission: (0, __injectivelabs_utils.toBigNumber)(response.totalCommission),
			totalTradingVolume: (0, __injectivelabs_utils.toBigNumber)(response.totalTradingVolume)
		};
	}
	static inviteeDetailsResponseToInviteeDetails(response) {
		return response;
	}
	static referrerByCodeResponseToReferrerByCode(response) {
		return (response === null || response === void 0 ? void 0 : response.referrerAddress) || "";
	}
};

//#endregion
//#region src/client/indexer/transformers/IndexerOracleStreamTransformer.ts
/**
* @category Indexer Stream Transformer
*/
var IndexerOracleStreamTransformer = class {};
require_defineProperty._defineProperty(IndexerOracleStreamTransformer, "pricesStreamCallback", (response) => ({
	price: response.price,
	timestamp: require_utils.bigIntToNumber(response.timestamp),
	operation: require_types.StreamOperation.Update
}));
require_defineProperty._defineProperty(IndexerOracleStreamTransformer, "pricesByMarketsCallback", (response) => ({ ...response }));

//#endregion
//#region src/client/indexer/transformers/IndexerRestExplorerTransformer.ts
const ZERO_IN_BASE = (0, __injectivelabs_utils.toBigNumber)(0);
const getContractTransactionAmount = (ApiTransaction) => {
	const { type, value: { msg } } = ApiTransaction.messages[0];
	if (!type.includes("MsgExecuteContract")) return ZERO_IN_BASE;
	if (typeof msg === "string" && !require_utils.isJsonString(msg)) return ZERO_IN_BASE;
	const msgObj = typeof msg === "string" ? JSON.parse(msg) : msg;
	if (!msgObj.transfer) return ZERO_IN_BASE;
	return (0, __injectivelabs_utils.toHumanReadable)(msgObj.transfer.amount);
};
const parseCW20Message = (jsonObject) => {
	if (!jsonObject) return;
	return JSON.parse(jsonObject);
};
/**
* @category Indexer Rest Transformer
*/
var IndexerRestExplorerTransformer = class IndexerRestExplorerTransformer {
	static blockToBlock(block) {
		return {
			height: block.height,
			proposer: block.proposer,
			moniker: block.moniker,
			blockHash: block.block_hash,
			parentHash: block.parent_hash,
			numPreCommits: block.num_pre_commits,
			numTxs: block.num_txs,
			timestamp: block.timestamp
		};
	}
	static blocksToBlocks(blocks) {
		return blocks.map(IndexerRestExplorerTransformer.blockToBlock);
	}
	static transactionToTransaction(transaction) {
		var _transaction$gas_fee, _transaction$gas_fee2, _transaction$gas_fee3, _transaction$gas_fee4;
		return {
			id: transaction.id,
			blockNumber: transaction.block_number,
			blockTimestamp: transaction.block_timestamp,
			hash: transaction.hash,
			code: transaction.code,
			info: transaction.info,
			memo: transaction.memo || "",
			gasWanted: transaction.gas_wanted,
			gasFee: {
				amounts: (_transaction$gas_fee = transaction.gas_fee) === null || _transaction$gas_fee === void 0 ? void 0 : _transaction$gas_fee.amount,
				gasLimit: (_transaction$gas_fee2 = transaction.gas_fee) === null || _transaction$gas_fee2 === void 0 ? void 0 : _transaction$gas_fee2.gas_limit,
				payer: (_transaction$gas_fee3 = transaction.gas_fee) === null || _transaction$gas_fee3 === void 0 ? void 0 : _transaction$gas_fee3.payer,
				granter: (_transaction$gas_fee4 = transaction.gas_fee) === null || _transaction$gas_fee4 === void 0 ? void 0 : _transaction$gas_fee4.granter
			},
			gasUsed: transaction.gas_used,
			codespace: transaction.codespace,
			signatures: transaction.signatures,
			txType: transaction.tx_type,
			data: transaction.data,
			events: transaction.events || [],
			messages: (transaction.messages || []).filter((m) => m).map((message) => ({
				type: message.type,
				message: message.value
			})),
			logs: transaction.logs,
			errorLog: transaction.error_log,
			claimIds: transaction.claim_id || []
		};
	}
	static transactionsToTransactions(transactions) {
		return transactions.map(IndexerRestExplorerTransformer.transactionToTransaction);
	}
	static blockWithTxToBlockWithTx(block) {
		return {
			height: block.height,
			proposer: block.proposer,
			moniker: block.moniker,
			blockHash: block.block_hash,
			parentHash: block.parent_hash,
			numPreCommits: block.num_pre_commits,
			numTxs: block.num_txs,
			timestamp: block.timestamp,
			txs: block.txs ? IndexerRestExplorerTransformer.transactionsToTransactions(block.txs) : []
		};
	}
	static blocksWithTxsToBlocksWithTxs(blocks) {
		return blocks.map(IndexerRestExplorerTransformer.blockWithTxToBlockWithTx);
	}
	static baseTransactionToTransaction(transaction) {
		return {
			...transaction,
			messages: (transaction.messages || []).filter((m) => m).map((message) => ({
				type: message.type,
				message: message.value
			})),
			memo: transaction.memo || ""
		};
	}
	static validatorExplorerToValidator(validators) {
		return validators.map((validator) => {
			return {
				id: validator.id,
				moniker: validator.moniker,
				consensusAddress: validator.consensus_address,
				operatorAddress: validator.operator_address,
				proposed: validator.proposed,
				signed: validator.signed,
				missed: validator.missed,
				uptimePercentage: validator.uptime_percentage,
				imageUrl: validator.imageURL
			};
		});
	}
	static validatorUptimeToExplorerValidatorUptime(validatorUptimeList) {
		return validatorUptimeList.map((validatorUptime) => ({
			blockNumber: validatorUptime.block_number,
			status: validatorUptime.status
		}));
	}
	static contractToExplorerContract(contract) {
		return {
			label: contract.label,
			address: contract.address,
			txHash: contract.tx_hash,
			creator: contract.creator,
			executes: contract.executes,
			instantiatedAt: contract.instantiated_at,
			lastExecutedAt: contract.last_executed_at,
			funds: contract.funds,
			codeId: contract.code_id,
			admin: contract.admin,
			cw20_metadata: contract.cw20_metadata,
			initMessage: parseCW20Message(contract.init_message),
			currentMigrateMessage: parseCW20Message(contract.current_migrate_message)
		};
	}
	static contractTransactionToExplorerContractTransaction(transaction) {
		return {
			txHash: transaction.hash,
			code: transaction.code,
			data: transaction.data,
			memo: transaction.memo,
			tx_number: transaction.tx_number,
			error_log: transaction.error_log,
			height: transaction.block_number,
			time: transaction.block_unix_timestamp,
			type: transaction.messages[0].type,
			logs: transaction.logs,
			signatures: transaction.signatures,
			messages: (transaction.messages || []).filter((m) => m).map((message) => ({
				type: message.type,
				message: message.value
			})),
			fee: transaction.gas_fee.amount ? (0, __injectivelabs_utils.toHumanReadable)(transaction.gas_fee.amount[0].amount) : ZERO_IN_BASE,
			amount: getContractTransactionAmount(transaction)
		};
	}
	static contractTransactionToExplorerContractTransactionWithMessages(transaction) {
		return {
			...IndexerRestExplorerTransformer.contractTransactionToExplorerContractTransaction(transaction),
			messages: (transaction.messages || []).map((message) => {
				if (!require_utils.isJsonString(message.value.msg)) return {
					type: message.type,
					value: {
						...message.value,
						msg: message.value.msg
					}
				};
				const msg = message.value.msg;
				return {
					type: message.type,
					value: {
						...message.value,
						msg: JSON.parse(msg)
					}
				};
			})
		};
	}
	static wasmCodeToExplorerWasmCode(wasmCode) {
		return {
			id: wasmCode.code_id,
			txHash: wasmCode.tx_hash,
			creator: wasmCode.creator,
			contractType: wasmCode.contract_type,
			version: wasmCode.version,
			instantiates: wasmCode.instantiates,
			creationDate: wasmCode.created_at,
			checksum: wasmCode.checksum,
			permission: wasmCode.permission,
			proposalId: wasmCode.proposal_id
		};
	}
	static CW20BalanceToExplorerCW20Balance(balance) {
		const { marketing_info, token_info: { name, symbol, decimals } } = balance.cw20_metadata || { token_info: {} };
		return {
			contractAddress: balance.contract_address,
			account: balance.account,
			balance: balance.balance,
			updatedAt: balance.updated_at,
			token: {
				address: balance.contract_address,
				denom: balance.contract_address,
				decimals,
				name,
				symbol,
				tokenVerification: require_types.TokenVerification.Internal,
				logo: (marketing_info === null || marketing_info === void 0 ? void 0 : marketing_info.logo) || "",
				coinGeckoId: name,
				tokenType: require_types.TokenType.Cw20
			}
		};
	}
	static bankTransferToBankTransfer(transfer) {
		return {
			sender: transfer.sender,
			recipient: transfer.recipient,
			amounts: transfer.amounts,
			blockNumber: transfer.block_number,
			blockTimestamp: new Date(transfer.block_timestamp).getTime()
		};
	}
	static bankTransfersToBankTransfers(transfers) {
		return transfers.map(IndexerRestExplorerTransformer.bankTransferToBankTransfer);
	}
};

//#endregion
//#region src/client/indexer/transformers/IndexerAccountStreamTransformer.ts
/**
* @category Indexer Stream Transformer
*/
var IndexerAccountStreamTransformer = class {};
require_defineProperty._defineProperty(IndexerAccountStreamTransformer, "balanceStreamCallback", (response) => {
	const balance = response.balance;
	return {
		balance: balance ? IndexerGrpcAccountTransformer.grpcBalanceToBalance(balance) : void 0,
		operation: require_types.StreamOperation.Update,
		timestamp: response.timestamp
	};
});

//#endregion
//#region src/client/indexer/transformers/IndexerAuctionStreamTransformer.ts
/**
* @category Indexer Stream Transformer
*/
var IndexerAuctionStreamTransformer = class {};
require_defineProperty._defineProperty(IndexerAuctionStreamTransformer, "bidsStreamCallback", (response) => ({
	bid: {
		bidder: response.bidder,
		bidAmount: response.bidAmount,
		bidTimestamp: require_utils.bigIntToNumber(response.timestamp)
	},
	operation: require_types.StreamOperation.Insert
}));

//#endregion
//#region src/client/indexer/transformers/IndexerGrpcMegaVaultTransformer.ts
var IndexerGrpcMegaVaultTransformer = class IndexerGrpcMegaVaultTransformer {
	static vaultResponseToVault(response) {
		const vault = response.vault;
		if (!vault) return;
		return {
			admin: vault.admin,
			lpDenom: vault.lpDenom,
			createdAt: vault.createdAt.toString(),
			updatedAt: vault.updatedAt.toString(),
			quoteDenom: vault.quoteDenom,
			contractName: vault.contractName,
			createdHeight: vault.createdHeight.toString(),
			updatedHeight: vault.updatedHeight.toString(),
			contractAddress: vault.contractAddress,
			contractVersion: vault.contractVersion,
			stats: vault.stats ? IndexerGrpcMegaVaultTransformer.grpcVaultStatsToVaultStats(vault.stats) : void 0,
			operators: vault.operators.map(IndexerGrpcMegaVaultTransformer.grpcOperatorToOperator),
			targetApr: vault.targetApr ? IndexerGrpcMegaVaultTransformer.grpcTargetAprToTargetApr(vault.targetApr) : void 0,
			incentives: vault.incentives ? IndexerGrpcMegaVaultTransformer.grpcIncentiveToIncentive(vault.incentives) : void 0
		};
	}
	static userResponseToUser(response) {
		const user = response.user;
		if (!user) return;
		return {
			address: user.address,
			updatedAt: user.updatedAt.toString(),
			updatedHeight: user.updatedHeight.toString(),
			contractAddress: user.contractAddress,
			stats: user.stats ? IndexerGrpcMegaVaultTransformer.grpcUserStatsToUserStats(user.stats) : void 0
		};
	}
	static subscriptionsResponseToSubscriptions(response) {
		return response.subscriptions.map(IndexerGrpcMegaVaultTransformer.grpcSubscriptionToSubscription);
	}
	static redemptionsResponseToRedemptions(response) {
		return response.redemptions.map(IndexerGrpcMegaVaultTransformer.grpcRedemptionToRedemption);
	}
	static operatorRedemptionBucketsResponseToOperatorRedemptionBuckets(response) {
		return response.buckets.map(IndexerGrpcMegaVaultTransformer.grpcOperatorRedemptionBucketToOperatorRedemptionBucket);
	}
	static tvlHistoryResponseToTvlHistory(response) {
		return response.history.map(IndexerGrpcMegaVaultTransformer.grpcHistoricalTVLToHistoricalTVL);
	}
	static pnlHistoryResponseToPnlHistory(response) {
		return response.history.map(IndexerGrpcMegaVaultTransformer.grpcHistoricalPnLToHistoricalPnL);
	}
	static grpcOperatorToOperator(operator) {
		return {
			address: operator.address,
			updatedAt: operator.updatedAt.toString(),
			percentage: operator.percentage,
			totalAmount: operator.totalAmount,
			subaccountId: operator.subaccountId,
			updatedHeight: operator.updatedHeight.toString(),
			totalLiquidAmount: operator.totalLiquidAmount
		};
	}
	static grpcIncentiveToIncentive(incentive) {
		return {
			address: incentive.address,
			amount: incentive.amount,
			updatedAt: incentive.updatedAt.toString(),
			updatedHeight: incentive.updatedHeight.toString()
		};
	}
	static grpcTargetAprToTargetApr(targetApr) {
		return {
			apr: targetApr.apr,
			updatedAt: targetApr.updatedAt.toString(),
			upperThreshold: targetApr.upperThreshold,
			lowerThreshold: targetApr.lowerThreshold,
			updatedHeight: targetApr.updatedHeight.toString()
		};
	}
	static grpcVaultStatsToVaultStats(stats) {
		return {
			currentAmount: stats.currentAmount,
			currentLpPrice: stats.currentLpPrice,
			currentLpAmount: stats.currentLpAmount,
			totalRedeemedAmount: stats.totalRedeemedAmount,
			totalSubscribedAmount: stats.totalSubscribedAmount,
			currentAmountWithoutIncentives: stats.currentAmountWithoutIncentives,
			apr: stats.apr ? IndexerGrpcMegaVaultTransformer.grpcAprStatsToAprStats(stats.apr) : void 0,
			pnl: stats.pnl ? IndexerGrpcMegaVaultTransformer.grpcPnlStatsToPnlStats(stats.pnl) : void 0,
			volatility: stats.volatility ? IndexerGrpcMegaVaultTransformer.grpcVolatilityStatsToVolatilityStats(stats.volatility) : void 0,
			maxDrawdown: stats.maxDrawdown ? IndexerGrpcMegaVaultTransformer.grpcMaxDrawdownToMaxDrawdown(stats.maxDrawdown) : void 0
		};
	}
	static grpcPnlStatsToPnlStats(pnl) {
		return {
			allTime: pnl.allTime ? IndexerGrpcMegaVaultTransformer.grpcPnlToPnl(pnl.allTime) : void 0,
			unrealized: pnl.unrealized ? IndexerGrpcMegaVaultTransformer.grpcUnrealizedPnlToUnrealizedPnl(pnl.unrealized) : void 0
		};
	}
	static grpcUnrealizedPnlToUnrealizedPnl(pnl) {
		return {
			value: pnl.value,
			percentage: pnl.percentage
		};
	}
	static grpcPnlToPnl(pnl) {
		return {
			value: pnl.value,
			percentage: pnl.percentage,
			currentAmount: pnl.currentAmount,
			totalAmountRedeemed: pnl.totalAmountRedeemed,
			totalAmountSubscribed: pnl.totalAmountSubscribed
		};
	}
	static grpcMaxDrawdownToMaxDrawdown(maxDrawdown) {
		return {
			value: maxDrawdown.value,
			latestPnLPeak: maxDrawdown.latestPnLPeak
		};
	}
	static grpcVolatilityStatsToVolatilityStats(volatility) {
		return { thirtyDays: volatility.thirtyDays ? IndexerGrpcMegaVaultTransformer.grpcVolatilityToVolatility(volatility.thirtyDays) : void 0 };
	}
	static grpcVolatilityToVolatility(volatility) {
		return { value: volatility.value };
	}
	static grpcAprStatsToAprStats(apr) {
		return { thirtyDays: apr.thirtyDays ? IndexerGrpcMegaVaultTransformer.grpcAprToApr(apr.thirtyDays) : void 0 };
	}
	static grpcAprToApr(apr) {
		return {
			value: apr.value,
			currentLpPrice: apr.currentLpPrice,
			originalLpPrice: apr.originalLpPrice
		};
	}
	static grpcUserStatsToUserStats(stats) {
		return {
			currentAmount: stats.currentAmount,
			depositedValue: stats.depositedValue,
			currentLpAmount: stats.currentLpAmount,
			pnl: stats.pnl ? IndexerGrpcMegaVaultTransformer.grpcPnlStatsToPnlStats(stats.pnl) : void 0
		};
	}
	static grpcSubscriptionsToSubscriptions(subscriptions) {
		return subscriptions.map(IndexerGrpcMegaVaultTransformer.grpcSubscriptionToSubscription);
	}
	static grpcSubscriptionToSubscription(subscription) {
		return {
			user: subscription.user,
			index: subscription.index.toString(),
			amount: subscription.amount,
			status: subscription.status,
			lpAmount: subscription.lpAmount,
			createdAt: subscription.createdAt.toString(),
			executedAt: subscription.executedAt.toString(),
			createdHeight: subscription.createdHeight.toString(),
			executedHeight: subscription.executedHeight.toString(),
			contractAddress: subscription.contractAddress,
			log: subscription.log.map(IndexerGrpcMegaVaultTransformer.grpcOperationStatusLogEntryToOperationStatusLogEntry)
		};
	}
	static grpcRedemptionToRedemption(redemption) {
		return {
			user: redemption.user,
			dueAt: redemption.dueAt.toString(),
			index: redemption.index.toString(),
			amount: redemption.amount,
			status: redemption.status,
			lpAmount: redemption.lpAmount,
			createdAt: redemption.createdAt.toString(),
			executedAt: redemption.executedAt.toString(),
			createdHeight: redemption.createdHeight.toString(),
			executedHeight: redemption.executedHeight.toString(),
			contractAddress: redemption.contractAddress,
			log: redemption.log.map(IndexerGrpcMegaVaultTransformer.grpcOperationStatusLogEntryToOperationStatusLogEntry)
		};
	}
	static grpcOperatorRedemptionBucketToOperatorRedemptionBucket(bucket) {
		return {
			bucket: bucket.bucket,
			neededAmount: bucket.neededAmount,
			lpAmountToRedeem: bucket.lpAmountToRedeem,
			missingLiquidity: bucket.missingLiquidity
		};
	}
	static grpcHistoricalTVLToHistoricalTVL(history) {
		return {
			t: history.t.toString(),
			v: history.v.toString()
		};
	}
	static grpcHistoricalPnLToHistoricalPnL(history) {
		return {
			t: history.t.toString(),
			v: history.v.toString()
		};
	}
	static grpcOperationStatusLogEntryToOperationStatusLogEntry(log) {
		return {
			status: log.status,
			txHash: log.txHash,
			blockTime: log.blockTime.toString(),
			blockHeight: log.blockHeight.toString()
		};
	}
};

//#endregion
//#region src/client/indexer/transformers/IndexerArchiverStreamTransformer.ts
/**
* @category Indexer Stream Transformer
*/
var IndexerArchiverStreamTransformer = class {};
require_defineProperty._defineProperty(IndexerArchiverStreamTransformer, "spotAverageEntriesStreamCallback", (response) => {
	const averageEntry = response.averageEntry;
	return {
		averageEntry: averageEntry ? IndexerGrpcArchiverTransformer.grpcSpotAverageEntryToSpotAverageEntry(averageEntry) : void 0,
		operation: require_types.StreamOperation.Update,
		timestamp: require_utils.bigIntToNumber(response.timestamp)
	};
});

//#endregion
//#region src/client/indexer/transformers/IndexerExplorerStreamTransformer.ts
/**
* @category Indexer Stream Transformer
*/
var ExplorerStreamTransformer = class {};
require_defineProperty._defineProperty(ExplorerStreamTransformer, "blocksStreamCallback", (response) => ({
	block: IndexerGrpcExplorerTransformer.grpcBlockToBlock(response),
	operation: require_types.StreamOperation.Insert
}));
require_defineProperty._defineProperty(ExplorerStreamTransformer, "blocksWithTxsStreamCallback", (response) => ({
	block: IndexerGrpcExplorerTransformer.grpcBlockToBlockWithTxs(response),
	operation: require_types.StreamOperation.Insert
}));
require_defineProperty._defineProperty(ExplorerStreamTransformer, "transactionsStreamCallback", (response) => ({
	block: IndexerGrpcExplorerTransformer.streamTxResponseToTxs(response),
	operation: require_types.StreamOperation.Insert
}));

//#endregion
//#region src/client/indexer/transformers/IndexerGrpcDerivativeTransformer.ts
const zeroPositionDelta = () => ({
	tradeDirection: require_types.TradeDirection.Buy,
	executionPrice: "0",
	executionQuantity: "0",
	executionMargin: "0"
});
/**
* @category Indexer Grpc Transformer
*/
var IndexerGrpcDerivativeTransformer = class IndexerGrpcDerivativeTransformer {
	static grpcTokenMetaToTokenMeta(tokenMeta) {
		if (!tokenMeta) return;
		return {
			name: tokenMeta.name,
			address: tokenMeta.address,
			symbol: tokenMeta.symbol,
			logo: tokenMeta.logo,
			decimals: tokenMeta.decimals,
			updatedAt: Number(tokenMeta.updatedAt),
			coinGeckoId: "",
			tokenType: require_types.TokenType.Unknown
		};
	}
	static grpcPerpetualMarketInfoToPerpetualMarketInfo(perpetualMarketInfo) {
		if (!perpetualMarketInfo) return;
		return {
			hourlyFundingRateCap: perpetualMarketInfo.hourlyFundingRateCap,
			hourlyInterestRate: perpetualMarketInfo.hourlyInterestRate,
			nextFundingTimestamp: Number(perpetualMarketInfo.nextFundingTimestamp),
			fundingInterval: Number(perpetualMarketInfo.fundingInterval)
		};
	}
	static grpcPerpetualMarketFundingToPerpetualMarketFunding(perpetualMarketFunding) {
		if (!perpetualMarketFunding) return;
		return {
			cumulativeFunding: perpetualMarketFunding.cumulativeFunding,
			cumulativePrice: perpetualMarketFunding.cumulativePrice,
			lastTimestamp: Number(perpetualMarketFunding.lastTimestamp)
		};
	}
	static grpcExpiryFuturesMarketInfoToExpiryFuturesMarketInfo(expiryFuturesMarketInfo) {
		if (!expiryFuturesMarketInfo) return;
		return {
			expirationTimestamp: Number(expiryFuturesMarketInfo.expirationTimestamp),
			settlementPrice: expiryFuturesMarketInfo.settlementPrice
		};
	}
	static marketResponseToMarket(response) {
		const market = response.market;
		return IndexerGrpcDerivativeTransformer.grpcMarketToMarket(market);
	}
	static marketsResponseToMarkets(response) {
		const markets = response.markets;
		return IndexerGrpcDerivativeTransformer.grpcMarketsToMarkets(markets);
	}
	static ordersResponseToOrders(response) {
		const orders = response.orders;
		const pagination = response.paging;
		return {
			orders: IndexerGrpcDerivativeTransformer.grpcOrdersToOrders(orders),
			pagination: require_utils.grpcPagingToPagingV2(pagination)
		};
	}
	static orderHistoryResponseToOrderHistory(response, isConditional) {
		const orderHistory = response.orders;
		const pagination = response.paging;
		return {
			orderHistory: IndexerGrpcDerivativeTransformer.grpcOrderHistoryListToOrderHistoryList(orderHistory, isConditional),
			pagination: require_utils.grpcPagingToPagingV2(pagination)
		};
	}
	static positionsResponseToPositions(response) {
		const positions = response.positions;
		const pagination = response.paging;
		return {
			positions: IndexerGrpcDerivativeTransformer.grpcPositionsToPositions(positions),
			pagination: require_utils.grpcPagingToPagingV2(pagination)
		};
	}
	static positionsV2ResponseToPositionsV2(response) {
		const positions = response.positions;
		const pagination = response.paging;
		return {
			positions: IndexerGrpcDerivativeTransformer.grpcPositionsV2ToPositionsV2(positions),
			pagination: require_utils.grpcPagingToPagingV2(pagination)
		};
	}
	static tradesResponseToTrades(response) {
		const trades = response.trades;
		const pagination = response.paging;
		return {
			trades: IndexerGrpcDerivativeTransformer.grpcTradesToTrades(trades),
			pagination: require_utils.grpcPagingToPagingV2(pagination)
		};
	}
	static subaccountTradesListResponseToSubaccountTradesList(response) {
		const tradesList = response.trades;
		return IndexerGrpcDerivativeTransformer.grpcTradesToTrades(tradesList);
	}
	static fundingPaymentsResponseToFundingPayments(response) {
		const fundingPayments = response.payments;
		const pagination = response.paging;
		return {
			fundingPayments: IndexerGrpcDerivativeTransformer.grpcFundingPaymentsToFundingPayments(fundingPayments),
			pagination: require_utils.grpcPagingToPagingV2(pagination)
		};
	}
	static fundingRatesResponseToFundingRates(response) {
		const fundingRates = response.fundingRates;
		const pagination = response.paging;
		return {
			fundingRates: IndexerGrpcDerivativeTransformer.grpcFundingRatesToFundingRates(fundingRates),
			pagination: require_utils.grpcPagingToPagingV2(pagination)
		};
	}
	static orderbookV2ResponseToOrderbookV2(response) {
		const orderbook = response.orderbook;
		return IndexerGrpcDerivativeTransformer.grpcOrderbookV2ToOrderbookV2({
			sequence: Number(orderbook.sequence),
			buys: (orderbook === null || orderbook === void 0 ? void 0 : orderbook.buys) || [],
			sells: (orderbook === null || orderbook === void 0 ? void 0 : orderbook.sells) || []
		});
	}
	static orderbooksV2ResponseToOrderbooksV2(response) {
		return response.orderbooks.map((o) => {
			const orderbook = o.orderbook;
			return {
				marketId: o.marketId,
				orderbook: IndexerGrpcDerivativeTransformer.grpcOrderbookV2ToOrderbookV2({
					sequence: Number(orderbook.sequence),
					buys: orderbook.buys || [],
					sells: orderbook.sells || []
				})
			};
		});
	}
	static binaryOptionsMarketResponseToBinaryOptionsMarket(response) {
		const market = response.market;
		return IndexerGrpcDerivativeTransformer.grpcBinaryOptionsMarketToBinaryOptionsMarket(market);
	}
	static binaryOptionsMarketResponseWithPaginationToBinaryOptionsMarket(response) {
		const markets = response.markets;
		const pagination = response.paging;
		return {
			markets: IndexerGrpcDerivativeTransformer.grpcBinaryOptionsMarketsToBinaryOptionsMarkets(markets),
			pagination: require_utils.grpcPagingToPagingV2(pagination)
		};
	}
	static binaryOptionsMarketsResponseToBinaryOptionsMarkets(response) {
		const markets = response.markets;
		return IndexerGrpcDerivativeTransformer.grpcBinaryOptionsMarketsToBinaryOptionsMarkets(markets);
	}
	static grpcBinaryOptionsMarketToBinaryOptionsMarket(market) {
		return {
			marketId: market.marketId,
			marketStatus: market.marketStatus,
			ticker: market.ticker,
			oracleSymbol: market.oracleSymbol,
			oracleProvider: market.oracleProvider,
			oracleType: market.oracleType,
			oracleScaleFactor: market.oracleScaleFactor,
			expirationTimestamp: Number(market.expirationTimestamp),
			settlementTimestamp: Number(market.settlementTimestamp),
			quoteDenom: market.quoteDenom,
			quoteToken: IndexerGrpcDerivativeTransformer.grpcTokenMetaToTokenMeta(market.quoteTokenMeta),
			makerFeeRate: market.makerFeeRate,
			takerFeeRate: market.takerFeeRate,
			serviceProviderFee: market.serviceProviderFee,
			minPriceTickSize: new __injectivelabs_utils.BigNumber(market.minPriceTickSize).toNumber(),
			minQuantityTickSize: new __injectivelabs_utils.BigNumber(market.minQuantityTickSize).toNumber(),
			minNotional: new __injectivelabs_utils.BigNumber(market.minNotional).toNumber(),
			settlementPrice: market.settlementPrice
		};
	}
	static grpcBinaryOptionsMarketsToBinaryOptionsMarkets(markets) {
		return markets.map(IndexerGrpcDerivativeTransformer.grpcBinaryOptionsMarketToBinaryOptionsMarket);
	}
	static grpcMarketToMarket(market) {
		return {
			oracleBase: market.oracleBase,
			oracleQuote: market.oracleQuote,
			oracleType: market.oracleType,
			oracleScaleFactor: market.oracleScaleFactor,
			reduceMarginRatio: market.reduceMarginRatio,
			initialMarginRatio: market.initialMarginRatio,
			maintenanceMarginRatio: market.maintenanceMarginRatio,
			isPerpetual: market.isPerpetual,
			marketId: market.marketId,
			marketStatus: market.marketStatus,
			ticker: market.ticker,
			quoteDenom: market.quoteDenom,
			quoteToken: IndexerGrpcDerivativeTransformer.grpcTokenMetaToTokenMeta(market.quoteTokenMeta),
			makerFeeRate: market.makerFeeRate,
			takerFeeRate: market.takerFeeRate,
			serviceProviderFee: market.serviceProviderFee,
			minPriceTickSize: new __injectivelabs_utils.BigNumber(market.minPriceTickSize).toNumber(),
			minQuantityTickSize: new __injectivelabs_utils.BigNumber(market.minQuantityTickSize).toNumber(),
			minNotional: new __injectivelabs_utils.BigNumber(market.minNotional).toNumber(),
			perpetualMarketInfo: IndexerGrpcDerivativeTransformer.grpcPerpetualMarketInfoToPerpetualMarketInfo(market.perpetualMarketInfo),
			perpetualMarketFunding: IndexerGrpcDerivativeTransformer.grpcPerpetualMarketFundingToPerpetualMarketFunding(market.perpetualMarketFunding),
			expiryFuturesMarketInfo: IndexerGrpcDerivativeTransformer.grpcExpiryFuturesMarketInfoToExpiryFuturesMarketInfo(market.expiryFuturesMarketInfo)
		};
	}
	static grpcMarketsToMarkets(markets) {
		return markets.map((market) => IndexerGrpcDerivativeTransformer.grpcMarketToMarket(market));
	}
	static grpcPositionDeltaToPositionDelta(positionDelta) {
		return {
			tradeDirection: positionDelta.tradeDirection,
			executionPrice: positionDelta.executionPrice,
			executionQuantity: positionDelta.executionQuantity,
			executionMargin: positionDelta.executionMargin
		};
	}
	static grpcPriceLevelToPriceLevel(priceLevel) {
		return {
			price: priceLevel.price,
			quantity: priceLevel.quantity,
			timestamp: Number(priceLevel.timestamp)
		};
	}
	static grpcPriceLevelsToPriceLevels(priceLevels) {
		return priceLevels.map((priceLevel) => IndexerGrpcDerivativeTransformer.grpcPriceLevelToPriceLevel(priceLevel));
	}
	static grpcOrderbookToOrderbook({ buys, sells }) {
		return {
			buys: IndexerGrpcDerivativeTransformer.grpcPriceLevelsToPriceLevels(buys),
			sells: IndexerGrpcDerivativeTransformer.grpcPriceLevelsToPriceLevels(sells)
		};
	}
	static grpcOrderbookV2ToOrderbookV2({ sequence, buys, sells }) {
		return {
			sequence,
			buys: IndexerGrpcDerivativeTransformer.grpcPriceLevelsToPriceLevels(buys),
			sells: IndexerGrpcDerivativeTransformer.grpcPriceLevelsToPriceLevels(sells)
		};
	}
	static priceLevelsToGrpcPriceLevels(priceLevels) {
		return priceLevels.map((priceLevel) => ({
			price: priceLevel.price,
			quantity: priceLevel.quantity,
			timestamp: BigInt(priceLevel.timestamp)
		}));
	}
	static grpcOrderToOrder(order) {
		return {
			orderHash: order.orderHash,
			orderSide: order.orderSide,
			marketId: order.marketId,
			cid: order.cid,
			subaccountId: order.subaccountId,
			isReduceOnly: order.isReduceOnly,
			margin: order.margin,
			price: order.price,
			quantity: order.quantity,
			unfilledQuantity: order.unfilledQuantity,
			triggerPrice: order.triggerPrice,
			feeRecipient: order.feeRecipient,
			state: order.state,
			createdAt: Number(order.createdAt),
			updatedAt: Number(order.updatedAt),
			orderNumber: Number(order.orderNumber),
			triggerAt: Number(order.triggerAt),
			orderType: order.orderType,
			isConditional: order.isConditional,
			placedOrderHash: order.placedOrderHash,
			executionType: order.executionType
		};
	}
	static grpcOrdersToOrders(orders) {
		return orders.map((order) => IndexerGrpcDerivativeTransformer.grpcOrderToOrder(order));
	}
	static grpcOrderHistoryToOrderHistory(orderHistory) {
		return {
			orderHash: orderHistory.orderHash,
			marketId: orderHistory.marketId,
			cid: orderHistory.cid,
			isActive: orderHistory.isActive,
			subaccountId: orderHistory.subaccountId,
			executionType: orderHistory.executionType,
			orderType: orderHistory.orderType,
			price: orderHistory.price,
			triggerPrice: orderHistory.triggerPrice,
			quantity: orderHistory.quantity,
			filledQuantity: orderHistory.filledQuantity,
			state: orderHistory.state,
			createdAt: Number(orderHistory.createdAt),
			updatedAt: Number(orderHistory.updatedAt),
			triggerAt: Number(orderHistory.triggerAt),
			isReduceOnly: orderHistory.isReduceOnly,
			direction: orderHistory.direction,
			isConditional: orderHistory.isConditional,
			placedOrderHash: orderHistory.placedOrderHash,
			margin: orderHistory.margin
		};
	}
	static grpcOrderHistoryListToOrderHistoryList(orderHistory, isConditional) {
		return (isConditional ? orderHistory : orderHistory.filter((order) => order.state !== require_types.OrderState.Booked)).map((orderHistory$1) => IndexerGrpcDerivativeTransformer.grpcOrderHistoryToOrderHistory(orderHistory$1));
	}
	static grpcPositionToPosition(position) {
		return {
			marketId: position.marketId,
			subaccountId: position.subaccountId,
			direction: position.direction,
			quantity: position.quantity,
			entryPrice: position.entryPrice,
			margin: position.margin,
			liquidationPrice: position.liquidationPrice,
			aggregateReduceOnlyQuantity: position.aggregateReduceOnlyQuantity,
			markPrice: position.markPrice,
			ticker: position.ticker,
			updatedAt: Number(position.updatedAt)
		};
	}
	static grpcPositionV2ToPositionV2(position) {
		return {
			marketId: position.marketId,
			subaccountId: position.subaccountId,
			direction: position.direction,
			quantity: position.quantity,
			entryPrice: position.entryPrice,
			margin: position.margin,
			denom: position.denom,
			liquidationPrice: position.liquidationPrice,
			markPrice: position.markPrice,
			ticker: position.ticker,
			updatedAt: Number(position.updatedAt),
			fundingSum: position.fundingSum,
			fundingLast: position.fundingLast,
			cumulativeFundingEntry: position.cumulativeFundingEntry,
			effectiveCumulativeFundingEntry: position.effectiveCumulativeFundingEntry
		};
	}
	static grpcPositionsToPositions(positions) {
		return positions.map((position) => IndexerGrpcDerivativeTransformer.grpcPositionToPosition(position));
	}
	static grpcPositionsV2ToPositionsV2(positions) {
		return positions.map((position) => IndexerGrpcDerivativeTransformer.grpcPositionV2ToPositionV2(position));
	}
	static grpcTradeToTrade(trade) {
		const positionDelta = trade.positionDelta;
		const mappedPositionDelta = positionDelta ? IndexerGrpcDerivativeTransformer.grpcPositionDeltaToPositionDelta(positionDelta) : zeroPositionDelta();
		return {
			cid: trade.cid,
			fee: trade.fee,
			pnl: trade.pnl,
			payout: trade.payout,
			tradeId: trade.tradeId,
			marketId: trade.marketId,
			orderHash: trade.orderHash,
			subaccountId: trade.subaccountId,
			feeRecipient: trade.feeRecipient,
			isLiquidation: trade.isLiquidation,
			executedAt: Number(trade.executedAt),
			executionSide: trade.executionSide,
			tradeExecutionType: trade.tradeExecutionType,
			...mappedPositionDelta
		};
	}
	static grpcTradesToTrades(trades) {
		return trades.map((trade) => IndexerGrpcDerivativeTransformer.grpcTradeToTrade(trade));
	}
	static grpcFundingPaymentToFundingPayment(fundingPayment) {
		return {
			marketId: fundingPayment.marketId,
			subaccountId: fundingPayment.subaccountId,
			amount: fundingPayment.amount,
			timestamp: Number(fundingPayment.timestamp)
		};
	}
	static grpcFundingPaymentsToFundingPayments(fundingPayments) {
		return fundingPayments.map(IndexerGrpcDerivativeTransformer.grpcFundingPaymentToFundingPayment);
	}
	static grpcFundingRateToFundingRate(fundingRate) {
		return {
			marketId: fundingRate.marketId,
			rate: fundingRate.rate,
			timestamp: Number(fundingRate.timestamp)
		};
	}
	static grpcFundingRatesToFundingRates(fundingRates) {
		return fundingRates.map(IndexerGrpcDerivativeTransformer.grpcFundingRateToFundingRate);
	}
};

//#endregion
//#region src/client/indexer/transformers/IndexerGrpcMitoStreamTransformer.ts
/**
* @category Indexer Stream Transformer
*/
var IndexerGrpcMitoStreamTransformer = class {};
require_defineProperty._defineProperty(IndexerGrpcMitoStreamTransformer, "transfersStreamCallback", (response) => ({
	transfer: response.data ? IndexerGrpcMitoTransformer.mitoTransferHistoryToTransferHistory(response.data) : void 0,
	opType: response.opType
}));
require_defineProperty._defineProperty(IndexerGrpcMitoStreamTransformer, "vaultStreamCallback", (response) => ({
	vault: response.data ? IndexerGrpcMitoTransformer.mitoVaultToVault(response.data) : void 0,
	opType: response.opType
}));
require_defineProperty._defineProperty(IndexerGrpcMitoStreamTransformer, "vaultHolderSubscriptionStreamCallback", (response) => ({
	subscription: response.data ? IndexerGrpcMitoTransformer.mitoSubscriptionToSubscription(response.data) : void 0,
	opType: response.opType
}));
require_defineProperty._defineProperty(IndexerGrpcMitoStreamTransformer, "stakingRewardByAccountStreamCallback", (response) => ({
	stakingReward: response.data ? IndexerGrpcMitoTransformer.mitoStakingRewardToStakingReward(response.data) : void 0,
	opType: response.opType
}));
require_defineProperty._defineProperty(IndexerGrpcMitoStreamTransformer, "historicalStakingStreamCallback", (response) => ({
	historicalStaking: response.data ? IndexerGrpcMitoTransformer.mitoStakingActivityToStakingActivity(response.data) : void 0,
	opType: response.opType
}));

//#endregion
//#region src/client/indexer/transformers/IndexerAccountPortfolioTransformer.ts
var IndexerGrpcAccountPortfolioTransformer = class IndexerGrpcAccountPortfolioTransformer {
	static accountPortfolioResponseToAccountPortfolio(response, address) {
		const portfolio = response.portfolio;
		const bankBalancesList = (portfolio === null || portfolio === void 0 ? void 0 : portfolio.bankBalances) || [];
		const subaccountList = (portfolio === null || portfolio === void 0 ? void 0 : portfolio.subaccounts) || [];
		const positionsWithUpnlList = (portfolio === null || portfolio === void 0 ? void 0 : portfolio.positionsWithUpnl) || [];
		if (!portfolio) return {
			accountAddress: address || "",
			bankBalancesList: [],
			subaccountsList: [],
			positionsWithUpnlList: []
		};
		return {
			accountAddress: portfolio.accountAddress,
			bankBalancesList: bankBalancesList.map(IndexerCommonTransformer.grpcCoinToCoin),
			subaccountsList: subaccountList.map(IndexerGrpcAccountPortfolioTransformer.grpcSubaccountBalanceToSubaccountBalance),
			positionsWithUpnlList: positionsWithUpnlList.map(IndexerGrpcAccountPortfolioTransformer.grpcPositionWithUPNLToPositionWithUPNL)
		};
	}
	static accountPortfolioBalancesResponseToAccountPortfolioBalances(response, address) {
		const portfolio = response.portfolio;
		const bankBalancesList = (portfolio === null || portfolio === void 0 ? void 0 : portfolio.bankBalances) || [];
		const subaccountList = (portfolio === null || portfolio === void 0 ? void 0 : portfolio.subaccounts) || [];
		if (!portfolio) return {
			accountAddress: address || "",
			bankBalancesList: [],
			subaccountsList: []
		};
		return {
			accountAddress: portfolio.accountAddress,
			bankBalancesList: bankBalancesList.map(IndexerCommonTransformer.grpcCoinToCoin),
			subaccountsList: subaccountList.map(IndexerGrpcAccountPortfolioTransformer.grpcSubaccountBalanceToSubaccountBalance)
		};
	}
	static grpcPositionWithUPNLToPositionWithUPNL(positionsWithUPNL) {
		const grpcPosition = positionsWithUPNL.position;
		return {
			position: grpcPosition ? IndexerGrpcDerivativeTransformer.grpcPositionToPosition(grpcPosition) : void 0,
			unrealizedPnl: positionsWithUPNL.unrealizedPnl
		};
	}
	static grpcSubaccountDepositToSubaccountDeposit(subaccountDeposit) {
		return {
			totalBalance: subaccountDeposit.totalBalance,
			availableBalance: subaccountDeposit.availableBalance
		};
	}
	static grpcSubaccountBalanceToSubaccountBalance(subaccountBalance) {
		const deposit = subaccountBalance.deposit;
		return {
			subaccountId: subaccountBalance.subaccountId,
			denom: subaccountBalance.denom,
			deposit: deposit ? IndexerGrpcAccountPortfolioTransformer.grpcSubaccountDepositToSubaccountDeposit(deposit) : void 0
		};
	}
};

//#endregion
//#region src/client/indexer/transformers/IndexerDerivativeStreamTransformer.ts
/**
* @category Indexer Stream Transformer
*/
var IndexerDerivativeStreamTransformer = class {};
require_defineProperty._defineProperty(IndexerDerivativeStreamTransformer, "tradesStreamCallback", (response) => {
	const trade = response.trade;
	return {
		trade: trade ? IndexerGrpcDerivativeTransformer.grpcTradeToTrade(trade) : void 0,
		operation: response.operationType,
		timestamp: response.timestamp
	};
});
require_defineProperty._defineProperty(IndexerDerivativeStreamTransformer, "positionStreamCallback", (response) => {
	const position = response.position;
	return {
		position: position ? IndexerGrpcDerivativeTransformer.grpcPositionToPosition(position) : void 0,
		timestamp: response.timestamp
	};
});
require_defineProperty._defineProperty(IndexerDerivativeStreamTransformer, "ordersStreamCallback", (response) => {
	const order = response.order;
	return {
		order: order ? IndexerGrpcDerivativeTransformer.grpcOrderToOrder(order) : void 0,
		operation: response.operationType,
		timestamp: response.timestamp
	};
});
require_defineProperty._defineProperty(IndexerDerivativeStreamTransformer, "orderHistoryStreamCallback", (response) => {
	const order = response.order;
	return {
		order: order ? IndexerGrpcDerivativeTransformer.grpcOrderHistoryToOrderHistory(order) : void 0,
		operation: response.operationType,
		timestamp: response.timestamp
	};
});
require_defineProperty._defineProperty(IndexerDerivativeStreamTransformer, "orderbookV2StreamCallback", (response) => {
	const orderbook = response.orderbook;
	return {
		orderbook: orderbook ? IndexerGrpcDerivativeTransformer.grpcOrderbookV2ToOrderbookV2({
			sequence: Number(orderbook.sequence),
			buys: orderbook.buys,
			sells: orderbook.sells
		}) : void 0,
		operation: response.operationType,
		marketId: response.marketId,
		timestamp: response.timestamp
	};
});
require_defineProperty._defineProperty(IndexerDerivativeStreamTransformer, "orderbookUpdateStreamCallback", (response) => {
	const orderbook = response.orderbookLevelUpdates;
	return {
		orderbook: orderbook ? IndexerGrpcDerivativeTransformer.grpcOrderbookV2ToOrderbookV2({
			sequence: Number(orderbook.sequence),
			buys: orderbook.buys,
			sells: orderbook.sells
		}) : void 0,
		operation: response.operationType,
		marketId: response.marketId,
		timestamp: response.timestamp
	};
});
require_defineProperty._defineProperty(IndexerDerivativeStreamTransformer, "positionV2StreamCallback", (response) => {
	const position = response.position;
	return {
		position: position ? IndexerGrpcDerivativeTransformer.grpcPositionV2ToPositionV2(position) : void 0,
		timestamp: response.timestamp
	};
});

//#endregion
//#region src/client/indexer/transformers/IndexerGrpcInsuranceFundTransformer.ts
/**
* @category Indexer Grpc Transformer
*/
var IndexerGrpcInsuranceFundTransformer = class IndexerGrpcInsuranceFundTransformer {
	static insuranceFundsResponseToInsuranceFunds(response) {
		const insuranceFunds = response.funds;
		return IndexerGrpcInsuranceFundTransformer.grpcInsuranceFundsToInsuranceFunds(insuranceFunds);
	}
	static redemptionsResponseToRedemptions(response) {
		const redemptions = response.redemptionSchedules;
		return IndexerGrpcInsuranceFundTransformer.grpcRedemptionsToRedemptions(redemptions);
	}
	static grpcInsuranceFundToInsuranceFund(grpcInsuranceFund) {
		const redemptionNoticePeriodDuration = grpcInsuranceFund.redemptionNoticePeriodDuration;
		const tokenMeta = grpcInsuranceFund.depositTokenMeta;
		return {
			depositDenom: grpcInsuranceFund.depositDenom,
			insurancePoolTokenDenom: grpcInsuranceFund.poolTokenDenom,
			redemptionNoticePeriodDuration: Number(redemptionNoticePeriodDuration || 0n),
			balance: grpcInsuranceFund.balance,
			totalShare: grpcInsuranceFund.totalShare,
			depositTokenMeta: tokenMeta,
			marketId: grpcInsuranceFund.marketId,
			marketTicker: grpcInsuranceFund.marketTicker,
			oracleBase: grpcInsuranceFund.oracleBase,
			oracleQuote: grpcInsuranceFund.oracleQuote,
			oracleType: Number(grpcInsuranceFund.oracleType),
			expiry: Number(grpcInsuranceFund.expiry)
		};
	}
	static grpcInsuranceFundsToInsuranceFunds(grpcInsuranceFunds) {
		return grpcInsuranceFunds.map(IndexerGrpcInsuranceFundTransformer.grpcInsuranceFundToInsuranceFund);
	}
	static grpcRedemptionToRedemption(redemption) {
		return {
			redemptionId: Number(redemption.redemptionId),
			status: redemption.status,
			redeemer: redemption.redeemer,
			claimableRedemptionTime: Number(redemption.claimableRedemptionTime),
			redemptionAmount: redemption.redemptionAmount,
			redemptionDenom: redemption.redemptionDenom,
			requestedAt: Number(redemption.requestedAt),
			disbursedAmount: redemption.disbursedAmount,
			disbursedDenom: redemption.disbursedDenom,
			disbursedAt: Number(redemption.disbursedAt)
		};
	}
	static grpcRedemptionsToRedemptions(redemptions) {
		return redemptions.map(IndexerGrpcInsuranceFundTransformer.grpcRedemptionToRedemption);
	}
};

//#endregion
//#region src/client/indexer/transformers/IndexerAccountPortfolioStreamTransformer.ts
/**
* @category Indexer Stream Transformer
*/
var IndexerAccountPortfolioStreamTransformer = class {};
require_defineProperty._defineProperty(IndexerAccountPortfolioStreamTransformer, "accountPortfolioStreamCallback", (response) => {
	return {
		type: response.type,
		denom: response.denom,
		amount: response.amount,
		subaccountId: response.subaccountId
	};
});

//#endregion
//#region src/client/indexer/grpc/IndexerGrpcMitoApi.ts
/**
* @category Indexer Grpc API
*/
var IndexerGrpcMitoApi = class extends require_BaseIndexerGrpcConsumer.BaseIndexerGrpcConsumer {
	constructor(..._args) {
		super(..._args);
		require_defineProperty._defineProperty(this, "module", require_IndexerGrpcWeb3GwApi.IndexerModule.Mito);
	}
	get client() {
		return this.initClient(__injectivelabs_mito_proto_ts_v2_generated_goadesign_goagen_mito_api_pb_client.MitoAPIClient);
	}
	async fetchVault({ contractAddress, slug }) {
		const request = __injectivelabs_mito_proto_ts_v2_generated_goadesign_goagen_mito_api_pb.GetVaultRequest.create();
		if (slug) request.slug = slug;
		if (contractAddress) request.contractAddress = contractAddress;
		const response = await this.executeGrpcCall(request, this.client.getVault.bind(this.client));
		return IndexerGrpcMitoTransformer.vaultResponseToVault(response);
	}
	async fetchVaults({ limit, codeId, pageIndex }) {
		const request = __injectivelabs_mito_proto_ts_v2_generated_goadesign_goagen_mito_api_pb.GetVaultsRequest.create();
		if (codeId) request.codeId = BigInt(codeId);
		if (limit) request.limit = limit;
		if (pageIndex) request.pageIndex = pageIndex;
		const response = await this.executeGrpcCall(request, this.client.getVaults.bind(this.client));
		return IndexerGrpcMitoTransformer.vaultsResponseToVaults(response);
	}
	async fetchLpTokenPriceChart({ to, from, vaultAddress }) {
		const request = __injectivelabs_mito_proto_ts_v2_generated_goadesign_goagen_mito_api_pb.LPTokenPriceChartRequest.create();
		request.vaultAddress = vaultAddress;
		if (from) request.fromTime = BigInt(from);
		if (to) request.toTime = BigInt(to);
		const response = await this.executeGrpcCall(request, this.client.lPTokenPriceChart.bind(this.client));
		return IndexerGrpcMitoTransformer.lpTokenPriceChartResponseToLPTokenPriceChart(response);
	}
	async fetchTVLChartRequest({ to, from, vaultAddress }) {
		const request = __injectivelabs_mito_proto_ts_v2_generated_goadesign_goagen_mito_api_pb.TVLChartRequest.create();
		request.vaultAddress = vaultAddress;
		if (to) request.toTime = BigInt(to);
		if (from) request.fromTime = BigInt(from);
		const response = await this.executeGrpcCall(request, this.client.tVLChart.bind(this.client));
		return IndexerGrpcMitoTransformer.lpTokenPriceChartResponseToLPTokenPriceChart(response);
	}
	async fetchVaultsByHolderAddress({ skip, limit, holderAddress, vaultAddress }) {
		const request = __injectivelabs_mito_proto_ts_v2_generated_goadesign_goagen_mito_api_pb.VaultsByHolderAddressRequest.create();
		request.holderAddress = holderAddress;
		if (vaultAddress) request.vaultAddress = vaultAddress;
		if (skip) request.skip = skip;
		if (limit) request.limit = limit;
		const response = await this.executeGrpcCall(request, this.client.vaultsByHolderAddress.bind(this.client));
		return IndexerGrpcMitoTransformer.vaultsByHolderAddressResponseToVaultsByHolderAddress(response);
	}
	async fetchLPHolders({ skip, limit, vaultAddress, stakingContractAddress }) {
		const request = __injectivelabs_mito_proto_ts_v2_generated_goadesign_goagen_mito_api_pb.LPHoldersRequest.create();
		request.vaultAddress = vaultAddress;
		request.stakingContractAddress = stakingContractAddress;
		if (skip) request.skip = skip;
		if (limit) request.limit = limit;
		const response = await this.executeGrpcCall(request, this.client.lPHolders.bind(this.client));
		return IndexerGrpcMitoTransformer.lpHoldersResponseToLPHolders(response);
	}
	async fetchHolderPortfolio({ holderAddress, stakingContractAddress }) {
		const request = __injectivelabs_mito_proto_ts_v2_generated_goadesign_goagen_mito_api_pb.PortfolioRequest.create();
		request.holderAddress = holderAddress;
		request.stakingContractAddress = stakingContractAddress;
		const response = await this.executeGrpcCall(request, this.client.portfolio.bind(this.client));
		return IndexerGrpcMitoTransformer.portfolioResponseToPortfolio(response);
	}
	async fetchLeaderboard(epochId) {
		const request = __injectivelabs_mito_proto_ts_v2_generated_goadesign_goagen_mito_api_pb.LeaderboardRequest.create();
		if (epochId) request.epochId = epochId;
		const response = await this.executeGrpcCall(request, this.client.leaderboard.bind(this.client));
		return IndexerGrpcMitoTransformer.leaderboardResponseToLeaderboard(response);
	}
	async fetchTransferHistory({ vault, account, limit, toNumber, fromNumber }) {
		const request = __injectivelabs_mito_proto_ts_v2_generated_goadesign_goagen_mito_api_pb.TransfersHistoryRequest.create();
		if (vault) request.vault = vault;
		if (account) request.account = account;
		if (limit) request.limit = limit;
		if (toNumber) request.toNumber = toNumber;
		if (fromNumber) request.fromNumber = fromNumber;
		const response = await this.executeGrpcCall(request, this.client.transfersHistory.bind(this.client));
		return IndexerGrpcMitoTransformer.transferHistoryResponseToTransfer(response);
	}
	async fetchLeaderboardEpochs({ limit, toEpochId, fromEpochId }) {
		const request = __injectivelabs_mito_proto_ts_v2_generated_goadesign_goagen_mito_api_pb.LeaderboardEpochsRequest.create();
		if (limit) request.limit = limit;
		if (toEpochId) request.toEpochId = toEpochId;
		if (fromEpochId) request.fromEpochId = fromEpochId;
		const response = await this.executeGrpcCall(request, this.client.leaderboardEpochs.bind(this.client));
		return IndexerGrpcMitoTransformer.leaderboardEpochsResponseToLeaderboardEpochs(response);
	}
	async fetchStakingPools({ staker, stakingContractAddress }) {
		const request = __injectivelabs_mito_proto_ts_v2_generated_goadesign_goagen_mito_api_pb.GetStakingPoolsRequest.create();
		request.stakingContractAddress = stakingContractAddress;
		if (staker) request.staker = staker;
		const response = await this.executeGrpcCall(request, this.client.getStakingPools.bind(this.client));
		return IndexerGrpcMitoTransformer.stakingPoolsResponseToStakingPools(response);
	}
	async fetchStakingHistory({ staker, toNumber, limit, fromNumber } = {}) {
		const request = __injectivelabs_mito_proto_ts_v2_generated_goadesign_goagen_mito_api_pb.StakingHistoryRequest.create();
		if (limit) request.limit = limit;
		if (staker) request.staker = staker;
		if (toNumber) request.toNumber = toNumber;
		if (fromNumber) request.fromNumber = fromNumber;
		const response = await this.executeGrpcCall(request, this.client.stakingHistory.bind(this.client));
		return IndexerGrpcMitoTransformer.mitoStakingHistoryResponseTpStakingHistory(response);
	}
	async fetchStakingRewardsByAccount({ staker, stakingContractAddress }) {
		const request = __injectivelabs_mito_proto_ts_v2_generated_goadesign_goagen_mito_api_pb.StakingRewardByAccountRequest.create();
		request.staker = staker;
		request.stakingContractAddress = stakingContractAddress;
		const response = await this.executeGrpcCall(request, this.client.stakingRewardByAccount.bind(this.client));
		return IndexerGrpcMitoTransformer.stakingRewardByAccountResponseToStakingRewardByAccount(response);
	}
	async fetchMissions({ accountAddress }) {
		const request = __injectivelabs_mito_proto_ts_v2_generated_goadesign_goagen_mito_api_pb.MissionsRequest.create();
		request.accountAddress = accountAddress;
		const response = await this.executeGrpcCall(request, this.client.missions.bind(this.client));
		return IndexerGrpcMitoTransformer.mitoMissionsResponseMissions(response);
	}
	async fetchMissionLeaderboard(userAddress) {
		const request = __injectivelabs_mito_proto_ts_v2_generated_goadesign_goagen_mito_api_pb.MissionLeaderboardRequest.create();
		if (userAddress) request.userAddress = userAddress;
		const response = await this.executeGrpcCall(request, this.client.missionLeaderboard.bind(this.client));
		return IndexerGrpcMitoTransformer.mitoMissionLeaderboardResponseToMissionLeaderboard(response);
	}
	async fetchIDO({ contractAddress, accountAddress }) {
		const request = __injectivelabs_mito_proto_ts_v2_generated_goadesign_goagen_mito_api_pb.GetIDORequest.create();
		request.contractAddress = contractAddress;
		if (accountAddress) request.accountAddress = accountAddress;
		const response = await this.executeGrpcCall(request, this.client.getIDO.bind(this.client));
		return IndexerGrpcMitoTransformer.mitoIDOResponseToIDO(response);
	}
	async fetchIDOs({ status, limit, toNumber, accountAddress, ownerAddress } = {}) {
		const request = __injectivelabs_mito_proto_ts_v2_generated_goadesign_goagen_mito_api_pb.ListIDOsRequest.create();
		if (status) request.status = status;
		if (limit) request.limit = limit;
		if (toNumber) request.toNumber = toNumber;
		if (accountAddress) request.accountAddress = accountAddress;
		if (ownerAddress) request.ownerAddress = ownerAddress;
		const response = await this.executeGrpcCall(request, this.client.listIDOs.bind(this.client));
		return IndexerGrpcMitoTransformer.mitoListIDOsResponseToIDOs(response);
	}
	async fetchIDOSubscribers({ skip, limit, sortBy, contractAddress }) {
		const request = __injectivelabs_mito_proto_ts_v2_generated_goadesign_goagen_mito_api_pb.GetIDOSubscribersRequest.create();
		request.contractAddress = contractAddress;
		if (limit) request.limit = limit;
		if (skip) request.skip = skip;
		if (sortBy) request.sortBy = sortBy;
		const response = await this.executeGrpcCall(request, this.client.getIDOSubscribers.bind(this.client));
		return IndexerGrpcMitoTransformer.mitoIDOSubscribersResponseToIDOSubscribers(response);
	}
	async fetchIDOSubscription({ contractAddress, accountAddress }) {
		const request = __injectivelabs_mito_proto_ts_v2_generated_goadesign_goagen_mito_api_pb.GetIDOSubscriptionRequest.create();
		request.accountAddress = accountAddress;
		request.contractAddress = contractAddress;
		const response = await this.executeGrpcCall(request, this.client.getIDOSubscription.bind(this.client));
		return IndexerGrpcMitoTransformer.mitoIDOSubscriptionResponseToIDOSubscription(response);
	}
	async fetchIDOActivities({ contractAddress, accountAddress, limit, toNumber } = {}) {
		const request = __injectivelabs_mito_proto_ts_v2_generated_goadesign_goagen_mito_api_pb.GetIDOActivitiesRequest.create();
		if (contractAddress) request.contractAddress = contractAddress;
		if (accountAddress) request.accountAddress = accountAddress;
		if (limit) request.limit = limit;
		if (toNumber) request.toNumber = toNumber;
		const response = await this.executeGrpcCall(request, this.client.getIDOActivities.bind(this.client));
		return IndexerGrpcMitoTransformer.mitoIDOActivitiesResponseToIDOActivities(response);
	}
	async fetchIDOWhitelist({ skip, limit, idoAddress }) {
		const request = __injectivelabs_mito_proto_ts_v2_generated_goadesign_goagen_mito_api_pb.GetWhitelistRequest.create();
		request.idoAddress = idoAddress;
		if (skip) request.skip = skip;
		if (limit) request.limit = limit;
		const response = await this.executeGrpcCall(request, this.client.getWhitelist.bind(this.client));
		return IndexerGrpcMitoTransformer.mitoWhitelistAccountResponseToWhitelistAccount(response);
	}
	async fetchClaimReferences({ skip, limit, idoAddress, accountAddress }) {
		const request = __injectivelabs_mito_proto_ts_v2_generated_goadesign_goagen_mito_api_pb.GetClaimReferencesRequest.create();
		request.idoAddress = idoAddress;
		request.accountAddress = accountAddress;
		if (skip) request.skip = skip;
		if (limit) request.limit = limit;
		const response = await this.executeGrpcCall(request, this.client.getClaimReferences.bind(this.client));
		return IndexerGrpcMitoTransformer.claimReferencesResponseToClaimReferences(response);
	}
};

//#endregion
//#region src/client/indexer/grpc/IndexerGrpcMetaApi.ts
/**
* @category Indexer Grpc API
*/
var IndexerGrpcMetaApi = class extends require_BaseIndexerGrpcConsumer.BaseIndexerGrpcConsumer {
	constructor(..._args) {
		super(..._args);
		require_defineProperty._defineProperty(this, "module", require_IndexerGrpcWeb3GwApi.IndexerModule.Meta);
	}
	get client() {
		return this.initClient(__injectivelabs_indexer_proto_ts_v2_generated_injective_meta_rpc_pb_client.InjectiveMetaRPCClient);
	}
	async fetchPing() {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_meta_rpc_pb.PingRequest.create();
		return await this.executeGrpcCall(request, this.client.ping.bind(this.client));
	}
	async fetchVersion() {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_meta_rpc_pb.VersionRequest.create();
		return await this.executeGrpcCall(request, this.client.version.bind(this.client));
	}
	async fetchInfo() {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_meta_rpc_pb.InfoRequest.create();
		request.timestamp = BigInt(Date.now());
		return await this.executeGrpcCall(request, this.client.info.bind(this.client));
	}
};

//#endregion
//#region src/client/indexer/grpc/IndexerGrpcSpotApi.ts
/**
* @category Indexer Grpc API
*/
var IndexerGrpcSpotApi = class extends require_BaseIndexerGrpcConsumer.BaseIndexerGrpcConsumer {
	constructor(..._args) {
		super(..._args);
		require_defineProperty._defineProperty(this, "module", require_IndexerGrpcWeb3GwApi.IndexerModule.Spot);
	}
	get client() {
		return this.initClient(__injectivelabs_indexer_proto_ts_v2_generated_injective_spot_exchange_rpc_pb_client.InjectiveSpotExchangeRPCClient);
	}
	async fetchMarkets(params) {
		const { baseDenom, marketStatus, quoteDenom, marketStatuses } = params || {};
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_spot_exchange_rpc_pb.MarketsRequest.create();
		if (baseDenom) request.baseDenom = baseDenom;
		if (marketStatus) request.marketStatus = marketStatus;
		if (marketStatuses) request.marketStatuses = marketStatuses;
		if (quoteDenom) request.quoteDenom = quoteDenom;
		const response = await this.executeGrpcCall(request, this.client.markets.bind(this.client));
		return IndexerGrpcSpotTransformer.marketsResponseToMarkets(response);
	}
	async fetchMarket(marketId) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_spot_exchange_rpc_pb.MarketRequest.create();
		request.marketId = marketId;
		const response = await this.executeGrpcCall(request, this.client.market.bind(this.client));
		return IndexerGrpcSpotTransformer.marketResponseToMarket(response);
	}
	/** @deprecated - use fetchOrderbookV2 */
	async fetchOrderbook(_marketId) {
		throw new __injectivelabs_exceptions.GeneralException(/* @__PURE__ */ new Error("deprecated - use fetchOrderbookV2"));
	}
	async fetchOrders(params) {
		const { cid, tradeId, marketId, marketIds, orderSide, pagination, subaccountId } = params || {};
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_spot_exchange_rpc_pb.OrdersRequest.create();
		if (marketId) request.marketId = marketId;
		if (marketIds) request.marketIds = marketIds;
		if (subaccountId) request.subaccountId = subaccountId;
		if (orderSide) request.orderSide = orderSide;
		if (cid) request.cid = cid;
		if (tradeId) request.tradeId = tradeId;
		if (pagination) {
			if (pagination.skip !== void 0) request.skip = BigInt(pagination.skip);
			if (pagination.limit !== void 0) request.limit = pagination.limit;
			if (pagination.endTime !== void 0) request.endTime = BigInt(pagination.endTime);
			if (pagination.startTime !== void 0) request.startTime = BigInt(pagination.startTime);
		}
		const response = await this.executeGrpcCall(request, this.client.orders.bind(this.client));
		return IndexerGrpcSpotTransformer.ordersResponseToOrders(response);
	}
	async fetchOrderHistory(params) {
		const { cid, state, tradeId, marketId, direction, marketIds, orderTypes, pagination, subaccountId, executionTypes } = params || {};
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_spot_exchange_rpc_pb.OrdersHistoryRequest.create();
		if (subaccountId) request.subaccountId = subaccountId;
		if (marketId) request.marketId = marketId;
		if (marketIds) request.marketIds = marketIds;
		if (orderTypes) request.orderTypes = orderTypes;
		if (executionTypes) request.executionTypes = executionTypes;
		if (direction) request.direction = direction;
		if (state) request.state = state;
		if (cid) request.cid = cid;
		if (tradeId) request.tradeId = tradeId;
		if (pagination) {
			if (pagination.skip !== void 0) request.skip = BigInt(pagination.skip);
			if (pagination.limit !== void 0) request.limit = pagination.limit;
			if (pagination.endTime !== void 0) request.endTime = BigInt(pagination.endTime);
			if (pagination.startTime !== void 0) request.startTime = BigInt(pagination.startTime);
		}
		const response = await this.executeGrpcCall(request, this.client.ordersHistory.bind(this.client));
		return IndexerGrpcSpotTransformer.orderHistoryResponseToOrderHistory(response);
	}
	async fetchTrades(params) {
		const { endTime, tradeId, marketId, startTime, direction, marketIds, pagination, subaccountId, executionSide, executionTypes, accountAddress, cid } = params || {};
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_spot_exchange_rpc_pb.TradesRequest.create();
		if (marketId) request.marketId = marketId;
		if (marketIds) request.marketIds = marketIds;
		if (subaccountId) request.subaccountId = subaccountId;
		if (accountAddress) request.accountAddress = accountAddress;
		if (tradeId) request.tradeId = tradeId;
		if (executionTypes) request.executionTypes = executionTypes;
		if (executionSide) request.executionSide = executionSide;
		if (direction) request.direction = direction;
		if (startTime) request.startTime = BigInt(startTime);
		if (endTime) request.endTime = BigInt(endTime);
		if (cid) request.cid = cid;
		if (pagination) {
			if (pagination.skip !== void 0) request.skip = BigInt(pagination.skip);
			if (pagination.limit !== void 0) request.limit = pagination.limit;
			if (pagination.endTime !== void 0) request.endTime = BigInt(pagination.endTime);
			if (pagination.startTime !== void 0) request.startTime = BigInt(pagination.startTime);
		}
		const response = await this.executeGrpcCall(request, this.client.trades.bind(this.client));
		return IndexerGrpcSpotTransformer.tradesResponseToTrades(response);
	}
	async fetchSubaccountOrdersList(params) {
		const { subaccountId, marketId, pagination } = params || {};
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_spot_exchange_rpc_pb.SubaccountOrdersListRequest.create();
		if (subaccountId) request.subaccountId = subaccountId;
		if (marketId) request.marketId = marketId;
		if (pagination) {
			if (pagination.skip !== void 0) request.skip = BigInt(pagination.skip);
			if (pagination.limit !== void 0) request.limit = pagination.limit;
		}
		const response = await this.executeGrpcCall(request, this.client.subaccountOrdersList.bind(this.client));
		return IndexerGrpcSpotTransformer.ordersResponseToOrders(response);
	}
	async fetchSubaccountTradesList(params) {
		const { subaccountId, marketId, direction, executionType, pagination } = params || {};
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_spot_exchange_rpc_pb.SubaccountTradesListRequest.create();
		if (subaccountId) request.subaccountId = subaccountId;
		if (marketId) request.marketId = marketId;
		if (direction) request.direction = direction;
		if (executionType) request.executionType = executionType;
		if (pagination) {
			if (pagination.skip !== void 0) request.skip = BigInt(pagination.skip);
			if (pagination.limit !== void 0) request.limit = pagination.limit;
		}
		const response = await this.executeGrpcCall(request, this.client.subaccountTradesList.bind(this.client));
		return IndexerGrpcSpotTransformer.subaccountTradesListResponseToTradesList(response);
	}
	/** @deprecated - use fetchOrderbooksV2 */
	async fetchOrderbooks(_marketIds) {
		throw new __injectivelabs_exceptions.GeneralException(/* @__PURE__ */ new Error("deprecated - use fetchOrderbooksV2"));
	}
	async fetchOrderbooksV2(marketIds) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_spot_exchange_rpc_pb.OrderbooksV2Request.create();
		if (marketIds.length > 0) request.marketIds = marketIds;
		const response = await this.executeGrpcCall(request, this.client.orderbooksV2.bind(this.client));
		return IndexerGrpcSpotTransformer.orderbooksV2ResponseToOrderbooksV2(response);
	}
	async fetchOrderbookV2(marketId) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_spot_exchange_rpc_pb.OrderbookV2Request.create();
		request.marketId = marketId;
		const response = await this.executeGrpcCall(request, this.client.orderbookV2.bind(this.client));
		return IndexerGrpcSpotTransformer.orderbookV2ResponseToOrderbookV2(response);
	}
	async fetchAtomicSwapHistory(params) {
		const { address, contractAddress, pagination } = params || {};
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_spot_exchange_rpc_pb.AtomicSwapHistoryRequest.create();
		request.address = address;
		request.contractAddress = contractAddress;
		if (pagination) {
			if (pagination.fromNumber !== void 0) request.fromNumber = pagination.fromNumber;
			if (pagination.toNumber !== void 0) request.toNumber = pagination.toNumber;
			if (pagination.skip !== void 0) request.skip = pagination.skip;
			if (pagination.limit !== void 0) request.limit = pagination.limit;
		}
		const response = await this.executeGrpcCall(request, this.client.atomicSwapHistory.bind(this.client));
		return IndexerGrpcSpotTransformer.grpcAtomicSwapHistoryListToAtomicSwapHistoryList(response);
	}
};

//#endregion
//#region src/client/indexer/grpc/IndexerGrpcOracleApi.ts
/**
* @category Indexer Grpc API
*/
var IndexerGrpcOracleApi = class extends require_BaseIndexerGrpcConsumer.BaseIndexerGrpcConsumer {
	constructor(..._args) {
		super(..._args);
		require_defineProperty._defineProperty(this, "module", require_IndexerGrpcWeb3GwApi.IndexerModule.Oracle);
	}
	get client() {
		return this.initClient(__injectivelabs_indexer_proto_ts_v2_generated_injective_oracle_rpc_pb_client.InjectiveOracleRPCClient);
	}
	async fetchOracleList() {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_oracle_rpc_pb.OracleListRequest.create();
		const response = await this.executeGrpcCall(request, this.client.oracleList.bind(this.client));
		return IndexerGrpcOracleTransformer.oraclesResponseToOracles(response);
	}
	async fetchOraclePrice({ baseSymbol, quoteSymbol, oracleScaleFactor, oracleType }) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_oracle_rpc_pb.PriceRequest.create();
		request.baseSymbol = baseSymbol;
		request.quoteSymbol = quoteSymbol;
		request.oracleType = oracleType;
		if (oracleScaleFactor) request.oracleScaleFactor = oracleScaleFactor;
		return await this.executeGrpcCall(request, this.client.price.bind(this.client));
	}
	async fetchOraclePriceNoThrow({ baseSymbol, quoteSymbol, oracleScaleFactor, oracleType }) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_oracle_rpc_pb.PriceRequest.create();
		request.baseSymbol = baseSymbol;
		request.quoteSymbol = quoteSymbol;
		request.oracleType = oracleType;
		if (oracleScaleFactor) request.oracleScaleFactor = oracleScaleFactor;
		try {
			return await this.executeGrpcCall(request, this.client.price.bind(this.client));
		} catch (e) {
			if (e.message.includes("object not found")) return { price: "0" };
			throw e;
		}
	}
};

//#endregion
//#region src/client/indexer/grpc/IndexerGrpcAccountApi.ts
/**
* @category Indexer Grpc API
*/
var IndexerGrpcAccountApi = class extends require_BaseIndexerGrpcConsumer.BaseIndexerGrpcConsumer {
	constructor(..._args) {
		super(..._args);
		require_defineProperty._defineProperty(this, "module", require_IndexerGrpcWeb3GwApi.IndexerModule.Account);
	}
	get client() {
		return this.initClient(__injectivelabs_indexer_proto_ts_v2_generated_injective_accounts_rpc_pb_client.InjectiveAccountsRPCClient);
	}
	/**
	* @deprecated - use IndexerGrpcAccountPortfolioApi.fetchPortfolio instead
	*/
	async fetchPortfolio(_address) {
		throw new __injectivelabs_exceptions.GeneralException(/* @__PURE__ */ new Error("deprecated - use IndexerGrpcAccountPortfolioApi.fetchPortfolio"));
	}
	async fetchRewards({ address, epoch }) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_accounts_rpc_pb.RewardsRequest.create();
		request.accountAddress = address;
		if (epoch) request.epoch = BigInt(epoch.toString());
		const response = await this.executeGrpcCall(request, this.client.rewards.bind(this.client));
		return IndexerGrpcAccountTransformer.tradingRewardsResponseToTradingRewards(response);
	}
	async fetchSubaccountsList(address) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_accounts_rpc_pb.SubaccountsListRequest.create();
		request.accountAddress = address;
		return (await this.executeGrpcCall(request, this.client.subaccountsList.bind(this.client))).subaccounts;
	}
	async fetchSubaccountBalance(subaccountId, denom) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_accounts_rpc_pb.SubaccountBalanceEndpointRequest.create();
		request.subaccountId = subaccountId;
		request.denom = denom;
		const response = await this.executeGrpcCall(request, this.client.subaccountBalanceEndpoint.bind(this.client));
		return IndexerGrpcAccountTransformer.balanceResponseToBalance(response);
	}
	async fetchSubaccountBalancesList(subaccountId) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_accounts_rpc_pb.SubaccountBalancesListRequest.create();
		request.subaccountId = subaccountId;
		const response = await this.executeGrpcCall(request, this.client.subaccountBalancesList.bind(this.client));
		return IndexerGrpcAccountTransformer.balancesResponseToBalances(response);
	}
	async fetchSubaccountHistory({ subaccountId, denom, transferTypes = [], pagination }) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_accounts_rpc_pb.SubaccountHistoryRequest.create();
		request.subaccountId = subaccountId;
		if (denom) request.denom = denom;
		if (transferTypes.length > 0) request.transferTypes = transferTypes;
		if (pagination) {
			if (pagination.skip !== void 0) request.skip = BigInt(pagination.skip.toString());
			if (pagination.limit !== void 0) request.limit = pagination.limit;
			if (pagination.endTime !== void 0) request.endTime = BigInt(pagination.endTime.toString());
		}
		const response = await this.executeGrpcCall(request, this.client.subaccountHistory.bind(this.client));
		return IndexerGrpcAccountTransformer.transferHistoryResponseToTransferHistory(response);
	}
	async fetchSubaccountOrderSummary({ subaccountId, marketId, orderDirection }) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_accounts_rpc_pb.SubaccountOrderSummaryRequest.create();
		request.subaccountId = subaccountId;
		if (marketId) request.marketId = marketId;
		if (orderDirection) request.orderDirection = orderDirection;
		return await this.executeGrpcCall(request, this.client.subaccountOrderSummary.bind(this.client));
	}
	async fetchOrderStates(params) {
		const { spotOrderHashes = [], derivativeOrderHashes = [] } = params || {};
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_accounts_rpc_pb.OrderStatesRequest.create();
		request.spotOrderHashes = spotOrderHashes;
		request.derivativeOrderHashes = derivativeOrderHashes;
		return await this.executeGrpcCall(request, this.client.orderStates.bind(this.client));
	}
};

//#endregion
//#region src/client/indexer/grpc/IndexerGrpcAuctionApi.ts
/**
* @category Indexer Grpc API
*/
var IndexerGrpcAuctionApi = class extends require_BaseIndexerGrpcConsumer.BaseIndexerGrpcConsumer {
	constructor(..._args) {
		super(..._args);
		require_defineProperty._defineProperty(this, "module", require_IndexerGrpcWeb3GwApi.IndexerModule.Auction);
	}
	get client() {
		return this.initClient(__injectivelabs_indexer_proto_ts_v2_generated_injective_auction_rpc_pb_client.InjectiveAuctionRPCClient);
	}
	async fetchAuction(round) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_auction_rpc_pb.AuctionEndpointRequest.create();
		/**
		* If round is provided, set it on the request,
		* otherwise fetch latest round
		**/
		if (round) request.round = BigInt(round);
		const response = await this.executeGrpcCall(request, this.client.auctionEndpoint.bind(this.client));
		return IndexerGrpcAuctionTransformer.auctionResponseToAuction(response);
	}
	async fetchAuctions() {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_auction_rpc_pb.AuctionsRequest.create();
		const response = await this.executeGrpcCall(request, this.client.auctions.bind(this.client));
		return IndexerGrpcAuctionTransformer.auctionsResponseToAuctions(response);
	}
	async fetchInjBurnt() {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_auction_rpc_pb.InjBurntEndpointRequest.create();
		const response = await this.executeGrpcCall(request, this.client.injBurntEndpoint.bind(this.client));
		return Number(response.totalInjBurnt);
	}
	async fetchAuctionsHistoryV2({ token, endTime, perPage = 5 }) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_auction_rpc_pb.AuctionsHistoryV2Request.create();
		request.perPage = perPage;
		if (endTime) request.endTime = BigInt(endTime);
		if (token) request.token = token;
		const response = await this.executeGrpcCall(request, this.client.auctionsHistoryV2.bind(this.client));
		return IndexerGrpcAuctionTransformer.auctionsHistoryV2ResponseToAuctionHistory(response);
	}
	async fetchAuctionV2(round = -1) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_auction_rpc_pb.AuctionV2Request.create();
		if (round) request.round = BigInt(round);
		const response = await this.executeGrpcCall(request, this.client.auctionV2.bind(this.client));
		return IndexerGrpcAuctionTransformer.grpcAuctionV2ToAuctionV2(response);
	}
	async fetchAccountAuctionsV2({ token, address, perPage = 5 }) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_auction_rpc_pb.AccountAuctionsV2Request.create();
		request.address = address;
		request.perPage = perPage;
		if (token) request.token = token.toString();
		const response = await this.executeGrpcCall(request, this.client.accountAuctionsV2.bind(this.client));
		return IndexerGrpcAuctionTransformer.accountAuctionsV2ResponseToAccountAuctionsV2(response);
	}
	async fetchAuctionStats() {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_auction_rpc_pb.AuctionsStatsRequest.create();
		const response = await this.executeGrpcCall(request, this.client.auctionsStats.bind(this.client));
		return IndexerGrpcAuctionTransformer.auctionStatsResponseToAuctionStats(response);
	}
	async fetchAccountAuctionStatus({ address, round = -1 }) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_auction_rpc_pb.AuctionAccountStatusRequest.create();
		if (round) request.round = BigInt(round);
		if (address) request.address = address;
		const response = await this.executeGrpcCall(request, this.client.auctionAccountStatus.bind(this.client));
		return IndexerGrpcAuctionTransformer.auctionAccountStatusResponseToAuctionAccountStatus(response);
	}
};

//#endregion
//#region src/client/indexer/grpc/IndexerGrpcTradingApi.ts
/**
* @category Indexer Grpc API
*/
var IndexerGrpcTradingApi = class extends require_BaseIndexerGrpcConsumer.BaseIndexerGrpcConsumer {
	constructor(..._args) {
		super(..._args);
		require_defineProperty._defineProperty(this, "module", require_IndexerGrpcWeb3GwApi.IndexerModule.Trading);
	}
	get client() {
		return this.initClient(__injectivelabs_indexer_proto_ts_v2_generated_injective_trading_rpc_pb_client.InjectiveTradingRPCClient);
	}
	async fetchTradingStats() {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_trading_rpc_pb.GetTradingStatsRequest.create();
		return await this.executeGrpcCall(request, this.client.getTradingStats.bind(this.client));
	}
	async fetchGridStrategies({ skip, state, limit, withTvl, endTime, marketId, startTime, marketType, strategyType, subaccountId, accountAddress, withPerformance, pendingExecution, lastExecutedTime, isTrailingStrategy }) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_trading_rpc_pb.ListTradingStrategiesRequest.create();
		if (accountAddress) request.accountAddress = accountAddress;
		if (subaccountId) request.subaccountId = subaccountId;
		if (strategyType) request.strategyType = strategyType;
		if (marketType) request.marketType = marketType;
		if (state) request.state = state;
		if (limit) request.limit = limit;
		if (skip) request.skip = BigInt(skip);
		if (marketId) request.marketId = marketId;
		if (withTvl) request.withTvl = withTvl;
		if (withPerformance) request.withPerformance = withPerformance;
		if (isTrailingStrategy) request.isTrailingStrategy = isTrailingStrategy;
		if (startTime) request.startTime = BigInt(startTime);
		if (endTime) request.endTime = BigInt(endTime);
		if (pendingExecution) request.pendingExecution = pendingExecution;
		if (lastExecutedTime) request.lastExecutedTime = BigInt(lastExecutedTime);
		return await this.executeGrpcCall(request, this.client.listTradingStrategies.bind(this.client));
	}
};

//#endregion
//#region src/client/indexer/grpc/IndexerGrpcExplorerApi.ts
/**
* @category Indexer Grpc API
*/
var IndexerGrpcExplorerApi = class extends require_BaseIndexerGrpcConsumer.BaseIndexerGrpcConsumer {
	constructor(..._args) {
		super(..._args);
		require_defineProperty._defineProperty(this, "module", require_IndexerGrpcWeb3GwApi.IndexerModule.Explorer);
	}
	get client() {
		return this.initClient(__injectivelabs_indexer_proto_ts_v2_generated_injective_explorer_rpc_pb_client.InjectiveExplorerRPCClient);
	}
	async fetchTxByHash(hash, isEvmHash = false) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_explorer_rpc_pb.GetTxByTxHashRequest.create();
		request.hash = hash;
		request.isEvmHash = isEvmHash;
		const response = await this.executeGrpcCall(request, this.client.getTxByTxHash.bind(this.client));
		return IndexerGrpcExplorerTransformer.getTxByTxHashResponseToTx(response);
	}
	async fetchAccountTx({ address, limit, type, before, after, startTime, endTime }) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_explorer_rpc_pb.GetAccountTxsRequest.create();
		request.address = address;
		if (limit) request.limit = limit;
		if (before) request.before = BigInt(before);
		if (after) request.after = BigInt(after);
		if (startTime) request.startTime = BigInt(startTime);
		if (endTime) request.endTime = BigInt(endTime);
		if (type) request.type = type;
		const response = await this.executeGrpcCall(request, this.client.getAccountTxs.bind(this.client));
		return IndexerGrpcExplorerTransformer.getAccountTxsResponseToAccountTxs(response);
	}
	async fetchValidator(validatorAddress) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_explorer_rpc_pb.GetValidatorRequest.create();
		request.address = validatorAddress;
		const response = await this.executeGrpcCall(request, this.client.getValidator.bind(this.client));
		return IndexerGrpcExplorerTransformer.validatorResponseToValidator(response);
	}
	async fetchValidatorUptime(validatorAddress) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_explorer_rpc_pb.GetValidatorUptimeRequest.create();
		request.address = validatorAddress;
		const response = await this.executeGrpcCall(request, this.client.getValidatorUptime.bind(this.client));
		return IndexerGrpcExplorerTransformer.getValidatorUptimeResponseToValidatorUptime(response);
	}
	async fetchPeggyDepositTxs({ sender, receiver, limit, skip }) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_explorer_rpc_pb.GetPeggyDepositTxsRequest.create();
		if (sender) request.sender = sender;
		if (receiver) request.receiver = receiver;
		if (limit) request.limit = limit;
		if (skip) request.skip = BigInt(skip);
		const response = await this.executeGrpcCall(request, this.client.getPeggyDepositTxs.bind(this.client));
		return IndexerGrpcExplorerTransformer.getPeggyDepositTxsResponseToPeggyDepositTxs(response);
	}
	async fetchPeggyWithdrawalTxs({ sender, receiver, limit, skip }) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_explorer_rpc_pb.GetPeggyWithdrawalTxsRequest.create();
		if (sender) request.sender = sender;
		if (receiver) request.receiver = receiver;
		if (limit) request.limit = limit;
		if (skip) request.skip = BigInt(skip);
		const response = await this.executeGrpcCall(request, this.client.getPeggyWithdrawalTxs.bind(this.client));
		return IndexerGrpcExplorerTransformer.getPeggyWithdrawalTxsResponseToPeggyWithdrawalTxs(response);
	}
	async fetchBlocks({ before, after, limit, from, to }) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_explorer_rpc_pb.GetBlocksRequest.create();
		if (before) request.before = BigInt(before);
		if (after) request.after = BigInt(after);
		if (from) request.from = BigInt(from);
		if (to) request.to = BigInt(to);
		if (limit) request.limit = limit;
		return await this.executeGrpcCall(request, this.client.getBlocks.bind(this.client));
	}
	async fetchBlock(id) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_explorer_rpc_pb.GetBlockRequest.create();
		request.id = id;
		return await this.executeGrpcCall(request, this.client.getBlock.bind(this.client));
	}
	async fetchTxs({ before, after, limit, skip, type, chainModule, startTime, endTime }) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_explorer_rpc_pb.GetTxsRequest.create();
		if (before) request.before = BigInt(before);
		if (after) request.after = BigInt(after);
		if (limit) request.limit = limit;
		if (skip) request.skip = BigInt(skip);
		if (type) request.type = type;
		if (chainModule) request.module = chainModule;
		if (startTime) request.startTime = BigInt(startTime);
		if (endTime) request.endTime = BigInt(endTime);
		return await this.executeGrpcCall(request, this.client.getTxs.bind(this.client));
	}
	async fetchIBCTransferTxs({ sender, receiver, srcChannel, srcPort, destChannel, destPort, limit, skip }) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_explorer_rpc_pb.GetIBCTransferTxsRequest.create();
		if (sender) request.sender = sender;
		if (receiver) request.receiver = receiver;
		if (limit) request.limit = limit;
		if (skip) request.skip = BigInt(skip);
		if (srcChannel) request.srcChannel = srcChannel;
		if (srcPort) request.srcPort = srcPort;
		if (destChannel) request.destChannel = destChannel;
		if (destPort) request.destPort = destPort;
		const response = await this.executeGrpcCall(request, this.client.getIBCTransferTxs.bind(this.client));
		return IndexerGrpcExplorerTransformer.getIBCTransferTxsResponseToIBCTransferTxs(response);
	}
	async fetchExplorerStats() {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_explorer_rpc_pb.GetStatsRequest.create();
		const response = await this.executeGrpcCall(request, this.client.getStats.bind(this.client));
		return IndexerGrpcExplorerTransformer.getExplorerStatsResponseToExplorerStats(response);
	}
	async fetchTxsV2({ type, token, status, perPage, endTime, startTime, blockNumber }) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_explorer_rpc_pb.GetTxsV2Request.create();
		if (token) request.token = token;
		if (blockNumber) request.blockNumber = BigInt(blockNumber);
		if (endTime) request.endTime = BigInt(endTime);
		if (startTime) request.startTime = BigInt(startTime);
		if (perPage) request.perPage = perPage;
		if (status) request.status = status;
		if (type) request.type = type;
		const response = await this.executeGrpcCall(request, this.client.getTxsV2.bind(this.client));
		return IndexerGrpcExplorerTransformer.getTxsV2ResponseToTxs(response);
	}
	async fetchAccountTxsV2({ type, token, address, endTime, perPage, startTime }) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_explorer_rpc_pb.GetAccountTxsV2Request.create();
		request.address = address;
		if (startTime) request.startTime = BigInt(startTime);
		if (endTime) request.endTime = BigInt(endTime);
		if (perPage) request.perPage = perPage;
		if (token) request.token = token;
		if (type) request.type = type;
		const response = await this.executeGrpcCall(request, this.client.getAccountTxsV2.bind(this.client));
		return IndexerGrpcExplorerTransformer.getAccountTxsV2ResponseToAccountTxs(response);
	}
	async fetchBlocksV2({ token, perPage }) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_explorer_rpc_pb.GetBlocksV2Request.create({});
		if (perPage) request.perPage = perPage;
		if (token) request.token = token;
		const response = await this.executeGrpcCall(request, this.client.getBlocksV2.bind(this.client));
		return IndexerGrpcExplorerTransformer.getBlocksV2ResponseToBlocks(response);
	}
	async fetchContractTxsV2({ to, from, token, height, status, perPage, contractAddress }) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_explorer_rpc_pb.GetContractTxsV2Request.create();
		request.address = contractAddress;
		if (from) request.from = BigInt(from);
		if (to) request.to = BigInt(to);
		if (perPage) request.perPage = perPage;
		if (token) request.token = token;
		if (height) request.height = BigInt(height);
		if (status) request.status = status;
		const response = await this.executeGrpcCall(request, this.client.getContractTxsV2.bind(this.client));
		return IndexerGrpcExplorerTransformer.getContractTxsV2ResponseToContractTxs(response);
	}
};

//#endregion
//#region src/client/indexer/grpc/IndexerGrpcCampaignApi.ts
/**
* @category Indexer Grpc API
*/
var IndexerGrpcCampaignApi = class extends require_BaseIndexerGrpcConsumer.BaseIndexerGrpcConsumer {
	constructor(..._args) {
		super(..._args);
		require_defineProperty._defineProperty(this, "module", require_IndexerGrpcWeb3GwApi.IndexerModule.Campaign);
	}
	get client() {
		return this.initClient(__injectivelabs_indexer_proto_ts_v2_generated_injective_campaign_rpc_pb_client.InjectiveCampaignRPCClient);
	}
	async fetchCampaign({ skip, limit, marketId, campaignId, accountAddress, contractAddress }) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_campaign_rpc_pb.RankingRequest.create();
		request.campaignId = campaignId;
		if (skip) request.skip = BigInt(skip);
		if (limit) request.limit = limit;
		if (marketId) request.marketId = marketId;
		if (accountAddress) request.accountAddress = accountAddress;
		if (contractAddress) request.contractAddress = contractAddress;
		const response = await this.executeGrpcCall(request, this.client.ranking.bind(this.client));
		return IndexerCampaignTransformer.CampaignResponseToCampaign(response);
	}
	async fetchCampaigns({ type, active, limit, cursor, status }) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_campaign_rpc_pb.CampaignsV2Request.create();
		if (type) request.type = type;
		if (active) request.active = active;
		if (limit) request.limit = limit;
		if (cursor) request.cursor = cursor;
		if (status) request.status = status;
		const response = await this.executeGrpcCall(request, this.client.campaignsV2.bind(this.client));
		return IndexerCampaignTransformer.CampaignsV2ResponseToCampaigns(response);
	}
	async fetchRound({ roundId, toRoundId, accountAddress, contractAddress }) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_campaign_rpc_pb.CampaignsRequest.create();
		if (roundId) request.roundId = BigInt(roundId);
		if (accountAddress) request.accountAddress = accountAddress;
		if (toRoundId) request.toRoundId = toRoundId;
		if (contractAddress) request.contractAddress = contractAddress;
		const response = await this.executeGrpcCall(request, this.client.campaigns.bind(this.client));
		return IndexerCampaignTransformer.RoundsResponseToRounds(response);
	}
	async fetchGuilds({ skip, limit, sortBy, campaignContract }) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_campaign_rpc_pb.ListGuildsRequest.create();
		request.sortBy = sortBy;
		request.campaignContract = campaignContract;
		if (skip) request.skip = skip;
		if (limit) request.limit = limit;
		const response = await this.executeGrpcCall(request, this.client.listGuilds.bind(this.client));
		return IndexerCampaignTransformer.GuildsResponseToGuilds(response);
	}
	async fetchGuildMember({ address, campaignContract }) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_campaign_rpc_pb.GetGuildMemberRequest.create();
		request.address = address;
		request.campaignContract = campaignContract;
		const response = await this.executeGrpcCall(request, this.client.getGuildMember.bind(this.client));
		return IndexerCampaignTransformer.GuildMemberResponseToGuildMember(response);
	}
	async fetchGuildMembers({ skip, limit, sortBy, guildId, campaignContract, includeGuildInfo }) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_campaign_rpc_pb.ListGuildMembersRequest.create();
		request.guildId = guildId;
		request.campaignContract = campaignContract;
		request.includeGuildInfo = includeGuildInfo;
		if (sortBy) request.sortBy = sortBy;
		if (skip) request.skip = skip;
		if (limit) request.limit = limit;
		const response = await this.executeGrpcCall(request, this.client.listGuildMembers.bind(this.client));
		return IndexerCampaignTransformer.GuildMembersResponseToGuildMembers(response);
	}
};

//#endregion
//#region src/client/indexer/grpc/IndexerGrpcArchiverApi.ts
/**
* @category Indexer Grpc API
*/
var IndexerGrpcArchiverApi = class extends require_BaseIndexerGrpcConsumer.BaseIndexerGrpcConsumer {
	constructor(..._args) {
		super(..._args);
		require_defineProperty._defineProperty(this, "module", require_IndexerGrpcWeb3GwApi.IndexerModule.Archiver);
	}
	get client() {
		return this.initClient(__injectivelabs_indexer_proto_ts_v2_generated_injective_archiver_rpc_pb_client.InjectiveArchiverRPCClient);
	}
	async fetchHistoricalBalance({ account, resolution }) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_archiver_rpc_pb.BalanceRequest.create();
		request.account = account;
		request.resolution = resolution;
		const response = await this.executeGrpcCall(request, this.client.balance.bind(this.client));
		return IndexerGrpcArchiverTransformer.grpcHistoricalBalanceResponseToHistoricalBalances(response);
	}
	async fetchHistoricalRpnl({ account, resolution }) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_archiver_rpc_pb.RpnlRequest.create();
		request.account = account;
		request.resolution = resolution;
		const response = await this.executeGrpcCall(request, this.client.rpnl.bind(this.client));
		return IndexerGrpcArchiverTransformer.grpcHistoricalRPNLResponseToHistoricalRPNL(response);
	}
	async fetchHistoricalVolumes({ account, resolution }) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_archiver_rpc_pb.VolumesRequest.create();
		request.account = account;
		request.resolution = resolution;
		const response = await this.executeGrpcCall(request, this.client.volumes.bind(this.client));
		return IndexerGrpcArchiverTransformer.grpcHistoricalVolumesResponseToHistoricalVolumes(response);
	}
	async fetchPnlLeaderboard({ startDate, endDate, limit, account }) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_archiver_rpc_pb.PnlLeaderboardRequest.create();
		request.startDate = BigInt(startDate);
		request.endDate = BigInt(endDate);
		if (limit) request.limit = limit;
		if (account) request.account = account;
		const response = await this.executeGrpcCall(request, this.client.pnlLeaderboard.bind(this.client));
		return IndexerGrpcArchiverTransformer.grpcPnlLeaderboardResponseToPnlLeaderboard(response);
	}
	async fetchVolLeaderboard({ startDate, endDate, limit, account }) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_archiver_rpc_pb.VolLeaderboardRequest.create();
		request.startDate = BigInt(startDate);
		request.endDate = BigInt(endDate);
		if (limit) request.limit = limit;
		if (account) request.account = account;
		const response = await this.executeGrpcCall(request, this.client.volLeaderboard.bind(this.client));
		return IndexerGrpcArchiverTransformer.grpcVolLeaderboardResponseToVolLeaderboard(response);
	}
	async fetchPnlLeaderboardFixedResolution({ resolution, limit, account }) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_archiver_rpc_pb.PnlLeaderboardFixedResolutionRequest.create();
		request.resolution = resolution;
		if (limit) request.limit = limit;
		if (account) request.account = account;
		const response = await this.executeGrpcCall(request, this.client.pnlLeaderboardFixedResolution.bind(this.client));
		return IndexerGrpcArchiverTransformer.grpcPnlLeaderboardFixedResolutionResponseToPnlLeaderboard(response);
	}
	async fetchVolLeaderboardFixedResolution({ resolution, limit, account }) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_archiver_rpc_pb.VolLeaderboardFixedResolutionRequest.create();
		request.resolution = resolution;
		if (limit) request.limit = limit;
		if (account) request.account = account;
		const response = await this.executeGrpcCall(request, this.client.volLeaderboardFixedResolution.bind(this.client));
		return IndexerGrpcArchiverTransformer.grpcVolLeaderboardFixedResolutionResponseToVolLeaderboard(response);
	}
	async fetchDenomHolders({ denom, token, limit }) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_archiver_rpc_pb.DenomHoldersRequest.create();
		request.denom = denom;
		if (token) request.token = token;
		if (limit) request.limit = limit;
		const response = await this.executeGrpcCall(request, this.client.denomHolders.bind(this.client));
		return IndexerGrpcArchiverTransformer.grpcDenomHoldersResponseToDenomHolders(response);
	}
	async fetchAccountStats({ account, period }) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_archiver_rpc_pb.AccountStatsRequest.create();
		request.account = account;
		if (period) request.period = period;
		const response = await this.executeGrpcCall(request, this.client.accountStats.bind(this.client));
		return IndexerGrpcArchiverTransformer.grpcAccountStatsResponseToAccountStats(response);
	}
};

//#endregion
//#region src/client/indexer/grpc/IndexerGrpcReferralApi.ts
/**
* @category Indexer Grpc API
*/
var IndexerGrpcReferralApi = class extends require_BaseIndexerGrpcConsumer.BaseIndexerGrpcConsumer {
	constructor(..._args) {
		super(..._args);
		require_defineProperty._defineProperty(this, "module", require_IndexerGrpcWeb3GwApi.IndexerModule.Referral);
	}
	get client() {
		return this.initClient(__injectivelabs_indexer_proto_ts_v2_generated_injective_referral_rpc_pb_client.InjectiveReferralRPCClient);
	}
	async fetchReferrerDetails(address) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_referral_rpc_pb.GetReferrerDetailsRequest.create();
		request.referrerAddress = address;
		const response = await this.executeGrpcCall(request, this.client.getReferrerDetails.bind(this.client));
		return IndexerGrpcReferralTransformer.referrerDetailsResponseToReferrerDetails(address, response);
	}
	async fetchInviteeDetails(address) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_referral_rpc_pb.GetInviteeDetailsRequest.create();
		request.inviteeAddress = address;
		const response = await this.executeGrpcCall(request, this.client.getInviteeDetails.bind(this.client));
		return IndexerGrpcReferralTransformer.inviteeDetailsResponseToInviteeDetails(response);
	}
	async fetchReferrerByCode(code) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_referral_rpc_pb.GetReferrerByCodeRequest.create();
		request.referralCode = code;
		const response = await this.executeGrpcCall(request, this.client.getReferrerByCode.bind(this.client));
		return IndexerGrpcReferralTransformer.referrerByCodeResponseToReferrerByCode(response);
	}
};

//#endregion
//#region src/client/indexer/grpc/IndexerGrpcMegaVaultApi.ts
/**
* @category Indexer Grpc API
*/
var IndexerGrpcMegaVaultApi = class extends require_BaseIndexerGrpcConsumer.BaseIndexerGrpcConsumer {
	constructor(..._args) {
		super(..._args);
		require_defineProperty._defineProperty(this, "module", require_IndexerGrpcWeb3GwApi.IndexerModule.MegaVault);
	}
	get client() {
		return this.initClient(__injectivelabs_indexer_proto_ts_v2_generated_injective_megavault_rpc_pb_client.InjectiveMegavaultRPCClient);
	}
	async fetchVault({ vaultAddress }) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_megavault_rpc_pb.GetVaultRequest.create();
		request.vaultAddress = vaultAddress;
		const response = await this.executeGrpcCall(request, this.client.getVault.bind(this.client));
		return IndexerGrpcMegaVaultTransformer.vaultResponseToVault(response);
	}
	async fetchVaultUser({ vaultAddress, userAddress }) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_megavault_rpc_pb.GetUserRequest.create();
		request.vaultAddress = vaultAddress;
		request.userAddress = userAddress;
		const response = await this.executeGrpcCall(request, this.client.getUser.bind(this.client));
		return IndexerGrpcMegaVaultTransformer.userResponseToUser(response);
	}
	async fetchVaultSubscriptions({ token, status, perPage, userAddress, vaultAddress }) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_megavault_rpc_pb.ListSubscriptionsRequest.create();
		request.vaultAddress = vaultAddress;
		request.userAddress = userAddress;
		if (status) request.status = status;
		if (perPage) request.perPage = perPage;
		if (token) request.token = token;
		const response = await this.executeGrpcCall(request, this.client.listSubscriptions.bind(this.client));
		return IndexerGrpcMegaVaultTransformer.subscriptionsResponseToSubscriptions(response);
	}
	async fetchVaultRedemptions({ token, status, perPage, userAddress, vaultAddress }) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_megavault_rpc_pb.ListRedemptionsRequest.create();
		request.vaultAddress = vaultAddress;
		request.userAddress = userAddress;
		if (status) request.status = status;
		if (perPage) request.perPage = perPage;
		if (token) request.token = token;
		const response = await this.executeGrpcCall(request, this.client.listRedemptions.bind(this.client));
		return IndexerGrpcMegaVaultTransformer.redemptionsResponseToRedemptions(response);
	}
	async fetchOperatorRedemptionBuckets({ vaultAddress, operatorAddress }) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_megavault_rpc_pb.GetOperatorRedemptionBucketsRequest.create();
		request.vaultAddress = vaultAddress;
		request.operatorAddress = operatorAddress;
		const response = await this.executeGrpcCall(request, this.client.getOperatorRedemptionBuckets.bind(this.client));
		return IndexerGrpcMegaVaultTransformer.operatorRedemptionBucketsResponseToOperatorRedemptionBuckets(response);
	}
	async fetchVaultTvlHistory({ since, vaultAddress, maxDataPoints }) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_megavault_rpc_pb.TvlHistoryRequest.create();
		request.vaultAddress = vaultAddress;
		request.since = BigInt(since);
		if (maxDataPoints) request.maxDataPoints = maxDataPoints;
		const response = await this.executeGrpcCall(request, this.client.tvlHistory.bind(this.client));
		return IndexerGrpcMegaVaultTransformer.tvlHistoryResponseToTvlHistory(response);
	}
	async fetchVaultPnlHistory({ since, vaultAddress, maxDataPoints }) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_megavault_rpc_pb.PnlHistoryRequest.create();
		request.vaultAddress = vaultAddress;
		request.since = BigInt(since);
		if (maxDataPoints) request.maxDataPoints = maxDataPoints;
		const response = await this.executeGrpcCall(request, this.client.pnlHistory.bind(this.client));
		return IndexerGrpcMegaVaultTransformer.pnlHistoryResponseToPnlHistory(response);
	}
};

//#endregion
//#region src/client/indexer/grpc/IndexerGrpcDerivativesApi.ts
/**
* @category Indexer Grpc API
*/
var IndexerGrpcDerivativesApi = class extends require_BaseIndexerGrpcConsumer.BaseIndexerGrpcConsumer {
	constructor(..._args) {
		super(..._args);
		require_defineProperty._defineProperty(this, "module", require_IndexerGrpcWeb3GwApi.IndexerModule.Derivatives);
	}
	get client() {
		return this.initClient(__injectivelabs_indexer_proto_ts_v2_generated_injective_derivative_exchange_rpc_pb_client.InjectiveDerivativeExchangeRPCClient);
	}
	async fetchMarkets(params) {
		const { marketStatus, quoteDenom, marketStatuses } = params || {};
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_derivative_exchange_rpc_pb.MarketsRequest.create();
		if (marketStatus) request.marketStatus = marketStatus;
		if (marketStatuses) request.marketStatuses = marketStatuses;
		if (quoteDenom) request.quoteDenom = quoteDenom;
		const response = await this.executeGrpcCall(request, this.client.markets.bind(this.client));
		return IndexerGrpcDerivativeTransformer.marketsResponseToMarkets(response);
	}
	async fetchMarket(marketId) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_derivative_exchange_rpc_pb.MarketRequest.create();
		request.marketId = marketId;
		const response = await this.executeGrpcCall(request, this.client.market.bind(this.client));
		return IndexerGrpcDerivativeTransformer.marketResponseToMarket(response);
	}
	async fetchBinaryOptionsMarkets(params) {
		const { marketStatus, quoteDenom, pagination } = params || {};
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_derivative_exchange_rpc_pb.BinaryOptionsMarketsRequest.create();
		if (marketStatus) request.marketStatus = marketStatus;
		if (quoteDenom) request.quoteDenom = quoteDenom;
		if (pagination) {
			if (pagination.skip !== void 0) request.skip = BigInt(pagination.skip);
			if (pagination.limit !== void 0) request.limit = pagination.limit;
		}
		const response = await this.executeGrpcCall(request, this.client.binaryOptionsMarkets.bind(this.client));
		return IndexerGrpcDerivativeTransformer.binaryOptionsMarketResponseWithPaginationToBinaryOptionsMarket(response);
	}
	async fetchBinaryOptionsMarket(marketId) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_derivative_exchange_rpc_pb.BinaryOptionsMarketRequest.create();
		request.marketId = marketId;
		const response = await this.executeGrpcCall(request, this.client.binaryOptionsMarket.bind(this.client));
		return IndexerGrpcDerivativeTransformer.binaryOptionsMarketResponseToBinaryOptionsMarket(response);
	}
	/** @deprecated - use fetchOrderbookV2 */
	async fetchOrderbook(_marketId) {
		throw new __injectivelabs_exceptions.GeneralException(/* @__PURE__ */ new Error("deprecated - use fetchOrderbookV2"));
	}
	async fetchOrders(params) {
		const { cid, marketId, marketIds, orderSide, pagination, isConditional, subaccountId, tradeId } = params || {};
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_derivative_exchange_rpc_pb.OrdersRequest.create();
		if (marketId) request.marketId = marketId;
		if (marketIds) request.marketIds = marketIds;
		if (subaccountId) request.subaccountId = subaccountId;
		if (orderSide) request.orderSide = orderSide;
		if (isConditional !== void 0) request.isConditional = isConditional ? "true" : "false";
		if (cid) request.cid = cid;
		if (tradeId) request.tradeId = tradeId;
		if (pagination) {
			if (pagination.skip !== void 0) request.skip = BigInt(pagination.skip);
			if (pagination.limit !== void 0) request.limit = pagination.limit;
			if (pagination.endTime !== void 0) request.endTime = BigInt(pagination.endTime);
			if (pagination.startTime !== void 0) request.startTime = BigInt(pagination.startTime);
		}
		const response = await this.executeGrpcCall(request, this.client.orders.bind(this.client));
		return IndexerGrpcDerivativeTransformer.ordersResponseToOrders(response);
	}
	async fetchOrderHistory(params) {
		const { cid, state, tradeId, marketId, marketIds, direction, pagination, orderTypes, subaccountId, isConditional, executionTypes } = params || {};
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_derivative_exchange_rpc_pb.OrdersHistoryRequest.create();
		if (subaccountId) request.subaccountId = subaccountId;
		if (marketId) request.marketId = marketId;
		if (marketIds) request.marketIds = marketIds;
		if (orderTypes) request.orderTypes = orderTypes;
		if (executionTypes) request.executionTypes = executionTypes;
		if (direction) request.direction = direction;
		if (isConditional !== void 0) request.isConditional = isConditional ? "true" : "false";
		if (state) request.state = state;
		if (cid) request.cid = cid;
		if (tradeId) request.tradeId = tradeId;
		if (pagination) {
			if (pagination.skip !== void 0) request.skip = BigInt(pagination.skip);
			if (pagination.limit !== void 0) request.limit = pagination.limit;
			if (pagination.endTime !== void 0) request.endTime = BigInt(pagination.endTime);
			if (pagination.startTime !== void 0) request.startTime = BigInt(pagination.startTime);
		}
		const response = await this.executeGrpcCall(request, this.client.ordersHistory.bind(this.client));
		return IndexerGrpcDerivativeTransformer.orderHistoryResponseToOrderHistory(response, isConditional);
	}
	async fetchPositions(params) {
		const { marketId, marketIds, subaccountId, direction, pagination } = params || {};
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_derivative_exchange_rpc_pb.PositionsRequest.create();
		if (marketId) request.marketId = marketId;
		if (marketIds) request.marketIds = marketIds;
		if (direction) request.direction = direction;
		if (subaccountId) request.subaccountId = subaccountId;
		if (pagination) {
			if (pagination.skip !== void 0) request.skip = BigInt(pagination.skip);
			if (pagination.limit !== void 0) request.limit = pagination.limit;
			if (pagination.endTime !== void 0) request.endTime = BigInt(pagination.endTime);
			if (pagination.startTime !== void 0) request.startTime = BigInt(pagination.startTime);
		}
		const response = await this.executeGrpcCall(request, this.client.positions.bind(this.client));
		return IndexerGrpcDerivativeTransformer.positionsResponseToPositions(response);
	}
	async fetchPositionsV2(params) {
		const { marketId, marketIds, subaccountId, direction, pagination, address } = params || {};
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_derivative_exchange_rpc_pb.PositionsV2Request.create();
		if (marketId) request.marketId = marketId;
		if (address) request.accountAddress = address;
		if (marketIds) request.marketIds = marketIds;
		if (direction) request.direction = direction;
		if (subaccountId) request.subaccountId = subaccountId;
		if (pagination) {
			if (pagination.skip !== void 0) request.skip = BigInt(pagination.skip);
			if (pagination.limit !== void 0) request.limit = pagination.limit;
			if (pagination.endTime !== void 0) request.endTime = BigInt(pagination.endTime);
			if (pagination.startTime !== void 0) request.startTime = BigInt(pagination.startTime);
		}
		const response = await this.executeGrpcCall(request, this.client.positionsV2.bind(this.client));
		return IndexerGrpcDerivativeTransformer.positionsV2ResponseToPositionsV2(response);
	}
	async fetchTrades(params) {
		const { endTime, tradeId, marketId, startTime, direction, marketIds, pagination, subaccountId, executionSide, executionTypes, accountAddress, cid } = params || {};
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_derivative_exchange_rpc_pb.TradesRequest.create();
		if (marketId) request.marketId = marketId;
		if (subaccountId) request.subaccountId = subaccountId;
		if (tradeId) request.tradeId = tradeId;
		if (accountAddress) request.accountAddress = accountAddress;
		if (marketIds) request.marketIds = marketIds;
		if (executionTypes) request.executionTypes = executionTypes;
		if (executionSide) request.executionSide = executionSide;
		if (direction) request.direction = direction;
		if (startTime) request.startTime = BigInt(startTime);
		if (endTime) request.endTime = BigInt(endTime);
		if (cid) request.cid = cid;
		if (pagination) {
			if (pagination.skip !== void 0) request.skip = BigInt(pagination.skip);
			if (pagination.limit !== void 0) request.limit = pagination.limit;
			if (pagination.endTime !== void 0) request.endTime = BigInt(pagination.endTime);
			if (pagination.startTime !== void 0) request.startTime = BigInt(pagination.startTime);
		}
		const response = await this.executeGrpcCall(request, this.client.trades.bind(this.client));
		return IndexerGrpcDerivativeTransformer.tradesResponseToTrades(response);
	}
	async fetchFundingPayments(params) {
		const { marketId, marketIds, subaccountId, pagination } = params || {};
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_derivative_exchange_rpc_pb.FundingPaymentsRequest.create();
		if (marketId) request.marketId = marketId;
		if (subaccountId) request.subaccountId = subaccountId;
		if (marketIds) request.marketIds = marketIds;
		if (pagination) {
			if (pagination.skip !== void 0) request.skip = BigInt(pagination.skip);
			if (pagination.limit !== void 0) request.limit = pagination.limit;
			if (pagination.endTime !== void 0) request.endTime = BigInt(pagination.endTime);
		}
		const response = await this.executeGrpcCall(request, this.client.fundingPayments.bind(this.client));
		return IndexerGrpcDerivativeTransformer.fundingPaymentsResponseToFundingPayments(response);
	}
	async fetchFundingRates(params) {
		const { marketId, pagination } = params || {};
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_derivative_exchange_rpc_pb.FundingRatesRequest.create();
		if (marketId) request.marketId = marketId;
		if (pagination) {
			if (pagination.skip !== void 0) request.skip = BigInt(pagination.skip);
			if (pagination.limit !== void 0) request.limit = pagination.limit;
		}
		const response = await this.executeGrpcCall(request, this.client.fundingRates.bind(this.client));
		return IndexerGrpcDerivativeTransformer.fundingRatesResponseToFundingRates(response);
	}
	async fetchSubaccountOrdersList(params) {
		const { marketId, subaccountId, pagination } = params || {};
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_derivative_exchange_rpc_pb.SubaccountOrdersListRequest.create();
		if (marketId) request.marketId = marketId;
		if (subaccountId) request.subaccountId = subaccountId;
		if (pagination) {
			if (pagination.skip !== void 0) request.skip = BigInt(pagination.skip);
			if (pagination.limit !== void 0) request.limit = pagination.limit;
		}
		const response = await this.executeGrpcCall(request, this.client.subaccountOrdersList.bind(this.client));
		return IndexerGrpcDerivativeTransformer.ordersResponseToOrders(response);
	}
	async fetchSubaccountTradesList(params) {
		const { marketId, subaccountId, direction, executionType, pagination } = params || {};
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_derivative_exchange_rpc_pb.SubaccountTradesListRequest.create();
		if (marketId) request.marketId = marketId;
		if (subaccountId) request.subaccountId = subaccountId;
		if (direction) request.direction = direction;
		if (executionType) request.executionType = executionType;
		if (pagination) {
			if (pagination.skip !== void 0) request.skip = BigInt(pagination.skip);
			if (pagination.limit !== void 0) request.limit = pagination.limit;
		}
		const response = await this.executeGrpcCall(request, this.client.subaccountTradesList.bind(this.client));
		return IndexerGrpcDerivativeTransformer.subaccountTradesListResponseToSubaccountTradesList(response);
	}
	/** @deprecated - use fetchOrderbooksV2 */
	async fetchOrderbooks(_marketIds) {
		throw new __injectivelabs_exceptions.GeneralException(/* @__PURE__ */ new Error("deprecated - use fetchOrderbooksV2"));
	}
	async fetchOrderbooksV2(marketIds) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_derivative_exchange_rpc_pb.OrderbooksV2Request.create();
		if (marketIds.length > 0) request.marketIds = marketIds;
		const response = await this.executeGrpcCall(request, this.client.orderbooksV2.bind(this.client));
		return IndexerGrpcDerivativeTransformer.orderbooksV2ResponseToOrderbooksV2(response);
	}
	async fetchOrderbookV2(marketId) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_derivative_exchange_rpc_pb.OrderbookV2Request.create();
		request.marketId = marketId;
		const response = await this.executeGrpcCall(request, this.client.orderbookV2.bind(this.client));
		return IndexerGrpcDerivativeTransformer.orderbookV2ResponseToOrderbookV2(response);
	}
};

//#endregion
//#region src/client/indexer/grpc/IndexerGrpcPortfolioApi.ts
/**
* @category Indexer Grpc API
*/
var IndexerGrpcAccountPortfolioApi = class extends require_BaseIndexerGrpcConsumer.BaseIndexerGrpcConsumer {
	constructor(..._args) {
		super(..._args);
		require_defineProperty._defineProperty(this, "module", require_IndexerGrpcWeb3GwApi.IndexerModule.Portfolio);
	}
	get client() {
		return this.initClient(__injectivelabs_indexer_proto_ts_v2_generated_injective_portfolio_rpc_pb_client.InjectivePortfolioRPCClient);
	}
	async fetchAccountPortfolio(address) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_portfolio_rpc_pb.AccountPortfolioRequest.create();
		request.accountAddress = address;
		try {
			const response = await this.executeGrpcCall(request, this.client.accountPortfolio.bind(this.client));
			return IndexerGrpcAccountPortfolioTransformer.accountPortfolioResponseToAccountPortfolio(response, address);
		} catch (e) {
			if ((e === null || e === void 0 ? void 0 : e.message) === "account address not found") return {
				accountAddress: address || "",
				bankBalancesList: [],
				subaccountsList: [],
				positionsWithUpnlList: []
			};
			throw e;
		}
	}
	async fetchAccountPortfolioBalances(address) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_portfolio_rpc_pb.AccountPortfolioBalancesRequest.create();
		request.accountAddress = address;
		try {
			const response = await this.executeGrpcCall(request, this.client.accountPortfolioBalances.bind(this.client));
			return IndexerGrpcAccountPortfolioTransformer.accountPortfolioBalancesResponseToAccountPortfolioBalances(response, address);
		} catch (e) {
			if ((e === null || e === void 0 ? void 0 : e.message) === "account address not found") return {
				accountAddress: address || "",
				bankBalancesList: [],
				subaccountsList: []
			};
			throw e;
		}
	}
};

//#endregion
//#region src/client/indexer/grpc/IndexerGrpcInsuranceFundApi.ts
/**
* @category Indexer Grpc API
*/
var IndexerGrpcInsuranceFundApi = class extends require_BaseIndexerGrpcConsumer.BaseIndexerGrpcConsumer {
	constructor(..._args) {
		super(..._args);
		require_defineProperty._defineProperty(this, "module", require_IndexerGrpcWeb3GwApi.IndexerModule.InsuranceFund);
	}
	get client() {
		return this.initClient(__injectivelabs_indexer_proto_ts_v2_generated_injective_insurance_rpc_pb_client.InjectiveInsuranceRPCClient);
	}
	async fetchRedemptions({ denom, address, status }) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_insurance_rpc_pb.RedemptionsRequest.create();
		request.redeemer = address;
		if (denom) request.redemptionDenom = denom;
		if (status) request.status = status;
		const response = await this.executeGrpcCall(request, this.client.redemptions.bind(this.client));
		return IndexerGrpcInsuranceFundTransformer.redemptionsResponseToRedemptions(response);
	}
	async fetchInsuranceFunds() {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_insurance_rpc_pb.FundsRequest.create();
		const response = await this.executeGrpcCall(request, this.client.funds.bind(this.client));
		return IndexerGrpcInsuranceFundTransformer.insuranceFundsResponseToInsuranceFunds(response);
	}
};

//#endregion
//#region src/client/indexer/rest/IndexerRestExplorerApi.ts
const explorerEndpointSuffix = "api/explorer/v1";
/**
* @category Indexer Rest API
*/
var IndexerRestExplorerApi = class extends require_BaseRestConsumer.BaseRestConsumer {
	constructor(endpoint) {
		super(endpoint.includes(explorerEndpointSuffix) ? endpoint : `${endpoint}/${explorerEndpointSuffix}`);
	}
	async fetchBlock(blockHashHeight) {
		const endpoint = `blocks/${blockHashHeight}`;
		try {
			const response = await this.retry(() => this.get(`blocks/${blockHashHeight}`));
			return IndexerRestExplorerTransformer.blockWithTxToBlockWithTx(response.data.data);
		} catch (e) {
			if (e instanceof __injectivelabs_exceptions.HttpRequestException) throw e;
			throw new __injectivelabs_exceptions.HttpRequestException(new Error(e), {
				code: __injectivelabs_exceptions.UnspecifiedErrorCode,
				context: `${this.endpoint}/${endpoint}`,
				contextModule: require_IndexerGrpcWeb3GwApi.IndexerModule.Explorer
			});
		}
	}
	async fetchBlocks(params) {
		const endpoint = "blocks";
		try {
			const { before, limit, from, to } = params || { limit: 12 };
			const { paging, data } = (await this.retry(() => this.get(endpoint, {
				before,
				limit,
				from,
				to
			}))).data;
			return {
				paging,
				blocks: IndexerRestExplorerTransformer.blocksToBlocks(data)
			};
		} catch (e) {
			if (e instanceof __injectivelabs_exceptions.HttpRequestException) throw e;
			throw new __injectivelabs_exceptions.HttpRequestException(new Error(e), {
				code: __injectivelabs_exceptions.UnspecifiedErrorCode,
				context: `${this.endpoint}/${endpoint}`,
				contextModule: require_IndexerGrpcWeb3GwApi.IndexerModule.Explorer
			});
		}
	}
	async fetchBlocksWithTx(params) {
		const endpoint = "blocks";
		try {
			const { before, limit, from, to } = params || { limit: 12 };
			const { paging, data } = (await this.retry(() => this.get(endpoint, {
				before,
				limit,
				from,
				to
			}))).data;
			return {
				paging,
				blocks: data ? IndexerRestExplorerTransformer.blocksWithTxsToBlocksWithTxs(data) : []
			};
		} catch (e) {
			if (e instanceof __injectivelabs_exceptions.HttpRequestException) throw e;
			throw new __injectivelabs_exceptions.HttpRequestException(new Error(e), {
				code: __injectivelabs_exceptions.UnspecifiedErrorCode,
				context: `${this.endpoint}/${endpoint}`,
				contextModule: require_IndexerGrpcWeb3GwApi.IndexerModule.Explorer
			});
		}
	}
	async fetchTransactions(params) {
		const endpoint = "txs";
		try {
			const { type, skip, after, limit, before, status, endTime, toNumber, startTime, fromNumber } = params || { limit: 12 };
			const { paging, data } = (await this.retry(() => this.get(endpoint, {
				skip,
				limit,
				after,
				before,
				status,
				end_time: endTime,
				to_number: toNumber,
				start_time: startTime,
				from_number: fromNumber,
				type: type ? type.join(",") : void 0
			}))).data;
			return {
				paging,
				transactions: data ? IndexerRestExplorerTransformer.transactionsToTransactions(data) : []
			};
		} catch (e) {
			if (e instanceof __injectivelabs_exceptions.HttpRequestException) throw e;
			throw new __injectivelabs_exceptions.HttpRequestException(new Error(e), {
				code: __injectivelabs_exceptions.UnspecifiedErrorCode,
				context: `${this.endpoint}/${endpoint}`,
				contextModule: require_IndexerGrpcWeb3GwApi.IndexerModule.Explorer
			});
		}
	}
	async fetchAccountTransactions({ account, params }) {
		const endpoint = `accountTxs/${account}`;
		try {
			const { type, skip, limit, after, before, status, endTime, toNumber, startTime, fromNumber, withClaimId } = params || { limit: 12 };
			const { paging, data } = (await this.retry(() => this.get(endpoint, {
				skip,
				limit,
				after,
				before,
				status,
				end_time: endTime,
				to_number: toNumber,
				start_time: startTime,
				from_number: fromNumber,
				type: type ? type.join(",") : void 0,
				with_claim_id: withClaimId
			}))).data;
			return {
				paging,
				transactions: data ? IndexerRestExplorerTransformer.transactionsToTransactions(data) : []
			};
		} catch (e) {
			if (e instanceof __injectivelabs_exceptions.HttpRequestException) throw e;
			throw new __injectivelabs_exceptions.HttpRequestException(new Error(e), {
				code: __injectivelabs_exceptions.UnspecifiedErrorCode,
				context: `${this.endpoint}/${endpoint}`,
				contextModule: require_IndexerGrpcWeb3GwApi.IndexerModule.Explorer
			});
		}
	}
	async fetchTransaction(hash, isEvmTx = false) {
		const endpoint = `txs/${hash}`;
		try {
			const response = await this.retry(() => this.get(endpoint, { is_evm_hash: isEvmTx }));
			return IndexerRestExplorerTransformer.transactionToTransaction(response.data.data);
		} catch (e) {
			if (e instanceof __injectivelabs_exceptions.HttpRequestException) throw e;
			throw new __injectivelabs_exceptions.HttpRequestException(new Error(e), {
				code: __injectivelabs_exceptions.UnspecifiedErrorCode,
				contextModule: require_IndexerGrpcWeb3GwApi.IndexerModule.Explorer
			});
		}
	}
	async fetchValidators() {
		const endpoint = "validators";
		try {
			const response = await this.retry(() => this.get(endpoint));
			if (!response.data || !response.data.data) return [];
			return IndexerRestExplorerTransformer.validatorExplorerToValidator(response.data.data);
		} catch (e) {
			if (e instanceof __injectivelabs_exceptions.HttpRequestException) throw e;
			throw new __injectivelabs_exceptions.HttpRequestException(new Error(e), {
				code: __injectivelabs_exceptions.UnspecifiedErrorCode,
				context: `${this.endpoint}/${endpoint}`,
				contextModule: require_IndexerGrpcWeb3GwApi.IndexerModule.Explorer
			});
		}
	}
	async fetchValidatorUptime(validatorConsensusAddress) {
		const endpoint = `validator_uptime/${validatorConsensusAddress}`;
		try {
			const response = await this.retry(() => this.get(endpoint));
			if (!response.data || !response.data.data) return [];
			return IndexerRestExplorerTransformer.validatorUptimeToExplorerValidatorUptime(response.data.data);
		} catch (e) {
			if (e instanceof __injectivelabs_exceptions.HttpRequestException) throw e;
			throw new __injectivelabs_exceptions.HttpRequestException(new Error(e), {
				code: __injectivelabs_exceptions.UnspecifiedErrorCode,
				context: `${this.endpoint}/${endpoint}`,
				contextModule: require_IndexerGrpcWeb3GwApi.IndexerModule.Explorer
			});
		}
	}
	async fetchContract(contractAddress) {
		const endpoint = `/wasm/contracts/${contractAddress}`;
		try {
			const response = await this.retry(() => this.get(endpoint));
			return IndexerRestExplorerTransformer.contractToExplorerContract(response.data);
		} catch (e) {
			if (e instanceof __injectivelabs_exceptions.HttpRequestException) throw e;
			throw new __injectivelabs_exceptions.HttpRequestException(new Error(e), {
				code: __injectivelabs_exceptions.UnspecifiedErrorCode,
				context: `${this.endpoint}/${endpoint}`,
				contextModule: require_IndexerGrpcWeb3GwApi.IndexerModule.Explorer
			});
		}
	}
	async fetchContracts(params) {
		const endpoint = `/wasm/contracts`;
		try {
			const { skip, limit, label, token, codeId, lookup, assetsOnly, fromNumber } = params || { limit: 12 };
			const { paging, data } = (await this.retry(() => this.get(endpoint, {
				skip,
				limit,
				label,
				token,
				lookup,
				assets_only: assetsOnly,
				from_number: fromNumber,
				code_id: codeId === null || codeId === void 0 ? void 0 : codeId.toString()
			}))).data;
			return {
				paging,
				contracts: data ? data.map(IndexerRestExplorerTransformer.contractToExplorerContract) : []
			};
		} catch (e) {
			if (e instanceof __injectivelabs_exceptions.HttpRequestException) throw e;
			throw new __injectivelabs_exceptions.HttpRequestException(new Error(e), {
				code: __injectivelabs_exceptions.UnspecifiedErrorCode,
				context: `${this.endpoint}/${endpoint}`,
				contextModule: require_IndexerGrpcWeb3GwApi.IndexerModule.Explorer
			});
		}
	}
	async fetchContractTransactions({ contractAddress, params }) {
		const endpoint = `/contractTxs/${contractAddress}`;
		try {
			const { fromNumber, limit, skip, toNumber } = params || { limit: 12 };
			const { paging, data } = (await this.retry(() => this.get(endpoint, {
				skip,
				limit,
				to_number: toNumber,
				from_number: fromNumber
			}))).data;
			return {
				paging,
				transactions: data ? data.map(IndexerRestExplorerTransformer.contractTransactionToExplorerContractTransaction) : []
			};
		} catch (e) {
			if (e instanceof __injectivelabs_exceptions.HttpRequestException) throw e;
			throw new __injectivelabs_exceptions.HttpRequestException(new Error(e), {
				code: __injectivelabs_exceptions.UnspecifiedErrorCode,
				context: `${this.endpoint}/${endpoint}`,
				contextModule: require_IndexerGrpcWeb3GwApi.IndexerModule.Explorer
			});
		}
	}
	async fetchContractTransactionsWithMessages({ contractAddress, params }) {
		const endpoint = `/contractTxs/${contractAddress}`;
		try {
			const { fromNumber, limit, skip, toNumber } = params || { limit: 12 };
			const { paging, data } = (await this.retry(() => this.get(endpoint, {
				skip,
				limit,
				to_number: toNumber,
				from_number: fromNumber
			}))).data;
			return {
				paging,
				transactions: data ? data.map(IndexerRestExplorerTransformer.contractTransactionToExplorerContractTransactionWithMessages) : []
			};
		} catch (e) {
			if (e instanceof __injectivelabs_exceptions.HttpRequestException) throw e;
			throw new __injectivelabs_exceptions.HttpRequestException(new Error(e), {
				code: __injectivelabs_exceptions.UnspecifiedErrorCode,
				context: `${this.endpoint}/${endpoint}`,
				contextModule: require_IndexerGrpcWeb3GwApi.IndexerModule.Explorer
			});
		}
	}
	async fetchWasmCode(codeId) {
		const endpoint = `/wasm/codes/${codeId}`;
		try {
			const response = await this.retry(() => this.get(endpoint));
			return IndexerRestExplorerTransformer.wasmCodeToExplorerWasmCode(response.data);
		} catch (e) {
			if (e instanceof __injectivelabs_exceptions.HttpRequestException) throw e;
			throw new __injectivelabs_exceptions.HttpRequestException(new Error(e), {
				code: __injectivelabs_exceptions.UnspecifiedErrorCode,
				context: `${this.endpoint}/${endpoint}`,
				contextModule: require_IndexerGrpcWeb3GwApi.IndexerModule.Explorer
			});
		}
	}
	async fetchWasmCodes(params) {
		const endpoint = `/wasm/codes`;
		try {
			const { fromNumber, limit, toNumber } = params || { limit: 12 };
			const { paging, data } = (await this.retry(() => this.get(endpoint, {
				limit,
				from_number: fromNumber,
				to_number: toNumber
			}))).data;
			return {
				paging,
				wasmCodes: data ? data.map(IndexerRestExplorerTransformer.wasmCodeToExplorerWasmCode) : []
			};
		} catch (e) {
			if (e instanceof __injectivelabs_exceptions.HttpRequestException) throw e;
			throw new __injectivelabs_exceptions.HttpRequestException(new Error(e), {
				code: __injectivelabs_exceptions.UnspecifiedErrorCode,
				context: `${this.endpoint}/${endpoint}`,
				contextModule: require_IndexerGrpcWeb3GwApi.IndexerModule.Explorer
			});
		}
	}
	async fetchCW20Balances(address) {
		const endpoint = `/wasm/${address}/cw20-balance`;
		try {
			const response = await this.retry(() => this.get(endpoint));
			if (response.data.length === 0) return [];
			return response.data.map(IndexerRestExplorerTransformer.CW20BalanceToExplorerCW20Balance);
		} catch (e) {
			if (e instanceof __injectivelabs_exceptions.HttpRequestException) throw e;
			throw new __injectivelabs_exceptions.HttpRequestException(new Error(e), {
				code: __injectivelabs_exceptions.UnspecifiedErrorCode,
				context: `${this.endpoint}/${endpoint}`,
				contextModule: require_IndexerGrpcWeb3GwApi.IndexerModule.Explorer
			});
		}
	}
	async fetchCW20BalancesNoThrow(address) {
		const endpoint = `/wasm/${address}/cw20-balance`;
		try {
			const response = await this.retry(() => this.get(endpoint));
			if (response.data.length === 0) return [];
			return response.data;
		} catch (e) {
			const error = e;
			if (error.message.includes(404) || error.message.includes(500)) return [];
			if (e instanceof __injectivelabs_exceptions.HttpRequestException) throw e;
			throw new __injectivelabs_exceptions.HttpRequestException(new Error(e), {
				code: __injectivelabs_exceptions.UnspecifiedErrorCode,
				context: `${this.endpoint}/${endpoint}`,
				contextModule: require_IndexerGrpcWeb3GwApi.IndexerModule.Explorer
			});
		}
	}
	async fetchBankTransfers(params) {
		const endpoint = `/bank/transfers`;
		const { endTime, limit, skip, startTime, address, recipients, senders } = params || { limit: 10 };
		try {
			const { data, paging } = (await this.retry(() => this.get(endpoint, {
				skip,
				limit,
				senders,
				address,
				recipients,
				end_time: endTime,
				start_time: startTime,
				is_community_pool_related: params.isCommunitySpendPool
			}))).data;
			return {
				paging,
				data: IndexerRestExplorerTransformer.bankTransfersToBankTransfers(data || [])
			};
		} catch (e) {
			if (e instanceof __injectivelabs_exceptions.HttpRequestException) throw e;
			throw new __injectivelabs_exceptions.HttpRequestException(new Error(e), {
				code: __injectivelabs_exceptions.UnspecifiedErrorCode,
				context: `${this.endpoint}/${endpoint}`,
				contextModule: require_IndexerGrpcWeb3GwApi.IndexerModule.Explorer
			});
		}
	}
};

//#endregion
//#region src/client/indexer/rest/IndexerRestSpotChronosApi.ts
/**
* @category Indexer Chronos API
*/
var IndexerRestSpotChronosApi = class extends require_BaseRestConsumer.BaseRestConsumer {
	async fetchMarketSummary(marketId) {
		const path = `market_summary`;
		try {
			const { data } = await this.retry(() => this.get(path, {
				marketId,
				resolution: "24h"
			}));
			return data;
		} catch (e) {
			if (e instanceof __injectivelabs_exceptions.HttpRequestException) throw e;
			throw new __injectivelabs_exceptions.HttpRequestException(new Error(e), {
				code: __injectivelabs_exceptions.UnspecifiedErrorCode,
				context: `${this.endpoint}/${path}?marketId=${marketId}`,
				contextModule: require_IndexerGrpcWeb3GwApi.IndexerModule.ChronosSpot
			});
		}
	}
	async fetchMarketsSummary() {
		const path = `market_summary_all`;
		try {
			const { data } = await this.retry(() => this.get(path, { resolution: "24h" }));
			return data;
		} catch (e) {
			if (e instanceof __injectivelabs_exceptions.HttpRequestException) throw e;
			throw new __injectivelabs_exceptions.HttpRequestException(new Error(e), {
				code: __injectivelabs_exceptions.UnspecifiedErrorCode,
				context: `${this.endpoint}/${path}`,
				contextModule: require_IndexerGrpcWeb3GwApi.IndexerModule.ChronosSpot
			});
		}
	}
};

//#endregion
//#region src/client/indexer/rest/IndexerRestMarketChronosApi.ts
var IndexerRestMarketChronosApi = class extends require_BaseRestConsumer.BaseRestConsumer {
	async fetchMarketsHistory({ marketIds, resolution, countback }) {
		const pathWithParams = `history?${[
			...marketIds.map((marketId) => ({ marketIDs: marketId })),
			{ resolution: String(resolution) },
			{ countback: String(countback) }
		].map((param) => new URLSearchParams(param)).join("&")}`;
		try {
			const { data } = await this.retry(() => this.get(pathWithParams));
			return data;
		} catch (e) {
			if (e instanceof __injectivelabs_exceptions.HttpRequestException) throw e;
			throw new __injectivelabs_exceptions.HttpRequestException(new Error(e), {
				code: __injectivelabs_exceptions.UnspecifiedErrorCode,
				context: `${this.endpoint}/${pathWithParams}`,
				contextModule: require_IndexerGrpcWeb3GwApi.IndexerModule.ChronosMarkets
			});
		}
	}
};

//#endregion
//#region src/client/indexer/rest/IndexerRestDerivativesChronosApi.ts
/**
* @category Indexer Chronos API
*/
var IndexerRestDerivativesChronosApi = class extends require_BaseRestConsumer.BaseRestConsumer {
	async fetchMarketSummary(marketId) {
		const path = `market_summary`;
		try {
			const { data } = await this.retry(() => this.get(path, {
				marketId,
				resolution: "24h"
			}));
			return data;
		} catch (e) {
			if (e instanceof __injectivelabs_exceptions.HttpRequestException) throw e;
			throw new __injectivelabs_exceptions.HttpRequestException(new Error(e), {
				code: __injectivelabs_exceptions.UnspecifiedErrorCode,
				context: `${this.endpoint}/${path}?marketId=${marketId}`,
				contextModule: require_IndexerGrpcWeb3GwApi.IndexerModule.ChronosDerivative
			});
		}
	}
	async fetchMarketsSummary() {
		const path = `market_summary_all`;
		try {
			const { data } = await this.retry(() => this.get(path, { resolution: "24h" }));
			return data;
		} catch (e) {
			if (e instanceof __injectivelabs_exceptions.HttpRequestException) throw e;
			throw new __injectivelabs_exceptions.HttpRequestException(new Error(e), {
				code: __injectivelabs_exceptions.UnspecifiedErrorCode,
				context: `${this.endpoint}/${path}`,
				contextModule: require_IndexerGrpcWeb3GwApi.IndexerModule.ChronosDerivative
			});
		}
	}
};

//#endregion
//#region src/client/indexer/rest/IndexerRestLeaderboardChronosApi.ts
/**
* @category Indexer Chronos API
*/
var IndexerRestLeaderboardChronosApi = class extends require_BaseRestConsumer.BaseRestConsumer {
	async fetchLeaderboard(resolution) {
		const path = ``;
		try {
			const { data } = await this.retry(() => this.get(path, { resolution }));
			return data;
		} catch (e) {
			if (e instanceof __injectivelabs_exceptions.HttpRequestException) throw e;
			throw new __injectivelabs_exceptions.HttpRequestException(new Error(e), {
				code: __injectivelabs_exceptions.UnspecifiedErrorCode,
				context: `${this.endpoint}`,
				contextModule: "Leaderboard"
			});
		}
	}
};

//#endregion
//#region src/client/indexer/grpc_stream/stream/streamHelpers.ts
/**
* Creates a subscription wrapper for V2 streaming with proper cancellation support.
*
* @param stream - The ServerStreamingCall from the V2 client
* @param handleResponse - Callback to process each stream response
* @param onEndCallback - Optional callback when stream ends normally
* @param onStatusCallback - Optional callback for stream errors
* @returns Subscription object with unsubscribe method
*/
function createStreamSubscription(stream, handleResponse, onEndCallback, onStatusCallback) {
	const abortController = new AbortController();
	const subscription = { unsubscribe: () => {
		abortController.abort();
	} };
	(async () => {
		try {
			for await (const response of stream.responses) {
				if (abortController.signal.aborted) break;
				handleResponse(response);
			}
			if (onEndCallback && !abortController.signal.aborted) onEndCallback();
		} catch (error) {
			if (!abortController.signal.aborted && onStatusCallback) onStatusCallback({
				code: 2,
				details: error instanceof Error ? error.message : "Unknown stream error",
				metadata: error
			});
		}
	})();
	return subscription;
}

//#endregion
//#region src/client/indexer/grpc_stream/stream/IndexerGrpcSpotStream.ts
/**
* @category Indexer Grpc Stream
* @description Provides streaming access to spot market data from Injective Indexer
*/
var IndexerGrpcSpotStream = class {
	constructor(endpoint, metadata) {
		require_defineProperty._defineProperty(this, "client", void 0);
		require_defineProperty._defineProperty(this, "transport", void 0);
		this.transport = new require_BaseGrpcConsumer.GrpcWebRpcTransport(endpoint, metadata);
		this.client = new __injectivelabs_indexer_proto_ts_v2_generated_injective_spot_exchange_rpc_pb_client.InjectiveSpotExchangeRPCClient(this.transport);
	}
	/** @deprecated - use streamOrderbookV2 */
	streamOrderbook(_args) {
		throw new __injectivelabs_exceptions.GeneralException(/* @__PURE__ */ new Error("deprecated - use streamOrderbookV2"));
	}
	/**
	* Stream spot orders
	* @param params - Stream parameters
	* @param params.marketId - Optional market ID to filter orders
	* @param params.subaccountId - Optional subaccount ID to filter orders
	* @param params.orderSide - Optional order side to filter
	* @param params.callback - Called for each order update
	* @param params.onEndCallback - Called when stream ends normally
	* @param params.onStatusCallback - Called on stream errors
	* @returns Subscription object with unsubscribe method
	*/
	streamOrders({ marketId, subaccountId, orderSide, callback, onEndCallback, onStatusCallback }) {
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_spot_exchange_rpc_pb.StreamOrdersRequest.create();
		if (marketId) request.marketId = marketId;
		if (subaccountId) request.subaccountId = subaccountId;
		if (orderSide) request.orderSide = orderSide;
		return createStreamSubscription(this.client.streamOrders(request), (response) => {
			callback(IndexerSpotStreamTransformer.ordersStreamCallback(response));
		}, onEndCallback, onStatusCallback);
	}
	/**
	* Stream spot order history
	* @param params - Stream parameters
	* @param params.marketId - Optional market ID to filter orders
	* @param params.subaccountId - Optional subaccount ID to filter orders
	* @param params.orderTypes - Optional array of order types to filter
	* @param params.executionTypes - Optional array of execution types to filter
	* @param params.direction - Optional trade direction to filter
	* @param params.state - Optional order state to filter
	* @param params.callback - Called for each order history update
	* @param params.onEndCallback - Called when stream ends normally
	* @param params.onStatusCallback - Called on stream errors
	* @returns Subscription object with unsubscribe method
	*/
	streamOrderHistory({ marketId, subaccountId, orderTypes, executionTypes, direction, state, callback, onEndCallback, onStatusCallback }) {
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_spot_exchange_rpc_pb.StreamOrdersHistoryRequest.create();
		if (subaccountId) request.subaccountId = subaccountId;
		if (marketId) request.marketId = marketId;
		if (orderTypes) request.orderTypes = orderTypes;
		if (direction) request.direction = direction;
		if (state) request.state = state;
		if (executionTypes) request.executionTypes = executionTypes;
		return createStreamSubscription(this.client.streamOrdersHistory(request), (response) => {
			callback(IndexerSpotStreamTransformer.orderHistoryStreamCallback(response));
		}, onEndCallback, onStatusCallback);
	}
	/**
	* Stream spot trades
	* @param params - Stream parameters
	* @param params.marketIds - Optional array of market IDs to filter trades
	* @param params.marketId - Optional market ID to filter trades
	* @param params.subaccountIds - Optional array of subaccount IDs to filter trades
	* @param params.subaccountId - Optional subaccount ID to filter trades
	* @param params.pagination - Optional pagination options
	* @param params.direction - Optional trade direction to filter
	* @param params.executionSide - Optional trade execution side to filter
	* @param params.callback - Called for each trade update
	* @param params.onEndCallback - Called when stream ends normally
	* @param params.onStatusCallback - Called on stream errors
	* @returns Subscription object with unsubscribe method
	*/
	streamTrades({ marketIds, marketId, subaccountIds, subaccountId, pagination, direction, executionSide, callback, onEndCallback, onStatusCallback }) {
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_spot_exchange_rpc_pb.StreamTradesRequest.create();
		if (marketIds) request.marketIds = marketIds;
		if (marketId) request.marketId = marketId;
		if (subaccountIds) request.subaccountIds = subaccountIds;
		if (subaccountId) request.subaccountId = subaccountId;
		if (executionSide) request.executionSide = executionSide;
		if (direction) request.direction = direction;
		if (pagination) {
			if (pagination.skip !== void 0) request.skip = BigInt(pagination.skip);
			if (pagination.limit !== void 0) request.limit = pagination.limit;
		}
		return createStreamSubscription(this.client.streamTrades(request), (response) => {
			callback(IndexerSpotStreamTransformer.tradesStreamCallback(response));
		}, onEndCallback, onStatusCallback);
	}
	/**
	* Stream spot market data
	* @param params - Stream parameters
	* @param params.marketIds - Optional array of market IDs to filter
	* @param params.callback - Called for each market update
	* @param params.onEndCallback - Called when stream ends normally
	* @param params.onStatusCallback - Called on stream errors
	* @returns Subscription object with unsubscribe method
	*/
	streamMarkets({ marketIds, callback, onEndCallback, onStatusCallback }) {
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_spot_exchange_rpc_pb.StreamMarketsRequest.create();
		if (marketIds) request.marketIds = marketIds;
		return createStreamSubscription(this.client.streamMarkets(request), (response) => {
			callback(response);
		}, onEndCallback, onStatusCallback);
	}
	/**
	* Stream spot orderbook V2
	* @param params - Stream parameters
	* @param params.marketIds - Array of market IDs to stream orderbook for
	* @param params.callback - Called for each orderbook update
	* @param params.onEndCallback - Called when stream ends normally
	* @param params.onStatusCallback - Called on stream errors
	* @returns Subscription object with unsubscribe method
	*/
	streamOrderbooksV2({ marketIds, callback, onEndCallback, onStatusCallback }) {
		if (!marketIds || marketIds.length === 0) throw new Error("marketIds is required and cannot be empty");
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_spot_exchange_rpc_pb.StreamOrderbookV2Request.create();
		request.marketIds = marketIds;
		return createStreamSubscription(this.client.streamOrderbookV2(request), (response) => {
			callback(IndexerSpotStreamTransformer.orderbookV2StreamCallback(response));
		}, onEndCallback, onStatusCallback);
	}
	/**
	* Stream spot orderbook updates
	* @param params - Stream parameters
	* @param params.marketIds - Array of market IDs to stream orderbook updates for
	* @param params.callback - Called for each orderbook update
	* @param params.onEndCallback - Called when stream ends normally
	* @param params.onStatusCallback - Called on stream errors
	* @returns Subscription object with unsubscribe method
	*/
	streamOrderbookUpdates({ marketIds, callback, onEndCallback, onStatusCallback }) {
		if (!marketIds || marketIds.length === 0) throw new Error("marketIds is required and cannot be empty");
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_spot_exchange_rpc_pb.StreamOrderbookUpdateRequest.create();
		request.marketIds = marketIds;
		return createStreamSubscription(this.client.streamOrderbookUpdate(request), (response) => {
			callback(IndexerSpotStreamTransformer.orderbookUpdateStreamCallback(response));
		}, onEndCallback, onStatusCallback);
	}
};

//#endregion
//#region src/client/indexer/grpc_stream/stream/IndexerGrpcMitoStream.ts
/**
* @category Indexer Grpc Stream
* @description Provides streaming access to Mito vault data from Injective Indexer
*/
var IndexerGrpcMitoStream = class {
	constructor(endpoint, metadata) {
		require_defineProperty._defineProperty(this, "client", void 0);
		require_defineProperty._defineProperty(this, "transport", void 0);
		this.transport = new require_BaseGrpcConsumer.GrpcWebRpcTransport(endpoint, metadata);
		this.client = new __injectivelabs_mito_proto_ts_v2_generated_goadesign_goagen_mito_api_pb_client.MitoAPIClient(this.transport);
	}
	/**
	* Stream vault transfers
	* @param params - Stream parameters
	* @param params.vault - Optional vault address to filter
	* @param params.account - Optional account address to filter
	* @param params.callback - Called for each transfer update
	* @param params.onEndCallback - Called when stream ends normally
	* @param params.onStatusCallback - Called on stream errors
	* @returns Subscription object with unsubscribe method
	*/
	streamTransfers({ vault, account, callback, onEndCallback, onStatusCallback }) {
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_mito_proto_ts_v2_generated_goadesign_goagen_mito_api_pb.StreamTransfersRequest.create();
		if (vault) request.vault = vault;
		if (account) request.account = account;
		return createStreamSubscription(this.client.streamTransfers(request), (response) => {
			callback(IndexerGrpcMitoStreamTransformer.transfersStreamCallback(response));
		}, onEndCallback, onStatusCallback);
	}
	/**
	* Stream vault information
	* @param params - Stream parameters
	* @param params.vault - Optional vault address to filter
	* @param params.callback - Called for each vault update
	* @param params.onEndCallback - Called when stream ends normally
	* @param params.onStatusCallback - Called on stream errors
	* @returns Subscription object with unsubscribe method
	*/
	streamVault({ vault, callback, onEndCallback, onStatusCallback }) {
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_mito_proto_ts_v2_generated_goadesign_goagen_mito_api_pb.StreamVaultRequest.create();
		if (vault) request.vault = vault;
		return createStreamSubscription(this.client.streamVault(request), (response) => {
			callback(IndexerGrpcMitoStreamTransformer.vaultStreamCallback(response));
		}, onEndCallback, onStatusCallback);
	}
	/**
	* Stream vault holder subscriptions
	* @param params - Stream parameters
	* @param params.holderAddress - The holder address to stream subscriptions for
	* @param params.vaultAddress - Optional vault address to filter
	* @param params.stakingContractAddress - Optional staking contract address to filter
	* @param params.callback - Called for each subscription update
	* @param params.onEndCallback - Called when stream ends normally
	* @param params.onStatusCallback - Called on stream errors
	* @returns Subscription object with unsubscribe method
	*/
	streamVaultHolderSubscriptions({ holderAddress, vaultAddress, stakingContractAddress, callback, onEndCallback, onStatusCallback }) {
		if (!holderAddress) throw new Error("holderAddress is required");
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_mito_proto_ts_v2_generated_goadesign_goagen_mito_api_pb.StreamHolderSubscriptionRequest.create();
		request.holderAddress = holderAddress;
		if (vaultAddress) request.vaultAddress = vaultAddress;
		if (stakingContractAddress) request.stakingContractAddress = stakingContractAddress;
		return createStreamSubscription(this.client.streamHolderSubscription(request), (response) => {
			callback(IndexerGrpcMitoStreamTransformer.vaultHolderSubscriptionStreamCallback(response));
		}, onEndCallback, onStatusCallback);
	}
	/**
	* Stream staking rewards by account
	* @param params - Stream parameters
	* @param params.staker - The staker address to stream rewards for
	* @param params.stakingContractAddress - The staking contract address
	* @param params.callback - Called for each reward update
	* @param params.onEndCallback - Called when stream ends normally
	* @param params.onStatusCallback - Called on stream errors
	* @returns Subscription object with unsubscribe method
	*/
	streamStakingRewardsByAccount({ staker, callback, onEndCallback, onStatusCallback, stakingContractAddress }) {
		if (!staker) throw new Error("staker is required");
		if (!stakingContractAddress) throw new Error("stakingContractAddress is required");
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_mito_proto_ts_v2_generated_goadesign_goagen_mito_api_pb.StreamStakingRewardByAccountRequest.create();
		request.staker = staker;
		request.stakingContractAddress = stakingContractAddress;
		return createStreamSubscription(this.client.streamStakingRewardByAccount(request), (response) => {
			callback(IndexerGrpcMitoStreamTransformer.stakingRewardByAccountStreamCallback(response));
		}, onEndCallback, onStatusCallback);
	}
	/**
	* Stream historical staking data
	* @param params - Stream parameters
	* @param params.staker - The staker address to stream data for
	* @param params.stakingContractAddress - The staking contract address
	* @param params.callback - Called for each historical staking update
	* @param params.onEndCallback - Called when stream ends normally
	* @param params.onStatusCallback - Called on stream errors
	* @returns Subscription object with unsubscribe method
	*/
	streamHistoricalStaking({ staker, stakingContractAddress, callback, onEndCallback, onStatusCallback }) {
		if (!staker) throw new Error("staker is required");
		if (!stakingContractAddress) throw new Error("stakingContractAddress is required");
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_mito_proto_ts_v2_generated_goadesign_goagen_mito_api_pb.StreamHistoricalStakingRequest.create();
		request.staker = staker;
		request.stakingContractAddress = stakingContractAddress;
		return createStreamSubscription(this.client.streamHistoricalStaking(request), (response) => {
			callback(IndexerGrpcMitoStreamTransformer.historicalStakingStreamCallback(response));
		}, onEndCallback, onStatusCallback);
	}
};

//#endregion
//#region src/client/indexer/grpc_stream/stream/IndexerGrpcOracleStream.ts
/**
* @category Indexer Grpc Stream
* @description Provides streaming access to oracle price data from Injective Indexer
*/
var IndexerGrpcOracleStream = class {
	constructor(endpoint, metadata) {
		require_defineProperty._defineProperty(this, "client", void 0);
		require_defineProperty._defineProperty(this, "transport", void 0);
		this.transport = new require_BaseGrpcConsumer.GrpcWebRpcTransport(endpoint, metadata);
		this.client = new __injectivelabs_indexer_proto_ts_v2_generated_injective_oracle_rpc_pb_client.InjectiveOracleRPCClient(this.transport);
	}
	/**
	* Stream oracle price updates
	* @param params - Stream parameters
	* @param params.oracleType - The oracle type to stream prices for
	* @param params.baseSymbol - Optional base symbol filter
	* @param params.quoteSymbol - Optional quote symbol filter
	* @param params.callback - Called for each price update
	* @param params.onEndCallback - Called when stream ends normally
	* @param params.onStatusCallback - Called on stream errors
	* @returns Subscription object with unsubscribe method
	*/
	streamOraclePrices({ oracleType, baseSymbol, quoteSymbol, callback, onEndCallback, onStatusCallback }) {
		if (!oracleType) throw new Error("oracleType is required");
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_oracle_rpc_pb.StreamPricesRequest.create();
		if (baseSymbol) request.baseSymbol = baseSymbol;
		if (quoteSymbol) request.quoteSymbol = quoteSymbol;
		request.oracleType = oracleType;
		return createStreamSubscription(this.client.streamPrices(request), (response) => {
			callback(IndexerOracleStreamTransformer.pricesStreamCallback(response));
		}, onEndCallback, onStatusCallback);
	}
	/**
	* Stream oracle prices by markets
	* @param params - Stream parameters
	* @param params.marketIds - Optional array of market IDs to filter
	* @param params.callback - Called for each price update
	* @param params.onEndCallback - Called when stream ends normally
	* @param params.onStatusCallback - Called on stream errors
	* @returns Subscription object with unsubscribe method
	*/
	streamOraclePricesByMarkets({ marketIds, callback, onEndCallback, onStatusCallback }) {
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_oracle_rpc_pb.StreamPricesByMarketsRequest.create();
		if (marketIds) request.marketIds = marketIds;
		return createStreamSubscription(this.client.streamPricesByMarkets(request), (response) => {
			callback(IndexerOracleStreamTransformer.pricesByMarketsCallback(response));
		}, onEndCallback, onStatusCallback);
	}
};

//#endregion
//#region src/client/indexer/grpc_stream/stream/IndexerGrpcAccountStream.ts
/**
* @category Indexer Grpc Stream
* @description Provides streaming access to account data from the Injective Indexer
*/
var IndexerGrpcAccountStream = class {
	constructor(endpoint, metadata) {
		require_defineProperty._defineProperty(this, "client", void 0);
		require_defineProperty._defineProperty(this, "transport", void 0);
		this.transport = new require_BaseGrpcConsumer.GrpcWebRpcTransport(endpoint, metadata);
		this.client = new __injectivelabs_indexer_proto_ts_v2_generated_injective_accounts_rpc_pb_client.InjectiveAccountsRPCClient(this.transport);
	}
	/**
	* Stream subaccount balance updates
	* @param params - Stream parameters
	* @param params.subaccountId - The subaccount ID to stream balance for
	* @param params.callback - Called for each balance update
	* @param params.onEndCallback - Called when stream ends normally
	* @param params.onStatusCallback - Called on stream errors
	* @returns Subscription object with unsubscribe method
	*/
	streamSubaccountBalance({ subaccountId, callback, onEndCallback, onStatusCallback }) {
		if (!subaccountId) throw new Error("subaccountId is required");
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_accounts_rpc_pb.StreamSubaccountBalanceRequest.create();
		request.subaccountId = subaccountId;
		return createStreamSubscription(this.client.streamSubaccountBalance(request), (response) => {
			callback(IndexerAccountStreamTransformer.balanceStreamCallback(response));
		}, onEndCallback, onStatusCallback);
	}
};

//#endregion
//#region src/client/indexer/grpc_stream/stream/IndexerGrpcAuctionStream.ts
/**
* @category Indexer Grpc Stream
* @description Provides streaming access to auction data from Injective Indexer
*/
var IndexerGrpcAuctionStream = class {
	constructor(endpoint, metadata) {
		require_defineProperty._defineProperty(this, "client", void 0);
		require_defineProperty._defineProperty(this, "transport", void 0);
		this.transport = new require_BaseGrpcConsumer.GrpcWebRpcTransport(endpoint, metadata);
		this.client = new __injectivelabs_indexer_proto_ts_v2_generated_injective_auction_rpc_pb_client.InjectiveAuctionRPCClient(this.transport);
	}
	/**
	* Stream auction bids
	* @param params - Stream parameters
	* @param params.callback - Called for each bid update
	* @param params.onEndCallback - Called when stream ends normally
	* @param params.onStatusCallback - Called on stream errors
	* @returns Subscription object with unsubscribe method
	*/
	streamBids({ callback, onEndCallback, onStatusCallback }) {
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_auction_rpc_pb.StreamBidsRequest.create();
		return createStreamSubscription(this.client.streamBids(request), (response) => {
			callback(IndexerAuctionStreamTransformer.bidsStreamCallback(response));
		}, onEndCallback, onStatusCallback);
	}
};

//#endregion
//#region src/client/indexer/grpc_stream/stream/IndexerGrpcTradingStream.ts
/**
* @category Indexer Grid Strategy Grpc Stream
* @description Provides streaming access to grid strategy data from Injective Indexer
*/
var IndexerGrpcTradingStream = class {
	constructor(endpoint, metadata) {
		require_defineProperty._defineProperty(this, "client", void 0);
		require_defineProperty._defineProperty(this, "transport", void 0);
		this.transport = new require_BaseGrpcConsumer.GrpcWebRpcTransport(endpoint, metadata);
		this.client = new __injectivelabs_indexer_proto_ts_v2_generated_injective_trading_rpc_pb_client.InjectiveTradingRPCClient(this.transport);
	}
	/**
	* Stream grid strategies
	* @param params - Stream parameters
	* @param params.marketId - Optional market ID to filter strategies
	* @param params.accountAddresses - Optional array of account addresses to filter
	* @param params.callback - Called for each strategy update
	* @param params.onEndCallback - Called when stream ends normally
	* @param params.onStatusCallback - Called on stream errors
	* @returns Subscription object with unsubscribe method
	*/
	streamGridStrategies({ marketId, callback, onEndCallback, accountAddresses, onStatusCallback }) {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_trading_rpc_pb.StreamStrategyRequest.create();
		if ((!accountAddresses || accountAddresses.length === 0) && !marketId) throw new Error("accountAddresses or marketId is required");
		if (typeof callback !== "function") throw new Error("callback must be a function");
		if (accountAddresses) request.accountAddresses = accountAddresses;
		if (marketId) request.marketId = marketId;
		return createStreamSubscription(this.client.streamStrategy(request), (response) => {
			callback(response);
		}, onEndCallback, onStatusCallback);
	}
};

//#endregion
//#region src/client/indexer/grpc_stream/stream/IndexerGrpcArchiverStream.ts
/**
* @category Indexer Grpc Stream
* @description Provides streaming access to archiver data from Injective Indexer
*/
var IndexerGrpcArchiverStream = class {
	constructor(endpoint, metadata) {
		require_defineProperty._defineProperty(this, "client", void 0);
		require_defineProperty._defineProperty(this, "transport", void 0);
		this.transport = new require_BaseGrpcConsumer.GrpcWebRpcTransport(endpoint, metadata);
		this.client = new __injectivelabs_indexer_proto_ts_v2_generated_injective_archiver_rpc_pb_client.InjectiveArchiverRPCClient(this.transport);
	}
	/**
	* Stream spot average entries
	* @param params - Stream parameters
	* @param params.account - The account address to stream entries for
	* @param params.callback - Called for each average entry update
	* @param params.onEndCallback - Called when stream ends normally
	* @param params.onStatusCallback - Called on stream errors
	* @returns Subscription object with unsubscribe method
	*/
	streamSpotAverageEntries({ account, callback, onEndCallback, onStatusCallback }) {
		if (!account) throw new Error("account is required");
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_archiver_rpc_pb.StreamSpotAverageEntriesRequest.create();
		request.account = account;
		return createStreamSubscription(this.client.streamSpotAverageEntries(request), (response) => {
			callback(IndexerArchiverStreamTransformer.spotAverageEntriesStreamCallback(response));
		}, onEndCallback, onStatusCallback);
	}
};

//#endregion
//#region src/client/indexer/grpc_stream/stream/IndexerGrpcExplorerStream.ts
/**
* @category Indexer Grpc Stream
* @description Provides streaming access to blockchain explorer data from Injective Indexer
*/
var IndexerGrpcExplorerStream = class {
	constructor(endpoint, metadata) {
		require_defineProperty._defineProperty(this, "client", void 0);
		require_defineProperty._defineProperty(this, "transport", void 0);
		this.transport = new require_BaseGrpcConsumer.GrpcWebRpcTransport(endpoint, metadata);
		this.client = new __injectivelabs_indexer_proto_ts_v2_generated_injective_explorer_rpc_pb_client.InjectiveExplorerRPCClient(this.transport);
	}
	/**
	* Stream block updates
	* @param params - Stream parameters
	* @param params.callback - Called for each block update
	* @param params.onEndCallback - Called when stream ends normally
	* @param params.onStatusCallback - Called on stream errors
	* @returns Subscription object with unsubscribe method
	*/
	streamBlocks({ callback, onEndCallback, onStatusCallback }) {
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_explorer_rpc_pb.StreamBlocksRequest.create();
		return createStreamSubscription(this.client.streamBlocks(request), (response) => {
			callback(ExplorerStreamTransformer.blocksStreamCallback(response));
		}, onEndCallback, onStatusCallback);
	}
	/**
	* Stream blocks with transactions
	* @param params - Stream parameters
	* @param params.callback - Called for each block with transactions update
	* @param params.onEndCallback - Called when stream ends normally
	* @param params.onStatusCallback - Called on stream errors
	* @returns Subscription object with unsubscribe method
	*/
	streamBlocksWithTxs({ callback, onEndCallback, onStatusCallback }) {
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_explorer_rpc_pb.StreamBlocksRequest.create();
		return createStreamSubscription(this.client.streamBlocks(request), (response) => {
			callback(ExplorerStreamTransformer.blocksWithTxsStreamCallback(response));
		}, onEndCallback, onStatusCallback);
	}
	/**
	* Stream transaction updates
	* @param params - Stream parameters
	* @param params.callback - Called for each transaction update
	* @param params.onEndCallback - Called when stream ends normally
	* @param params.onStatusCallback - Called on stream errors
	* @returns Subscription object with unsubscribe method
	*/
	streamTransactions({ callback, onEndCallback, onStatusCallback }) {
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_explorer_rpc_pb.StreamTxsRequest.create();
		return createStreamSubscription(this.client.streamTxs(request), (response) => {
			callback(ExplorerStreamTransformer.transactionsStreamCallback(response));
		}, onEndCallback, onStatusCallback);
	}
};

//#endregion
//#region src/client/indexer/grpc_stream/stream/IndexerGrpcDerivativesStream.ts
/**
* @category Indexer Grpc Stream
* @description Provides streaming access to derivatives market data from Injective Indexer
*/
var IndexerGrpcDerivativesStream = class {
	constructor(endpoint, metadata) {
		require_defineProperty._defineProperty(this, "client", void 0);
		require_defineProperty._defineProperty(this, "transport", void 0);
		this.transport = new require_BaseGrpcConsumer.GrpcWebRpcTransport(endpoint, metadata);
		this.client = new __injectivelabs_indexer_proto_ts_v2_generated_injective_derivative_exchange_rpc_pb_client.InjectiveDerivativeExchangeRPCClient(this.transport);
	}
	/**
	* Stream derivative orders
	* @param params - Stream parameters
	* @param params.marketId - Optional market ID to filter orders
	* @param params.subaccountId - Optional subaccount ID to filter orders
	* @param params.orderSide - Optional order side to filter
	* @param params.callback - Called for each order update
	* @param params.onEndCallback - Called when stream ends normally
	* @param params.onStatusCallback - Called on stream errors
	* @returns Subscription object with unsubscribe method
	*/
	streamOrders({ marketId, subaccountId, orderSide, callback, onEndCallback, onStatusCallback }) {
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_derivative_exchange_rpc_pb.StreamOrdersRequest.create();
		if (marketId) request.marketId = marketId;
		if (subaccountId) request.subaccountId = subaccountId;
		if (orderSide) request.orderSide = orderSide;
		return createStreamSubscription(this.client.streamOrders(request), (response) => {
			callback(IndexerDerivativeStreamTransformer.ordersStreamCallback(response));
		}, onEndCallback, onStatusCallback);
	}
	/**
	* Stream derivative order history
	* @param params - Stream parameters
	* @param params.marketId - Optional market ID to filter orders
	* @param params.subaccountId - Optional subaccount ID to filter orders
	* @param params.orderTypes - Optional array of order types to filter
	* @param params.direction - Optional trade direction to filter
	* @param params.state - Optional order state to filter
	* @param params.executionTypes - Optional array of execution types to filter
	* @param params.callback - Called for each order history update
	* @param params.onEndCallback - Called when stream ends normally
	* @param params.onStatusCallback - Called on stream errors
	* @returns Subscription object with unsubscribe method
	*/
	streamOrdersHistory({ marketId, subaccountId, orderTypes, direction, state, executionTypes, callback, onEndCallback, onStatusCallback }) {
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_derivative_exchange_rpc_pb.StreamOrdersHistoryRequest.create();
		if (subaccountId) request.subaccountId = subaccountId;
		if (marketId) request.marketId = marketId;
		if (orderTypes) request.orderTypes = orderTypes;
		if (direction) request.direction = direction;
		if (state) request.state = state;
		if (executionTypes) request.executionTypes = executionTypes;
		return createStreamSubscription(this.client.streamOrdersHistory(request), (response) => {
			callback(IndexerDerivativeStreamTransformer.orderHistoryStreamCallback(response));
		}, onEndCallback, onStatusCallback);
	}
	/**
	* Stream derivative trades
	* @param params - Stream parameters
	* @param params.marketIds - Optional array of market IDs to filter trades
	* @param params.marketId - Optional market ID to filter trades
	* @param params.subaccountIds - Optional array of subaccount IDs to filter trades
	* @param params.subaccountId - Optional subaccount ID to filter trades
	* @param params.executionSide - Optional trade execution side to filter
	* @param params.direction - Optional trade direction to filter
	* @param params.pagination - Optional pagination options
	* @param params.callback - Called for each trade update
	* @param params.onEndCallback - Called when stream ends normally
	* @param params.onStatusCallback - Called on stream errors
	* @returns Subscription object with unsubscribe method
	*/
	streamTrades({ marketIds, marketId, subaccountIds, subaccountId, executionSide, direction, pagination, callback, onEndCallback, onStatusCallback }) {
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_derivative_exchange_rpc_pb.StreamTradesRequest.create();
		if (marketIds) request.marketIds = marketIds;
		if (marketId) request.marketId = marketId;
		if (subaccountIds) request.subaccountIds = subaccountIds;
		if (subaccountId) request.subaccountId = subaccountId;
		if (executionSide) request.executionSide = executionSide;
		if (direction) request.direction = direction;
		if (pagination) {
			if (pagination.skip !== void 0) request.skip = BigInt(pagination.skip);
			if (pagination.limit !== void 0) request.limit = pagination.limit;
		}
		return createStreamSubscription(this.client.streamTrades(request), (response) => {
			callback(IndexerDerivativeStreamTransformer.tradesStreamCallback(response));
		}, onEndCallback, onStatusCallback);
	}
	/**
	* Stream derivative positions
	* @param params - Stream parameters
	* @param params.marketId - Optional market ID to filter positions
	* @param params.address - Optional account address to filter positions
	* @param params.subaccountId - Optional subaccount ID to filter positions
	* @param params.callback - Called for each position update
	* @param params.onEndCallback - Called when stream ends normally
	* @param params.onStatusCallback - Called on stream errors
	* @returns Subscription object with unsubscribe method
	*/
	streamPositions({ marketId, address, subaccountId, callback, onEndCallback, onStatusCallback }) {
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_derivative_exchange_rpc_pb.StreamPositionsRequest.create();
		if (marketId) request.marketId = marketId;
		if (address) request.accountAddress = address;
		if (subaccountId) request.subaccountId = subaccountId;
		return createStreamSubscription(this.client.streamPositions(request), (response) => {
			callback(IndexerDerivativeStreamTransformer.positionStreamCallback(response));
		}, onEndCallback, onStatusCallback);
	}
	/**
	* Stream derivative markets
	* @param params - Stream parameters
	* @param params.marketIds - Optional array of market IDs to filter
	* @param params.callback - Called for each market update
	* @param params.onEndCallback - Called when stream ends normally
	* @param params.onStatusCallback - Called on stream errors
	* @returns Subscription object with unsubscribe method
	*/
	streamMarkets({ marketIds, callback, onEndCallback, onStatusCallback }) {
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_derivative_exchange_rpc_pb.StreamMarketRequest.create();
		if (marketIds && marketIds.length) request.marketIds = marketIds;
		return createStreamSubscription(this.client.streamMarket(request), (response) => {
			callback(response);
		}, onEndCallback, onStatusCallback);
	}
	/**
	* Stream derivative orderbooks V2
	* @param params - Stream parameters
	* @param params.marketIds - Array of market IDs to stream orderbook for
	* @param params.callback - Called for each orderbook update
	* @param params.onEndCallback - Called when stream ends normally
	* @param params.onStatusCallback - Called on stream errors
	* @returns Subscription object with unsubscribe method
	*/
	streamOrderbooksV2({ marketIds, callback, onEndCallback, onStatusCallback }) {
		if (!marketIds || marketIds.length === 0) throw new Error("marketIds is required and cannot be empty");
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_derivative_exchange_rpc_pb.StreamOrderbookV2Request.create();
		request.marketIds = marketIds;
		return createStreamSubscription(this.client.streamOrderbookV2(request), (response) => {
			callback(IndexerDerivativeStreamTransformer.orderbookV2StreamCallback(response));
		}, onEndCallback, onStatusCallback);
	}
	/**
	* Stream derivative orderbook updates
	* @param params - Stream parameters
	* @param params.marketIds - Array of market IDs to stream orderbook updates for
	* @param params.callback - Called for each orderbook update
	* @param params.onEndCallback - Called when stream ends normally
	* @param params.onStatusCallback - Called on stream errors
	* @returns Subscription object with unsubscribe method
	*/
	streamOrderbookUpdates({ marketIds, callback, onEndCallback, onStatusCallback }) {
		if (!marketIds || marketIds.length === 0) throw new Error("marketIds is required and cannot be empty");
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_derivative_exchange_rpc_pb.StreamOrderbookUpdateRequest.create();
		request.marketIds = marketIds;
		return createStreamSubscription(this.client.streamOrderbookUpdate(request), (response) => {
			callback(IndexerDerivativeStreamTransformer.orderbookUpdateStreamCallback(response));
		}, onEndCallback, onStatusCallback);
	}
	/**
	* Stream derivative positions V2
	* @param params - Stream parameters
	* @param params.marketId - Optional market ID to filter positions
	* @param params.address - Optional account address to filter positions
	* @param params.subaccountId - Optional subaccount ID to filter positions
	* @param params.callback - Called for each position update
	* @param params.onEndCallback - Called when stream ends normally
	* @param params.onStatusCallback - Called on stream errors
	* @returns Subscription object with unsubscribe method
	*/
	streamPositionsV2({ marketId, address, subaccountId, callback, onEndCallback, onStatusCallback }) {
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_derivative_exchange_rpc_pb.StreamPositionsV2Request.create();
		if (marketId) request.marketId = marketId;
		if (address) request.accountAddress = address;
		if (subaccountId) request.subaccountId = subaccountId;
		return createStreamSubscription(this.client.streamPositionsV2(request), (response) => {
			callback(IndexerDerivativeStreamTransformer.positionV2StreamCallback(response));
		}, onEndCallback, onStatusCallback);
	}
};

//#endregion
//#region src/client/indexer/grpc_stream/stream/IndexerGrpcAccountPortfolioStream.ts
/**
* @category Indexer Grpc Stream
* @description Provides streaming access to account portfolio data from Injective Indexer
*/
var IndexerGrpcAccountPortfolioStream = class {
	constructor(endpoint, metadata) {
		require_defineProperty._defineProperty(this, "client", void 0);
		require_defineProperty._defineProperty(this, "transport", void 0);
		this.transport = new require_BaseGrpcConsumer.GrpcWebRpcTransport(endpoint, metadata);
		this.client = new __injectivelabs_indexer_proto_ts_v2_generated_injective_portfolio_rpc_pb_client.InjectivePortfolioRPCClient(this.transport);
	}
	/**
	* Stream account portfolio updates
	* @param params - Stream parameters
	* @param params.accountAddress - The account address to stream portfolio for
	* @param params.subaccountId - Optional subaccount ID to filter
	* @param params.type - Optional portfolio type to filter
	* @param params.callback - Called for each portfolio update
	* @param params.onEndCallback - Called when stream ends normally
	* @param params.onStatusCallback - Called on stream errors
	* @returns Subscription object with unsubscribe method
	*/
	streamAccountPortfolio({ subaccountId, accountAddress, type, callback, onEndCallback, onStatusCallback }) {
		if (!accountAddress) throw new Error("accountAddress is required");
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_portfolio_rpc_pb.StreamAccountPortfolioRequest.create();
		request.accountAddress = accountAddress;
		if (subaccountId) request.subaccountId = subaccountId;
		if (type) request.type = type;
		return createStreamSubscription(this.client.streamAccountPortfolio(request), (response) => {
			callback(IndexerAccountPortfolioStreamTransformer.accountPortfolioStreamCallback(response));
		}, onEndCallback, onStatusCallback);
	}
};

//#endregion
//#region src/client/indexer/grpc_stream/stream/StreamManager.ts
/**
* StreamManager - Simple registry for managing multiple V1 stream subscriptions by key
*
* This is a lightweight utility for storing and canceling multiple V1 RxJS-based streams.
* For V2 streams with advanced lifecycle management and retry logic, use StreamManagerV2.
*/
var StreamManager = class {
	constructor() {
		require_defineProperty._defineProperty(this, "streams", /* @__PURE__ */ new Map());
	}
	set(stream, streamKey) {
		if (this.streams.has(streamKey)) throw new Error(`Stream ${streamKey} already exists`);
		this.streams.set(streamKey, stream);
	}
	get(streamKey) {
		if (!this.streams.has(streamKey)) throw new Error(`Stream ${streamKey} is not found`);
		return this.streams.get(streamKey);
	}
	exists(streamKey) {
		return this.streams.has(streamKey);
	}
	cancelAll() {
		this.streams.forEach((stream) => {
			stream.cancel();
		});
		this.streams = /* @__PURE__ */ new Map();
	}
	cancel(streamKey) {
		if (!this.streams.has(streamKey)) throw new Error(`Stream ${streamKey} is not found`);
		this.streams.get(streamKey).cancel();
		this.streams.delete(streamKey);
	}
	cancelIfExists(streamKey) {
		if (!this.streams.has(streamKey)) return;
		this.streams.get(streamKey).cancel();
		this.streams.delete(streamKey);
	}
};

//#endregion
//#region src/client/indexer/grpc_stream/streamV2/streamHelpersV2.ts
/**
* Extracts detailed error information from a gRPC/RpcError object.
*
* gRPC-web errors typically have these properties:
* - code: gRPC status code (number)
* - message: Error message
* - name: 'RpcError'
* - methodName: The RPC method that failed
* - serviceName: The service name
* - metadata: Response metadata/trailers
*/
function extractGrpcError(error) {
	let code = require_types.GrpcStatusCode.UNKNOWN;
	let details = "Unknown stream error";
	let metadata = void 0;
	if (error && typeof error === "object") {
		if ("code" in error && typeof error.code === "number") code = error.code;
		if ("message" in error && typeof error.message === "string") details = error.message;
		else if ("details" in error && typeof error.details === "string") details = error.details;
		const errorObj = error;
		metadata = {
			originalError: error,
			..."name" in errorObj && { errorName: errorObj.name },
			..."methodName" in errorObj && { methodName: errorObj.methodName },
			..."serviceName" in errorObj && { serviceName: errorObj.serviceName },
			..."metadata" in errorObj && { grpcMetadata: errorObj.metadata }
		};
	} else if (error instanceof Error) {
		details = error.message;
		metadata = {
			originalError: error,
			stack: error.stack
		};
	}
	return {
		code,
		details,
		metadata
	};
}
/**
* Creates an event-based subscription for StreamManager V2.
* This emits 'error' and 'complete' events instead of using callbacks.
*
* Error Handling:
* - gRPC errors are extracted with full metadata and emitted as 'error' events
* - User callback errors are caught and emitted separately to distinguish from stream errors
* - Aborted streams don't emit any events (clean shutdown)
*
* @param stream - The ServerStreamingCall from the V2 client
* @param handleResponse - Callback to process each stream response
* @returns StreamSubscription with event emitters for error/complete
*/
function createStreamSubscriptionV2(stream, handleResponse) {
	const emitter = new eventemitter3.EventEmitter();
	const abortController = new AbortController();
	let hasEmittedTerminalEvent = false;
	const subscription = {
		unsubscribe: () => {
			abortController.abort();
			emitter.removeAllListeners();
		},
		on: (event, handler) => {
			emitter.on(event, handler);
		},
		off: (event, handler) => {
			emitter.off(event, handler);
		}
	};
	(async () => {
		try {
			for await (const response of stream.responses) {
				if (abortController.signal.aborted) return;
				try {
					handleResponse(response);
				} catch (callbackError) {
					if (!abortController.signal.aborted && !hasEmittedTerminalEvent) {
						hasEmittedTerminalEvent = true;
						const streamError = {
							code: require_types.GrpcStatusCode.INTERNAL,
							details: callbackError instanceof Error ? `Callback error: ${callbackError.message}` : "Callback error: Unknown",
							metadata: {
								type: "callback-error",
								originalError: callbackError,
								stack: callbackError instanceof Error ? callbackError.stack : void 0
							}
						};
						emitter.emit("error", streamError);
					}
					return;
				}
			}
			if (!abortController.signal.aborted && !hasEmittedTerminalEvent) {
				hasEmittedTerminalEvent = true;
				emitter.emit("complete");
			}
		} catch (error) {
			if (!abortController.signal.aborted && !hasEmittedTerminalEvent) {
				hasEmittedTerminalEvent = true;
				const streamError = extractGrpcError(error);
				emitter.emit("error", streamError);
			}
		}
	})();
	return subscription;
}

//#endregion
//#region src/client/indexer/grpc_stream/streamV2/IndexerGrpcSpotStreamV2.ts
var IndexerGrpcSpotStreamV2 = class {
	constructor(endpoint, metadata) {
		require_defineProperty._defineProperty(this, "client", void 0);
		require_defineProperty._defineProperty(this, "transport", void 0);
		this.transport = new require_BaseGrpcConsumer.GrpcWebRpcTransport(endpoint, metadata);
		this.client = new __injectivelabs_indexer_proto_ts_v2_generated_injective_spot_exchange_rpc_pb_client.InjectiveSpotExchangeRPCClient(this.transport);
	}
	/**
	* Stream spot orderbook updates
	* @param params.marketIds - Array of market IDs to stream
	* @param params.callback - Called for each orderbook update
	* @returns StreamSubscription
	*/
	streamOrderbookUpdates({ marketIds, callback }) {
		if (!marketIds || marketIds.length === 0) throw new Error("marketIds is required");
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_spot_exchange_rpc_pb.StreamOrderbookUpdateRequest.create();
		request.marketIds = marketIds;
		return createStreamSubscriptionV2(this.client.streamOrderbookUpdate(request), (response) => {
			callback(IndexerSpotStreamTransformer.orderbookUpdateStreamCallback(response));
		});
	}
	/**
	* Stream spot orders
	* @param params.marketId - Optional market ID to filter
	* @param params.subaccountId - Optional subaccount ID to filter
	* @param params.orderSide - Optional order side to filter
	* @param params.callback - Called for each order update
	* @returns StreamSubscription
	*/
	streamOrders({ marketId, subaccountId, orderSide, callback }) {
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_spot_exchange_rpc_pb.StreamOrdersRequest.create();
		if (marketId) request.marketId = marketId;
		if (subaccountId) request.subaccountId = subaccountId;
		if (orderSide) request.orderSide = orderSide;
		return createStreamSubscriptionV2(this.client.streamOrders(request), (response) => {
			callback(IndexerSpotStreamTransformer.ordersStreamCallback(response));
		});
	}
	/**
	* Stream spot order history
	* @param params.subaccountId - Optional subaccount ID to filter
	* @param params.marketId - Optional market ID to filter
	* @param params.orderTypes - Optional order types to filter
	* @param params.direction - Optional direction to filter
	* @param params.state - Optional state to filter
	* @param params.executionTypes - Optional execution types to filter
	* @param params.callback - Called for each order history update
	* @returns StreamSubscription
	*/
	streamOrderHistory({ subaccountId, marketId, orderTypes, direction, state, executionTypes, callback }) {
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_spot_exchange_rpc_pb.StreamOrdersHistoryRequest.create();
		if (subaccountId) request.subaccountId = subaccountId;
		if (marketId) request.marketId = marketId;
		if (orderTypes) request.orderTypes = orderTypes;
		if (direction) request.direction = direction;
		if (state) request.state = state;
		if (executionTypes) request.executionTypes = executionTypes;
		return createStreamSubscriptionV2(this.client.streamOrdersHistory(request), (response) => {
			callback(IndexerSpotStreamTransformer.orderHistoryStreamCallback(response));
		});
	}
	/**
	* Stream spot trades
	* @param params.marketId - Optional market ID to filter
	* @param params.marketIds - Optional array of market IDs to filter
	* @param params.subaccountId - Optional subaccount ID to filter
	* @param params.subaccountIds - Optional array of subaccount IDs to filter
	* @param params.executionSide - Optional execution side to filter
	* @param params.direction - Optional direction to filter
	* @param params.executionTypes - Optional execution types to filter
	* @param params.callback - Called for each trade update
	* @returns StreamSubscription
	*/
	streamTrades({ marketId, marketIds, subaccountId, subaccountIds, executionSide, direction, executionTypes, callback }) {
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_spot_exchange_rpc_pb.StreamTradesRequest.create();
		if (marketId) request.marketId = marketId;
		if (marketIds) request.marketIds = marketIds;
		if (subaccountId) request.subaccountId = subaccountId;
		if (subaccountIds) request.subaccountIds = subaccountIds;
		if (executionSide) request.executionSide = executionSide;
		if (direction) request.direction = direction;
		if (executionTypes) request.executionTypes = executionTypes;
		return createStreamSubscriptionV2(this.client.streamTrades(request), (response) => {
			callback(IndexerSpotStreamTransformer.tradesStreamCallback(response));
		});
	}
};

//#endregion
//#region src/client/indexer/grpc_stream/streamV2/IndexerGrpcMitoStreamV2.ts
var IndexerGrpcMitoStreamV2 = class {
	constructor(endpoint, metadata) {
		require_defineProperty._defineProperty(this, "client", void 0);
		require_defineProperty._defineProperty(this, "transport", void 0);
		this.transport = new require_BaseGrpcConsumer.GrpcWebRpcTransport(endpoint, metadata);
		this.client = new __injectivelabs_mito_proto_ts_v2_generated_goadesign_goagen_mito_api_pb_client.MitoAPIClient(this.transport);
	}
	/**
	* Stream vault transfers
	* @param params.vault - Optional vault address to filter
	* @param params.account - Optional account address to filter
	* @param params.callback - Called for each transfer update
	* @returns StreamSubscription
	*/
	streamTransfers({ vault, account, callback }) {
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_mito_proto_ts_v2_generated_goadesign_goagen_mito_api_pb.StreamTransfersRequest.create();
		if (vault) request.vault = vault;
		if (account) request.account = account;
		return createStreamSubscriptionV2(this.client.streamTransfers(request), (response) => {
			callback(IndexerGrpcMitoStreamTransformer.transfersStreamCallback(response));
		});
	}
	/**
	* Stream vault information
	* @param params.vault - Optional vault address to filter
	* @param params.callback - Called for each vault update
	* @returns StreamSubscription
	*/
	streamVault({ vault, callback }) {
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_mito_proto_ts_v2_generated_goadesign_goagen_mito_api_pb.StreamVaultRequest.create();
		if (vault) request.vault = vault;
		return createStreamSubscriptionV2(this.client.streamVault(request), (response) => {
			callback(IndexerGrpcMitoStreamTransformer.vaultStreamCallback(response));
		});
	}
	/**
	* Stream vault holder subscriptions
	* @param params.holderAddress - The holder address to stream subscriptions for
	* @param params.vaultAddress - Optional vault address to filter
	* @param params.stakingContractAddress - Optional staking contract address to filter
	* @param params.callback - Called for each subscription update
	* @returns StreamSubscription
	*/
	streamVaultHolderSubscriptions({ holderAddress, vaultAddress, stakingContractAddress, callback }) {
		if (!holderAddress) throw new Error("holderAddress is required");
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_mito_proto_ts_v2_generated_goadesign_goagen_mito_api_pb.StreamHolderSubscriptionRequest.create();
		request.holderAddress = holderAddress;
		if (vaultAddress) request.vaultAddress = vaultAddress;
		if (stakingContractAddress) request.stakingContractAddress = stakingContractAddress;
		return createStreamSubscriptionV2(this.client.streamHolderSubscription(request), (response) => {
			callback(IndexerGrpcMitoStreamTransformer.vaultHolderSubscriptionStreamCallback(response));
		});
	}
	/**
	* Stream staking rewards by account
	* @param params.staker - The staker address to stream rewards for
	* @param params.stakingContractAddress - The staking contract address
	* @param params.callback - Called for each reward update
	* @returns StreamSubscription
	*/
	streamStakingRewardsByAccount({ staker, stakingContractAddress, callback }) {
		if (!staker) throw new Error("staker is required");
		if (!stakingContractAddress) throw new Error("stakingContractAddress is required");
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_mito_proto_ts_v2_generated_goadesign_goagen_mito_api_pb.StreamStakingRewardByAccountRequest.create();
		request.staker = staker;
		request.stakingContractAddress = stakingContractAddress;
		return createStreamSubscriptionV2(this.client.streamStakingRewardByAccount(request), (response) => {
			callback(IndexerGrpcMitoStreamTransformer.stakingRewardByAccountStreamCallback(response));
		});
	}
	/**
	* Stream historical staking data
	* @param params.staker - The staker address to stream data for
	* @param params.stakingContractAddress - The staking contract address
	* @param params.callback - Called for each historical staking update
	* @returns StreamSubscription
	*/
	streamHistoricalStaking({ staker, stakingContractAddress, callback }) {
		if (!staker) throw new Error("staker is required");
		if (!stakingContractAddress) throw new Error("stakingContractAddress is required");
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_mito_proto_ts_v2_generated_goadesign_goagen_mito_api_pb.StreamHistoricalStakingRequest.create();
		request.staker = staker;
		request.stakingContractAddress = stakingContractAddress;
		return createStreamSubscriptionV2(this.client.streamHistoricalStaking(request), (response) => {
			callback(IndexerGrpcMitoStreamTransformer.historicalStakingStreamCallback(response));
		});
	}
};

//#endregion
//#region src/client/indexer/grpc_stream/streamV2/IndexerGrpcOracleStreamV2.ts
var IndexerGrpcOracleStreamV2 = class {
	constructor(endpoint, metadata) {
		require_defineProperty._defineProperty(this, "client", void 0);
		require_defineProperty._defineProperty(this, "transport", void 0);
		this.transport = new require_BaseGrpcConsumer.GrpcWebRpcTransport(endpoint, metadata);
		this.client = new __injectivelabs_indexer_proto_ts_v2_generated_injective_oracle_rpc_pb_client.InjectiveOracleRPCClient(this.transport);
	}
	/**
	* Stream oracle price updates
	* @param params.oracleType - The oracle type to stream prices for
	* @param params.baseSymbol - Optional base symbol filter
	* @param params.quoteSymbol - Optional quote symbol filter
	* @param params.callback - Called for each price update
	* @returns StreamSubscription
	*/
	streamOraclePrices({ oracleType, baseSymbol, quoteSymbol, callback }) {
		if (!oracleType) throw new Error("oracleType is required");
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_oracle_rpc_pb.StreamPricesRequest.create();
		if (baseSymbol) request.baseSymbol = baseSymbol;
		if (quoteSymbol) request.quoteSymbol = quoteSymbol;
		request.oracleType = oracleType;
		return createStreamSubscriptionV2(this.client.streamPrices(request), (response) => {
			callback(IndexerOracleStreamTransformer.pricesStreamCallback(response));
		});
	}
	/**
	* Stream oracle prices by markets
	* @param params.marketIds - Optional array of market IDs to filter
	* @param params.callback - Called for each price update
	* @returns StreamSubscription
	*/
	streamOraclePricesByMarkets({ marketIds, callback }) {
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_oracle_rpc_pb.StreamPricesByMarketsRequest.create();
		if (marketIds) request.marketIds = marketIds;
		return createStreamSubscriptionV2(this.client.streamPricesByMarkets(request), (response) => {
			callback(IndexerOracleStreamTransformer.pricesByMarketsCallback(response));
		});
	}
};

//#endregion
//#region src/client/indexer/grpc_stream/streamV2/IndexerGrpcAccountStreamV2.ts
var IndexerGrpcAccountStreamV2 = class {
	constructor(endpoint, metadata) {
		require_defineProperty._defineProperty(this, "client", void 0);
		require_defineProperty._defineProperty(this, "transport", void 0);
		this.transport = new require_BaseGrpcConsumer.GrpcWebRpcTransport(endpoint, metadata);
		this.client = new __injectivelabs_indexer_proto_ts_v2_generated_injective_accounts_rpc_pb_client.InjectiveAccountsRPCClient(this.transport);
	}
	/**
	* Stream subaccount balance updates
	* @param params.subaccountId - The subaccount ID to stream balance for
	* @param params.callback - Called for each balance update
	* @returns StreamSubscription
	*/
	streamSubaccountBalance({ subaccountId, callback }) {
		if (!subaccountId) throw new Error("subaccountId is required");
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_accounts_rpc_pb.StreamSubaccountBalanceRequest.create();
		request.subaccountId = subaccountId;
		return createStreamSubscriptionV2(this.client.streamSubaccountBalance(request), (response) => {
			callback(IndexerAccountStreamTransformer.balanceStreamCallback(response));
		});
	}
};

//#endregion
//#region src/client/indexer/grpc_stream/streamV2/IndexerGrpcAuctionStreamV2.ts
var IndexerGrpcAuctionStreamV2 = class {
	constructor(endpoint, metadata) {
		require_defineProperty._defineProperty(this, "client", void 0);
		require_defineProperty._defineProperty(this, "transport", void 0);
		this.transport = new require_BaseGrpcConsumer.GrpcWebRpcTransport(endpoint, metadata);
		this.client = new __injectivelabs_indexer_proto_ts_v2_generated_injective_auction_rpc_pb_client.InjectiveAuctionRPCClient(this.transport);
	}
	/**
	* Stream auction bids
	* @param params.callback - Called for each bid update
	* @returns StreamSubscription
	*/
	streamBids({ callback }) {
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_auction_rpc_pb.StreamBidsRequest.create();
		return createStreamSubscriptionV2(this.client.streamBids(request), (response) => {
			callback(IndexerAuctionStreamTransformer.bidsStreamCallback(response));
		});
	}
};

//#endregion
//#region src/client/indexer/grpc_stream/streamV2/IndexerGrpcTradingStreamV2.ts
var IndexerGrpcTradingStreamV2 = class {
	constructor(endpoint, metadata) {
		require_defineProperty._defineProperty(this, "client", void 0);
		require_defineProperty._defineProperty(this, "transport", void 0);
		this.transport = new require_BaseGrpcConsumer.GrpcWebRpcTransport(endpoint, metadata);
		this.client = new __injectivelabs_indexer_proto_ts_v2_generated_injective_trading_rpc_pb_client.InjectiveTradingRPCClient(this.transport);
	}
	/**
	* Stream grid strategies
	* @param params.marketId - Optional market ID to filter strategies
	* @param params.accountAddresses - Optional array of account addresses to filter
	* @param params.callback - Called for each strategy update
	* @returns StreamSubscription
	*/
	streamGridStrategies({ marketId, accountAddresses, callback }) {
		if ((!accountAddresses || accountAddresses.length === 0) && !marketId) throw new Error("accountAddresses or marketId is required");
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_trading_rpc_pb.StreamStrategyRequest.create();
		if (accountAddresses) request.accountAddresses = accountAddresses;
		if (marketId) request.marketId = marketId;
		return createStreamSubscriptionV2(this.client.streamStrategy(request), (response) => {
			callback(response);
		});
	}
};

//#endregion
//#region src/client/indexer/grpc_stream/streamV2/IndexerGrpcArchiverStreamV2.ts
var IndexerGrpcArchiverStreamV2 = class {
	constructor(endpoint, metadata) {
		require_defineProperty._defineProperty(this, "client", void 0);
		require_defineProperty._defineProperty(this, "transport", void 0);
		this.transport = new require_BaseGrpcConsumer.GrpcWebRpcTransport(endpoint, metadata);
		this.client = new __injectivelabs_indexer_proto_ts_v2_generated_injective_archiver_rpc_pb_client.InjectiveArchiverRPCClient(this.transport);
	}
	/**
	* Stream spot average entries
	* @param params.account - The account address to stream entries for
	* @param params.callback - Called for each average entry update
	* @returns StreamSubscription
	*/
	streamSpotAverageEntries({ account, callback }) {
		if (!account) throw new Error("account is required");
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_archiver_rpc_pb.StreamSpotAverageEntriesRequest.create();
		request.account = account;
		return createStreamSubscriptionV2(this.client.streamSpotAverageEntries(request), (response) => {
			callback(IndexerArchiverStreamTransformer.spotAverageEntriesStreamCallback(response));
		});
	}
};

//#endregion
//#region src/client/indexer/grpc_stream/streamV2/IndexerGrpcExplorerStreamV2.ts
var IndexerGrpcExplorerStreamV2 = class {
	constructor(endpoint, metadata) {
		require_defineProperty._defineProperty(this, "client", void 0);
		require_defineProperty._defineProperty(this, "transport", void 0);
		this.transport = new require_BaseGrpcConsumer.GrpcWebRpcTransport(endpoint, metadata);
		this.client = new __injectivelabs_indexer_proto_ts_v2_generated_injective_explorer_rpc_pb_client.InjectiveExplorerRPCClient(this.transport);
	}
	/**
	* Stream block updates
	* @param params.callback - Called for each block update
	* @returns StreamSubscription
	*/
	streamBlocks({ callback }) {
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_explorer_rpc_pb.StreamBlocksRequest.create();
		return createStreamSubscriptionV2(this.client.streamBlocks(request), (response) => {
			callback(ExplorerStreamTransformer.blocksStreamCallback(response));
		});
	}
	/**
	* Stream blocks with transactions
	* @param params.callback - Called for each block with transactions update
	* @returns StreamSubscription
	*/
	streamBlocksWithTxs({ callback }) {
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_explorer_rpc_pb.StreamBlocksRequest.create();
		return createStreamSubscriptionV2(this.client.streamBlocks(request), (response) => {
			callback(ExplorerStreamTransformer.blocksWithTxsStreamCallback(response));
		});
	}
	/**
	* Stream transaction updates
	* @param params.callback - Called for each transaction update
	* @returns StreamSubscription
	*/
	streamTransactions({ callback }) {
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_explorer_rpc_pb.StreamTxsRequest.create();
		return createStreamSubscriptionV2(this.client.streamTxs(request), (response) => {
			callback(ExplorerStreamTransformer.transactionsStreamCallback(response));
		});
	}
};

//#endregion
//#region src/client/indexer/grpc_stream/streamV2/IndexerGrpcDerivativesStreamV2.ts
var IndexerGrpcDerivativesStreamV2 = class {
	constructor(endpoint, metadata) {
		require_defineProperty._defineProperty(this, "client", void 0);
		require_defineProperty._defineProperty(this, "transport", void 0);
		this.transport = new require_BaseGrpcConsumer.GrpcWebRpcTransport(endpoint, metadata);
		this.client = new __injectivelabs_indexer_proto_ts_v2_generated_injective_derivative_exchange_rpc_pb_client.InjectiveDerivativeExchangeRPCClient(this.transport);
	}
	/**
	* Stream derivative orders
	* @param params.marketId - Optional market ID to filter
	* @param params.subaccountId - Optional subaccount ID to filter
	* @param params.orderSide - Optional order side to filter
	* @param params.callback - Called for each order update
	* @returns StreamSubscription
	*/
	streamOrders({ marketId, subaccountId, orderSide, callback }) {
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_derivative_exchange_rpc_pb.StreamOrdersRequest.create();
		if (marketId) request.marketId = marketId;
		if (subaccountId) request.subaccountId = subaccountId;
		if (orderSide) request.orderSide = orderSide;
		return createStreamSubscriptionV2(this.client.streamOrders(request), (response) => {
			callback(IndexerDerivativeStreamTransformer.ordersStreamCallback(response));
		});
	}
	/**
	* Stream derivative order history
	* @param params.subaccountId - Optional subaccount ID to filter
	* @param params.marketId - Optional market ID to filter
	* @param params.orderTypes - Optional order types to filter
	* @param params.direction - Optional direction to filter
	* @param params.state - Optional state to filter
	* @param params.executionTypes - Optional execution types to filter
	* @param params.callback - Called for each order history update
	* @returns StreamSubscription
	*/
	streamOrdersHistory({ subaccountId, marketId, orderTypes, direction, state, executionTypes, callback }) {
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_derivative_exchange_rpc_pb.StreamOrdersHistoryRequest.create();
		if (subaccountId) request.subaccountId = subaccountId;
		if (marketId) request.marketId = marketId;
		if (orderTypes) request.orderTypes = orderTypes;
		if (direction) request.direction = direction;
		if (state) request.state = state;
		if (executionTypes) request.executionTypes = executionTypes;
		return createStreamSubscriptionV2(this.client.streamOrdersHistory(request), (response) => {
			callback(IndexerDerivativeStreamTransformer.orderHistoryStreamCallback(response));
		});
	}
	/**
	* Stream derivative trades
	* @param params.marketId - Optional market ID to filter
	* @param params.marketIds - Optional array of market IDs to filter
	* @param params.subaccountId - Optional subaccount ID to filter
	* @param params.subaccountIds - Optional array of subaccount IDs to filter
	* @param params.executionSide - Optional execution side to filter
	* @param params.direction - Optional direction to filter
	* @param params.pagination - Optional pagination options
	* @param params.callback - Called for each trade update
	* @returns StreamSubscription
	*/
	streamTrades({ marketIds, marketId, subaccountIds, subaccountId, executionSide, direction, pagination, callback }) {
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_derivative_exchange_rpc_pb.StreamTradesRequest.create();
		if (marketIds) request.marketIds = marketIds;
		if (marketId) request.marketId = marketId;
		if (subaccountIds) request.subaccountIds = subaccountIds;
		if (subaccountId) request.subaccountId = subaccountId;
		if (executionSide) request.executionSide = executionSide;
		if (direction) request.direction = direction;
		if (pagination) {
			if (pagination.skip !== void 0) request.skip = BigInt(pagination.skip);
			if (pagination.limit !== void 0) request.limit = pagination.limit;
		}
		return createStreamSubscriptionV2(this.client.streamTrades(request), (response) => {
			callback(IndexerDerivativeStreamTransformer.tradesStreamCallback(response));
		});
	}
	/**
	* Stream derivative positions
	* @param params.marketId - Optional market ID to filter
	* @param params.address - Optional address to filter
	* @param params.subaccountId - Optional subaccount ID to filter
	* @param params.callback - Called for each position update
	* @returns StreamSubscription
	*/
	streamPositions({ marketId, address, subaccountId, callback }) {
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_derivative_exchange_rpc_pb.StreamPositionsRequest.create();
		if (marketId) request.marketId = marketId;
		if (address) request.accountAddress = address;
		if (subaccountId) request.subaccountId = subaccountId;
		return createStreamSubscriptionV2(this.client.streamPositions(request), (response) => {
			callback(IndexerDerivativeStreamTransformer.positionStreamCallback(response));
		});
	}
	/**
	* Stream derivative markets
	* @param params.marketIds - Optional array of market IDs to filter
	* @param params.callback - Called for each market update
	* @returns StreamSubscription
	*/
	streamMarkets({ marketIds, callback }) {
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_derivative_exchange_rpc_pb.StreamMarketRequest.create();
		if (marketIds && marketIds.length) request.marketIds = marketIds;
		return createStreamSubscriptionV2(this.client.streamMarket(request), (response) => {
			callback(response);
		});
	}
	/**
	* Stream derivative orderbooks V2
	* @param params.marketIds - Array of market IDs to stream
	* @param params.callback - Called for each orderbook update
	* @returns StreamSubscription
	*/
	streamOrderbooksV2({ marketIds, callback }) {
		if (!marketIds || marketIds.length === 0) throw new Error("marketIds is required and cannot be empty");
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_derivative_exchange_rpc_pb.StreamOrderbookV2Request.create();
		request.marketIds = marketIds;
		return createStreamSubscriptionV2(this.client.streamOrderbookV2(request), (response) => {
			callback(IndexerDerivativeStreamTransformer.orderbookV2StreamCallback(response));
		});
	}
	/**
	* Stream derivative orderbook updates
	* @param params.marketIds - Array of market IDs to stream
	* @param params.callback - Called for each orderbook update
	* @returns StreamSubscription
	*/
	streamOrderbookUpdates({ marketIds, callback }) {
		if (!marketIds || marketIds.length === 0) throw new Error("marketIds is required and cannot be empty");
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_derivative_exchange_rpc_pb.StreamOrderbookUpdateRequest.create();
		request.marketIds = marketIds;
		return createStreamSubscriptionV2(this.client.streamOrderbookUpdate(request), (response) => {
			callback(IndexerDerivativeStreamTransformer.orderbookUpdateStreamCallback(response));
		});
	}
	/**
	* Stream derivative positions V2
	* @param params.marketId - Optional market ID to filter
	* @param params.address - Optional address to filter
	* @param params.subaccountId - Optional subaccount ID to filter
	* @param params.callback - Called for each position update
	* @returns StreamSubscription
	*/
	streamPositionsV2({ marketId, address, subaccountId, callback }) {
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_derivative_exchange_rpc_pb.StreamPositionsV2Request.create();
		if (marketId) request.marketId = marketId;
		if (address) request.accountAddress = address;
		if (subaccountId) request.subaccountId = subaccountId;
		return createStreamSubscriptionV2(this.client.streamPositionsV2(request), (response) => {
			callback(IndexerDerivativeStreamTransformer.positionV2StreamCallback(response));
		});
	}
};

//#endregion
//#region src/client/indexer/grpc_stream/streamV2/IndexerGrpcAccountPortfolioStreamV2.ts
var IndexerGrpcAccountPortfolioStreamV2 = class {
	constructor(endpoint, metadata) {
		require_defineProperty._defineProperty(this, "client", void 0);
		require_defineProperty._defineProperty(this, "transport", void 0);
		this.transport = new require_BaseGrpcConsumer.GrpcWebRpcTransport(endpoint, metadata);
		this.client = new __injectivelabs_indexer_proto_ts_v2_generated_injective_portfolio_rpc_pb_client.InjectivePortfolioRPCClient(this.transport);
	}
	/**
	* Stream account portfolio updates
	* @param params.accountAddress - The account address to stream portfolio for
	* @param params.subaccountId - Optional subaccount ID to filter
	* @param params.type - Optional portfolio type to filter
	* @param params.callback - Called for each portfolio update
	* @returns StreamSubscription
	*/
	streamAccountPortfolio({ accountAddress, subaccountId, type, callback }) {
		if (!accountAddress) throw new Error("accountAddress is required");
		if (typeof callback !== "function") throw new Error("callback must be a function");
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_portfolio_rpc_pb.StreamAccountPortfolioRequest.create();
		request.accountAddress = accountAddress;
		if (subaccountId) request.subaccountId = subaccountId;
		if (type) request.type = type;
		return createStreamSubscriptionV2(this.client.streamAccountPortfolio(request), (response) => {
			callback(IndexerAccountPortfolioStreamTransformer.accountPortfolioStreamCallback(response));
		});
	}
};

//#endregion
//#region src/client/indexer/grpc_stream/streamV2/StreamManagerV2.ts
/**
* Default retry configuration
*/
const DEFAULT_RETRY_CONFIG = {
	enabled: true,
	maxAttempts: 5,
	initialDelayMs: 1e3,
	maxDelayMs: 3e4,
	backoffMultiplier: 2,
	persistent: true
};
/**
* Maps gRPC status code to disconnect reason
*/
function mapGrpcCodeToReason(code) {
	switch (code) {
		case require_types.GrpcStatusCode.CANCELLED: return require_types.StreamDisconnectReason.UserStopped;
		case require_types.GrpcStatusCode.UNAVAILABLE: return require_types.StreamDisconnectReason.NetworkError;
		case require_types.GrpcStatusCode.DEADLINE_EXCEEDED: return require_types.StreamDisconnectReason.Timeout;
		case require_types.GrpcStatusCode.UNAUTHENTICATED:
		case require_types.GrpcStatusCode.PERMISSION_DENIED: return require_types.StreamDisconnectReason.AuthenticationError;
		case require_types.GrpcStatusCode.RESOURCE_EXHAUSTED: return require_types.StreamDisconnectReason.RateLimited;
		case require_types.GrpcStatusCode.INVALID_ARGUMENT:
		case require_types.GrpcStatusCode.NOT_FOUND:
		case require_types.GrpcStatusCode.ALREADY_EXISTS:
		case require_types.GrpcStatusCode.OUT_OF_RANGE:
		case require_types.GrpcStatusCode.UNIMPLEMENTED:
		case require_types.GrpcStatusCode.FAILED_PRECONDITION: return require_types.StreamDisconnectReason.InvalidRequest;
		case require_types.GrpcStatusCode.UNKNOWN:
		case require_types.GrpcStatusCode.INTERNAL:
		case require_types.GrpcStatusCode.DATA_LOSS:
		case require_types.GrpcStatusCode.ABORTED:
		default: return require_types.StreamDisconnectReason.StreamError;
	}
}
/**
* Determines if a disconnect reason should trigger a retry
*/
function isRetryableReason(reason) {
	switch (reason) {
		case require_types.StreamDisconnectReason.NetworkError:
		case require_types.StreamDisconnectReason.Timeout:
		case require_types.StreamDisconnectReason.RateLimited:
		case require_types.StreamDisconnectReason.StreamError:
		case require_types.StreamDisconnectReason.StreamEnded: return true;
		case require_types.StreamDisconnectReason.UserStopped:
		case require_types.StreamDisconnectReason.MaxRetries:
		case require_types.StreamDisconnectReason.AuthenticationError:
		case require_types.StreamDisconnectReason.InvalidRequest: return false;
		default: return false;
	}
}
/**
* StreamManagerV2 - Manages gRPC stream connections with automatic retry
*
* V2 Features:
* - Event-based lifecycle (on/off methods)
* - Automatic retry with exponential backoff
* - Persistent retry mode
* - Comprehensive gRPC error code mapping
* - Distinguishes retryable vs non-retryable errors
*
*/
var StreamManagerV2 = class extends eventemitter3.EventEmitter {
	constructor(config) {
		super();
		require_defineProperty._defineProperty(this, "config", void 0);
		require_defineProperty._defineProperty(this, "state", require_types.StreamState.Idle);
		require_defineProperty._defineProperty(this, "subscription", null);
		require_defineProperty._defineProperty(this, "retryTimeoutId", null);
		require_defineProperty._defineProperty(this, "retryAttempt", 0);
		this.config = {
			id: config.id,
			streamFactory: config.streamFactory,
			onData: config.onData,
			retryConfig: {
				...DEFAULT_RETRY_CONFIG,
				...config.retryConfig
			}
		};
		const originalEmit = this.emit.bind(this);
		this.emit = ((event, ...args) => {
			if (event === require_types.StreamEvent.Data && args.length > 0) this.handleData(args[0]);
			return originalEmit(event, ...args);
		});
	}
	start() {
		if (this.state !== require_types.StreamState.Idle && this.state !== require_types.StreamState.Stopped) {
			this.emit(require_types.StreamEvent.Warn, { message: `Stream already started (state: ${this.state})` });
			return;
		}
		this.connect();
	}
	stop() {
		this.handleDisconnect(require_types.StreamDisconnectReason.UserStopped);
	}
	getId() {
		return this.config.id;
	}
	/**
	* Destroy the stream manager and clean up all resources
	* Call this when the stream manager is no longer needed
	*/
	destroy() {
		this.stop();
		this.removeAllListeners();
	}
	getState() {
		return this.state;
	}
	updateState(newState) {
		const oldState = this.state;
		this.state = newState;
		this.emit(require_types.StreamEvent.StateChange, {
			from: oldState,
			to: newState
		});
	}
	clearSubscription() {
		if (!this.subscription) return;
		this.subscription.unsubscribe();
		this.subscription = null;
	}
	clearRetryTimeout() {
		if (!this.retryTimeoutId) return;
		clearTimeout(this.retryTimeoutId);
		this.retryTimeoutId = null;
	}
	calculateNextBackoff(reason) {
		const baseDelay = reason === require_types.StreamDisconnectReason.RateLimited ? Math.max(this.config.retryConfig.initialDelayMs, 5e3) : this.config.retryConfig.initialDelayMs;
		if (this.config.retryConfig.maxAttempts > 0 && this.retryAttempt >= this.config.retryConfig.maxAttempts) return this.config.retryConfig.persistent ? this.config.retryConfig.maxDelayMs : null;
		const nextBackoffDelay = baseDelay * Math.pow(this.config.retryConfig.backoffMultiplier, this.retryAttempt);
		return Math.min(nextBackoffDelay, this.config.retryConfig.maxDelayMs);
	}
	scheduleRetry(reason) {
		if (!this.config.retryConfig.enabled) return;
		const nextBackoff = this.calculateNextBackoff(reason);
		if (nextBackoff === null) {
			this.handleMaxRetriesReached();
			return;
		}
		this.retryTimeoutId = setTimeout(() => {
			this.retryAttempt++;
			this.emit(require_types.StreamEvent.Retry, {
				attempt: this.retryAttempt,
				delayMs: nextBackoff,
				nextBackoff: this.calculateNextBackoff(reason)
			});
			this.connect();
		}, nextBackoff);
	}
	handleMaxRetriesReached() {
		this.emit(require_types.StreamEvent.Error, { message: `Max retries (${this.config.retryConfig.maxAttempts}) reached` });
		this.handleDisconnect(require_types.StreamDisconnectReason.MaxRetries);
	}
	handleError(error) {
		const errorInfo = this.extractErrorInfo(error);
		this.emit(require_types.StreamEvent.Error, errorInfo);
		const reason = mapGrpcCodeToReason(error && typeof error === "object" && "code" in error ? error.code : require_types.GrpcStatusCode.UNKNOWN);
		this.handleDisconnect(reason);
	}
	/**
	* Handles incoming data - calls user callback
	* Called automatically when user emits 'data' event from streamFactory callback
	*/
	handleData(response) {
		try {
			this.config.onData(response);
		} catch (error) {
			this.handleError(error);
		}
	}
	handleConnected(isReconnect) {
		this.updateState(require_types.StreamState.Connected);
		this.retryAttempt = 0;
		this.emit(require_types.StreamEvent.Connect, {
			isReconnect,
			attempt: 0
		});
	}
	handleDisconnect(reason) {
		this.clearSubscription();
		this.clearRetryTimeout();
		const willRetry = isRetryableReason(reason) && this.config.retryConfig.enabled;
		this.emit(require_types.StreamEvent.Disconnect, {
			reason,
			willRetry,
			attempt: this.retryAttempt
		});
		if (willRetry) {
			this.updateState(require_types.StreamState.Reconnecting);
			this.scheduleRetry(reason);
		} else this.updateState(require_types.StreamState.Stopped);
	}
	connect() {
		this.clearSubscription();
		const isReconnect = this.state === require_types.StreamState.Reconnecting;
		this.updateState(isReconnect ? require_types.StreamState.Reconnecting : require_types.StreamState.Connecting);
		try {
			this.subscription = this.config.streamFactory();
			this.subscription.on("error", (error) => {
				this.handleError(error);
			});
			this.subscription.on("complete", () => {
				this.handleDisconnect(require_types.StreamDisconnectReason.StreamEnded);
			});
			this.handleConnected(isReconnect);
		} catch (error) {
			this.handleError(error);
		}
	}
	/**
	* Extracts error message, code, and details from an error object
	*/
	extractErrorInfo(error) {
		if (error && typeof error === "object" && "details" in error) return {
			message: error.details,
			code: error.code,
			details: error
		};
		const code = error && typeof error === "object" && "code" in error ? error.code : void 0;
		return {
			message: error instanceof Error ? error.message : "Unknown error",
			code,
			details: error instanceof Error ? error.stack : error
		};
	}
};

//#endregion
Object.defineProperty(exports, 'ExplorerStreamTransformer', {
  enumerable: true,
  get: function () {
    return ExplorerStreamTransformer;
  }
});
Object.defineProperty(exports, 'IndexerAccountPortfolioStreamTransformer', {
  enumerable: true,
  get: function () {
    return IndexerAccountPortfolioStreamTransformer;
  }
});
Object.defineProperty(exports, 'IndexerAccountStreamTransformer', {
  enumerable: true,
  get: function () {
    return IndexerAccountStreamTransformer;
  }
});
Object.defineProperty(exports, 'IndexerArchiverStreamTransformer', {
  enumerable: true,
  get: function () {
    return IndexerArchiverStreamTransformer;
  }
});
Object.defineProperty(exports, 'IndexerAuctionStreamTransformer', {
  enumerable: true,
  get: function () {
    return IndexerAuctionStreamTransformer;
  }
});
Object.defineProperty(exports, 'IndexerCampaignTransformer', {
  enumerable: true,
  get: function () {
    return IndexerCampaignTransformer;
  }
});
Object.defineProperty(exports, 'IndexerDerivativeStreamTransformer', {
  enumerable: true,
  get: function () {
    return IndexerDerivativeStreamTransformer;
  }
});
Object.defineProperty(exports, 'IndexerGrpcAccountApi', {
  enumerable: true,
  get: function () {
    return IndexerGrpcAccountApi;
  }
});
Object.defineProperty(exports, 'IndexerGrpcAccountPortfolioApi', {
  enumerable: true,
  get: function () {
    return IndexerGrpcAccountPortfolioApi;
  }
});
Object.defineProperty(exports, 'IndexerGrpcAccountPortfolioStream', {
  enumerable: true,
  get: function () {
    return IndexerGrpcAccountPortfolioStream;
  }
});
Object.defineProperty(exports, 'IndexerGrpcAccountPortfolioStreamV2', {
  enumerable: true,
  get: function () {
    return IndexerGrpcAccountPortfolioStreamV2;
  }
});
Object.defineProperty(exports, 'IndexerGrpcAccountPortfolioTransformer', {
  enumerable: true,
  get: function () {
    return IndexerGrpcAccountPortfolioTransformer;
  }
});
Object.defineProperty(exports, 'IndexerGrpcAccountStream', {
  enumerable: true,
  get: function () {
    return IndexerGrpcAccountStream;
  }
});
Object.defineProperty(exports, 'IndexerGrpcAccountStreamV2', {
  enumerable: true,
  get: function () {
    return IndexerGrpcAccountStreamV2;
  }
});
Object.defineProperty(exports, 'IndexerGrpcAccountTransformer', {
  enumerable: true,
  get: function () {
    return IndexerGrpcAccountTransformer;
  }
});
Object.defineProperty(exports, 'IndexerGrpcArchiverApi', {
  enumerable: true,
  get: function () {
    return IndexerGrpcArchiverApi;
  }
});
Object.defineProperty(exports, 'IndexerGrpcArchiverStream', {
  enumerable: true,
  get: function () {
    return IndexerGrpcArchiverStream;
  }
});
Object.defineProperty(exports, 'IndexerGrpcArchiverStreamV2', {
  enumerable: true,
  get: function () {
    return IndexerGrpcArchiverStreamV2;
  }
});
Object.defineProperty(exports, 'IndexerGrpcArchiverTransformer', {
  enumerable: true,
  get: function () {
    return IndexerGrpcArchiverTransformer;
  }
});
Object.defineProperty(exports, 'IndexerGrpcAuctionApi', {
  enumerable: true,
  get: function () {
    return IndexerGrpcAuctionApi;
  }
});
Object.defineProperty(exports, 'IndexerGrpcAuctionStream', {
  enumerable: true,
  get: function () {
    return IndexerGrpcAuctionStream;
  }
});
Object.defineProperty(exports, 'IndexerGrpcAuctionStreamV2', {
  enumerable: true,
  get: function () {
    return IndexerGrpcAuctionStreamV2;
  }
});
Object.defineProperty(exports, 'IndexerGrpcAuctionTransformer', {
  enumerable: true,
  get: function () {
    return IndexerGrpcAuctionTransformer;
  }
});
Object.defineProperty(exports, 'IndexerGrpcCampaignApi', {
  enumerable: true,
  get: function () {
    return IndexerGrpcCampaignApi;
  }
});
Object.defineProperty(exports, 'IndexerGrpcDerivativeTransformer', {
  enumerable: true,
  get: function () {
    return IndexerGrpcDerivativeTransformer;
  }
});
Object.defineProperty(exports, 'IndexerGrpcDerivativesApi', {
  enumerable: true,
  get: function () {
    return IndexerGrpcDerivativesApi;
  }
});
Object.defineProperty(exports, 'IndexerGrpcDerivativesStream', {
  enumerable: true,
  get: function () {
    return IndexerGrpcDerivativesStream;
  }
});
Object.defineProperty(exports, 'IndexerGrpcDerivativesStreamV2', {
  enumerable: true,
  get: function () {
    return IndexerGrpcDerivativesStreamV2;
  }
});
Object.defineProperty(exports, 'IndexerGrpcExplorerApi', {
  enumerable: true,
  get: function () {
    return IndexerGrpcExplorerApi;
  }
});
Object.defineProperty(exports, 'IndexerGrpcExplorerStream', {
  enumerable: true,
  get: function () {
    return IndexerGrpcExplorerStream;
  }
});
Object.defineProperty(exports, 'IndexerGrpcExplorerStreamV2', {
  enumerable: true,
  get: function () {
    return IndexerGrpcExplorerStreamV2;
  }
});
Object.defineProperty(exports, 'IndexerGrpcExplorerTransformer', {
  enumerable: true,
  get: function () {
    return IndexerGrpcExplorerTransformer;
  }
});
Object.defineProperty(exports, 'IndexerGrpcInsuranceFundApi', {
  enumerable: true,
  get: function () {
    return IndexerGrpcInsuranceFundApi;
  }
});
Object.defineProperty(exports, 'IndexerGrpcInsuranceFundTransformer', {
  enumerable: true,
  get: function () {
    return IndexerGrpcInsuranceFundTransformer;
  }
});
Object.defineProperty(exports, 'IndexerGrpcMegaVaultApi', {
  enumerable: true,
  get: function () {
    return IndexerGrpcMegaVaultApi;
  }
});
Object.defineProperty(exports, 'IndexerGrpcMegaVaultTransformer', {
  enumerable: true,
  get: function () {
    return IndexerGrpcMegaVaultTransformer;
  }
});
Object.defineProperty(exports, 'IndexerGrpcMetaApi', {
  enumerable: true,
  get: function () {
    return IndexerGrpcMetaApi;
  }
});
Object.defineProperty(exports, 'IndexerGrpcMitoApi', {
  enumerable: true,
  get: function () {
    return IndexerGrpcMitoApi;
  }
});
Object.defineProperty(exports, 'IndexerGrpcMitoStream', {
  enumerable: true,
  get: function () {
    return IndexerGrpcMitoStream;
  }
});
Object.defineProperty(exports, 'IndexerGrpcMitoStreamTransformer', {
  enumerable: true,
  get: function () {
    return IndexerGrpcMitoStreamTransformer;
  }
});
Object.defineProperty(exports, 'IndexerGrpcMitoStreamV2', {
  enumerable: true,
  get: function () {
    return IndexerGrpcMitoStreamV2;
  }
});
Object.defineProperty(exports, 'IndexerGrpcMitoTransformer', {
  enumerable: true,
  get: function () {
    return IndexerGrpcMitoTransformer;
  }
});
Object.defineProperty(exports, 'IndexerGrpcOracleApi', {
  enumerable: true,
  get: function () {
    return IndexerGrpcOracleApi;
  }
});
Object.defineProperty(exports, 'IndexerGrpcOracleStream', {
  enumerable: true,
  get: function () {
    return IndexerGrpcOracleStream;
  }
});
Object.defineProperty(exports, 'IndexerGrpcOracleStreamV2', {
  enumerable: true,
  get: function () {
    return IndexerGrpcOracleStreamV2;
  }
});
Object.defineProperty(exports, 'IndexerGrpcOracleTransformer', {
  enumerable: true,
  get: function () {
    return IndexerGrpcOracleTransformer;
  }
});
Object.defineProperty(exports, 'IndexerGrpcReferralApi', {
  enumerable: true,
  get: function () {
    return IndexerGrpcReferralApi;
  }
});
Object.defineProperty(exports, 'IndexerGrpcReferralTransformer', {
  enumerable: true,
  get: function () {
    return IndexerGrpcReferralTransformer;
  }
});
Object.defineProperty(exports, 'IndexerGrpcSpotApi', {
  enumerable: true,
  get: function () {
    return IndexerGrpcSpotApi;
  }
});
Object.defineProperty(exports, 'IndexerGrpcSpotStream', {
  enumerable: true,
  get: function () {
    return IndexerGrpcSpotStream;
  }
});
Object.defineProperty(exports, 'IndexerGrpcSpotStreamV2', {
  enumerable: true,
  get: function () {
    return IndexerGrpcSpotStreamV2;
  }
});
Object.defineProperty(exports, 'IndexerGrpcSpotTransformer', {
  enumerable: true,
  get: function () {
    return IndexerGrpcSpotTransformer;
  }
});
Object.defineProperty(exports, 'IndexerGrpcTradingApi', {
  enumerable: true,
  get: function () {
    return IndexerGrpcTradingApi;
  }
});
Object.defineProperty(exports, 'IndexerGrpcTradingStream', {
  enumerable: true,
  get: function () {
    return IndexerGrpcTradingStream;
  }
});
Object.defineProperty(exports, 'IndexerGrpcTradingStreamV2', {
  enumerable: true,
  get: function () {
    return IndexerGrpcTradingStreamV2;
  }
});
Object.defineProperty(exports, 'IndexerOracleStreamTransformer', {
  enumerable: true,
  get: function () {
    return IndexerOracleStreamTransformer;
  }
});
Object.defineProperty(exports, 'IndexerRestDerivativesChronosApi', {
  enumerable: true,
  get: function () {
    return IndexerRestDerivativesChronosApi;
  }
});
Object.defineProperty(exports, 'IndexerRestExplorerApi', {
  enumerable: true,
  get: function () {
    return IndexerRestExplorerApi;
  }
});
Object.defineProperty(exports, 'IndexerRestExplorerTransformer', {
  enumerable: true,
  get: function () {
    return IndexerRestExplorerTransformer;
  }
});
Object.defineProperty(exports, 'IndexerRestLeaderboardChronosApi', {
  enumerable: true,
  get: function () {
    return IndexerRestLeaderboardChronosApi;
  }
});
Object.defineProperty(exports, 'IndexerRestMarketChronosApi', {
  enumerable: true,
  get: function () {
    return IndexerRestMarketChronosApi;
  }
});
Object.defineProperty(exports, 'IndexerRestSpotChronosApi', {
  enumerable: true,
  get: function () {
    return IndexerRestSpotChronosApi;
  }
});
Object.defineProperty(exports, 'IndexerSpotStreamTransformer', {
  enumerable: true,
  get: function () {
    return IndexerSpotStreamTransformer;
  }
});
Object.defineProperty(exports, 'StreamManager', {
  enumerable: true,
  get: function () {
    return StreamManager;
  }
});
Object.defineProperty(exports, 'StreamManagerV2', {
  enumerable: true,
  get: function () {
    return StreamManagerV2;
  }
});
Object.defineProperty(exports, 'createStreamSubscription', {
  enumerable: true,
  get: function () {
    return createStreamSubscription;
  }
});
Object.defineProperty(exports, 'createStreamSubscriptionV2', {
  enumerable: true,
  get: function () {
    return createStreamSubscriptionV2;
  }
});