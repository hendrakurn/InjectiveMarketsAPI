import { u as Any } from "./tx_pb-Wr-aZfKH.cjs";
import { f as GrpcWebTransportAdditionalOptions } from "./index-Bp-AQIP3.cjs";
import { SnakeCase } from "type-fest";
import { ChainId, Coin } from "@injectivelabs/ts-types";
import { Network, NetworkEndpoints } from "@injectivelabs/networks";

//#region ../../node_modules/.pnpm/no-case@3.0.4/node_modules/no-case/dist/index.d.ts
interface Options {
  splitRegexp?: RegExp | RegExp[];
  stripRegexp?: RegExp | RegExp[];
  delimiter?: string;
  transform?: (part: string, index: number, parts: string[]) => string;
}
//#endregion
//#region ../../node_modules/.pnpm/snakecase-keys@5.4.4/node_modules/snakecase-keys/index.d.ts
// eslint-disable-next-line @typescript-eslint/ban-types
type EmptyTuple = [];

/**
Return a default type if input type is nil.
@template T - Input type.
@template U - Default type.
*/
type WithDefault<T, U extends T> = T extends undefined | void | null ? U : T;

/**
Check if an element is included in a tuple.
@template List - List of values.
@template Target - Target to search.
*/
type Includes<List extends readonly unknown[], Target> = List extends undefined ? false : List extends Readonly<EmptyTuple> ? false : List extends readonly [infer First, ...infer Rest] ? First extends Target ? true : Includes<Rest, Target> : boolean;

/**
Append a segment to dot-notation path.
@template S - Base path.
@template Last - Additional path.
*/
type AppendPath<S extends string, Last extends string> = S extends "" ? Last : `${S}.${Last}`;
declare namespace snakecaseKeys {
  /**
  Convert keys of an object to snake-case strings.
  @template T - Input object or array.
  @template Deep - Deep conversion flag.
  @template Exclude - Excluded keys.
  @template Path - Path of keys.
  */
  export type SnakeCaseKeys<T extends Record<string, any> | readonly any[], Deep extends boolean = true, Exclude extends readonly unknown[] = EmptyTuple, Path extends string = ""> = T extends readonly any[] ?
  // Handle arrays or tuples.
  { [P in keyof T]: T[P] extends Record<string, any> | readonly any[] ? SnakeCaseKeys<T[P], Deep, Exclude> : T[P] } : T extends Record<string, any> ?
  // Handle objects.
  { [P in keyof T as [Includes<Exclude, P>] extends [true] ? P : SnakeCase<P>]: [Deep] extends [true] ? T[P] extends Record<string, any> | undefined ? SnakeCaseKeys<T[P], Deep, Exclude, AppendPath<Path, P & string>> : T[P] : T[P] } :
  // Return anything else as-is.
  T;
  interface Options {
    /**
    Recurse nested objects and objects in arrays.
    @default true
    */
    readonly deep?: boolean;

    /**
    Exclude keys from being snakeCased.
    @default []
    */
    readonly exclude?: ReadonlyArray<string | RegExp>;

    /**
    Options object that gets passed to snake-case parsing function.
    @default {}
    */
    readonly parsingOptions?: Options;
  }
}

/**
Convert object keys to snake using [`to-snake-case`](https://github.com/ianstormtaylor/to-snake-case).
@param input - Object or array of objects to snake-case.
@param options - Options of conversion.
*/
declare function snakecaseKeys<T extends Record<string, any> | readonly any[], Options$1 extends snakecaseKeys.Options>(input: T, options?: Options$1): snakecaseKeys.SnakeCaseKeys<T, WithDefault<Options$1["deep"], true>, WithDefault<Options$1["exclude"], EmptyTuple>>;
//#endregion
//#region src/core/tx/eip712/types.d.ts
interface TypedDataField {
  name: string;
  type: string;
}
type Eip712ConvertTxArgs = {
  accountNumber: string;
  sequence: string;
  timeoutHeight: string;
  chainId: string;
  memo?: string;
};
type Eip712ConvertFeeArgs = {
  amount?: {
    amount: string;
    denom: string;
  }[];
  gas?: string;
  feePayer?: string;
};
interface TypedDataField {
  name: string;
  type: string;
}
type MapOfTypedDataField = Map<string, TypedDataField[]>;
//#endregion
//#region src/core/modules/MsgBase.d.ts
type SnakeCaseKeys$1<T extends Record<string, any> | readonly any[]> = snakecaseKeys.SnakeCaseKeys<T>;
/**
 * @category Messages
 */
declare abstract class MsgBase<Params$1, ProtoRepresentation extends Object, ObjectRepresentation extends Record<string, unknown> = {}> {
  params: Params$1;
  constructor(params: Params$1);
  abstract toProto(): ProtoRepresentation;
  abstract toData(): ProtoRepresentation & {
    '@type': string;
  };
  abstract toDirectSign(): {
    type: string;
    message: ProtoRepresentation;
  };
  abstract toAmino(): {
    type: string;
    value: ObjectRepresentation | SnakeCaseKeys$1<ProtoRepresentation>;
  };
  abstract toBinary(): Uint8Array;
  /** @deprecated - use toWeb3Gw instead, renamed for clarity */
  toWeb3(): ObjectRepresentation | (SnakeCaseKeys$1<ProtoRepresentation> & {
    '@type': string;
  });
  abstract toWeb3Gw(): ObjectRepresentation | (SnakeCaseKeys$1<ProtoRepresentation> & {
    '@type': string;
  });
  toJSON(): string;
  /**
   * Returns the types of the message for EIP712
   */
  toEip712Types(): Map<string, TypedDataField[]>;
  /**
   * Returns the values of the message for EIP712
   */
  toEip712(): {
    type: string;
    value: ObjectRepresentation | SnakeCaseKeys$1<ProtoRepresentation>;
  };
  /**
   * Returns the values of the message for EIP712_V2
   */
  toEip712V2(): ObjectRepresentation | (snakecaseKeys.SnakeCaseKeys<ProtoRepresentation, true, [], ""> & {
    '@type': string;
  });
  toDirectSignJSON(): string;
}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/cosmwasm/wasm/v1/types_pb.d.ts
/**
 * AccessConfig access control type.
 *
 * @generated from protobuf message cosmwasm.wasm.v1.AccessConfig
 */
interface AccessConfig {
  /**
   * @generated from protobuf field: cosmwasm.wasm.v1.AccessType permission = 1
   */
  permission: AccessType;
  /**
   * @generated from protobuf field: repeated string addresses = 3
   */
  addresses: string[];
}
/**
 * ContractInfo stores a WASM contract instance
 *
 * @generated from protobuf message cosmwasm.wasm.v1.ContractInfo
 */
interface ContractInfo {
  /**
   * CodeID is the reference to the stored Wasm code
   *
   * @generated from protobuf field: uint64 code_id = 1
   */
  codeId: bigint;
  /**
   * Creator address who initially instantiated the contract
   *
   * @generated from protobuf field: string creator = 2
   */
  creator: string;
  /**
   * Admin is an optional address that can execute migrations
   *
   * @generated from protobuf field: string admin = 3
   */
  admin: string;
  /**
   * Label is optional metadata to be stored with a contract instance.
   *
   * @generated from protobuf field: string label = 4
   */
  label: string;
  /**
   * Created Tx position when the contract was instantiated.
   *
   * @generated from protobuf field: cosmwasm.wasm.v1.AbsoluteTxPosition created = 5
   */
  created?: AbsoluteTxPosition;
  /**
   * @generated from protobuf field: string ibc_port_id = 6
   */
  ibcPortId: string;
  /**
   * Extension is an extension point to store custom metadata within the
   * persistence model.
   *
   * @generated from protobuf field: google.protobuf.Any extension = 7
   */
  extension?: Any;
}
/**
 * ContractCodeHistoryEntry metadata to a contract.
 *
 * @generated from protobuf message cosmwasm.wasm.v1.ContractCodeHistoryEntry
 */
interface ContractCodeHistoryEntry {
  /**
   * @generated from protobuf field: cosmwasm.wasm.v1.ContractCodeHistoryOperationType operation = 1
   */
  operation: ContractCodeHistoryOperationType;
  /**
   * CodeID is the reference to the stored WASM code
   *
   * @generated from protobuf field: uint64 code_id = 2
   */
  codeId: bigint;
  /**
   * Updated Tx position when the operation was executed.
   *
   * @generated from protobuf field: cosmwasm.wasm.v1.AbsoluteTxPosition updated = 3
   */
  updated?: AbsoluteTxPosition;
  /**
   * @generated from protobuf field: bytes msg = 4
   */
  msg: Uint8Array;
}
/**
 * AbsoluteTxPosition is a unique transaction position that allows for global
 * ordering of transactions.
 *
 * @generated from protobuf message cosmwasm.wasm.v1.AbsoluteTxPosition
 */
interface AbsoluteTxPosition {
  /**
   * BlockHeight is the block the contract was created at
   *
   * @generated from protobuf field: uint64 block_height = 1
   */
  blockHeight: bigint;
  /**
   * TxIndex is a monotonic counter within the block (actual transaction index,
   * or gas consumed)
   *
   * @generated from protobuf field: uint64 tx_index = 2
   */
  txIndex: bigint;
}
/**
 * Model is a struct that holds a KV pair
 *
 * @generated from protobuf message cosmwasm.wasm.v1.Model
 */
interface Model {
  /**
   * hex-encode key to read it better (this is often ascii)
   *
   * @generated from protobuf field: bytes key = 1
   */
  key: Uint8Array;
  /**
   * base64-encode raw value
   *
   * @generated from protobuf field: bytes value = 2
   */
  value: Uint8Array;
}
/**
 * AccessType permission types
 *
 * @generated from protobuf enum cosmwasm.wasm.v1.AccessType
 */
declare enum AccessType {
  /**
   * AccessTypeUnspecified placeholder for empty value
   *
   * @generated from protobuf enum value: ACCESS_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,
  /**
   * AccessTypeNobody forbidden
   *
   * @generated from protobuf enum value: ACCESS_TYPE_NOBODY = 1;
   */
  NOBODY = 1,
  /**
   * AccessTypeEverybody unrestricted
   *
   * @generated from protobuf enum value: ACCESS_TYPE_EVERYBODY = 3;
   */
  EVERYBODY = 3,
  /**
   * AccessTypeAnyOfAddresses allow any of the addresses
   *
   * @generated from protobuf enum value: ACCESS_TYPE_ANY_OF_ADDRESSES = 4;
   */
  ANY_OF_ADDRESSES = 4,
}
/**
 * ContractCodeHistoryOperationType actions that caused a code change
 *
 * @generated from protobuf enum cosmwasm.wasm.v1.ContractCodeHistoryOperationType
 */
declare enum ContractCodeHistoryOperationType {
  /**
   * ContractCodeHistoryOperationTypeUnspecified placeholder for empty value
   *
   * @generated from protobuf enum value: CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,
  /**
   * ContractCodeHistoryOperationTypeInit on chain contract instantiation
   *
   * @generated from protobuf enum value: CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT = 1;
   */
  INIT = 1,
  /**
   * ContractCodeHistoryOperationTypeMigrate code migration
   *
   * @generated from protobuf enum value: CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE = 2;
   */
  MIGRATE = 2,
  /**
   * ContractCodeHistoryOperationTypeGenesis based on genesis data
   *
   * @generated from protobuf enum value: CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS = 3;
   */
  GENESIS = 3,
}
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.AccessConfig
 */
declare const AccessConfig = new AccessConfig$Type();
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.ContractInfo
 */
declare const ContractInfo = new ContractInfo$Type();
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.ContractCodeHistoryEntry
 */
declare const ContractCodeHistoryEntry = new ContractCodeHistoryEntry$Type();
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.AbsoluteTxPosition
 */
declare const AbsoluteTxPosition = new AbsoluteTxPosition$Type();
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.Model
 */
declare const Model = new Model$Type();
//#endregion
//#region src/core/modules/wasm/ExecArgBase.d.ts
type ExecDataRepresentation$1<Data> = {
  [key: string]: Data;
};
declare abstract class ExecArgBase<Params$1, DataRepresentation> {
  params: Params$1;
  constructor(params: Params$1);
  abstract toData(): DataRepresentation;
  abstract toExecData(): ExecDataRepresentation$1<DataRepresentation>;
  toJSON(): Uint8Array;
  toExecJSON(): Uint8Array;
}
//#endregion
//#region src/core/modules/wasm/exec-args/ExecArgCW20Send.d.ts
/**
 * When we execute the `send` action on
 * a CW20 contract the  flow is the following:
 * Contract A -> moves tokens to Contract B -> Contract B executed a `receive` method
 * to move the tokens from its ownership to the recipient
 *
 * From the CW20 docs
 * Send{contract, amount, msg} - Moves amount tokens from the env.sender account to the recipient account.
 * contract must be an address of a contract that implements the Receiver interface.
 * The msg will be passed to the recipient contract, along with the amount.
 *
 * @experimental
 */
declare namespace ExecArgCW20Send {
  interface Params {
    contractAddress: string;
    amount: string;
    /**
     * This object represents the underlying method
     * that we want to execute on the CW20 smart contract
     */
    msg?: object;
  }
  interface Data {
    contract: string;
    amount: string;
    msg: string;
  }
}
/**
 * @category Contract Exec Arguments
 */
declare class ExecArgCW20Send extends ExecArgBase<ExecArgCW20Send.Params, ExecArgCW20Send.Data> {
  static fromJSON(params: ExecArgCW20Send.Params): ExecArgCW20Send;
  toData(): ExecArgCW20Send.Data;
  toExecData(): ExecDataRepresentation$1<ExecArgCW20Send.Data>;
}
//#endregion
//#region src/core/modules/wasm/exec-args/ExecArgSubmitVaa.d.ts
declare namespace ExecArgSubmitVaa {
  interface Params {
    signed: string;
  }
  interface Data {
    data: string;
  }
}
/**
 * @category Contract Exec Arguments
 */
declare class ExecArgSubmitVaa extends ExecArgBase<ExecArgSubmitVaa.Params, ExecArgSubmitVaa.Data> {
  static fromJSON(params: ExecArgSubmitVaa.Params): ExecArgSubmitVaa;
  toData(): ExecArgSubmitVaa.Data;
  toExecData(): ExecDataRepresentation$1<ExecArgSubmitVaa.Data>;
}
//#endregion
//#region src/core/modules/wasm/exec-args/ExecArgCreateRound.d.ts
declare namespace ExecArgCreateRound {
  interface Params {
    name: string;
    endDate: number;
    startDate: number;
  }
  interface Data {
    name: string;
    end_date: number;
    start_date: number;
  }
}
/**
 * @category Contract Exec Arguments
 */
declare class ExecArgCreateRound extends ExecArgBase<ExecArgCreateRound.Params, ExecArgCreateRound.Data> {
  static fromJSON(params: ExecArgCreateRound.Params): ExecArgCreateRound;
  toData(): ExecArgCreateRound.Data;
  toExecData(): ExecDataRepresentation$1<ExecArgCreateRound.Data>;
}
//#endregion
//#region src/core/modules/wasm/exec-args/ExecArgCW20Transfer.d.ts
/**
 * When we execute the `transfer` action on
 * a CW20 contract the  flow is the following:
 * Contract A moves ownership of the tokens from Bob to Alice
 *
 * Transfer{recipient, amount} - Moves amount tokens from the env.sender account to the recipient account.
 * This is designed to send to an address controlled by a private key and
 * does not trigger any actions on the recipient if it is a contract.
 */
declare namespace ExecArgCW20Transfer {
  interface Params {
    amount: string;
    recipient: string;
  }
  interface Data {
    recipient: string;
    amount: string;
  }
}
/**
 * @category Contract Exec Arguments
 */
declare class ExecArgCW20Transfer extends ExecArgBase<ExecArgCW20Transfer.Params, ExecArgCW20Transfer.Data> {
  static fromJSON(params: ExecArgCW20Transfer.Params): ExecArgCW20Transfer;
  toData(): ExecArgCW20Transfer.Data;
  toExecData(): ExecDataRepresentation$1<ExecArgCW20Transfer.Data>;
}
//#endregion
//#region src/core/modules/wasm/exec-args/ExecArgFundCampaign.d.ts
declare namespace ExecArgFundCampaign {
  interface Params {
    campaignId: number;
  }
  interface Data {
    campaign_id: number;
  }
}
/**
 * @category Contract Exec Arguments
 */
declare class ExecArgFundCampaign extends ExecArgBase<ExecArgFundCampaign.Params, ExecArgFundCampaign.Data> {
  static fromJSON(params: ExecArgFundCampaign.Params): ExecArgFundCampaign;
  toData(): ExecArgFundCampaign.Data;
  toExecData(): ExecDataRepresentation$1<ExecArgFundCampaign.Data>;
}
//#endregion
//#region src/core/modules/wasm/exec-args/ExecArgDepositTokens.d.ts
declare namespace ExecArgDepositTokens {
  interface Params {}
  interface Data {}
}
/**
 * @category Contract Exec Arguments
 */
declare class ExecArgDepositTokens extends ExecArgBase<ExecArgDepositTokens.Params, ExecArgDepositTokens.Data> {
  static fromJSON(params: ExecArgDepositTokens.Params): ExecArgDepositTokens;
  toData(): ExecArgDepositTokens.Data;
  toExecData(): ExecDataRepresentation$1<ExecArgDepositTokens.Data>;
}
//#endregion
//#region src/core/modules/wasm/exec-args/ExecArgSwapMinOutput.d.ts
declare namespace ExecArgSwapMinOutput {
  interface Params {
    minOutputQuantity: string;
    targetDenom: string;
    feeRecipient?: string;
  }
  interface Data {
    min_output_quantity: string;
    target_denom: string;
    fee_recipient?: string;
  }
}
/**
 * @category Contract Exec Arguments
 */
declare class ExecArgSwapMinOutput extends ExecArgBase<ExecArgSwapMinOutput.Params, ExecArgSwapMinOutput.Data> {
  static fromJSON(params: ExecArgSwapMinOutput.Params): ExecArgSwapMinOutput;
  toData(): ExecArgSwapMinOutput.Data;
  toExecData(): ExecDataRepresentation$1<ExecArgSwapMinOutput.Data>;
}
//#endregion
//#region src/core/modules/wasm/exec-args/ExecArgCreateCampaign.d.ts
declare namespace ExecArgCreateCampaign {
  interface Params {
    name: string;
    rewards: Coin[];
    inRound: number;
    marketId: string;
    description: string;
    subaccountIdSuffix: string;
  }
  interface Data {
    name: string;
    rewards: Coin[];
    in_round: number;
    market_id: string;
    description: string;
    subaccount_id_suffix: string;
  }
}
/**
 * @category Contract Exec Arguments
 */
declare class ExecArgCreateCampaign extends ExecArgBase<ExecArgCreateCampaign.Params, ExecArgCreateCampaign.Data> {
  static fromJSON(params: ExecArgCreateCampaign.Params): ExecArgCreateCampaign;
  toData(): ExecArgCreateCampaign.Data;
  toExecData(): ExecDataRepresentation$1<ExecArgCreateCampaign.Data>;
}
//#endregion
//#region src/core/modules/wasm/exec-args/ExecArgSwapExactOutput.d.ts
declare namespace ExecArgSwapExactOutput {
  interface Params {
    targetOutputQuantity: string;
    targetDenom: string;
    feeRecipient?: string;
  }
  interface Data {
    target_output_quantity: string;
    target_denom: string;
    fee_recipient?: string;
  }
}
/**
 * @category Contract Exec Arguments
 */
declare class ExecArgSwapExactOutput extends ExecArgBase<ExecArgSwapExactOutput.Params, ExecArgSwapExactOutput.Data> {
  static fromJSON(params: ExecArgSwapExactOutput.Params): ExecArgSwapExactOutput;
  toData(): ExecArgSwapExactOutput.Data;
  toExecData(): ExecDataRepresentation$1<ExecArgSwapExactOutput.Data>;
}
//#endregion
//#region src/core/modules/wasm/exec-args/ExecArgInitiateTransfer.d.ts
declare namespace ExecArgInitiateTransfer {
  interface Params {
    amount: string;
    recipient: string;
    recipientChainId: ChainId | number | string;
    info: Record<string, any>;
    relayerFee?: string;
    payload?: Uint8Array | null;
  }
  interface Data {
    nonce: number;
    asset: {
      amount: string;
      info: Record<string, any>;
    };
    recipient_chain: ChainId | number | string;
    recipient: string;
    fee: string;
    payload?: string;
  }
}
/**
 * @category Contract Exec Arguments
 */
declare class ExecArgInitiateTransfer extends ExecArgBase<ExecArgInitiateTransfer.Params, ExecArgInitiateTransfer.Data> {
  static fromJSON(params: ExecArgInitiateTransfer.Params): ExecArgInitiateTransfer;
  toData(): ExecArgInitiateTransfer.Data;
  toExecData(): ExecDataRepresentation$1<ExecArgInitiateTransfer.Data>;
}
//#endregion
//#region src/core/modules/wasm/exec-args/ExecArgUpdateGridConfig.d.ts
declare namespace ExecArgUpdateGridConfig {
  interface Params {
    maximumOrderValueDeviation?: string;
    maximumRebalanceRetries?: number;
    slippage?: string;
  }
  interface Data {
    maximum_order_value_deviation?: string;
    maximum_rebalance_retries?: number;
    slippage?: string;
  }
}
/**
 * @category Contract Exec Arguments
 */
declare class ExecArgUpdateGridConfig extends ExecArgBase<ExecArgUpdateGridConfig.Params, ExecArgUpdateGridConfig.Data> {
  static fromJSON(params: ExecArgUpdateGridConfig.Params): ExecArgUpdateGridConfig;
  toData(): ExecArgUpdateGridConfig.Data;
  toExecData(): ExecDataRepresentation$1<ExecArgUpdateGridConfig.Data>;
}
//#endregion
//#region src/core/modules/wasm/exec-args/ExecArgIncreaseAllowance.d.ts
declare namespace ExecArgIncreaseAllowance {
  interface Params {
    amount: string;
    spender: string;
    expires: Record<string, any>;
  }
  interface Data {
    amount: string;
    spender: string;
    expires: Record<string, any>;
  }
}
/**
 * @category Contract Exec Arguments
 */
declare class ExecArgIncreaseAllowance extends ExecArgBase<ExecArgIncreaseAllowance.Params, ExecArgIncreaseAllowance.Data> {
  static fromJSON(params: ExecArgIncreaseAllowance.Params): ExecArgIncreaseAllowance;
  toData(): ExecArgIncreaseAllowance.Data;
  toExecData(): ExecDataRepresentation$1<ExecArgIncreaseAllowance.Data>;
}
//#endregion
//#region src/core/modules/wasm/exec-args/ExecArgRemoveGridStrategy.d.ts
declare namespace ExecArgRemoveGridStrategy {
  interface Params {
    subaccountId?: string;
  }
  interface Data {
    subaccount_id?: string;
  }
}
/**
 * @category Contract Exec Arguments
 */
declare class ExecArgRemoveGridStrategy extends ExecArgBase<ExecArgRemoveGridStrategy.Params, ExecArgRemoveGridStrategy.Data> {
  static fromJSON(params: ExecArgRemoveGridStrategy.Params): ExecArgRemoveGridStrategy;
  toData(): ExecArgRemoveGridStrategy.Data;
  toExecData(): ExecDataRepresentation$1<ExecArgRemoveGridStrategy.Data>;
}
//#endregion
//#region src/core/modules/wasm/types.d.ts
declare const ExitType: {
  readonly Default: "default";
  readonly Quote: "quote";
  readonly Base: "base";
};
type ExitType = (typeof ExitType)[keyof typeof ExitType];
declare const StrategyType: {
  readonly Arithmetic: "arithmetic";
  readonly ArithmeticLP: "trailing_arithmetic_lp";
  readonly Geometric: "geometric";
};
type StrategyType = (typeof StrategyType)[keyof typeof StrategyType];
type TrailingArithmetic = {
  trailing_arithmetic: {
    lower_trailing_bound: string;
    upper_trailing_bound: string;
  };
};
type TrailingArithmeticLP = {
  trailing_arithmetic_l_p: {
    lower_trailing_bound: string;
    upper_trailing_bound: string;
  };
};
type ExitConfig = {
  exitType: ExitType;
  exitPrice: string;
};
//#endregion
//#region src/core/modules/wasm/exec-args/ExecArgCreatePerpGridStrategy.d.ts
declare namespace ExecArgCreatePerpGridStrategy {
  interface Params {
    subaccountId: string;
    lowerBound: string;
    upperBound: string;
    levels: number;
    slippage?: string;
    stopLoss?: string;
    takeProfit?: string;
    marginRatio: string;
    feeRecipient?: string;
  }
  interface Data {
    subaccount_id: string;
    bounds: [string, string];
    slippage?: string;
    stop_loss?: {
      exit_type: ExitType;
      exit_price: string;
    };
    take_profit?: {
      exit_type: ExitType;
      exit_price: string;
    };
    levels: number;
    strategy_type: {
      perpetual: {
        margin_ratio: string;
      };
    };
    fee_recipient?: string;
  }
}
/**
 * @category Contract Exec Arguments
 */
/** @deprecated */
declare class ExecArgCreatePerpGridStrategy extends ExecArgBase<ExecArgCreatePerpGridStrategy.Params, ExecArgCreatePerpGridStrategy.Data> {
  static fromJSON(params: ExecArgCreatePerpGridStrategy.Params): ExecArgCreatePerpGridStrategy;
  toData(): ExecArgCreatePerpGridStrategy.Data;
  toExecData(): ExecDataRepresentation$1<ExecArgCreatePerpGridStrategy.Data>;
}
//#endregion
//#region src/core/modules/wasm/exec-args/ExecArgCreateSpotGridStrategy.d.ts
declare namespace ExecArgCreateSpotGridStrategy {
  interface Params {
    subaccountId: string;
    lowerBound: string;
    upperBound: string;
    levels: number;
    slippage?: string;
    stopLoss?: ExitConfig;
    takeProfit?: ExitConfig;
    exitType?: ExitType;
    strategyType?: StrategyType;
    trailingArithmetic?: {
      upperTrailing: string;
      lowerTrailing: string;
      lpMode?: boolean;
    };
    feeRecipient?: string;
  }
  interface Data {
    subaccount_id: string;
    bounds: [string, string];
    levels: number;
    slippage?: string;
    stop_loss?: {
      exit_type: ExitType;
      exit_price: string;
    };
    take_profit?: {
      exit_type: ExitType;
      exit_price: string;
    };
    exit_type?: ExitType;
    strategy_type?: StrategyType | TrailingArithmetic | TrailingArithmeticLP;
    fee_recipient?: string;
  }
}
/**
 * @category Contract Exec Arguments
 */
/** @deprecated */
declare class ExecArgCreateSpotGridStrategy extends ExecArgBase<ExecArgCreateSpotGridStrategy.Params, ExecArgCreateSpotGridStrategy.Data> {
  static fromJSON(params: ExecArgCreateSpotGridStrategy.Params): ExecArgCreateSpotGridStrategy;
  toData(): ExecArgCreateSpotGridStrategy.Data;
  toExecData(): ExecDataRepresentation$1<ExecArgCreateSpotGridStrategy.Data>;
}
//#endregion
//#region src/core/modules/wasm/ExecPrivilegedArgBase.d.ts
type ExecDataRepresentation<Data> = {
  origin: string;
  name: string;
  args: Data;
};
/** Executing Messages with injective_exec */
declare abstract class ExecPrivilegedArgBase<Params$1, DataRepresentation> {
  params: Params$1;
  constructor(params: Params$1);
  abstract toData(): DataRepresentation;
  abstract toExecData(): ExecDataRepresentation<DataRepresentation>;
  toJSON(): string;
  toExecJSON(): string;
}
//#endregion
//#region src/core/modules/wasm/exec-priv-args/ExecPrivilegedArgVaultRedeem.d.ts
declare namespace ExecPrivilegedArgVaultRedeem {
  interface Params {
    origin: string;
    vaultSubaccountId: string;
    traderSubaccountId: string;
    args: Record<string, any>;
  }
  interface Data {
    vault_subaccount_id: string;
    trader_subaccount_id: string;
    msg: {
      redeem: Record<string, any>;
    };
  }
}
/**
 * @category Contract Exec Arguments
 */
declare class ExecPrivilegedArgVaultRedeem extends ExecPrivilegedArgBase<ExecPrivilegedArgVaultRedeem.Params, ExecPrivilegedArgVaultRedeem.Data> {
  static fromJSON(params: ExecPrivilegedArgVaultRedeem.Params): ExecPrivilegedArgVaultRedeem;
  toData(): ExecPrivilegedArgVaultRedeem.Data;
  toExecData(): ExecDataRepresentation<ExecPrivilegedArgVaultRedeem.Data>;
}
//#endregion
//#region src/core/modules/wasm/exec-priv-args/ExecPrivilegedArgVaultSubscribe.d.ts
declare namespace ExecPrivilegedArgVaultSubscribe {
  interface Params {
    origin: string;
    vaultSubaccountId: string;
    traderSubaccountId: string;
    args: Record<string, any>;
  }
  interface Data {
    vault_subaccount_id: string;
    trader_subaccount_id: string;
    msg: {
      subscribe: Record<string, any>;
    };
  }
}
/**
 * @category Contract Exec Arguments
 */
declare class ExecPrivilegedArgVaultSubscribe extends ExecPrivilegedArgBase<ExecPrivilegedArgVaultSubscribe.Params, ExecPrivilegedArgVaultSubscribe.Data> {
  static fromJSON(params: ExecPrivilegedArgVaultSubscribe.Params): ExecPrivilegedArgVaultSubscribe;
  toData(): ExecPrivilegedArgVaultSubscribe.Data;
  toExecData(): ExecDataRepresentation<ExecPrivilegedArgVaultSubscribe.Data>;
}
//#endregion
//#region src/core/modules/wasm/exec-args/ExecArgCW20AdapterRedeemAndTransfer.d.ts
declare namespace ExecArgCW20AdapterRedeemAndTransfer {
  interface Params {
    recipient: string;
  }
  interface Data {
    recipient: string;
  }
}
/**
 * @category Contract Exec Arguments
 */
declare class ExecArgCW20AdapterRedeemAndTransfer extends ExecArgBase<ExecArgCW20AdapterRedeemAndTransfer.Params, ExecArgCW20AdapterRedeemAndTransfer.Data> {
  static fromJSON(params: ExecArgCW20AdapterRedeemAndTransfer.Params): ExecArgCW20AdapterRedeemAndTransfer;
  toData(): ExecArgCW20AdapterRedeemAndTransfer.Data;
  toExecData(): ExecDataRepresentation$1<ExecArgCW20AdapterRedeemAndTransfer.Data>;
}
//#endregion
//#region src/core/modules/wasm/exec-priv-args/ExecPrivilegedArgOffChainVaultRedeem.d.ts
declare namespace ExecPrivilegedArgOffChainVaultRedeem {
  interface Params {
    origin: string;
    args: Record<string, any>;
  }
  interface Data {
    Redeem: {
      args: Record<string, any>;
    };
  }
}
/**
 * @category Contract Exec Arguments
 */
declare class ExecPrivilegedArgOffChainVaultRedeem extends ExecPrivilegedArgBase<ExecPrivilegedArgOffChainVaultRedeem.Params, ExecPrivilegedArgOffChainVaultRedeem.Data> {
  static fromJSON(params: ExecPrivilegedArgOffChainVaultRedeem.Params): ExecPrivilegedArgOffChainVaultRedeem;
  toData(): ExecPrivilegedArgOffChainVaultRedeem.Data;
  toExecData(): ExecDataRepresentation<ExecPrivilegedArgOffChainVaultRedeem.Data>;
}
//#endregion
//#region src/core/modules/wasm/exec-priv-args/ExecPrivilegedArgOffChainVaultSubscribe.d.ts
declare namespace ExecPrivilegedArgOffChainVaultSubscribe {
  interface Params {
    origin: string;
    args: Record<string, any>;
  }
  interface Data {
    Subscribe: {
      args: Record<string, any>;
    };
  }
}
/**
 * @category Contract Exec Arguments
 */
declare class ExecPrivilegedArgOffChainVaultSubscribe extends ExecPrivilegedArgBase<ExecPrivilegedArgOffChainVaultSubscribe.Params, ExecPrivilegedArgOffChainVaultSubscribe.Data> {
  static fromJSON(params: ExecPrivilegedArgOffChainVaultSubscribe.Params): ExecPrivilegedArgOffChainVaultSubscribe;
  toData(): ExecPrivilegedArgOffChainVaultSubscribe.Data;
  toExecData(): ExecDataRepresentation<ExecPrivilegedArgOffChainVaultSubscribe.Data>;
}
//#endregion
//#region src/core/modules/wasm/exec-args.d.ts
type ExecArgs = ExecArgCW20Send | ExecArgSubmitVaa | ExecArgCreateRound | ExecArgCW20Transfer | ExecArgFundCampaign | ExecArgSwapMinOutput | ExecArgDepositTokens | ExecArgCreateCampaign | ExecArgSwapExactOutput | ExecArgInitiateTransfer | ExecArgUpdateGridConfig | ExecArgIncreaseAllowance | ExecArgRemoveGridStrategy | ExecArgCreateSpotGridStrategy | ExecArgCreatePerpGridStrategy | ExecArgCW20AdapterRedeemAndTransfer;
type ExecPrivilegedArgs = ExecPrivilegedArgVaultRedeem | ExecPrivilegedArgVaultSubscribe | ExecPrivilegedArgOffChainVaultRedeem | ExecPrivilegedArgOffChainVaultSubscribe;
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/injective/wasmx/v1/proposal_pb.d.ts
/**
 * @generated from protobuf enum injective.wasmx.v1.FundingMode
 */
declare enum FundingMode {
  /**
   * @generated from protobuf enum value: Unspecified = 0;
   */
  Unspecified = 0,
  /**
   * @generated from protobuf enum value: SelfFunded = 1;
   */
  SelfFunded = 1,
  /**
   * @generated from protobuf enum value: GrantOnly = 2;
   */
  GrantOnly = 2,
  /**
   * @generated from protobuf enum value: Dual = 3;
   */
  Dual = 3,
}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/injective/wasmx/v1/wasmx_pb.d.ts
/**
 * @generated from protobuf message injective.wasmx.v1.Params
 */
interface Params {
  /**
   * Set the status to active to indicate that contracts can be executed in
   * begin blocker.
   *
   * @generated from protobuf field: bool is_execution_enabled = 1
   */
  isExecutionEnabled: boolean;
  /**
   * Maximum aggregate total gas to be used for the contract executions in the
   * BeginBlocker.
   *
   * @generated from protobuf field: uint64 max_begin_block_total_gas = 2
   */
  maxBeginBlockTotalGas: bigint;
  /**
   * the maximum gas limit each individual contract can consume in the
   * BeginBlocker.
   *
   * @generated from protobuf field: uint64 max_contract_gas_limit = 3
   */
  maxContractGasLimit: bigint;
  /**
   * min_gas_price defines the minimum gas price the contracts must pay to be
   * executed in the BeginBlocker.
   *
   * @generated from protobuf field: uint64 min_gas_price = 4
   */
  minGasPrice: bigint;
  /**
   * @generated from protobuf field: cosmwasm.wasm.v1.AccessConfig register_contract_access = 5
   */
  registerContractAccess?: AccessConfig;
}
/**
 * @generated from protobuf message injective.wasmx.v1.RegisteredContract
 */
interface RegisteredContract {
  /**
   * limit of gas per BB execution
   *
   * @generated from protobuf field: uint64 gas_limit = 1
   */
  gasLimit: bigint;
  /**
   * gas price that contract is willing to pay for execution in BeginBlocker
   *
   * @generated from protobuf field: uint64 gas_price = 2
   */
  gasPrice: bigint;
  /**
   * is contract currently active
   *
   * @generated from protobuf field: bool is_executable = 3
   */
  isExecutable: boolean;
  /**
   * code_id that is allowed to be executed (to prevent malicious updates) - if
   * nil/0 any code_id can be executed
   *
   * @generated from protobuf field: uint64 code_id = 4
   */
  codeId: bigint;
  /**
   * optional - admin addr that is allowed to update contract data
   *
   * @generated from protobuf field: string admin_address = 5
   */
  adminAddress: string;
  /**
   * Optional: address of the contract granting fee
   * Must be set if fund_mode is GrantOnly
   *
   * @generated from protobuf field: string granter_address = 6
   */
  granterAddress: string;
  /**
   * funding mode
   *
   * @generated from protobuf field: injective.wasmx.v1.FundingMode fund_mode = 7
   */
  fundMode: FundingMode;
}
/**
 * @generated MessageType for protobuf message injective.wasmx.v1.Params
 */
declare const Params = new Params$Type();
/**
 * @generated MessageType for protobuf message injective.wasmx.v1.RegisteredContract
 */
declare const RegisteredContract = new RegisteredContract$Type();
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/injective/wasmx/v1/tx_pb.d.ts
/**
 * MsgExecuteContractCompat submits the given message data to a smart contract,
 * compatible with EIP712
 *
 * @generated from protobuf message injective.wasmx.v1.MsgExecuteContractCompat
 */
interface MsgExecuteContractCompat$1 {
  /**
   * Sender is the that actor that signed the messages
   *
   * @generated from protobuf field: string sender = 1
   */
  sender: string;
  /**
   * Contract is the address of the smart contract
   *
   * @generated from protobuf field: string contract = 2
   */
  contract: string;
  /**
   * Msg json encoded message to be passed to the contract
   *
   * @generated from protobuf field: string msg = 3
   */
  msg: string;
  /**
   * Funds coins that are transferred to the contract on execution
   *
   * @generated from protobuf field: string funds = 4
   */
  funds: string;
}
/**
 * @generated MessageType for protobuf message injective.wasmx.v1.MsgExecuteContractCompat
 */
declare const MsgExecuteContractCompat$1 = new MsgExecuteContractCompat$Type();
//#endregion
//#region src/core/modules/wasm/msgs/MsgExecuteContractCompat.d.ts
declare namespace MsgExecuteContractCompat {
  interface Params {
    funds?: Coin | Coin[];
    sender: string;
    contractAddress: string;
    execArgs?: ExecArgs;
    exec?: {
      msg: Record<string, any>;
      action: string;
    };
    /**
     * Same as exec but you don't pass
     * the action as a separate property
     * but as a whole object
     * example:
        msg: {
          reset: {
            count: 10
          },
        },
     */
    msg?: Record<string, any>;
  }
  type Proto = MsgExecuteContractCompat$1;
  type Object = Omit<MsgExecuteContractCompat$1, 'msg'> & {
    msg: string;
  };
}
/**
 * @category Messages
 */
declare class MsgExecuteContractCompat extends MsgBase<MsgExecuteContractCompat.Params, MsgExecuteContractCompat.Proto> {
  static fromJSON(params: MsgExecuteContractCompat.Params): MsgExecuteContractCompat;
  toProto(): MsgExecuteContractCompat$1;
  toData(): {
    sender: string;
    contract: string;
    msg: string;
    funds: string;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      sender: string;
      contract: string;
      msg: string;
      funds: string;
    };
  };
  toWeb3Gw(): {
    sender: string;
    contract: string;
    msg: string;
    funds: string;
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgExecuteContractCompat$1;
  };
  toBinary(): Uint8Array;
  private getMsgObject;
}
//#endregion
//#region src/client/wasm/types.d.ts
interface WasmContractQueryResponse {
  data: Uint8Array;
}
//#endregion
//#region src/client/wasm/swap/types.d.ts
interface QueryRouteResponse {
  steps: string[];
  source_denom: string;
  target_denom: string;
}
interface QueryQuantityAndFeesResponse {
  expected_fees: {
    amount: string;
    denom: string;
  }[];
  result_quantity: string;
}
//#endregion
//#region src/client/wasm/swap/transformer.d.ts
declare class SwapQueryTransformer {
  static contractRouteResponseToContractRoute(response: WasmContractQueryResponse): {
    steps: string[];
    sourceDenom: string;
    targetDenom: string;
  };
  static contractAllRoutesResponseToContractAllRoutes(response: WasmContractQueryResponse): {
    steps: string[];
    sourceDenom: string;
    targetDenom: string;
  }[];
  static contractQuantityResponseToContractQuantity(response: WasmContractQueryResponse): {
    expectedFees: {
      amount: string;
      denom: string;
    }[];
    resultQuantity: string;
  };
}
//#endregion
//#region src/client/wasm/BaseWasmQuery.d.ts
declare abstract class BaseWasmQuery<Params$1> {
  params: Params$1;
  constructor(params: Params$1);
  abstract toPayload(): string;
}
//#endregion
//#region src/client/wasm/swap/queries/QueryRoute.d.ts
declare namespace QueryRouteArg {
  interface Params {
    sourceDenom: string;
    targetDenom: string;
  }
}
declare class QueryRoute extends BaseWasmQuery<QueryRouteArg.Params> {
  toPayload(): string;
}
//#endregion
//#region src/client/wasm/swap/queries/QueryAllRoutes.d.ts
declare namespace QueryAllRoutesArg {
  interface Params {}
}
declare class QueryAllRoutes extends BaseWasmQuery<QueryAllRoutesArg.Params> {
  toPayload(): string;
}
//#endregion
//#region src/client/wasm/swap/queries/QueryInputQuantity.d.ts
declare namespace QueryInputQuantityArg {
  interface Params {
    toQuantity: string;
    sourceDenom: string;
    targetDenom: string;
  }
}
declare class QueryInputQuantity extends BaseWasmQuery<QueryInputQuantityArg.Params> {
  toPayload(): string;
}
//#endregion
//#region src/client/wasm/swap/queries/QueryOutputQuantity.d.ts
declare namespace QueryOutputQuantityArg {
  interface Params {
    fromQuantity: string;
    sourceDenom: string;
    targetDenom: string;
  }
}
declare class QueryOutputQuantity extends BaseWasmQuery<QueryOutputQuantityArg.Params> {
  toPayload(): string;
}
//#endregion
//#region src/client/wasm/neptune/types.d.ts
type AssetInfo = {
  token: {
    contract_addr: string;
  };
} | {
  native_token: {
    denom: string;
  };
};
type AssetInfoWithPrice = {
  assetInfo: AssetInfo;
  price: string;
};
type PriceResponse = Array<[AssetInfo, {
  price: string;
}]>;
type LendingRateResponse = Array<[AssetInfo, string]>;
declare const NEPTUNE_USDT_CW20_CONTRACT = "inj1cy9hes20vww2yr6crvs75gxy5hpycya2hmjg9s";
//#endregion
//#region src/client/wasm/neptune/service.d.ts
declare class NeptuneService {
  private client;
  private priceOracleContract;
  /**
   * Constructs a new NeptuneService instan ce.
   * @param network The network to use (default: Mainnet).
   * @param endpoints Optional custom network endpoints.
   */
  constructor(network?: Network, endpoints?: NetworkEndpoints, options?: GrpcWebTransportAdditionalOptions);
  /**
   * Fetch prices for given assets from the Neptune Price Oracle contract.
   * @param assets Array of AssetInfo objects.
   * @returns Array of Price objects.
   */
  fetchPrices(assets: AssetInfo[]): Promise<AssetInfoWithPrice[]>;
  /**
   * Fetch the redemption ratio based on CW20 and native asset prices.
   * @param cw20Asset AssetInfo for the CW20 token.
   * @param nativeAsset AssetInfo for the native token.
   * @returns Redemption ratio as a number.
   */
  fetchRedemptionRatio({
    cw20Asset,
    nativeAsset
  }: {
    cw20Asset: AssetInfo;
    nativeAsset: AssetInfo;
  }): Promise<number>;
  /**
   * Convert CW20 nUSDT to bank nUSDT using the redemption ratio.
   * @param amountCW20 Amount in CW20 nUSDT.
   * @param redemptionRatio Redemption ratio.
   * @returns Amount in bank nUSDT.
   */
  calculateBankAmount(amountCW20: number, redemptionRatio: number): number;
  /**
   * Convert bank nUSDT to CW20 nUSDT using the redemption ratio.
   * @param amountBank Amount in bank nUSDT.
   * @param redemptionRatio Redemption ratio.
   * @returns Amount in CW20 nUSDT.
   */
  calculateCw20Amount(amountBank: number, redemptionRatio: number): number;
  /**
   * Create a deposit message.
   * @param sender Sender's Injective address.
   * @param contractAddress USDT market contract address.
   * @param denom Denomination of the asset.
   * @param amount Amount to deposit as a string.
   * @returns MsgExecuteContractCompat message.
   */
  createDepositMsg({
    denom,
    amount,
    sender,
    contractAddress
  }: {
    denom: string;
    amount: string;
    sender: string;
    contractAddress?: string;
  }): MsgExecuteContractCompat;
  /**
   * Create a withdraw message.
   * @param sender Sender's Injective address.
   * @param contractAddress nUSDT contract address.
   * @param amount Amount to withdraw as a string.
   * @returns MsgExecuteContractCompat message.
   */
  createWithdrawMsg({
    amount,
    sender,
    cw20ContractAddress,
    marketContractAddress
  }: {
    amount: string;
    sender: string;
    cw20ContractAddress?: string;
    marketContractAddress?: string;
  }): MsgExecuteContractCompat;
  /**
   * Fetch lending rates with optional pagination parameters.
   * @param limit Maximum number of lending rates to fetch.
   * @param startAfter AssetInfo to start after for pagination.
   * @returns Array of [AssetInfo, Decimal256] tuples.
   */
  getLendingRates({
    limit,
    startAfter,
    contractAddress
  }: {
    limit?: number;
    startAfter?: AssetInfo;
    contractAddress?: string;
  }): Promise<Array<{
    assetInfo: AssetInfo;
    lendingRate: string;
  }>>;
  /**
   * Fetch the lending rate for a specific denom by querying the smart contract with pagination.
   * @param denom The denomination string of the asset to find the lending rate for.
   * @returns Lending rate as a string.
   */
  getLendingRateByDenom({
    denom,
    contractAddress
  }: {
    denom: string;
    contractAddress?: string;
  }): Promise<string | undefined>;
  /**
   * Calculates APY from APR and compounding frequency.
   *
   * @param apr - The annual percentage rate as a decimal (e.g., 0.10 for 10%)
   * @param compoundingFrequency - Number of times interest is compounded per year
   * @returns The annual percentage yield as a decimal
   */
  calculateAPY(apr: number): number;
}
//#endregion
//#region src/client/wasm/neptune/transformer.d.ts
declare class NeptuneQueryTransformer {
  static contractPricesResponseToPrices(response: WasmContractQueryResponse): Array<{
    assetInfo: AssetInfo;
    price: string;
  }>;
  static contractLendingRatesResponseToLendingRates(response: WasmContractQueryResponse): Array<{
    assetInfo: AssetInfo;
    lendingRate: string;
  }>;
}
//#endregion
//#region src/client/wasm/neptune/queries/QueryGetPrices.d.ts
declare namespace QueryGetPrices {
  interface Params {
    assets: AssetInfo[];
  }
}
declare class QueryGetPrices extends BaseWasmQuery<QueryGetPrices.Params> {
  toPayload(): string;
}
//#endregion
//#region src/client/wasm/neptune/queries/QueryLendingRates.d.ts
declare namespace QueryGetAllLendingRates {
  interface Params {
    limit?: number;
    startAfter?: AssetInfo;
  }
}
declare class QueryGetAllLendingRates extends BaseWasmQuery<QueryGetAllLendingRates.Params> {
  toPayload(): string;
}
//#endregion
//#region src/client/wasm/neptune/index.d.ts
declare const NEPTUNE_PRICE_CONTRACT = "inj1u6cclz0qh5tep9m2qayry9k97dm46pnlqf8nre";
//#endregion
//#region src/client/wasm/incentives/types.d.ts
interface QueryRoundResponse {
  id: number;
  name: string;
  end_date: number;
  start_date: number;
  campaigns: string[];
}
interface QueryCampaignResponse {
  id: number;
  name: string;
  rewards: Coin[];
  in_round: number;
  market_id: string;
  is_funded: boolean;
  description: string;
  total_rewards: string;
  is_finalized: boolean;
  subaccount_id_suffix: string;
}
//#endregion
//#region ../ts-types/dist/esm/index.d.ts
//#endregion
//#region src/cosmos.d.ts
interface Coin$1 {
  denom: string;
  amount: string;
}
//#endregion
//#region src/client/wasm/incentives/transformer.d.ts
declare class IncentivesQueryTransformer {
  static contractRoundResponseToContractRound(response: WasmContractQueryResponse): {
    id: number;
    name: string;
    endDate: number;
    campaigns: string[];
    startDate: number;
  }[];
  static contractCampaignResponseToContractCampaign(response: WasmContractQueryResponse): {
    id: number;
    name: string;
    rewards: Coin$1[];
    inRound: number;
    marketId: string;
    isFunded: boolean;
    description: string;
    isFinalized: boolean;
    totalRewards: string;
    subaccountIdSuffix: string;
  }[];
}
//#endregion
//#region src/client/wasm/incentives/queries/QueryAllRounds.d.ts
declare namespace QueryAllRoundsArg {
  interface Params {
    startAfter?: string;
    limit?: number;
  }
}
declare class QueryAllRounds extends BaseWasmQuery<QueryAllRoundsArg.Params> {
  toPayload(): string;
}
//#endregion
//#region src/client/wasm/incentives/queries/QueryGetCampaigns.d.ts
declare namespace QueryGetCampaignsArg {
  interface Params {
    campaigns: string[];
  }
}
declare class QueryGetCampaigns extends BaseWasmQuery<QueryGetCampaignsArg.Params> {
  toPayload(): string;
}
//#endregion
//#region src/client/wasm/nameservice/transformer.d.ts
declare class InjNameServiceQueryTransformer {
  static resolverAddressResponseToResolverAddress(response: WasmContractQueryResponse): any;
  static injectiveAddressResponseToInjectiveAddress(response: WasmContractQueryResponse): any;
  static injectiveNameResponseToInjectiveName(response: WasmContractQueryResponse): any;
}
//#endregion
//#region src/client/wasm/nameservice/queries/QueryInjName.d.ts
declare namespace QueryInjName {
  interface Params {
    address: string;
  }
}
declare class QueryInjName extends BaseWasmQuery<QueryInjName.Params> {
  toPayload(): string;
}
//#endregion
//#region src/client/wasm/nameservice/queries/QueryResolverAddress.d.ts
declare namespace QueryResolverAddress {
  interface Params {
    node: number[];
  }
}
declare class QueryResolverAddress extends BaseWasmQuery<QueryResolverAddress.Params> {
  toPayload(): string;
}
//#endregion
//#region src/client/wasm/nameservice/queries/QueryInjectiveAddress.d.ts
declare namespace QueryInjectiveAddress {
  interface Params {
    node: number[];
  }
}
declare class QueryInjectiveAddress extends BaseWasmQuery<QueryInjectiveAddress.Params> {
  toPayload(): string;
}
//#endregion
//#region src/client/wasm/trading_strategies/queries/QueryTradingStrategyContractConfig.d.ts
declare namespace QueryTradingStrategyContractConfig {
  interface Params {}
}
declare class QueryTradingStrategyContractConfig extends BaseWasmQuery<QueryTradingStrategyContractConfig.Params> {
  toPayload(): string;
}
//#endregion
//#region src/client/wasm/trading_strategies/queries/QueryTradingStrategyContractAllStrategies.d.ts
declare namespace QueryTradingStrategyContractAllStrategies {
  interface Params {
    startAfter?: string;
    limit?: number;
  }
}
declare class QueryTradingStrategyContractAllStrategies extends BaseWasmQuery<QueryTradingStrategyContractAllStrategies.Params> {
  toPayload(): string;
}
//#endregion
//#region src/client/wasm/trading_strategies/queries/QueryTradingStrategyContractUserStrategies.d.ts
declare namespace QueryTradingStrategyContractUserStrategies {
  interface Params {
    user: string;
  }
}
declare class QueryTradingStrategyContractUserStrategies extends BaseWasmQuery<QueryTradingStrategyContractUserStrategies.Params> {
  toPayload(): string;
}
//#endregion
//#region src/client/wasm/trading_strategies/queries/QueryTradingStrategyContractTotalStrategies.d.ts
declare namespace QueryTradingStrategyContractTotalStrategies {
  interface Params {}
}
declare class QueryTradingStrategyContractTotalStrategies extends BaseWasmQuery<QueryTradingStrategyContractTotalStrategies.Params> {
  toPayload(): string;
}
//#endregion
export { ExecArgInitiateTransfer as $, QueryQuantityAndFeesResponse as A, ExecArgCW20AdapterRedeemAndTransfer as B, NEPTUNE_USDT_CW20_CONTRACT as C, snakecaseKeys as Ct, QueryAllRoutes as D, QueryInputQuantity as E, RegisteredContract as F, ExitConfig as G, ExecPrivilegedArgVaultRedeem as H, ExecArgs as I, TrailingArithmetic as J, ExitType as K, ExecPrivilegedArgs as L, WasmContractQueryResponse as M, MsgExecuteContractCompat as N, QueryRoute as O, Params as P, ExecArgUpdateGridConfig as Q, ExecPrivilegedArgOffChainVaultSubscribe as R, LendingRateResponse as S, TypedDataField as St, QueryOutputQuantity as T, ExecArgCreateSpotGridStrategy as U, ExecPrivilegedArgVaultSubscribe as V, ExecArgCreatePerpGridStrategy as W, ExecArgRemoveGridStrategy as X, TrailingArithmeticLP as Y, ExecArgIncreaseAllowance as Z, QueryGetPrices as _, Model as _t, QueryInjectiveAddress as a, ExecArgCW20Transfer as at, AssetInfo as b, Eip712ConvertTxArgs as bt, InjNameServiceQueryTransformer as c, ExecArgCW20Send as ct, IncentivesQueryTransformer as d, AbsoluteTxPosition as dt, ExecArgSwapExactOutput as et, Coin$1 as f, AccessConfig as ft, QueryGetAllLendingRates as g, ContractInfo as gt, NEPTUNE_PRICE_CONTRACT as h, ContractCodeHistoryOperationType as ht, QueryTradingStrategyContractConfig as i, ExecArgFundCampaign as it, QueryRouteResponse as j, SwapQueryTransformer as k, QueryGetCampaigns as l, ExecArgBase as lt, QueryRoundResponse as m, ContractCodeHistoryEntry as mt, QueryTradingStrategyContractUserStrategies as n, ExecArgSwapMinOutput as nt, QueryResolverAddress as o, ExecArgCreateRound as ot, QueryCampaignResponse as p, AccessType as pt, StrategyType as q, QueryTradingStrategyContractAllStrategies as r, ExecArgDepositTokens as rt, QueryInjName as s, ExecArgSubmitVaa as st, QueryTradingStrategyContractTotalStrategies as t, ExecArgCreateCampaign as tt, QueryAllRounds as u, ExecDataRepresentation$1 as ut, NeptuneQueryTransformer as v, MsgBase as vt, PriceResponse as w, AssetInfoWithPrice as x, MapOfTypedDataField as xt, NeptuneService as y, Eip712ConvertFeeArgs as yt, ExecPrivilegedArgOffChainVaultRedeem as z };