const require_chunk = require('./chunk-CbDLau6x.cjs');
const require_utils = require('./utils-D3XFGv8y.cjs');
const require_defineProperty = require('./defineProperty-dyr5BsvG.cjs');
const require_types = require('./types-BSrt7JzM.cjs');
let __injectivelabs_utils = require("@injectivelabs/utils");
let __injectivelabs_networks = require("@injectivelabs/networks");

//#region src/service/TokenPrice.ts
const ASSET_PRICE_SERVICE_URL = "https://k8s.mainnet.asset.injective.network/asset-price/v1";
const TESTNET_ASSET_PRICE_SERVICE_URL = "https://k8s.testnet.asset.injective.network/asset-price/v1";
const DEVNET_ASSET_PRICE_SERVICE_URL = "https://devnet.asset.injective.dev/asset-price/v1";
const getAssetMicroserviceEndpoint = (network = __injectivelabs_networks.Network.Mainnet) => {
	if ((0, __injectivelabs_networks.isTestnet)(network)) return TESTNET_ASSET_PRICE_SERVICE_URL;
	if ((0, __injectivelabs_networks.isDevnet)(network)) return DEVNET_ASSET_PRICE_SERVICE_URL;
	return ASSET_PRICE_SERVICE_URL;
};
var TokenPrice = class {
	constructor(network) {
		require_defineProperty._defineProperty(this, "client", void 0);
		this.client = new __injectivelabs_utils.HttpRestClient(getAssetMicroserviceEndpoint(network));
	}
	async fetchUsdTokensPriceMap() {
		const response = await this.client.retry(() => this.client.get(`denoms?withPrice=true`));
		return Object.values(response.data).reduce((prices, tokenWithPrice) => {
			const id = tokenWithPrice.coingecko_id || tokenWithPrice.denom;
			if (prices[id]) return prices;
			prices[id] = tokenWithPrice.price.price;
			return prices;
		}, {});
	}
};

//#endregion
//#region src/service/TokenFactoryStatic.ts
/** @deprecated */
var TokenFactoryStatic = class {
	constructor(registry) {
		require_defineProperty._defineProperty(this, "registry", void 0);
		require_defineProperty._defineProperty(this, "tokensByDenom", void 0);
		require_defineProperty._defineProperty(this, "tokensBySymbol", void 0);
		require_defineProperty._defineProperty(this, "tokensByAddress", void 0);
		this.registry = registry;
		this.tokensByDenom = registry.reduce((list, token) => {
			const denom = token.denom.toLowerCase();
			if (list[denom]) return list;
			list[denom] = token;
			return list;
		}, {});
		this.tokensBySymbol = registry.reduce((list, token) => {
			const symbol = token.symbol.toLowerCase();
			if (list[symbol]) {
				list[symbol] = [...list[symbol], token];
				return list;
			}
			list[symbol] = [token];
			return list;
		}, {});
		this.tokensByAddress = registry.reduce((list, token) => {
			const address = token.address.toLowerCase();
			if (!address) return list;
			if (list[address]) return list;
			list[address] = [token];
			return list;
		}, {});
	}
	toToken(denom) {
		return this.getMetaByDenomOrAddress(denom) || this.getMetaBySymbol(denom);
	}
	getMetaBySymbol(symbol, { type, source, verification } = {}) {
		const tokensBySymbol = this.tokensBySymbol[symbol.toLowerCase()];
		if (!tokensBySymbol) return;
		const token = tokensBySymbol.find((token$1) => {
			const isType = !type || token$1.tokenType === type;
			const isSource = !source || token$1.source === source;
			const isVerification = !verification || token$1.tokenVerification === verification;
			return isType && isSource && isVerification;
		});
		const sortedTokens = tokensBySymbol.sort((t1, t2) => {
			const t1IsVerified = t1.tokenVerification === require_types.TokenVerification.Verified;
			const t2IsVerified = t2.tokenVerification === require_types.TokenVerification.Verified;
			return t1IsVerified && !t2IsVerified ? -1 : 1;
		});
		return token || sortedTokens[0];
	}
	getMetaByDenomOrAddress(denomOrAddress) {
		const formattedDenom = denomOrAddress.toLowerCase();
		if (this.tokensByDenom[formattedDenom]) return this.tokensByDenom[formattedDenom];
		if (!this.tokensByAddress[formattedDenom]) return;
		return this.tokensByAddress[formattedDenom].find(({ tokenVerification }) => tokenVerification === require_types.TokenVerification.Verified) || this.tokensByAddress[formattedDenom][0];
	}
};

//#endregion
//#region src/service/TokenStaticFactory.ts
var TokenStaticFactory = class {
	constructor(registry) {
		require_defineProperty._defineProperty(this, "registry", void 0);
		require_defineProperty._defineProperty(this, "denomVerifiedMap", void 0);
		require_defineProperty._defineProperty(this, "denomBlacklistedMap", void 0);
		require_defineProperty._defineProperty(this, "denomUnverifiedMap", void 0);
		require_defineProperty._defineProperty(this, "cw20AddressVerifiedMap", void 0);
		require_defineProperty._defineProperty(this, "cw20AddressUnverifiedMap", void 0);
		require_defineProperty._defineProperty(this, "factoryTokenDenomVerifiedMap", void 0);
		require_defineProperty._defineProperty(this, "factoryTokenDenomUnverifiedMap", void 0);
		require_defineProperty._defineProperty(this, "ibcDenomsVerifiedMap", void 0);
		require_defineProperty._defineProperty(this, "ibcDenomsUnverifiedMap", void 0);
		require_defineProperty._defineProperty(this, "ibcBaseDenomsVerifiedMap", void 0);
		require_defineProperty._defineProperty(this, "ibcBaseDenomsUnverifiedMap", void 0);
		require_defineProperty._defineProperty(this, "symbolTokensMap", void 0);
		require_defineProperty._defineProperty(this, "insuranceTokensMap", void 0);
		this.registry = registry;
		this.denomVerifiedMap = {};
		this.denomBlacklistedMap = {};
		this.denomUnverifiedMap = {};
		this.cw20AddressVerifiedMap = {};
		this.cw20AddressUnverifiedMap = {};
		this.factoryTokenDenomVerifiedMap = {};
		this.factoryTokenDenomUnverifiedMap = {};
		this.ibcDenomsVerifiedMap = {};
		this.ibcDenomsUnverifiedMap = {};
		this.ibcBaseDenomsVerifiedMap = {};
		this.ibcBaseDenomsUnverifiedMap = {};
		this.symbolTokensMap = {};
		this.insuranceTokensMap = {};
		if (registry.length > 0) this.mapRegistry(registry);
	}
	mapRegistry(registry) {
		for (const token of registry) {
			const { denom, baseDenom, symbol, address, tokenType, tokenVerification } = token;
			if (tokenVerification === require_types.TokenVerification.Verified) {
				this.denomVerifiedMap[denom] = token;
				this.symbolTokensMap[symbol.toLowerCase()] = token;
			} else this.denomUnverifiedMap[denom] = token;
			if (tokenType === require_types.TokenType.InsuranceFund) this.insuranceTokensMap[symbol.toLowerCase()] = token;
			if (denom.startsWith("factory/")) if (tokenVerification === require_types.TokenVerification.Verified) this.factoryTokenDenomVerifiedMap[denom] = token;
			else this.factoryTokenDenomUnverifiedMap[denom] = token;
			if (tokenType === require_types.TokenType.Cw20) if (tokenVerification === require_types.TokenVerification.Verified) this.cw20AddressVerifiedMap[address] = token;
			else this.cw20AddressUnverifiedMap[address] = token;
			if (tokenType === require_types.TokenType.Ibc) if (tokenVerification === require_types.TokenVerification.Verified) {
				this.ibcDenomsVerifiedMap[denom] = token;
				if (baseDenom) {
					const existingIbcBaseDenomToken = this.ibcBaseDenomsVerifiedMap[baseDenom];
					if (!existingIbcBaseDenomToken || !existingIbcBaseDenomToken.isNative) this.ibcBaseDenomsVerifiedMap[baseDenom] = token;
				}
			} else {
				this.ibcDenomsUnverifiedMap[denom] = token;
				if (baseDenom && token.baseDenom !== "Unknown") this.ibcBaseDenomsUnverifiedMap[baseDenom] = token;
			}
		}
	}
	getSymbolToken(symbol) {
		return this.symbolTokensMap[symbol.toLowerCase()];
	}
	getInsuranceToken(symbol) {
		return this.insuranceTokensMap[symbol.toLowerCase()];
	}
	getIbcToken(denom, { source, tokenVerification } = {}) {
		const denomTrimmed = denom.trim();
		if (source) return (tokenVerification === require_types.TokenVerification.Verified ? Object.values(this.ibcDenomsVerifiedMap) : [...Object.values(this.ibcDenomsVerifiedMap), ...Object.values(this.ibcDenomsVerifiedMap).flat()]).find((token) => token.source === source && (token.denom === denomTrimmed || (token === null || token === void 0 ? void 0 : token.baseDenom) === denomTrimmed));
		if (tokenVerification === require_types.TokenVerification.Verified) return this.ibcBaseDenomsVerifiedMap[denomTrimmed] || this.ibcDenomsVerifiedMap[denomTrimmed];
		return this.ibcBaseDenomsVerifiedMap[denomTrimmed] || this.ibcDenomsVerifiedMap[denomTrimmed] || this.ibcBaseDenomsUnverifiedMap[denomTrimmed] || this.ibcDenomsUnverifiedMap[denomTrimmed];
	}
	getCw20Token(address, { tokenVerification } = {}) {
		if (tokenVerification === require_types.TokenVerification.Verified) return this.cw20AddressVerifiedMap[address];
		return this.cw20AddressVerifiedMap[address] || this.cw20AddressUnverifiedMap[address];
	}
	getTokenFactoryToken(denom, { tokenVerification } = {}) {
		if (tokenVerification === require_types.TokenVerification.Verified) return this.factoryTokenDenomVerifiedMap[denom];
		return this.factoryTokenDenomVerifiedMap[denom] || this.factoryTokenDenomUnverifiedMap[denom];
	}
	toToken(denomOrSymbol, { source, verification } = {}) {
		const denomOrSymbolTrimmed = denomOrSymbol.trim();
		if (denomOrSymbolTrimmed === "inj") return this.denomVerifiedMap[denomOrSymbolTrimmed];
		if (source) return this.getIbcToken(denomOrSymbol, {
			source,
			tokenVerification: verification
		});
		if (denomOrSymbolTrimmed.startsWith("factory/wormhole")) return this.getIbcToken(denomOrSymbolTrimmed, { tokenVerification: verification });
		if (denomOrSymbolTrimmed.length < 42) return this.getSymbolToken(denomOrSymbolTrimmed) || this.getInsuranceToken(denomOrSymbolTrimmed) || this.getIbcToken(denomOrSymbolTrimmed, { tokenVerification: verification }) || this.denomVerifiedMap[denomOrSymbolTrimmed];
		if (require_utils.isCw20ContractAddress(denomOrSymbolTrimmed)) return this.getCw20Token(denomOrSymbolTrimmed, { tokenVerification: verification });
		if (denomOrSymbolTrimmed.startsWith("factory/")) return this.getTokenFactoryToken(denomOrSymbolTrimmed, { tokenVerification: verification });
		return this.denomVerifiedMap[denomOrSymbolTrimmed] || this.denomUnverifiedMap[denomOrSymbolTrimmed];
	}
};

//#endregion
Object.defineProperty(exports, 'TokenFactoryStatic', {
  enumerable: true,
  get: function () {
    return TokenFactoryStatic;
  }
});
Object.defineProperty(exports, 'TokenPrice', {
  enumerable: true,
  get: function () {
    return TokenPrice;
  }
});
Object.defineProperty(exports, 'TokenStaticFactory', {
  enumerable: true,
  get: function () {
    return TokenStaticFactory;
  }
});