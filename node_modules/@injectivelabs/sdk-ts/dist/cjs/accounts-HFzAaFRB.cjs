const require_chunk = require('./chunk-CbDLau6x.cjs');
const require_utils = require('./utils-D3XFGv8y.cjs');
const require_defineProperty = require('./defineProperty-dyr5BsvG.cjs');
const require_MsgBase = require('./MsgBase-D_1CCpXQ.cjs');
let __injectivelabs_core_proto_ts_v2_generated_cosmos_tx_v1beta1_tx_pb = require("@injectivelabs/core-proto-ts-v2/generated/cosmos/tx/v1beta1/tx_pb");
__injectivelabs_core_proto_ts_v2_generated_cosmos_tx_v1beta1_tx_pb = require_chunk.__toESM(__injectivelabs_core_proto_ts_v2_generated_cosmos_tx_v1beta1_tx_pb);
let viem = require("viem");
let __injectivelabs_utils = require("@injectivelabs/utils");
let __injectivelabs_exceptions = require("@injectivelabs/exceptions");
let __scure_base = require("@scure/base");
let __noble_curves_secp256k1 = require("@noble/curves/secp256k1");
let __injectivelabs_core_proto_ts_v2_generated_google_protobuf_any_pb = require("@injectivelabs/core-proto-ts-v2/generated/google/protobuf/any_pb");
__injectivelabs_core_proto_ts_v2_generated_google_protobuf_any_pb = require_chunk.__toESM(__injectivelabs_core_proto_ts_v2_generated_google_protobuf_any_pb);
let __injectivelabs_core_proto_ts_v2_generated_injective_crypto_v1beta1_ethsecp256k1_keys_pb = require("@injectivelabs/core-proto-ts-v2/generated/injective/crypto/v1beta1/ethsecp256k1/keys_pb");
__injectivelabs_core_proto_ts_v2_generated_injective_crypto_v1beta1_ethsecp256k1_keys_pb = require_chunk.__toESM(__injectivelabs_core_proto_ts_v2_generated_injective_crypto_v1beta1_ethsecp256k1_keys_pb);
let __scure_bip39 = require("@scure/bip39");
let __scure_bip39_wordlists_english = require("@scure/bip39/wordlists/english");
let __injectivelabs_ts_types = require("@injectivelabs/ts-types");
let ethers = require("ethers");
let __injectivelabs_core_proto_ts_v2_generated_injective_types_v1beta1_tx_ext_pb = require("@injectivelabs/core-proto-ts-v2/generated/injective/types/v1beta1/tx_ext_pb");
__injectivelabs_core_proto_ts_v2_generated_injective_types_v1beta1_tx_ext_pb = require_chunk.__toESM(__injectivelabs_core_proto_ts_v2_generated_injective_types_v1beta1_tx_ext_pb);
let __injectivelabs_core_proto_ts_v2_generated_cosmos_base_v1beta1_coin_pb = require("@injectivelabs/core-proto-ts-v2/generated/cosmos/base/v1beta1/coin_pb");
__injectivelabs_core_proto_ts_v2_generated_cosmos_base_v1beta1_coin_pb = require_chunk.__toESM(__injectivelabs_core_proto_ts_v2_generated_cosmos_base_v1beta1_coin_pb);
let __injectivelabs_core_proto_ts_v2_generated_cosmos_crypto_secp256k1_keys_pb = require("@injectivelabs/core-proto-ts-v2/generated/cosmos/crypto/secp256k1/keys_pb");
__injectivelabs_core_proto_ts_v2_generated_cosmos_crypto_secp256k1_keys_pb = require_chunk.__toESM(__injectivelabs_core_proto_ts_v2_generated_cosmos_crypto_secp256k1_keys_pb);
let __injectivelabs_core_proto_ts_v2_generated_injective_exchange_v1beta1_tx_pb = require("@injectivelabs/core-proto-ts-v2/generated/injective/exchange/v1beta1/tx_pb");
__injectivelabs_core_proto_ts_v2_generated_injective_exchange_v1beta1_tx_pb = require_chunk.__toESM(__injectivelabs_core_proto_ts_v2_generated_injective_exchange_v1beta1_tx_pb);

//#region src/core/accounts/Address.ts
/**
* @category Utility Classes
*/
var Address = class Address {
	constructor(bech32Address) {
		require_defineProperty._defineProperty(this, "bech32Address", void 0);
		this.bech32Address = bech32Address;
	}
	compare(address) {
		return this.bech32Address === address.bech32Address;
	}
	get address() {
		return this.bech32Address;
	}
	/**
	* Create an address instance from a bech32-encoded address and a prefix
	* @param {string} bech32 bech32-encoded address
	* @param {string} prefix
	* @return {Address}
	* @throws {Error} if bech is not a valid bech32-encoded address
	*/
	static fromBech32(bech, prefix = require_utils.BECH32_ADDR_ACC_PREFIX) {
		try {
			const address = require_utils.uint8ArrayToHex(__scure_base.bech32.fromWords(__scure_base.bech32.decode(bech).words));
			const addressBuffer = (0, viem.toBytes)((address.startsWith("0x") ? address : `0x${address}`).toString());
			return new Address(__scure_base.bech32.encode(prefix, __scure_base.bech32.toWords(addressBuffer)));
		} catch (e) {
			throw new __injectivelabs_exceptions.GeneralException(new Error(e), { type: __injectivelabs_exceptions.ErrorType.ValidationError });
		}
	}
	/**
	* Create an address instance from an ethereum address
	* @param {string} hex Ethereum address
	* @param {string} prefix
	* @return {Address}
	* @throws {Error} if bech is not a valid bech32-encoded address
	*/
	static fromHex(hex, prefix = require_utils.BECH32_ADDR_ACC_PREFIX) {
		const addressBuffer = (0, viem.toBytes)((hex.startsWith("0x") ? hex : `0x${hex}`).toString());
		return new Address(__scure_base.bech32.encode(prefix, __scure_base.bech32.toWords(addressBuffer)));
	}
	/**
	* Convert an address instance to a bech32-encoded account address
	* @param {string} prefix
	* @returns {string}
	*/
	toBech32(prefix = require_utils.BECH32_ADDR_ACC_PREFIX) {
		const address = this.toHex();
		const addressBuffer = (0, viem.toBytes)(address.startsWith("0x") ? address : `0x${address}`);
		return __scure_base.bech32.encode(prefix, __scure_base.bech32.toWords(addressBuffer));
	}
	/**
	* Return a bech32-encoded account address
	* @return {string}
	* @throws {Error} if this address is not a valid account address
	* */
	toAccountAddress() {
		return this.toBech32(require_utils.BECH32_ADDR_ACC_PREFIX);
	}
	/**
	* Return a bech32-encoded validator address
	* @return {string}
	* @throws {Error} if this address is not a valid validator address
	* */
	toValidatorAddress() {
		return this.toBech32(require_utils.BECH32_ADDR_VAL_PREFIX);
	}
	/**
	* Return a bech32-encoded consensus address
	* @return {string}
	* @throws {Error} if this address is not a valid consensus address
	* */
	toConsensusAddress() {
		return this.toBech32(require_utils.BECH32_ADDR_CONS_PREFIX);
	}
	/**
	* Return a hex representation of address
	* @return {string}
	* @throws {Error} if this address is not a valid account address
	* */
	toHex() {
		const { bech32Address } = this;
		const address = require_utils.uint8ArrayToHex(__scure_base.bech32.fromWords(__scure_base.bech32.decode(bech32Address).words));
		return address.startsWith("0x") ? address : `0x${address}`;
	}
	/**
	* Return a subaccount address from the given bech32 encoded address
	* @param {number} index the subaccount index
	* @return {string}
	* @throws {Error} if this address is not a valid account address
	* */
	getSubaccountId(index = 0) {
		const suffix = "0".repeat(23) + index;
		return `${this.toHex()}${suffix}`;
	}
	/**
	* Return a ethereum address from the given bech32 encoded address
	* @return {string}
	* @throws {Error} if this address is not a valid account address
	* */
	getEthereumAddress() {
		return this.toHex();
	}
};

//#endregion
//#region src/core/accounts/PublicKey.ts
/**
* @category Crypto Utility Classes
*/
var PublicKey = class PublicKey {
	constructor(key, type) {
		require_defineProperty._defineProperty(this, "type", void 0);
		require_defineProperty._defineProperty(this, "key", void 0);
		this.key = key;
		this.type = type || "/injective.crypto.v1beta1.ethsecp256k1.PubKey";
	}
	static fromBase64(publicKey) {
		return new PublicKey(require_utils.base64ToUint8Array(publicKey));
	}
	static fromBytes(publicKey) {
		return new PublicKey(publicKey);
	}
	static fromHex(pubKey) {
		return new PublicKey(require_utils.hexToUint8Array((pubKey.startsWith("0x") ? pubKey.slice(2) : pubKey).toString()));
	}
	static fromPrivateKeyHex(privateKey) {
		const isString = typeof privateKey === "string";
		const privateKeyHex = isString && privateKey.startsWith("0x") ? privateKey.slice(2) : privateKey;
		const privateKeyBuff = isString ? require_utils.hexToUint8Array(privateKeyHex.toString()) : privateKey;
		return new PublicKey(__noble_curves_secp256k1.secp256k1.getPublicKey(privateKeyBuff, true), "/injective.crypto.v1beta1.ethsecp256k1.PubKey");
	}
	toPubKeyBytes() {
		return this.key;
	}
	toBase64() {
		return require_utils.uint8ArrayToBase64(this.toPubKeyBytes());
	}
	toHex() {
		return require_utils.uint8ArrayToHex(this.toPubKeyBytes());
	}
	/**
	* Convert the public key to a pubkey in bech32 format.
	* Note: this does not convert the public key to an address.
	*/
	toBech32() {
		return __scure_base.bech32.encode(require_utils.BECH32_PUBKEY_ACC_PREFIX, __scure_base.bech32.toWords(require_utils.hexToUint8Array(this.toHex())));
	}
	toAddress() {
		const decompressedPublicKey = require_utils.decompressPubKey(this.toHex());
		const addressBuffer = (0, viem.keccak256)((0, viem.toBytes)(decompressedPublicKey.startsWith("0x") ? decompressedPublicKey : "0x" + decompressedPublicKey), "bytes").subarray(-20);
		return Address.fromHex(require_utils.uint8ArrayToHex(addressBuffer).toLowerCase());
	}
	toProto() {
		const proto = __injectivelabs_core_proto_ts_v2_generated_injective_crypto_v1beta1_ethsecp256k1_keys_pb.PubKey.create();
		proto.key = this.key;
		return proto;
	}
	toAny() {
		const proto = this.toProto();
		const message = __injectivelabs_core_proto_ts_v2_generated_google_protobuf_any_pb.Any.create();
		message.typeUrl = this.type;
		message.value = __injectivelabs_core_proto_ts_v2_generated_injective_crypto_v1beta1_ethsecp256k1_keys_pb.PubKey.toBinary(proto);
		return message;
	}
};

//#endregion
//#region src/core/tx/utils/helpers.ts
const createAnyMessage = (msg) => {
	const message = __injectivelabs_core_proto_ts_v2_generated_google_protobuf_any_pb.Any.create();
	message.typeUrl = `${msg.type.startsWith("/") ? "" : "/"}${msg.type}`;
	message.value = msg.value;
	return message;
};
const createAny = (value, type) => {
	const message = __injectivelabs_core_proto_ts_v2_generated_google_protobuf_any_pb.Any.create();
	message.typeUrl = type;
	message.value = value;
	return message;
};
const getInjectiveSignerAddress = (address) => {
	if (!address) return "";
	if (address.startsWith("inj")) return address;
	if (address.startsWith("0x")) return require_utils.getInjectiveAddress(address);
	return address;
};
const getEthereumSignerAddress = (address) => {
	if (!address) return "";
	if (address.startsWith("0x")) return address;
	if (address.startsWith("inj")) return require_utils.getEthereumAddress(address);
	return `0x${address}`;
};

//#endregion
//#region src/core/tx/utils/tx.ts
const getPublicKey = ({ chainId, key }) => {
	if (typeof key !== "string") return key;
	let proto;
	let path;
	let baseProto;
	if (chainId.startsWith("injective")) {
		proto = __injectivelabs_core_proto_ts_v2_generated_cosmos_crypto_secp256k1_keys_pb.PubKey.create();
		baseProto = __injectivelabs_core_proto_ts_v2_generated_cosmos_crypto_secp256k1_keys_pb.PubKey;
		path = "/injective.crypto.v1beta1.ethsecp256k1.PubKey";
	} else if (chainId.startsWith("evmos")) {
		proto = __injectivelabs_core_proto_ts_v2_generated_cosmos_crypto_secp256k1_keys_pb.PubKey.create();
		baseProto = __injectivelabs_core_proto_ts_v2_generated_cosmos_crypto_secp256k1_keys_pb.PubKey;
		path = "/ethermint.crypto.v1.ethsecp256k1.PubKey";
	} else {
		proto = __injectivelabs_core_proto_ts_v2_generated_cosmos_crypto_secp256k1_keys_pb.PubKey.create();
		baseProto = __injectivelabs_core_proto_ts_v2_generated_cosmos_crypto_secp256k1_keys_pb.PubKey;
		path = "/cosmos.crypto.secp256k1.PubKey";
	}
	proto.key = require_utils.base64ToUint8Array(key);
	return createAny(baseProto.toBinary(proto), path);
};
const createBody = ({ message, memo = "", timeoutHeight }) => {
	const messages = Array.isArray(message) ? message : [message];
	const txBody = __injectivelabs_core_proto_ts_v2_generated_cosmos_tx_v1beta1_tx_pb.TxBody.create();
	txBody.messages = messages.map((message$1) => createAnyMessage({
		value: message$1.toBinary(),
		type: message$1.toDirectSign().type
	}));
	txBody.memo = memo;
	if (timeoutHeight) txBody.timeoutHeight = BigInt(timeoutHeight);
	return txBody;
};
const createFee = ({ fee, payer, granter, gasLimit }) => {
	const feeAmount = __injectivelabs_core_proto_ts_v2_generated_cosmos_base_v1beta1_coin_pb.Coin.create();
	feeAmount.amount = fee.amount;
	feeAmount.denom = fee.denom;
	const feeProto = __injectivelabs_core_proto_ts_v2_generated_cosmos_tx_v1beta1_tx_pb.Fee.create();
	feeProto.gasLimit = BigInt(gasLimit);
	feeProto.amount = [feeAmount];
	if (payer) feeProto.payer = payer;
	if (granter) feeProto.granter = granter;
	return feeProto;
};
const createSigners = ({ chainId, mode, signers }) => {
	return signers.map((s) => createSignerInfo({
		mode,
		chainId,
		publicKey: s.pubKey,
		sequence: s.sequence
	}));
};
const createSignerInfo = ({ chainId, publicKey, sequence, mode }) => {
	const pubKey = getPublicKey({
		chainId,
		key: publicKey
	});
	const single = __injectivelabs_core_proto_ts_v2_generated_cosmos_tx_v1beta1_tx_pb.ModeInfo_Single.create();
	single.mode = mode;
	const modeInfo = __injectivelabs_core_proto_ts_v2_generated_cosmos_tx_v1beta1_tx_pb.ModeInfo.create();
	modeInfo.sum = {
		oneofKind: "single",
		single
	};
	const signerInfo = __injectivelabs_core_proto_ts_v2_generated_cosmos_tx_v1beta1_tx_pb.SignerInfo.create();
	signerInfo.publicKey = pubKey;
	signerInfo.sequence = BigInt(sequence);
	signerInfo.modeInfo = modeInfo;
	return signerInfo;
};
const createAuthInfo = ({ signerInfo, fee }) => {
	const authInfo = __injectivelabs_core_proto_ts_v2_generated_cosmos_tx_v1beta1_tx_pb.AuthInfo.create();
	authInfo.signerInfos = signerInfo;
	authInfo.fee = fee;
	return authInfo;
};
const createSignDoc = ({ bodyBytes, authInfoBytes, chainId, accountNumber }) => {
	const signDoc = __injectivelabs_core_proto_ts_v2_generated_cosmos_tx_v1beta1_tx_pb.SignDoc.create();
	signDoc.accountNumber = BigInt(accountNumber);
	signDoc.chainId = chainId;
	signDoc.bodyBytes = bodyBytes;
	signDoc.authInfoBytes = authInfoBytes;
	return signDoc;
};
const createSignDocFromTransaction = (args) => {
	return __injectivelabs_core_proto_ts_v2_generated_cosmos_tx_v1beta1_tx_pb.SignDoc.create({
		bodyBytes: args.txRaw.bodyBytes,
		authInfoBytes: args.txRaw.authInfoBytes,
		accountNumber: BigInt(args.accountNumber),
		chainId: args.chainId
	});
};
const createTxRawEIP712 = (txRaw, extension, nonCriticalExtension) => {
	const body = __injectivelabs_core_proto_ts_v2_generated_cosmos_tx_v1beta1_tx_pb.TxBody.fromBinary(txRaw.bodyBytes);
	body.extensionOptions = [createAny(__injectivelabs_core_proto_ts_v2_generated_injective_types_v1beta1_tx_ext_pb.ExtensionOptionsWeb3Tx.toBinary(extension), "/injective.types.v1beta1.ExtensionOptionsWeb3Tx")];
	if (nonCriticalExtension) body.nonCriticalExtensionOptions = Array.isArray(nonCriticalExtension) ? nonCriticalExtension : [nonCriticalExtension];
	txRaw.bodyBytes = __injectivelabs_core_proto_ts_v2_generated_cosmos_tx_v1beta1_tx_pb.TxBody.toBinary(body);
	return txRaw;
};
const createWeb3Extension = ({ evmChainId, feePayer, feePayerSig }) => {
	const web3Extension = __injectivelabs_core_proto_ts_v2_generated_injective_types_v1beta1_tx_ext_pb.ExtensionOptionsWeb3Tx.create();
	web3Extension.typedDataChainID = BigInt(evmChainId);
	if (feePayer) web3Extension.feePayer = feePayer;
	if (feePayerSig) web3Extension.feePayerSig = feePayerSig;
	return web3Extension;
};
const createNonCriticalExtensionFromObject = (object) => {
	return createAny(new TextEncoder().encode(require_utils.safeBigIntStringify(object)), "/google.protobuf.Struct");
};
const getTransactionPartsFromTxRaw = (txRaw) => {
	const authInfo = __injectivelabs_core_proto_ts_v2_generated_cosmos_tx_v1beta1_tx_pb.AuthInfo.fromBinary(txRaw.authInfoBytes);
	return {
		body: __injectivelabs_core_proto_ts_v2_generated_cosmos_tx_v1beta1_tx_pb.TxBody.fromBinary(txRaw.bodyBytes),
		authInfo,
		signatures: txRaw.signatures
	};
};
const getAminoStdSignDoc = ({ memo, chainId, accountNumber, timeoutHeight, sequence, gas, msgs }) => ({
	chain_id: chainId,
	timeout_height: timeoutHeight || "",
	account_number: accountNumber.toString(),
	sequence: sequence.toString(),
	fee: (0, __injectivelabs_utils.getStdFee)({ gas }),
	msgs: msgs.map((m) => m.toAmino()),
	memo: memo || ""
});

//#endregion
//#region src/core/tx/eip712/utils.ts
const getEip712Domain = (evmChainId) => {
	return { domain: {
		name: "Injective Web3",
		version: "1.0.0",
		chainId: "0x" + (0, __injectivelabs_utils.toBigNumber)(evmChainId).toString(16),
		salt: "0",
		verifyingContract: "cosmos"
	} };
};
const getEip712DomainV2 = (evmChainId) => {
	return { domain: {
		name: "Injective Web3",
		version: "1.0.0",
		chainId: "0x" + (0, __injectivelabs_utils.toBigNumber)(evmChainId).toString(16),
		verifyingContract: "0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC",
		salt: "0"
	} };
};
const getDefaultEip712Types = () => {
	return { types: {
		EIP712Domain: [
			{
				name: "name",
				type: "string"
			},
			{
				name: "version",
				type: "string"
			},
			{
				name: "chainId",
				type: "uint256"
			},
			{
				name: "verifyingContract",
				type: "string"
			},
			{
				name: "salt",
				type: "string"
			}
		],
		Tx: [
			{
				name: "account_number",
				type: "string"
			},
			{
				name: "chain_id",
				type: "string"
			},
			{
				name: "fee",
				type: "Fee"
			},
			{
				name: "memo",
				type: "string"
			},
			{
				name: "msgs",
				type: "Msg[]"
			},
			{
				name: "sequence",
				type: "string"
			},
			{
				name: "timeout_height",
				type: "string"
			}
		],
		Fee: [{
			name: "amount",
			type: "Coin[]"
		}, {
			name: "gas",
			type: "string"
		}],
		Coin: [{
			name: "denom",
			type: "string"
		}, {
			name: "amount",
			type: "string"
		}],
		Msg: [{
			name: "type",
			type: "string"
		}, {
			name: "value",
			type: "MsgValue"
		}]
	} };
};
const getDefaultEip712TypesV2 = () => {
	return { types: {
		EIP712Domain: [
			{
				name: "name",
				type: "string"
			},
			{
				name: "version",
				type: "string"
			},
			{
				name: "chainId",
				type: "uint256"
			},
			{
				name: "verifyingContract",
				type: "address"
			},
			{
				name: "salt",
				type: "string"
			}
		],
		Tx: [{
			name: "context",
			type: "string"
		}, {
			name: "msgs",
			type: "string"
		}]
	} };
};
const getEip712Fee = (params) => {
	const defaultStdFee = (0, __injectivelabs_utils.getDefaultStdFee)();
	if (!params) return { fee: defaultStdFee };
	const { amount, gas, feePayer } = {
		amount: params.amount || defaultStdFee.amount,
		gas: params.gas || __injectivelabs_utils.DEFAULT_GAS_LIMIT.toFixed(),
		feePayer: params.feePayer
	};
	return { fee: {
		...feePayer && { feePayer },
		gas,
		amount
	} };
};
const getEip712FeeV2 = (params) => {
	const defaultStdFee = (0, __injectivelabs_utils.getDefaultStdFee)();
	if (!params) return { fee: {
		amount: [{
			denom: defaultStdFee.amount[0].denom,
			amount: defaultStdFee.amount[0].amount
		}],
		gas: Number(defaultStdFee.gas)
	} };
	const amountFromParams = (params.amount || defaultStdFee.amount)[0];
	const { amount, gas, payer } = {
		amount: [{
			denom: amountFromParams.denom,
			amount: amountFromParams.amount
		}],
		gas: Number(params.gas || __injectivelabs_utils.DEFAULT_GAS_LIMIT.toFixed()),
		payer: params.feePayer
	};
	return { fee: {
		amount,
		gas,
		...payer && { payer }
	} };
};
const getTypesIncludingFeePayer = ({ fee, types }) => {
	if (!fee) return types;
	if (!fee.feePayer) return types;
	types.types["Fee"].unshift({
		name: "feePayer",
		type: "string"
	});
	return types;
};
const getEipTxDetails = ({ accountNumber, sequence, timeoutHeight, chainId, memo }) => {
	return {
		account_number: accountNumber,
		chain_id: chainId,
		timeout_height: timeoutHeight,
		memo: memo || "",
		sequence
	};
};
const getEipTxContext = ({ accountNumber, sequence, fee, timeoutHeight, chainId, memo }) => {
	return {
		account_number: Number(accountNumber),
		chain_id: chainId,
		...getEip712FeeV2(fee),
		memo: memo || "",
		sequence: Number(sequence),
		timeout_height: Number(timeoutHeight)
	};
};

//#endregion
//#region src/core/tx/eip712/eip712.ts
const getEip712TypedData = ({ msgs, tx, fee, evmChainId }) => {
	const messages = Array.isArray(msgs) ? msgs : [msgs];
	const eip712Msgs = messages.map((m) => m.toEip712());
	const eip712MessageTypes = messages[0].toEip712Types();
	return {
		...getTypesIncludingFeePayer({
			fee,
			types: { types: {
				...getDefaultEip712Types().types,
				...Object.fromEntries(eip712MessageTypes)
			} }
		}),
		primaryType: "Tx",
		...getEip712Domain(evmChainId),
		message: {
			...getEipTxDetails(tx),
			...getEip712Fee(fee),
			msgs: eip712Msgs
		}
	};
};
const getEip712TypedDataV2 = ({ msgs, tx, fee, evmChainId }) => {
	const eip712Msgs = (Array.isArray(msgs) ? msgs : [msgs]).map((m) => m.toEip712V2());
	return {
		...getDefaultEip712TypesV2(),
		primaryType: "Tx",
		...getEip712DomainV2(evmChainId),
		message: {
			context: require_utils.safeBigIntStringify(getEipTxContext({
				...tx,
				fee
			})),
			msgs: require_utils.safeBigIntStringify(eip712Msgs)
		}
	};
};

//#endregion
//#region src/core/modules/exchange/msgs/MsgSignData.ts
/**
* @category Messages
*/
var MsgSignData = class MsgSignData extends require_MsgBase.MsgBase {
	static fromJSON(params) {
		return new MsgSignData(params);
	}
	toProto() {
		const { params } = this;
		return __injectivelabs_core_proto_ts_v2_generated_injective_exchange_v1beta1_tx_pb.MsgSignData.create({
			signer: require_utils.hexToUint8Array(require_utils.getEthereumAddress(params.sender)),
			data: require_utils.stringToUint8Array(require_utils.toUtf8(params.data))
		});
	}
	toData() {
		const proto = this.toProto();
		return {
			"@type": "/injective.exchange.v1beta1.MsgSignData",
			...proto
		};
	}
	toAmino() {
		const proto = this.toProto();
		return {
			type: "sign/MsgSignData",
			value: {
				signer: require_utils.uint8ArrayToHex(proto.signer),
				data: require_utils.toUtf8(proto.data)
			}
		};
	}
	toWeb3Gw() {
		const { value } = this.toAmino();
		return {
			"@type": "/injective.exchange.v1beta1.MsgSignData",
			...value
		};
	}
	toDirectSign() {
		return {
			type: "/injective.exchange.v1beta1.MsgSignData",
			message: this.toProto()
		};
	}
	toBinary() {
		return __injectivelabs_core_proto_ts_v2_generated_injective_exchange_v1beta1_tx_pb.MsgSignData.toBinary(this.toProto());
	}
};

//#endregion
//#region src/core/modules/exchange/msgs/MsgIncreasePositionMargin.ts
const createMessage = (params) => {
	return __injectivelabs_core_proto_ts_v2_generated_injective_exchange_v1beta1_tx_pb.MsgIncreasePositionMargin.create({
		sender: params.injectiveAddress,
		sourceSubaccountId: params.srcSubaccountId,
		destinationSubaccountId: params.dstSubaccountId,
		marketId: params.marketId,
		amount: params.amount
	});
};
/**
* @category Messages
*/
var MsgIncreasePositionMargin = class MsgIncreasePositionMargin extends require_MsgBase.MsgBase {
	static fromJSON(params) {
		return new MsgIncreasePositionMargin(params);
	}
	toProto() {
		const { params: initialParams } = this;
		return createMessage({
			...initialParams,
			amount: (0, __injectivelabs_utils.toChainFormat)(initialParams.amount).toFixed()
		});
	}
	toData() {
		const proto = this.toProto();
		return {
			"@type": "/injective.exchange.v1beta1.MsgIncreasePositionMargin",
			...proto
		};
	}
	toAmino() {
		const { params } = this;
		return {
			type: "exchange/MsgIncreasePositionMargin",
			value: {
				sender: params.injectiveAddress,
				source_subaccount_id: params.srcSubaccountId,
				destination_subaccount_id: params.dstSubaccountId,
				market_id: params.marketId,
				amount: params.amount
			}
		};
	}
	toWeb3Gw() {
		const { value } = this.toAmino();
		return {
			"@type": "/injective.exchange.v1beta1.MsgIncreasePositionMargin",
			...value
		};
	}
	toEip712() {
		const { type, value } = this.toAmino();
		return {
			type,
			value: {
				...value,
				amount: (0, __injectivelabs_utils.toChainFormat)(value.amount).toFixed()
			}
		};
	}
	toEip712V2() {
		const { params } = this;
		return {
			...this.toWeb3Gw(),
			amount: require_utils.numberToCosmosSdkDecString(params.amount)
		};
	}
	toDirectSign() {
		return {
			type: "/injective.exchange.v1beta1.MsgIncreasePositionMargin",
			message: this.toProto()
		};
	}
	toBinary() {
		return __injectivelabs_core_proto_ts_v2_generated_injective_exchange_v1beta1_tx_pb.MsgIncreasePositionMargin.toBinary(this.toProto());
	}
};

//#endregion
//#region src/core/tx/eip712/MsgDecoder.ts
var MsgDecoder = class {
	static decode(message) {
		const type = message.typeUrl;
		switch (true) {
			case type.includes("MsgIncreasePositionMargin"): {
				const msg = __injectivelabs_core_proto_ts_v2_generated_injective_exchange_v1beta1_tx_pb.MsgIncreasePositionMargin.fromBinary(message.value);
				return MsgIncreasePositionMargin.fromJSON({
					marketId: msg.marketId,
					injectiveAddress: msg.sender,
					srcSubaccountId: msg.sourceSubaccountId,
					dstSubaccountId: msg.destinationSubaccountId,
					amount: msg.amount
				});
			}
			case type.includes("MsgSignData"): {
				const msg = __injectivelabs_core_proto_ts_v2_generated_injective_exchange_v1beta1_tx_pb.MsgSignData.fromBinary(message.value);
				return MsgSignData.fromJSON({
					data: require_utils.toUtf8(msg.data),
					sender: require_utils.getInjectiveAddress(require_utils.uint8ArrayToHex(msg.signer))
				});
			}
			default: throw new Error("Unknown message type");
		}
	}
};

//#endregion
//#region src/core/accounts/PrivateKey.ts
/**
* Class for wrapping SigningKey that is used for signature creation and public key derivation.
*
* @category Crypto Utility Classes
*/
var PrivateKey = class PrivateKey {
	constructor(wallet) {
		require_defineProperty._defineProperty(this, "wallet", void 0);
		this.wallet = wallet;
	}
	/**
	* Generate new private key with random mnemonic phrase
	* @returns { privateKey: PrivateKey, mnemonic: string }
	*/
	static generate() {
		const mnemonic = (0, __scure_bip39.generateMnemonic)(__scure_bip39_wordlists_english.wordlist);
		return {
			privateKey: PrivateKey.fromMnemonic(mnemonic),
			mnemonic
		};
	}
	/**
	* Create a PrivateKey instance from a given mnemonic phrase and a HD derivation path.
	* If path is not given, default to Band's HD prefix 494 and all other indexes being zeroes.
	* @param {string} words the mnemonic phrase
	* @param {string|undefined} path the HD path that follows the BIP32 standard (optional)
	* @returns {PrivateKey} Initialized PrivateKey object
	*/
	static fromMnemonic(words, path = require_utils.DEFAULT_DERIVATION_PATH) {
		return new PrivateKey(new ethers.Wallet(ethers.HDNodeWallet.fromPhrase(words, void 0, path).privateKey));
	}
	/**
	* Create a PrivateKey instance from a given private key and a HD derivation path.
	* If path is not given, default to Band's HD prefix 494 and all other indexes being zeroes.
	* @param {string} privateKey  the private key
	* @returns {PrivateKey} Initialized PrivateKey object
	*
	* @deprecated - use fromHex instead
	*/
	static fromPrivateKey(privateKey) {
		return new PrivateKey(new ethers.Wallet(privateKey));
	}
	/**
	* Create a PrivateKey instance from a given private key and a HD derivation path.
	* If path is not given, default to Band's HD prefix 494 and all other indexes being zeroes.
	* @param {string} privateKey  the private key
	* @returns {PrivateKey} Initialized PrivateKey object
	*/
	static fromHex(privateKey) {
		const isString = typeof privateKey === "string";
		const privateKeyHex = isString && privateKey.startsWith("0x") ? privateKey.slice(2) : privateKey;
		return new PrivateKey(new ethers.Wallet(require_utils.uint8ArrayToHex(isString ? require_utils.hexToUint8Array(privateKeyHex.toString()) : privateKey)));
	}
	/**
	* Return the private key in hex
	* @returns {string}
	**/
	toPrivateKeyHex() {
		return this.wallet.privateKey.startsWith("0x") ? this.wallet.privateKey : `0x${this.wallet.privateKey}`;
	}
	/**
	* Return the PublicKey associated with this private key.
	* @returns {PublicKey} a Public key that can be used to verify the signatures made with this PrivateKey
	**/
	toPublicKey() {
		return PublicKey.fromPrivateKeyHex(this.wallet.privateKey);
	}
	/**
	* Return the hex address associated with this private key.
	* @returns {string}
	*/
	toHex() {
		return this.wallet.address.startsWith("0x") ? this.wallet.address : `0x${this.wallet.address}`;
	}
	/**
	* Return the Address associated with this private key.
	* @returns {Address}
	**/
	toAddress() {
		return Address.fromHex(this.toHex());
	}
	/**
	* Return the Bech32 address associated with this private key.
	* @returns {string}
	**/
	toBech32() {
		return Address.fromHex(this.toHex()).toBech32();
	}
	/**
	* Sign the given message using the wallet's _signingKey function.
	* @param {string} messageBytes: the message that will be hashed and signed, a Buffer made of bytes
	* @returns {Uint8Array} a signature of this private key over the given message
	*/
	sign(messageBytes) {
		const { wallet } = this;
		const msgHash = (0, viem.keccak256)(messageBytes);
		const signature = wallet.signingKey.sign(msgHash);
		const splittedSignature = ethers.Signature.from(signature);
		return (0, ethers.getBytes)((0, ethers.concat)([splittedSignature.r, splittedSignature.s]));
	}
	/**
	* Sign the given message using the edcsa sign_deterministic function.
	* @param {Buffer} messageBytes: the message that will be hashed and signed, a Buffer made of bytes
	* @returns {Uint8Array} a signature of this private key over the given message
	*/
	signEcda(messageBytes) {
		const { wallet } = this;
		const msgHash = (0, viem.keccak256)(messageBytes);
		const privateKey = require_utils.hexToUint8Array(wallet.privateKey.startsWith("0x") ? wallet.privateKey.slice(2) : wallet.privateKey);
		return __noble_curves_secp256k1.secp256k1.sign((0, viem.toBytes)(msgHash), privateKey).toCompactRawBytes();
	}
	/**
	* Sign the given message using the wallet's _signingKey function.
	* @param {string} messageHashedBytes: the message that will be signed, a Buffer made of bytes
	* @returns {Uint8Array} a signature of this private key over the given message
	*/
	signHashed(messageHashedBytes) {
		const { wallet } = this;
		const signature = wallet.signingKey.sign(messageHashedBytes);
		const splittedSignature = ethers.Signature.from(signature);
		return (0, ethers.getBytes)((0, ethers.concat)([splittedSignature.r, splittedSignature.s]));
	}
	/**
	* Sign the given message using the edcsa sign_deterministic function.
	* @param {Buffer} messageHashedBytes: the message that will be signed, a Buffer made of bytes
	* @returns {Uint8Array} a signature of this private key over the given message
	*/
	signHashedEcda(messageHashedBytes) {
		const { wallet } = this;
		const privateKey = require_utils.hexToUint8Array(wallet.privateKey.startsWith("0x") ? wallet.privateKey.slice(2) : wallet.privateKey);
		return __noble_curves_secp256k1.secp256k1.sign(messageHashedBytes, privateKey).toCompactRawBytes();
	}
	/**
	* Sign the given typed data using the edcsa sign_deterministic function.
	* @param {TypedDataDefinition | any} eip712Data: the typed data that will be hashed and signed
	* @returns {Uint8Array} a signature of this private key over the given message
	*/
	async signTypedData(eip712Data) {
		const { wallet } = this;
		const privateKeyHex = wallet.privateKey.startsWith("0x") ? wallet.privateKey.slice(2) : wallet.privateKey;
		const msgHashBytes = (0, viem.hashTypedData)(require_utils.TypedDataUtilsSanitizeData(eip712Data));
		const privateKey = require_utils.hexToUint8Array(privateKeyHex);
		const sig = __noble_curves_secp256k1.secp256k1.sign((0, viem.toBytes)(msgHashBytes), privateKey);
		const signature = sig.toCompactRawBytes();
		const signatureWithRecovery = new Uint8Array(signature.length + 1);
		signatureWithRecovery.set(signature);
		signatureWithRecovery[signature.length] = sig.recovery + 27;
		return signatureWithRecovery;
	}
	/**
	* Sign the given typed data using the edcsa sign_deterministic function.
	* @param {Buffer} eip712Data: the typed data that will be signed, a Buffer made of bytes
	* @returns {Uint8Array} a signature of this private key over the given message
	*/
	signHashedTypedData(eip712Data) {
		const { wallet } = this;
		const privateKey = require_utils.hexToUint8Array(wallet.privateKey.startsWith("0x") ? wallet.privateKey.slice(2) : wallet.privateKey);
		return __noble_curves_secp256k1.secp256k1.sign(eip712Data, privateKey).toCompactRawBytes();
	}
	/**
	* Verify signature using EIP712 typed data
	* and the publicKey
	*
	* (params are passed as an object)
	*
	* @param {string} signature: the signature to verify in hex
	* @param {any} eip712: the EIP712 typed data to verify against
	* @param {string} publicKey: the public key to verify against in hex
	* */
	static async verifySignature({ signature, eip712, publicKey }) {
		const publicKeyInHex = publicKey.startsWith("0x") ? publicKey : `0x${publicKey}`;
		const recoveredPubKey = await require_utils.recoverTypedSignaturePubKey(eip712, signature);
		const recoveredPubKeyInHex = recoveredPubKey.startsWith("0x") ? recoveredPubKey : `0x${recoveredPubKey}`;
		/** uncompressed/compressed key */
		if (publicKeyInHex.length !== recoveredPubKeyInHex.length) return recoveredPubKeyInHex.substring(0, publicKeyInHex.length) === publicKeyInHex;
		return publicKeyInHex === recoveredPubKeyInHex;
	}
	/**
	* Verify signature using EIP712 typed data
	* and the publicKey
	*
	* (params are passed as an object)
	*
	* @param {string} signature: the signature to verify in hex
	* @param {any} eip712: the EIP712 typed data to verify against
	* @param {string} publicKey: the public key to verify against in hex
	* */
	async verifyThisPkSignature({ signature, eip712 }) {
		const publicKeyInHex = `0x${this.toPublicKey().toHex()}`;
		const recoveredPubKey = await require_utils.recoverTypedSignaturePubKey(eip712, signature);
		const recoveredPubKeyInHex = recoveredPubKey.startsWith("0x") ? recoveredPubKey : `0x${recoveredPubKey}`;
		/** uncompressed/compressed key */
		if (publicKeyInHex.length !== recoveredPubKeyInHex.length) return recoveredPubKeyInHex.substring(0, publicKeyInHex.length) === publicKeyInHex;
		return publicKeyInHex === recoveredPubKeyInHex;
	}
	/**
	* Verify cosmos signature EIP712 typed
	* data from the TxRaw and verify the signature
	* that's included in the TxRaw
	*
	* (params are passed as an object)
	*
	* @param {CosmosTxV1Beta1TxPb.TxRaw} txRaw: the signature to verify in hex
	* @param {object} signer: the public key and the account number to verify against
	**/
	static async verifyCosmosSignature({ txRaw, signer }) {
		const { body, authInfo, signatures } = getTransactionPartsFromTxRaw(txRaw);
		if (authInfo.signerInfos.length > 1 || signatures.length > 1) throw new __injectivelabs_exceptions.GeneralException(/* @__PURE__ */ new Error("Validation of multiple signers is not supported"));
		if (body.messages.length > 1) throw new __injectivelabs_exceptions.GeneralException(/* @__PURE__ */ new Error("Validation of multiple messages is not supported"));
		const getChainIds = () => {
			if (!body.extensionOptions.length) return {
				chainId: __injectivelabs_ts_types.ChainId.Mainnet,
				EvmChainId: __injectivelabs_ts_types.EvmChainId.Mainnet
			};
			const extension = body.extensionOptions.find((extension$1) => extension$1.typeUrl.includes("ExtensionOptionsWeb3Tx"));
			if (!extension) return {
				chainId: __injectivelabs_ts_types.ChainId.Mainnet,
				EvmChainId: __injectivelabs_ts_types.EvmChainId.Mainnet
			};
			const decodedExtension = __injectivelabs_core_proto_ts_v2_generated_injective_types_v1beta1_tx_ext_pb.ExtensionOptionsWeb3Tx.fromBinary(extension.value);
			const evmChainId$1 = Number(decodedExtension.typedDataChainID);
			return {
				evmChainId: __injectivelabs_ts_types.EvmChainId,
				chainId: [
					__injectivelabs_ts_types.EvmChainId.Kovan,
					__injectivelabs_ts_types.EvmChainId.Goerli,
					__injectivelabs_ts_types.EvmChainId.Sepolia
				].includes(evmChainId$1) ? __injectivelabs_ts_types.ChainId.Testnet : __injectivelabs_ts_types.ChainId.Mainnet
			};
		};
		const { evmChainId, chainId } = getChainIds();
		const [signerInfo] = authInfo.signerInfos;
		const [signature] = signatures;
		const [msg] = body.messages;
		const eip712TypedData = getEip712TypedData({
			msgs: [MsgDecoder.decode(msg)],
			fee: authInfo.fee,
			tx: {
				memo: body.memo,
				accountNumber: signer.accountNumber.toString(),
				sequence: signerInfo.sequence.toString(),
				timeoutHeight: body.timeoutHeight.toString(),
				chainId
			},
			evmChainId
		});
		return await this.verifySignature({
			eip712: eip712TypedData,
			signature: require_utils.uint8ArrayToHex(signature),
			publicKey: require_utils.uint8ArrayToHex(require_utils.base64ToUint8Array(signer.publicKey))
		});
	}
	/**
	* Verify signature using ADR-36 sign doc
	* and the publicKey
	*
	* (params are passed as an object)
	*
	* @param {string} signature: the signature to verify in hex
	* @param {any} signDoc: the signDoc to verify against
	* @param {string} publicKey:the public key to verify against in hex
	* */
	static verifyArbitrarySignature({ signature, signDoc, publicKey }) {
		const sigHex = signature.startsWith("0x") ? signature : `0x${signature}`;
		const pubHex = publicKey.startsWith("0x") ? publicKey : `0x${publicKey}`;
		return __noble_curves_secp256k1.secp256k1.verify((0, viem.toBytes)(sigHex), (0, viem.toBytes)((0, viem.keccak256)(signDoc)), (0, viem.toBytes)(pubHex));
	}
};

//#endregion
//#region src/core/accounts/BaseAccount.ts
/**
* @category Utility Classes
*/
var BaseAccount = class BaseAccount extends Address {
	constructor({ address, accountNumber, sequence, pubKey }) {
		super(address);
		require_defineProperty._defineProperty(this, "accountNumber", void 0);
		require_defineProperty._defineProperty(this, "sequence", void 0);
		require_defineProperty._defineProperty(this, "pubKey", void 0);
		this.accountNumber = accountNumber;
		this.sequence = sequence;
		this.pubKey = pubKey;
	}
	static fromRestApi(accountResponse) {
		const { base_account: baseAccount } = accountResponse.account;
		return new BaseAccount({
			address: baseAccount.address,
			accountNumber: baseAccount.account_number ? parseInt(baseAccount.account_number, 10) : 0,
			sequence: baseAccount.sequence ? parseInt(baseAccount.sequence, 10) : 0,
			pubKey: baseAccount.pub_key ? {
				type: baseAccount.pub_key["@type"],
				key: baseAccount.pub_key.key
			} : {
				type: "",
				key: ""
			}
		});
	}
	static fromRestCosmosApi(accountResponse) {
		return new BaseAccount({
			address: accountResponse.address,
			accountNumber: accountResponse.account_number ? parseInt(accountResponse.account_number, 10) : 0,
			sequence: accountResponse.sequence ? parseInt(accountResponse.sequence, 10) : 0,
			pubKey: accountResponse.pub_key ? {
				type: accountResponse.pub_key["@type"],
				key: accountResponse.pub_key.key
			} : {
				type: "",
				key: ""
			}
		});
	}
	incrementSequence() {
		this.sequence += 1;
		return this;
	}
	toAccountDetails() {
		return {
			pubKey: this.pubKey,
			sequence: this.sequence,
			address: this.bech32Address,
			accountNumber: this.accountNumber
		};
	}
};

//#endregion
Object.defineProperty(exports, 'Address', {
  enumerable: true,
  get: function () {
    return Address;
  }
});
Object.defineProperty(exports, 'BaseAccount', {
  enumerable: true,
  get: function () {
    return BaseAccount;
  }
});
Object.defineProperty(exports, 'MsgDecoder', {
  enumerable: true,
  get: function () {
    return MsgDecoder;
  }
});
Object.defineProperty(exports, 'MsgIncreasePositionMargin', {
  enumerable: true,
  get: function () {
    return MsgIncreasePositionMargin;
  }
});
Object.defineProperty(exports, 'MsgSignData', {
  enumerable: true,
  get: function () {
    return MsgSignData;
  }
});
Object.defineProperty(exports, 'PrivateKey', {
  enumerable: true,
  get: function () {
    return PrivateKey;
  }
});
Object.defineProperty(exports, 'PublicKey', {
  enumerable: true,
  get: function () {
    return PublicKey;
  }
});
Object.defineProperty(exports, 'createAny', {
  enumerable: true,
  get: function () {
    return createAny;
  }
});
Object.defineProperty(exports, 'createAnyMessage', {
  enumerable: true,
  get: function () {
    return createAnyMessage;
  }
});
Object.defineProperty(exports, 'createAuthInfo', {
  enumerable: true,
  get: function () {
    return createAuthInfo;
  }
});
Object.defineProperty(exports, 'createBody', {
  enumerable: true,
  get: function () {
    return createBody;
  }
});
Object.defineProperty(exports, 'createFee', {
  enumerable: true,
  get: function () {
    return createFee;
  }
});
Object.defineProperty(exports, 'createNonCriticalExtensionFromObject', {
  enumerable: true,
  get: function () {
    return createNonCriticalExtensionFromObject;
  }
});
Object.defineProperty(exports, 'createSignDoc', {
  enumerable: true,
  get: function () {
    return createSignDoc;
  }
});
Object.defineProperty(exports, 'createSignDocFromTransaction', {
  enumerable: true,
  get: function () {
    return createSignDocFromTransaction;
  }
});
Object.defineProperty(exports, 'createSignerInfo', {
  enumerable: true,
  get: function () {
    return createSignerInfo;
  }
});
Object.defineProperty(exports, 'createSigners', {
  enumerable: true,
  get: function () {
    return createSigners;
  }
});
Object.defineProperty(exports, 'createTxRawEIP712', {
  enumerable: true,
  get: function () {
    return createTxRawEIP712;
  }
});
Object.defineProperty(exports, 'createWeb3Extension', {
  enumerable: true,
  get: function () {
    return createWeb3Extension;
  }
});
Object.defineProperty(exports, 'getAminoStdSignDoc', {
  enumerable: true,
  get: function () {
    return getAminoStdSignDoc;
  }
});
Object.defineProperty(exports, 'getDefaultEip712Types', {
  enumerable: true,
  get: function () {
    return getDefaultEip712Types;
  }
});
Object.defineProperty(exports, 'getDefaultEip712TypesV2', {
  enumerable: true,
  get: function () {
    return getDefaultEip712TypesV2;
  }
});
Object.defineProperty(exports, 'getEip712Domain', {
  enumerable: true,
  get: function () {
    return getEip712Domain;
  }
});
Object.defineProperty(exports, 'getEip712DomainV2', {
  enumerable: true,
  get: function () {
    return getEip712DomainV2;
  }
});
Object.defineProperty(exports, 'getEip712Fee', {
  enumerable: true,
  get: function () {
    return getEip712Fee;
  }
});
Object.defineProperty(exports, 'getEip712FeeV2', {
  enumerable: true,
  get: function () {
    return getEip712FeeV2;
  }
});
Object.defineProperty(exports, 'getEip712TypedData', {
  enumerable: true,
  get: function () {
    return getEip712TypedData;
  }
});
Object.defineProperty(exports, 'getEip712TypedDataV2', {
  enumerable: true,
  get: function () {
    return getEip712TypedDataV2;
  }
});
Object.defineProperty(exports, 'getEipTxContext', {
  enumerable: true,
  get: function () {
    return getEipTxContext;
  }
});
Object.defineProperty(exports, 'getEipTxDetails', {
  enumerable: true,
  get: function () {
    return getEipTxDetails;
  }
});
Object.defineProperty(exports, 'getEthereumSignerAddress', {
  enumerable: true,
  get: function () {
    return getEthereumSignerAddress;
  }
});
Object.defineProperty(exports, 'getInjectiveSignerAddress', {
  enumerable: true,
  get: function () {
    return getInjectiveSignerAddress;
  }
});
Object.defineProperty(exports, 'getPublicKey', {
  enumerable: true,
  get: function () {
    return getPublicKey;
  }
});
Object.defineProperty(exports, 'getTransactionPartsFromTxRaw', {
  enumerable: true,
  get: function () {
    return getTransactionPartsFromTxRaw;
  }
});
Object.defineProperty(exports, 'getTypesIncludingFeePayer', {
  enumerable: true,
  get: function () {
    return getTypesIncludingFeePayer;
  }
});