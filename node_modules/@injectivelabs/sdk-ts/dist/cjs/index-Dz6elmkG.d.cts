import { a as SignerInfo, d as Coin$1, f as DecCoin, i as SignDoc, l as SignMode, n as Fee, o as TxBody, r as ModeInfo, s as TxRaw, t as AuthInfo, u as Any } from "./tx_pb-Wr-aZfKH.cjs";
import { $ as SpotMarketOrder, A as DerivativeMarketOrder, At as MethodInfo, B as MarketStatus, C as BinaryOptionsMarket$1, D as Deposit$1, Dt as DuplexStreamingCall, E as DenomMinNotional, Et as UnaryCall, F as FeeDiscountSchedule$1, G as OrderType$1, H as MidPriceAndTOB, I as FeeDiscountTierInfo$1, J as PerpetualMarketInfo$2, K as Params$16, L as FeeDiscountTierTTL$1, M as DerivativeOrder$1, N as EffectiveGrant, O as DerivativeLimitOrder$2, Ot as ClientStreamingCall, P as ExpiryFuturesMarketInfo$2, Q as SpotMarket$1, R as GrantAuthorization$2, S as AggregateSubaccountVolumeRecord, St as TokenType, T as DenomDecimals, Tt as RpcTransport, U as OrderInfo$1, V as MarketVolume, W as OrderMask, X as Position$1, Y as PointsMultiplier$1, Z as SpotLimitOrder$2, _ as OrderState, _t as StreamState, a as StreamOperation, at as BandIBCParams, b as TradeExecutionType, ct as Params$17, et as SpotOrder$1, f as GrpcWebTransportAdditionalOptions, g as OrderSide, ht as StreamManagerEvents, i as PaginationOption, it as TradingRewardCampaignInfo$1, j as DerivativeMarketSettlementInfo, k as DerivativeMarket$1, kt as ServerStreamingCall, l as GrpcCoin, mt as StreamManagerConfig, nt as TradeRecords, ot as BandOracleRequest, p as GrpcWebOptions, q as PerpetualMarketFunding$2, r as Pagination, rt as TradingRewardCampaignBoostInfo$1, st as OracleType, t as ExchangePagination, tt as SubaccountTradeNonce, v as TradeDirection, vt as StreamSubscription, w as CampaignRewardPool$1, wt as RpcOptions, x as ActiveGrant, xt as TokenStatic, y as TradeExecutionSide, yt as TokenMeta, z as MarketFeeMultiplier } from "./index-Bp-AQIP3.cjs";
import { t as BaseGrpcConsumer } from "./BaseGrpcConsumer-DjBlHZXf.cjs";
import { Ct as snakecaseKeys, F as RegisteredContract, I as ExecArgs, L as ExecPrivilegedArgs, N as MsgExecuteContractCompat, P as Params$14, St as TypedDataField, _t as Model, bt as Eip712ConvertTxArgs, dt as AbsoluteTxPosition$1, f as Coin$8, ft as AccessConfig, gt as ContractInfo$1, ht as ContractCodeHistoryOperationType$1, lt as ExecArgBase, mt as ContractCodeHistoryEntry$1, pt as AccessType$1, ut as ExecDataRepresentation, vt as MsgBase, yt as Eip712ConvertFeeArgs } from "./index-CSWj2FPd.cjs";
import { V as BaseIndexerGrpcConsumer } from "./index-Bobbl6ef.cjs";
import { StdFee } from "@cosmjs/amino";
import { DirectSignResponse } from "@cosmjs/proto-signing";
import { AccountAddress, ChainId, Coin, EvmChainId, MsgStatus, MsgType } from "@injectivelabs/ts-types";
import { HttpClient, HttpRestClient, getExactDecimalsFromNumber, getSignificantDecimalsFromNumber } from "@injectivelabs/utils";
import { Network, NetworkEndpoints } from "@injectivelabs/networks";
import { Subscription } from "rxjs";

//#region ../../node_modules/.pnpm/@protobuf-ts+grpcweb-transport@2.11.1/node_modules/@protobuf-ts/grpcweb-transport/build/types/grpc-web-transport.d.ts
/**
 * Implements the grpc-web protocol, supporting text format or binary
 * format on the wire. Uses the fetch API to do the HTTP requests.
 *
 * Does not support client streaming or duplex calls because grpc-web
 * does not support them.
 */
declare class GrpcWebFetchTransport implements RpcTransport {
  private readonly defaultOptions;
  constructor(defaultOptions: GrpcWebOptions);
  mergeOptions(options?: Partial<RpcOptions>): RpcOptions;
  /**
   * Create an URI for a gRPC web call.
   *
   * Takes the `baseUrl` option and appends:
   * - slash "/"
   * - package name
   * - dot "."
   * - service name
   * - slash "/"
   * - method name
   *
   * If the service was declared without a package, the package name and dot
   * are omitted.
   *
   * All names are used exactly like declared in .proto.
   */
  protected makeUrl(method: MethodInfo, options: GrpcWebOptions): string;
  clientStreaming<I extends object, O extends object>(method: MethodInfo<I, O>): ClientStreamingCall<I, O>;
  duplex<I extends object, O extends object>(method: MethodInfo<I, O>): DuplexStreamingCall<I, O>;
  serverStreaming<I extends object, O extends object>(method: MethodInfo<I, O>, input: I, options: RpcOptions): ServerStreamingCall<I, O>;
  unary<I extends object, O extends object>(method: MethodInfo<I, O>, input: I, options: RpcOptions): UnaryCall<I, O>;
}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/google/protobuf/timestamp_pb.d.ts
/**
 * A Timestamp represents a point in time independent of any time zone or local
 * calendar, encoded as a count of seconds and fractions of seconds at
 * nanosecond resolution. The count is relative to an epoch at UTC midnight on
 * January 1, 1970, in the proleptic Gregorian calendar which extends the
 * Gregorian calendar backwards to year one.
 *
 * All minutes are 60 seconds long. Leap seconds are "smeared" so that no leap
 * second table is needed for interpretation, using a [24-hour linear
 * smear](https://developers.google.com/time/smear).
 *
 * The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By
 * restricting to that range, we ensure that we can convert to and from [RFC
 * 3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.
 *
 * # Examples
 *
 * Example 1: Compute Timestamp from POSIX `time()`.
 *
 *     Timestamp timestamp;
 *     timestamp.set_seconds(time(NULL));
 *     timestamp.set_nanos(0);
 *
 * Example 2: Compute Timestamp from POSIX `gettimeofday()`.
 *
 *     struct timeval tv;
 *     gettimeofday(&tv, NULL);
 *
 *     Timestamp timestamp;
 *     timestamp.set_seconds(tv.tv_sec);
 *     timestamp.set_nanos(tv.tv_usec * 1000);
 *
 * Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.
 *
 *     FILETIME ft;
 *     GetSystemTimeAsFileTime(&ft);
 *     UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;
 *
 *     // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z
 *     // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.
 *     Timestamp timestamp;
 *     timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));
 *     timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));
 *
 * Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.
 *
 *     long millis = System.currentTimeMillis();
 *
 *     Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)
 *         .setNanos((int) ((millis % 1000) * 1000000)).build();
 *
 * Example 5: Compute Timestamp from Java `Instant.now()`.
 *
 *     Instant now = Instant.now();
 *
 *     Timestamp timestamp =
 *         Timestamp.newBuilder().setSeconds(now.getEpochSecond())
 *             .setNanos(now.getNano()).build();
 *
 * Example 6: Compute Timestamp from current time in Python.
 *
 *     timestamp = Timestamp()
 *     timestamp.GetCurrentTime()
 *
 * # JSON Mapping
 *
 * In JSON format, the Timestamp type is encoded as a string in the
 * [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the
 * format is "{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z"
 * where {year} is always expressed using four digits while {month}, {day},
 * {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional
 * seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),
 * are optional. The "Z" suffix indicates the timezone ("UTC"); the timezone
 * is required. A proto3 JSON serializer should always use UTC (as indicated by
 * "Z") when printing the Timestamp type and a proto3 JSON parser should be
 * able to accept both UTC and other timezones (as indicated by an offset).
 *
 * For example, "2017-01-15T01:30:15.01Z" encodes 15.01 seconds past
 * 01:30 UTC on January 15, 2017.
 *
 * In JavaScript, one can convert a Date object to this format using the
 * standard
 * [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)
 * method. In Python, a standard `datetime.datetime` object can be converted
 * to this format using
 * [`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with
 * the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use
 * the Joda Time's [`ISODateTimeFormat.dateTime()`](
 * http://joda-time.sourceforge.net/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime()
 * ) to obtain a formatter capable of generating timestamps in this format.
 *
 *
 * @generated from protobuf message google.protobuf.Timestamp
 */
interface Timestamp {
  /**
   * Represents seconds of UTC time since Unix epoch
   * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
   * 9999-12-31T23:59:59Z inclusive.
   *
   * @generated from protobuf field: int64 seconds = 1
   */
  seconds: bigint;
  /**
   * Non-negative fractions of a second at nanosecond resolution. Negative
   * second values with fractions must still have non-negative nanos values
   * that count forward in time. Must be from 0 to 999,999,999
   * inclusive.
   *
   * @generated from protobuf field: int32 nanos = 2
   */
  nanos: number;
}
/**
 * @generated MessageType for protobuf message google.protobuf.Timestamp
 */
declare const Timestamp = new Timestamp$Type();
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/google/protobuf/duration_pb.d.ts
/**
 * A Duration represents a signed, fixed-length span of time represented
 * as a count of seconds and fractions of seconds at nanosecond
 * resolution. It is independent of any calendar and concepts like "day"
 * or "month". It is related to Timestamp in that the difference between
 * two Timestamp values is a Duration and it can be added or subtracted
 * from a Timestamp. Range is approximately +-10,000 years.
 *
 * # Examples
 *
 * Example 1: Compute Duration from two Timestamps in pseudo code.
 *
 *     Timestamp start = ...;
 *     Timestamp end = ...;
 *     Duration duration = ...;
 *
 *     duration.seconds = end.seconds - start.seconds;
 *     duration.nanos = end.nanos - start.nanos;
 *
 *     if (duration.seconds < 0 && duration.nanos > 0) {
 *       duration.seconds += 1;
 *       duration.nanos -= 1000000000;
 *     } else if (duration.seconds > 0 && duration.nanos < 0) {
 *       duration.seconds -= 1;
 *       duration.nanos += 1000000000;
 *     }
 *
 * Example 2: Compute Timestamp from Timestamp + Duration in pseudo code.
 *
 *     Timestamp start = ...;
 *     Duration duration = ...;
 *     Timestamp end = ...;
 *
 *     end.seconds = start.seconds + duration.seconds;
 *     end.nanos = start.nanos + duration.nanos;
 *
 *     if (end.nanos < 0) {
 *       end.seconds -= 1;
 *       end.nanos += 1000000000;
 *     } else if (end.nanos >= 1000000000) {
 *       end.seconds += 1;
 *       end.nanos -= 1000000000;
 *     }
 *
 * Example 3: Compute Duration from datetime.timedelta in Python.
 *
 *     td = datetime.timedelta(days=3, minutes=10)
 *     duration = Duration()
 *     duration.FromTimedelta(td)
 *
 * # JSON Mapping
 *
 * In JSON format, the Duration type is encoded as a string rather than an
 * object, where the string ends in the suffix "s" (indicating seconds) and
 * is preceded by the number of seconds, with nanoseconds expressed as
 * fractional seconds. For example, 3 seconds with 0 nanoseconds should be
 * encoded in JSON format as "3s", while 3 seconds and 1 nanosecond should
 * be expressed in JSON format as "3.000000001s", and 3 seconds and 1
 * microsecond should be expressed in JSON format as "3.000001s".
 *
 *
 * @generated from protobuf message google.protobuf.Duration
 */
interface Duration {
  /**
   * Signed seconds of the span of time. Must be from -315,576,000,000
   * to +315,576,000,000 inclusive. Note: these bounds are computed from:
   * 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
   *
   * @generated from protobuf field: int64 seconds = 1
   */
  seconds: bigint;
  /**
   * Signed fractions of a second at nanosecond resolution of the span
   * of time. Durations less than one second are represented with a 0
   * `seconds` field and a positive or negative `nanos` field. For durations
   * of one second or more, a non-zero value for the `nanos` field must be
   * of the same sign as the `seconds` field. Must be from -999,999,999
   * to +999,999,999 inclusive.
   *
   * @generated from protobuf field: int32 nanos = 2
   */
  nanos: number;
}
/**
 * @generated MessageType for protobuf message google.protobuf.Duration
 */
declare const Duration = new Duration$Type();
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/cosmos/gov/v1/gov_pb.d.ts
/**
 * WeightedVoteOption defines a unit of vote for vote split.
 *
 * @generated from protobuf message cosmos.gov.v1.WeightedVoteOption
 */
interface WeightedVoteOption$1 {
  /**
   * option defines the valid vote options, it must not contain duplicate vote options.
   *
   * @generated from protobuf field: cosmos.gov.v1.VoteOption option = 1
   */
  option: VoteOption$1;
  /**
   * weight is the vote weight associated with the vote option.
   *
   * @generated from protobuf field: string weight = 2
   */
  weight: string;
}
/**
 * Deposit defines an amount deposited by an account address to an active
 * proposal.
 *
 * @generated from protobuf message cosmos.gov.v1.Deposit
 */
interface Deposit {
  /**
   * proposal_id defines the unique id of the proposal.
   *
   * @generated from protobuf field: uint64 proposal_id = 1
   */
  proposalId: bigint;
  /**
   * depositor defines the deposit addresses from the proposals.
   *
   * @generated from protobuf field: string depositor = 2
   */
  depositor: string;
  /**
   * amount to be deposited by depositor.
   *
   * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin amount = 3
   */
  amount: Coin$1[];
}
/**
 * Proposal defines the core field members of a governance proposal.
 *
 * @generated from protobuf message cosmos.gov.v1.Proposal
 */
interface Proposal$1 {
  /**
   * id defines the unique id of the proposal.
   *
   * @generated from protobuf field: uint64 id = 1
   */
  id: bigint;
  /**
   * messages are the arbitrary messages to be executed if the proposal passes.
   *
   * @generated from protobuf field: repeated google.protobuf.Any messages = 2
   */
  messages: Any[];
  /**
   * status defines the proposal status.
   *
   * @generated from protobuf field: cosmos.gov.v1.ProposalStatus status = 3
   */
  status: ProposalStatus$1;
  /**
   * final_tally_result is the final tally result of the proposal. When
   * querying a proposal via gRPC, this field is not populated until the
   * proposal's voting period has ended.
   *
   * @generated from protobuf field: cosmos.gov.v1.TallyResult final_tally_result = 4
   */
  finalTallyResult?: TallyResult$1;
  /**
   * submit_time is the time of proposal submission.
   *
   * @generated from protobuf field: google.protobuf.Timestamp submit_time = 5
   */
  submitTime?: Timestamp;
  /**
   * deposit_end_time is the end time for deposition.
   *
   * @generated from protobuf field: google.protobuf.Timestamp deposit_end_time = 6
   */
  depositEndTime?: Timestamp;
  /**
   * total_deposit is the total deposit on the proposal.
   *
   * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin total_deposit = 7
   */
  totalDeposit: Coin$1[];
  /**
   * voting_start_time is the starting time to vote on a proposal.
   *
   * @generated from protobuf field: google.protobuf.Timestamp voting_start_time = 8
   */
  votingStartTime?: Timestamp;
  /**
   * voting_end_time is the end time of voting on a proposal.
   *
   * @generated from protobuf field: google.protobuf.Timestamp voting_end_time = 9
   */
  votingEndTime?: Timestamp;
  /**
   * metadata is any arbitrary metadata attached to the proposal.
   * the recommended format of the metadata is to be found here:
   * https://docs.cosmos.network/v0.47/modules/gov#proposal-3
   *
   * @generated from protobuf field: string metadata = 10
   */
  metadata: string;
  /**
   * title is the title of the proposal
   *
   * Since: cosmos-sdk 0.47
   *
   * @generated from protobuf field: string title = 11
   */
  title: string;
  /**
   * summary is a short summary of the proposal
   *
   * Since: cosmos-sdk 0.47
   *
   * @generated from protobuf field: string summary = 12
   */
  summary: string;
  /**
   * proposer is the address of the proposal sumbitter
   *
   * Since: cosmos-sdk 0.47
   *
   * @generated from protobuf field: string proposer = 13
   */
  proposer: string;
  /**
   * expedited defines if the proposal is expedited
   *
   * Since: cosmos-sdk 0.50
   *
   * @generated from protobuf field: bool expedited = 14
   */
  expedited: boolean;
  /**
   * failed_reason defines the reason why the proposal failed
   *
   * Since: cosmos-sdk 0.50
   *
   * @generated from protobuf field: string failed_reason = 15
   */
  failedReason: string;
}
/**
 * TallyResult defines a standard tally for a governance proposal.
 *
 * @generated from protobuf message cosmos.gov.v1.TallyResult
 */
interface TallyResult$1 {
  /**
   * yes_count is the number of yes votes on a proposal.
   *
   * @generated from protobuf field: string yes_count = 1
   */
  yesCount: string;
  /**
   * abstain_count is the number of abstain votes on a proposal.
   *
   * @generated from protobuf field: string abstain_count = 2
   */
  abstainCount: string;
  /**
   * no_count is the number of no votes on a proposal.
   *
   * @generated from protobuf field: string no_count = 3
   */
  noCount: string;
  /**
   * no_with_veto_count is the number of no with veto votes on a proposal.
   *
   * @generated from protobuf field: string no_with_veto_count = 4
   */
  noWithVetoCount: string;
}
/**
 * Vote defines a vote on a governance proposal.
 * A Vote consists of a proposal ID, the voter, and the vote option.
 *
 * @generated from protobuf message cosmos.gov.v1.Vote
 */
interface Vote$1 {
  /**
   * proposal_id defines the unique id of the proposal.
   *
   * @generated from protobuf field: uint64 proposal_id = 1
   */
  proposalId: bigint;
  /**
   * voter is the voter address of the proposal.
   *
   * @generated from protobuf field: string voter = 2
   */
  voter: string;
  /**
   * options is the weighted vote options.
   *
   * @generated from protobuf field: repeated cosmos.gov.v1.WeightedVoteOption options = 4
   */
  options: WeightedVoteOption$1[];
  /**
   * metadata is any arbitrary metadata attached to the vote.
   * the recommended format of the metadata is to be found here: https://docs.cosmos.network/v0.47/modules/gov#vote-5
   *
   * @generated from protobuf field: string metadata = 5
   */
  metadata: string;
}
/**
 * DepositParams defines the params for deposits on governance proposals.
 *
 * @deprecated
 * @generated from protobuf message cosmos.gov.v1.DepositParams
 */
interface DepositParams {
  /**
   * Minimum deposit for a proposal to enter voting period.
   *
   * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin min_deposit = 1
   */
  minDeposit: Coin$1[];
  /**
   * Maximum period for Atom holders to deposit on a proposal. Initial value: 2
   * months.
   *
   * @generated from protobuf field: google.protobuf.Duration max_deposit_period = 2
   */
  maxDepositPeriod?: Duration;
}
/**
 * VotingParams defines the params for voting on governance proposals.
 *
 * @deprecated
 * @generated from protobuf message cosmos.gov.v1.VotingParams
 */
interface VotingParams {
  /**
   * Duration of the voting period.
   *
   * @generated from protobuf field: google.protobuf.Duration voting_period = 1
   */
  votingPeriod?: Duration;
}
/**
 * TallyParams defines the params for tallying votes on governance proposals.
 *
 * @deprecated
 * @generated from protobuf message cosmos.gov.v1.TallyParams
 */
interface TallyParams {
  /**
   * Minimum percentage of total stake needed to vote for a result to be
   * considered valid.
   *
   * @generated from protobuf field: string quorum = 1
   */
  quorum: string;
  /**
   * Minimum proportion of Yes votes for proposal to pass. Default value: 0.5.
   *
   * @generated from protobuf field: string threshold = 2
   */
  threshold: string;
  /**
   * Minimum value of Veto votes to Total votes ratio for proposal to be
   * vetoed. Default value: 1/3.
   *
   * @generated from protobuf field: string veto_threshold = 3
   */
  vetoThreshold: string;
}
/**
 * Params defines the parameters for the x/gov module.
 *
 * Since: cosmos-sdk 0.47
 *
 * @generated from protobuf message cosmos.gov.v1.Params
 */
interface Params$13 {
  /**
   * Minimum deposit for a proposal to enter voting period.
   *
   * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin min_deposit = 1
   */
  minDeposit: Coin$1[];
  /**
   * Maximum period for Atom holders to deposit on a proposal. Initial value: 2
   * months.
   *
   * @generated from protobuf field: google.protobuf.Duration max_deposit_period = 2
   */
  maxDepositPeriod?: Duration;
  /**
   * Duration of the voting period.
   *
   * @generated from protobuf field: google.protobuf.Duration voting_period = 3
   */
  votingPeriod?: Duration;
  /**
   *  Minimum percentage of total stake needed to vote for a result to be
   *  considered valid.
   *
   * @generated from protobuf field: string quorum = 4
   */
  quorum: string;
  /**
   *  Minimum proportion of Yes votes for proposal to pass. Default value: 0.5.
   *
   * @generated from protobuf field: string threshold = 5
   */
  threshold: string;
  /**
   *  Minimum value of Veto votes to Total votes ratio for proposal to be
   *  vetoed. Default value: 1/3.
   *
   * @generated from protobuf field: string veto_threshold = 6
   */
  vetoThreshold: string;
  /**
   *  The ratio representing the proportion of the deposit value that must be paid at proposal submission.
   *
   * @generated from protobuf field: string min_initial_deposit_ratio = 7
   */
  minInitialDepositRatio: string;
  /**
   * The cancel ratio which will not be returned back to the depositors when a proposal is cancelled.
   *
   * Since: cosmos-sdk 0.50
   *
   * @generated from protobuf field: string proposal_cancel_ratio = 8
   */
  proposalCancelRatio: string;
  /**
   * The address which will receive (proposal_cancel_ratio * deposit) proposal deposits.
   * If empty, the (proposal_cancel_ratio * deposit) proposal deposits will be burned.
   *
   * Since: cosmos-sdk 0.50
   *
   * @generated from protobuf field: string proposal_cancel_dest = 9
   */
  proposalCancelDest: string;
  /**
   * Duration of the voting period of an expedited proposal.
   *
   * Since: cosmos-sdk 0.50
   *
   * @generated from protobuf field: google.protobuf.Duration expedited_voting_period = 10
   */
  expeditedVotingPeriod?: Duration;
  /**
   * Minimum proportion of Yes votes for proposal to pass. Default value: 0.67.
   *
   * Since: cosmos-sdk 0.50
   *
   * @generated from protobuf field: string expedited_threshold = 11
   */
  expeditedThreshold: string;
  /**
   *  Minimum expedited deposit for a proposal to enter voting period.
   *
   * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin expedited_min_deposit = 12
   */
  expeditedMinDeposit: Coin$1[];
  /**
   * burn deposits if a proposal does not meet quorum
   *
   * @generated from protobuf field: bool burn_vote_quorum = 13
   */
  burnVoteQuorum: boolean;
  /**
   * burn deposits if the proposal does not enter voting period
   *
   * @generated from protobuf field: bool burn_proposal_deposit_prevote = 14
   */
  burnProposalDepositPrevote: boolean;
  /**
   * burn deposits if quorum with vote type no_veto is met
   *
   * @generated from protobuf field: bool burn_vote_veto = 15
   */
  burnVoteVeto: boolean;
  /**
   * The ratio representing the proportion of the deposit value minimum that must be met when making a deposit.
   * Default value: 0.01. Meaning that for a chain with a min_deposit of 100stake, a deposit of 1stake would be
   * required.
   *
   * Since: cosmos-sdk 0.50
   *
   * @generated from protobuf field: string min_deposit_ratio = 16
   */
  minDepositRatio: string;
}
/**
 * VoteOption enumerates the valid vote options for a given governance proposal.
 *
 * @generated from protobuf enum cosmos.gov.v1.VoteOption
 */
declare enum VoteOption$1 {
  /**
   * VOTE_OPTION_UNSPECIFIED defines a no-op vote option.
   *
   * @generated from protobuf enum value: VOTE_OPTION_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,
  /**
   * VOTE_OPTION_YES defines a yes vote option.
   *
   * @generated from protobuf enum value: VOTE_OPTION_YES = 1;
   */
  YES = 1,
  /**
   * VOTE_OPTION_ABSTAIN defines an abstain vote option.
   *
   * @generated from protobuf enum value: VOTE_OPTION_ABSTAIN = 2;
   */
  ABSTAIN = 2,
  /**
   * VOTE_OPTION_NO defines a no vote option.
   *
   * @generated from protobuf enum value: VOTE_OPTION_NO = 3;
   */
  NO = 3,
  /**
   * VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option.
   *
   * @generated from protobuf enum value: VOTE_OPTION_NO_WITH_VETO = 4;
   */
  NO_WITH_VETO = 4,
}
/**
 * ProposalStatus enumerates the valid statuses of a proposal.
 *
 * @generated from protobuf enum cosmos.gov.v1.ProposalStatus
 */
declare enum ProposalStatus$1 {
  /**
   * PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.
   *
   * @generated from protobuf enum value: PROPOSAL_STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,
  /**
   * PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit
   * period.
   *
   * @generated from protobuf enum value: PROPOSAL_STATUS_DEPOSIT_PERIOD = 1;
   */
  DEPOSIT_PERIOD = 1,
  /**
   * PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting
   * period.
   *
   * @generated from protobuf enum value: PROPOSAL_STATUS_VOTING_PERIOD = 2;
   */
  VOTING_PERIOD = 2,
  /**
   * PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has
   * passed.
   *
   * @generated from protobuf enum value: PROPOSAL_STATUS_PASSED = 3;
   */
  PASSED = 3,
  /**
   * PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has
   * been rejected.
   *
   * @generated from protobuf enum value: PROPOSAL_STATUS_REJECTED = 4;
   */
  REJECTED = 4,
  /**
   * PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has
   * failed.
   *
   * @generated from protobuf enum value: PROPOSAL_STATUS_FAILED = 5;
   */
  FAILED = 5,
}
/**
 * @generated MessageType for protobuf message cosmos.gov.v1.WeightedVoteOption
 */
declare const WeightedVoteOption$1 = new WeightedVoteOption$Type();
/**
 * @generated MessageType for protobuf message cosmos.gov.v1.Deposit
 */
declare const Deposit = new Deposit$Type();
/**
 * @generated MessageType for protobuf message cosmos.gov.v1.Proposal
 */
declare const Proposal$1 = new Proposal$Type();
/**
 * @generated MessageType for protobuf message cosmos.gov.v1.TallyResult
 */
declare const TallyResult$1 = new TallyResult$Type();
/**
 * @generated MessageType for protobuf message cosmos.gov.v1.Vote
 */
declare const Vote$1 = new Vote$Type();
/**
 * @deprecated
 * @generated MessageType for protobuf message cosmos.gov.v1.DepositParams
 */
declare const DepositParams = new DepositParams$Type();
/**
 * @deprecated
 * @generated MessageType for protobuf message cosmos.gov.v1.VotingParams
 */
declare const VotingParams = new VotingParams$Type();
/**
 * @deprecated
 * @generated MessageType for protobuf message cosmos.gov.v1.TallyParams
 */
declare const TallyParams = new TallyParams$Type();
/**
 * @generated MessageType for protobuf message cosmos.gov.v1.Params
 */
declare const Params$13 = new Params$Type();
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/cosmos/gov/v1/tx_pb.d.ts
/**
 * MsgSubmitProposal defines an sdk.Msg type that supports submitting arbitrary
 * proposal Content.
 *
 * @generated from protobuf message cosmos.gov.v1.MsgSubmitProposal
 */
interface MsgSubmitProposal$2 {
  /**
   * messages are the arbitrary messages to be executed if proposal passes.
   *
   * @generated from protobuf field: repeated google.protobuf.Any messages = 1
   */
  messages: Any[];
  /**
   * initial_deposit is the deposit value that must be paid at proposal submission.
   *
   * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin initial_deposit = 2
   */
  initialDeposit: Coin$1[];
  /**
   * proposer is the account address of the proposer.
   *
   * @generated from protobuf field: string proposer = 3
   */
  proposer: string;
  /**
   * metadata is any arbitrary metadata attached to the proposal.
   *
   * @generated from protobuf field: string metadata = 4
   */
  metadata: string;
  /**
   * title is the title of the proposal.
   *
   * Since: cosmos-sdk 0.47
   *
   * @generated from protobuf field: string title = 5
   */
  title: string;
  /**
   * summary is the summary of the proposal
   *
   * Since: cosmos-sdk 0.47
   *
   * @generated from protobuf field: string summary = 6
   */
  summary: string;
  /**
   * expedited defines if the proposal is expedited or not
   *
   * Since: cosmos-sdk 0.50
   *
   * @generated from protobuf field: bool expedited = 7
   */
  expedited: boolean;
}
/**
 * MsgExecLegacyContent is used to wrap the legacy content field into a message.
 * This ensures backwards compatibility with v1beta1.MsgSubmitProposal.
 *
 * @generated from protobuf message cosmos.gov.v1.MsgExecLegacyContent
 */
interface MsgExecLegacyContent {
  /**
   * content is the proposal's content.
   *
   * @generated from protobuf field: google.protobuf.Any content = 1
   */
  content?: Any;
  /**
   * authority must be the gov module address.
   *
   * @generated from protobuf field: string authority = 2
   */
  authority: string;
}
/**
 * MsgVote defines a message to cast a vote.
 *
 * @generated from protobuf message cosmos.gov.v1.MsgVote
 */
interface MsgVote$1 {
  /**
   * proposal_id defines the unique id of the proposal.
   *
   * @generated from protobuf field: uint64 proposal_id = 1
   */
  proposalId: bigint;
  /**
   * voter is the voter address for the proposal.
   *
   * @generated from protobuf field: string voter = 2
   */
  voter: string;
  /**
   * option defines the vote option.
   *
   * @generated from protobuf field: cosmos.gov.v1.VoteOption option = 3
   */
  option: VoteOption$1;
  /**
   * metadata is any arbitrary metadata attached to the Vote.
   *
   * @generated from protobuf field: string metadata = 4
   */
  metadata: string;
}
/**
 * MsgDeposit defines a message to submit a deposit to an existing proposal.
 *
 * @generated from protobuf message cosmos.gov.v1.MsgDeposit
 */
interface MsgDeposit$3 {
  /**
   * proposal_id defines the unique id of the proposal.
   *
   * @generated from protobuf field: uint64 proposal_id = 1
   */
  proposalId: bigint;
  /**
   * depositor defines the deposit addresses from the proposals.
   *
   * @generated from protobuf field: string depositor = 2
   */
  depositor: string;
  /**
   * amount to be deposited by depositor.
   *
   * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin amount = 3
   */
  amount: Coin$1[];
}
/**
 * @generated MessageType for protobuf message cosmos.gov.v1.MsgSubmitProposal
 */
declare const MsgSubmitProposal$2 = new MsgSubmitProposal$Type();
/**
 * @generated MessageType for protobuf message cosmos.gov.v1.MsgExecLegacyContent
 */
declare const MsgExecLegacyContent = new MsgExecLegacyContent$Type();
/**
 * @generated MessageType for protobuf message cosmos.gov.v1.MsgVote
 */
declare const MsgVote$1 = new MsgVote$Type();
/**
 * @generated MessageType for protobuf message cosmos.gov.v1.MsgDeposit
 */
declare const MsgDeposit$3 = new MsgDeposit$Type();
//#endregion
//#region src/core/modules/gov/msgs/MsgVote.d.ts
declare namespace MsgVote {
  interface Params {
    proposalId: number;
    metadata?: string;
    vote: VoteOption$1;
    voter: string;
  }
  type Proto = MsgVote$1;
}
/**
 * @category Messages
 */
declare class MsgVote extends MsgBase<MsgVote.Params, MsgVote.Proto> {
  static fromJSON(params: MsgVote.Params): MsgVote;
  toProto(): MsgVote$1;
  toData(): {
    proposalId: bigint;
    voter: string;
    option: VoteOption$1;
    metadata: string;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      proposal_id: string;
      voter: string;
      option: VoteOption$1;
      metadata: string;
    };
  };
  toWeb3Gw(): {
    proposal_id: string;
    voter: string;
    option: VoteOption$1;
    metadata: string;
    '@type': string;
  };
  toEip712V2(): {
    proposal_id: string;
    voter: string;
    option: VoteOption$1;
    metadata: string;
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgVote$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/cosmos/bank/v1beta1/bank_pb.d.ts
/**
 * Params defines the parameters for the bank module.
 *
 * @generated from protobuf message cosmos.bank.v1beta1.Params
 */
interface Params$10 {
  /**
   * Deprecated: Use of SendEnabled in params is deprecated.
   * For genesis, use the newly added send_enabled field in the genesis object.
   * Storage, lookup, and manipulation of this information is now in the keeper.
   *
   * As of cosmos-sdk 0.47, this only exists for backwards compatibility of genesis files.
   *
   * @deprecated
   * @generated from protobuf field: repeated cosmos.bank.v1beta1.SendEnabled send_enabled = 1 [deprecated = true]
   */
  sendEnabled: SendEnabled$1[];
  /**
   * @generated from protobuf field: bool default_send_enabled = 2
   */
  defaultSendEnabled: boolean;
}
/**
 * SendEnabled maps coin denom to a send_enabled status (whether a denom is
 * sendable).
 *
 * @generated from protobuf message cosmos.bank.v1beta1.SendEnabled
 */
interface SendEnabled$1 {
  /**
   * @generated from protobuf field: string denom = 1
   */
  denom: string;
  /**
   * @generated from protobuf field: bool enabled = 2
   */
  enabled: boolean;
}
/**
 * Input models transaction input.
 *
 * @generated from protobuf message cosmos.bank.v1beta1.Input
 */
interface Input {
  /**
   * @generated from protobuf field: string address = 1
   */
  address: string;
  /**
   * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin coins = 2
   */
  coins: Coin$1[];
}
/**
 * Output models transaction outputs.
 *
 * @generated from protobuf message cosmos.bank.v1beta1.Output
 */
interface Output {
  /**
   * @generated from protobuf field: string address = 1
   */
  address: string;
  /**
   * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin coins = 2
   */
  coins: Coin$1[];
}
/**
 * Supply represents a struct that passively keeps track of the total supply
 * amounts in the network.
 * This message is deprecated now that supply is indexed by denom.
 *
 * @deprecated
 * @generated from protobuf message cosmos.bank.v1beta1.Supply
 */
interface Supply {
  /**
   * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin total = 1
   */
  total: Coin$1[];
}
/**
 * DenomUnit represents a struct that describes a given
 * denomination unit of the basic token.
 *
 * @generated from protobuf message cosmos.bank.v1beta1.DenomUnit
 */
interface DenomUnit {
  /**
   * denom represents the string name of the given denom unit (e.g uatom).
   *
   * @generated from protobuf field: string denom = 1
   */
  denom: string;
  /**
   * exponent represents power of 10 exponent that one must
   * raise the base_denom to in order to equal the given DenomUnit's denom
   * 1 denom = 10^exponent base_denom
   * (e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with
   * exponent = 6, thus: 1 atom = 10^6 uatom).
   *
   * @generated from protobuf field: uint32 exponent = 2
   */
  exponent: number;
  /**
   * aliases is a list of string aliases for the given denom
   *
   * @generated from protobuf field: repeated string aliases = 3
   */
  aliases: string[];
}
/**
 * Metadata represents a struct that describes
 * a basic token.
 *
 * @generated from protobuf message cosmos.bank.v1beta1.Metadata
 */
interface Metadata$1 {
  /**
   * @generated from protobuf field: string description = 1
   */
  description: string;
  /**
   * denom_units represents the list of DenomUnit's for a given coin
   *
   * @generated from protobuf field: repeated cosmos.bank.v1beta1.DenomUnit denom_units = 2
   */
  denomUnits: DenomUnit[];
  /**
   * base represents the base denom (should be the DenomUnit with exponent = 0).
   *
   * @generated from protobuf field: string base = 3
   */
  base: string;
  /**
   * display indicates the suggested denom that should be
   * displayed in clients.
   *
   * @generated from protobuf field: string display = 4
   */
  display: string;
  /**
   * name defines the name of the token (eg: Cosmos Atom)
   *
   * Since: cosmos-sdk 0.43
   *
   * @generated from protobuf field: string name = 5
   */
  name: string;
  /**
   * symbol is the token symbol usually shown on exchanges (eg: ATOM). This can
   * be the same as the display.
   *
   * Since: cosmos-sdk 0.43
   *
   * @generated from protobuf field: string symbol = 6
   */
  symbol: string;
  /**
   * URI to a document (on or off-chain) that contains additional information. Optional.
   *
   * Since: cosmos-sdk 0.46
   *
   * @generated from protobuf field: string uri = 7
   */
  uri: string;
  /**
   * URIHash is a sha256 hash of a document pointed by URI. It's used to verify that
   * the document didn't change. Optional.
   *
   * Since: cosmos-sdk 0.46
   *
   * @generated from protobuf field: string uri_hash = 8
   */
  uriHash: string;
  /**
   * Decimals represent the number of decimals use to represent token amount on chain
   *
   * Since: cosmos-sdk 0.50
   *
   * @generated from protobuf field: uint32 decimals = 9
   */
  decimals: number;
}
/**
 * @generated MessageType for protobuf message cosmos.bank.v1beta1.Params
 */
declare const Params$10 = new Params$Type();
/**
 * @generated MessageType for protobuf message cosmos.bank.v1beta1.SendEnabled
 */
declare const SendEnabled$1 = new SendEnabled$Type();
/**
 * @generated MessageType for protobuf message cosmos.bank.v1beta1.Input
 */
declare const Input = new Input$Type();
/**
 * @generated MessageType for protobuf message cosmos.bank.v1beta1.Output
 */
declare const Output = new Output$Type();
/**
 * @deprecated
 * @generated MessageType for protobuf message cosmos.bank.v1beta1.Supply
 */
declare const Supply = new Supply$Type();
/**
 * @generated MessageType for protobuf message cosmos.bank.v1beta1.DenomUnit
 */
declare const DenomUnit = new DenomUnit$Type();
/**
 * @generated MessageType for protobuf message cosmos.bank.v1beta1.Metadata
 */
declare const Metadata$1 = new Metadata$Type();
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/cosmos/bank/v1beta1/tx_pb.d.ts
/**
 * MsgSend represents a message to send coins from one account to another.
 *
 * @generated from protobuf message cosmos.bank.v1beta1.MsgSend
 */
interface MsgSend$1 {
  /**
   * @generated from protobuf field: string from_address = 1
   */
  fromAddress: string;
  /**
   * @generated from protobuf field: string to_address = 2
   */
  toAddress: string;
  /**
   * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin amount = 3
   */
  amount: Coin$1[];
}
/**
 * MsgMultiSend represents an arbitrary multi-in, multi-out send message.
 *
 * @generated from protobuf message cosmos.bank.v1beta1.MsgMultiSend
 */
interface MsgMultiSend$1 {
  /**
   * Inputs, despite being `repeated`, only allows one sender input. This is
   * checked in MsgMultiSend's ValidateBasic.
   *
   * @generated from protobuf field: repeated cosmos.bank.v1beta1.Input inputs = 1
   */
  inputs: Input[];
  /**
   * @generated from protobuf field: repeated cosmos.bank.v1beta1.Output outputs = 2
   */
  outputs: Output[];
}
/**
 * @generated MessageType for protobuf message cosmos.bank.v1beta1.MsgSend
 */
declare const MsgSend$1 = new MsgSend$Type();
/**
 * @generated MessageType for protobuf message cosmos.bank.v1beta1.MsgMultiSend
 */
declare const MsgMultiSend$1 = new MsgMultiSend$Type();
//#endregion
//#region src/core/modules/bank/msgs/MsgSend.d.ts
declare namespace MsgSend {
  interface Params {
    amount: Coin | Coin[];
    srcInjectiveAddress: string;
    dstInjectiveAddress: string;
  }
  type Proto = MsgSend$1;
}
/**
 * @category Messages
        }[]
    srcInjectiveAddress: string
    dstInjectiveAddress: string
  }

  export type Proto = CosmosBankV1Beta1TxPb.MsgSend
}

/**
 * @category Messages
 */
declare class MsgSend extends MsgBase<MsgSend.Params, MsgSend.Proto> {
  static fromJSON(params: MsgSend.Params): MsgSend;
  toProto(): MsgSend$1;
  toData(): {
    fromAddress: string;
    toAddress: string;
    amount: Coin$1[];
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      from_address: string;
      to_address: string;
      amount: Coin$1[];
    };
  };
  toWeb3Gw(): {
    from_address: string;
    to_address: string;
    amount: Coin$1[];
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgSend$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/injective/auction/v1beta1/auction_pb.d.ts
/**
 * @generated from protobuf message injective.auction.v1beta1.Params
 */
interface Params$5 {
  /**
   * auction_period_duration defines the auction period duration
   *
   * @generated from protobuf field: int64 auction_period = 1
   */
  auctionPeriod: bigint;
  /**
   * min_next_bid_increment_rate defines the minimum increment rate for new bids
   *
   * @generated from protobuf field: string min_next_bid_increment_rate = 2
   */
  minNextBidIncrementRate: string;
  /**
   * inj_basket_max_cap defines the maximum cap for INJ contained in an auction
   * basket
   *
   * @generated from protobuf field: string inj_basket_max_cap = 3
   */
  injBasketMaxCap: string;
  /**
   * bidders_whitelist defines the list of addresses that are allowed to bid
   * if empty, any address can bid; if populated, only whitelisted addresses can
   * bid
   *
   * @generated from protobuf field: repeated string bidders_whitelist = 4
   */
  biddersWhitelist: string[];
}
/**
 * @generated from protobuf message injective.auction.v1beta1.Bid
 */
interface Bid {
  /**
   * @generated from protobuf field: string bidder = 1
   */
  bidder: string;
  /**
   * @generated from protobuf field: cosmos.base.v1beta1.Coin amount = 2
   */
  amount?: Coin$1;
}
/**
 * @generated from protobuf message injective.auction.v1beta1.LastAuctionResult
 */
interface LastAuctionResult {
  /**
   * winner describes the address of the winner
   *
   * @generated from protobuf field: string winner = 1
   */
  winner: string;
  /**
   * amount describes the amount the winner get from the auction
   *
   * @generated from protobuf field: cosmos.base.v1beta1.Coin amount = 2
   */
  amount?: Coin$1;
  /**
   * round defines the round number of auction
   *
   * @generated from protobuf field: uint64 round = 3
   */
  round: bigint;
}
/**
 * @generated from protobuf message injective.auction.v1beta1.EventBid
 */
interface EventBid {
  /**
   * bidder describes the address of bidder
   *
   * @generated from protobuf field: string bidder = 1
   */
  bidder: string;
  /**
   * amount describes the amount the bidder put on the auction
   *
   * @generated from protobuf field: cosmos.base.v1beta1.Coin amount = 2
   */
  amount?: Coin$1;
  /**
   * round defines the round number of auction
   *
   * @generated from protobuf field: uint64 round = 3
   */
  round: bigint;
}
/**
 * @generated from protobuf message injective.auction.v1beta1.EventAuctionResult
 */
interface EventAuctionResult {
  /**
   * winner describes the address of the winner
   *
   * @generated from protobuf field: string winner = 1
   */
  winner: string;
  /**
   * amount describes the amount the winner get from the auction
   *
   * @generated from protobuf field: cosmos.base.v1beta1.Coin amount = 2
   */
  amount?: Coin$1;
  /**
   * round defines the round number of auction
   *
   * @generated from protobuf field: uint64 round = 3
   */
  round: bigint;
}
/**
 * @generated from protobuf message injective.auction.v1beta1.EventAuctionStart
 */
interface EventAuctionStart {
  /**
   * round defines the round number of auction
   *
   * @generated from protobuf field: uint64 round = 1
   */
  round: bigint;
  /**
   * ending_timestamp describes auction end time
   *
   * @generated from protobuf field: int64 ending_timestamp = 2
   */
  endingTimestamp: bigint;
  /**
   * new_basket describes auction module balance at the time of new auction
   * start
   *
   * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin new_basket = 3
   */
  newBasket: Coin$1[];
}
/**
 * @generated MessageType for protobuf message injective.auction.v1beta1.Params
 */
declare const Params$5 = new Params$Type();
/**
 * @generated MessageType for protobuf message injective.auction.v1beta1.Bid
 */
declare const Bid = new Bid$Type();
/**
 * @generated MessageType for protobuf message injective.auction.v1beta1.LastAuctionResult
 */
declare const LastAuctionResult = new LastAuctionResult$Type();
/**
 * @generated MessageType for protobuf message injective.auction.v1beta1.EventBid
 */
declare const EventBid = new EventBid$Type();
/**
 * @generated MessageType for protobuf message injective.auction.v1beta1.EventAuctionResult
 */
declare const EventAuctionResult = new EventAuctionResult$Type();
/**
 * @generated MessageType for protobuf message injective.auction.v1beta1.EventAuctionStart
 */
declare const EventAuctionStart = new EventAuctionStart$Type();
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/injective/auction/v1beta1/tx_pb.d.ts
/**
 * Bid defines a SDK message for placing a bid for an auction
 *
 * @generated from protobuf message injective.auction.v1beta1.MsgBid
 */
interface MsgBid$1 {
  /**
   * the sender's Injective address
   *
   * @generated from protobuf field: string sender = 1
   */
  sender: string;
  /**
   * amount of the bid in INJ tokens
   *
   * @generated from protobuf field: cosmos.base.v1beta1.Coin bid_amount = 2
   */
  bidAmount?: Coin$1;
  /**
   * the current auction round being bid on
   *
   * @generated from protobuf field: uint64 round = 3
   */
  round: bigint;
}
/**
 * @generated MessageType for protobuf message injective.auction.v1beta1.MsgBid
 */
declare const MsgBid$1 = new MsgBid$Type();
//#endregion
//#region src/core/modules/auction/msgs/MsgBid.d.ts
declare namespace MsgBid {
  interface Params {
    round: number;
    injectiveAddress: string;
    amount: {
      denom: string;
      amount: string;
    };
  }
  type Proto = MsgBid$1;
}
/**
 * @category Messages
 */
declare class MsgBid extends MsgBase<MsgBid.Params, MsgBid.Proto> {
  static fromJSON(params: MsgBid.Params): MsgBid;
  toProto(): MsgBid$1;
  toData(): {
    sender: string;
    bidAmount?: Coin$1;
    round: bigint;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      sender: string;
      bid_amount: Coin$1 | undefined;
      round: string;
    };
  };
  toDirectSign(): {
    type: string;
    message: MsgBid$1;
  };
  toWeb3Gw(): {
    sender: string;
    bid_amount: Coin$1 | undefined;
    round: string;
    '@type': string;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/cosmos/authz/v1beta1/authz_pb.d.ts
/**
 * GenericAuthorization gives the grantee unrestricted permissions to execute
 * the provided method on behalf of the granter's account.
 *
 * @generated from protobuf message cosmos.authz.v1beta1.GenericAuthorization
 */
interface GenericAuthorization$2 {
  /**
   * Msg, identified by it's type URL, to grant unrestricted permissions to execute
   *
   * @generated from protobuf field: string msg = 1
   */
  msg: string;
}
/**
 * Grant gives permissions to execute
 * the provide method with expiration time.
 *
 * @generated from protobuf message cosmos.authz.v1beta1.Grant
 */
interface Grant {
  /**
   * @generated from protobuf field: google.protobuf.Any authorization = 1
   */
  authorization?: Any;
  /**
   * time when the grant will expire and will be pruned. If null, then the grant
   * doesn't have a time expiration (other conditions  in `authorization`
   * may apply to invalidate the grant)
   *
   * @generated from protobuf field: google.protobuf.Timestamp expiration = 2
   */
  expiration?: Timestamp;
}
/**
 * GrantAuthorization extends a grant with both the addresses of the grantee and granter.
 * It is used in genesis.proto and query.proto
 *
 * @generated from protobuf message cosmos.authz.v1beta1.GrantAuthorization
 */
interface GrantAuthorization {
  /**
   * @generated from protobuf field: string granter = 1
   */
  granter: string;
  /**
   * @generated from protobuf field: string grantee = 2
   */
  grantee: string;
  /**
   * @generated from protobuf field: google.protobuf.Any authorization = 3
   */
  authorization?: Any;
  /**
   * @generated from protobuf field: google.protobuf.Timestamp expiration = 4
   */
  expiration?: Timestamp;
}
/**
 * @generated MessageType for protobuf message cosmos.authz.v1beta1.GenericAuthorization
 */
declare const GenericAuthorization$2 = new GenericAuthorization$Type();
/**
 * @generated MessageType for protobuf message cosmos.authz.v1beta1.Grant
 */
declare const Grant = new Grant$Type();
/**
 * @generated MessageType for protobuf message cosmos.authz.v1beta1.GrantAuthorization
 */
declare const GrantAuthorization = new GrantAuthorization$Type();
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/cosmos/authz/v1beta1/tx_pb.d.ts
/**
 * MsgGrant is a request type for Grant method. It declares authorization to the grantee
 * on behalf of the granter with the provided expiration time.
 *
 * @generated from protobuf message cosmos.authz.v1beta1.MsgGrant
 */
interface MsgGrant$1 {
  /**
   * @generated from protobuf field: string granter = 1
   */
  granter: string;
  /**
   * @generated from protobuf field: string grantee = 2
   */
  grantee: string;
  /**
   * @generated from protobuf field: cosmos.authz.v1beta1.Grant grant = 3
   */
  grant?: Grant;
}
/**
 * MsgExec attempts to execute the provided messages using
 * authorizations granted to the grantee. Each message should have only
 * one signer corresponding to the granter of the authorization.
 *
 * @generated from protobuf message cosmos.authz.v1beta1.MsgExec
 */
interface MsgExec$1 {
  /**
   * @generated from protobuf field: string grantee = 1
   */
  grantee: string;
  /**
   * Execute Msg.
   * The x/authz will try to find a grant matching (msg.signers[0], grantee, MsgTypeURL(msg))
   * triple and validate it.
   *
   * @generated from protobuf field: repeated google.protobuf.Any msgs = 2
   */
  msgs: Any[];
}
/**
 * MsgRevoke revokes any authorization with the provided sdk.Msg type on the
 * granter's account with that has been granted to the grantee.
 *
 * @generated from protobuf message cosmos.authz.v1beta1.MsgRevoke
 */
interface MsgRevoke$1 {
  /**
   * @generated from protobuf field: string granter = 1
   */
  granter: string;
  /**
   * @generated from protobuf field: string grantee = 2
   */
  grantee: string;
  /**
   * @generated from protobuf field: string msg_type_url = 3
   */
  msgTypeUrl: string;
}
/**
 * @generated MessageType for protobuf message cosmos.authz.v1beta1.MsgGrant
 */
declare const MsgGrant$1 = new MsgGrant$Type();
/**
 * @generated MessageType for protobuf message cosmos.authz.v1beta1.MsgExec
 */
declare const MsgExec$1 = new MsgExec$Type();
/**
 * @generated MessageType for protobuf message cosmos.authz.v1beta1.MsgRevoke
 */
declare const MsgRevoke$1 = new MsgRevoke$Type();
//#endregion
//#region src/core/modules/authz/msgs/MsgGrant.d.ts
/**
 * @deprecated please use MsgGrantWithAuthorization
 */
declare namespace MsgGrant {
  interface Params {
    /**
     * @deprecated Use `authorization` instead - for generic authorizations,
     * use `getGenericAuthorizationFromMessageType` function
     * to get the authorization object from messageType
     */
    messageType?: string;
    authorization?: Any;
    grantee: string;
    granter: string;
    expiration?: number;
    expiryInYears?: number;
    expiryInSeconds?: number;
  }
  type Proto = MsgGrant$1;
  type Object = Omit<MsgGrant$1, 'msgs'> & {
    msgs: any;
  };
}
/**
 * @category Messages
 */
declare class MsgGrant extends MsgBase<MsgGrant.Params, MsgGrant.Proto> {
  static fromJSON(params: MsgGrant.Params): MsgGrant;
  toProto(): MsgGrant$1;
  toData(): {
    granter: string;
    grantee: string;
    grant?: Grant;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: MsgGrant.Object;
  };
  toDirectSign(): {
    type: string;
    message: MsgGrant$1;
  };
  toWeb3Gw(): {
    granter: string;
    grantee: string;
    grant: {
      authorization: {
        '@type': string;
        msg: string;
      };
      expiration: string;
    };
    '@type': string;
  };
  getTimestamp(): Timestamp;
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/authz/msgs/MsgRevoke.d.ts
type SnakeCaseKeys$2<T extends Record<string, any> | readonly any[]> = snakecaseKeys.SnakeCaseKeys<T>;
declare namespace MsgRevoke {
  interface Params {
    messageType: string;
    grantee: string;
    granter: string;
  }
  type Proto = MsgRevoke$1;
}
/**
 * @category Messages
 */
declare class MsgRevoke extends MsgBase<MsgRevoke.Params, MsgRevoke.Proto> {
  static fromJSON(params: MsgRevoke.Params): MsgRevoke;
  toProto(): MsgRevoke$1;
  toData(): {
    granter: string;
    grantee: string;
    msgTypeUrl: string;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: SnakeCaseKeys$2<MsgRevoke$1>;
  };
  toWeb3Gw(): {
    granter: string;
    grantee: string;
    msg_type_url: string;
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgRevoke$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/gov/msgs/MsgDeposit.d.ts
declare namespace MsgDeposit$1 {
  interface Params {
    proposalId: number;
    amount: {
      denom: string;
      amount: string;
    };
    depositor: string;
  }
  type Proto = MsgDeposit$3;
}
/**
 * @category Messages
 */
declare class MsgDeposit$1 extends MsgBase<MsgDeposit$1.Params, MsgDeposit$1.Proto> {
  static fromJSON(params: MsgDeposit$1.Params): MsgDeposit$1;
  toProto(): MsgDeposit$3;
  toData(): {
    proposalId: bigint;
    depositor: string;
    amount: Coin$1[];
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      proposal_id: string;
      depositor: string;
      amount: Coin$1[];
    };
  };
  toWeb3Gw(): {
    proposal_id: string;
    depositor: string;
    amount: Coin$1[];
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgDeposit$3;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/cosmos/gov/v1beta1/gov_pb.d.ts
/**
 * TextProposal defines a standard text proposal whose changes need to be
 * manually updated in case of approval.
 *
 * @generated from protobuf message cosmos.gov.v1beta1.TextProposal
 */
interface TextProposal {
  /**
   * title of the proposal.
   *
   * @generated from protobuf field: string title = 1
   */
  title: string;
  /**
   * description associated with the proposal.
   *
   * @generated from protobuf field: string description = 2
   */
  description: string;
}
/**
 * @generated MessageType for protobuf message cosmos.gov.v1beta1.TextProposal
 */
declare const TextProposal = new TextProposal$Type();
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/cosmos/gov/v1beta1/tx_pb.d.ts
/**
 * MsgSubmitProposal defines an sdk.Msg type that supports submitting arbitrary
 * proposal Content.
 *
 * @generated from protobuf message cosmos.gov.v1beta1.MsgSubmitProposal
 */
interface MsgSubmitProposal$1 {
  /**
   * content is the proposal's content.
   *
   * @generated from protobuf field: google.protobuf.Any content = 1
   */
  content?: Any;
  /**
   * initial_deposit is the deposit value that must be paid at proposal submission.
   *
   * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin initial_deposit = 2
   */
  initialDeposit: Coin$1[];
  /**
   * proposer is the account address of the proposer.
   *
   * @generated from protobuf field: string proposer = 3
   */
  proposer: string;
}
/**
 * @generated MessageType for protobuf message cosmos.gov.v1beta1.MsgSubmitProposal
 */
declare const MsgSubmitProposal$1 = new MsgSubmitProposal$Type();
//#endregion
//#region src/core/modules/gov/msgs/MsgSubmitTextProposal.d.ts
declare namespace MsgSubmitTextProposal {
  interface Params {
    title: string;
    description: string;
    proposer: string;
    deposit: {
      amount: string;
      denom: string;
    };
  }
  type Proto = MsgSubmitProposal$1;
  type Object = Omit<MsgSubmitProposal$1, 'content'> & {
    content: {
      type_url: string;
      value: any;
    };
  };
}
/**
 * @category Messages
 */
declare class MsgSubmitTextProposal extends MsgBase<MsgSubmitTextProposal.Params, MsgSubmitTextProposal.Proto> {
  static fromJSON(params: MsgSubmitTextProposal.Params): MsgSubmitTextProposal;
  toProto(): MsgSubmitProposal$1;
  toData(): {
    content?: Any;
    initialDeposit: Coin$1[];
    proposer: string;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      content: {
        type: string;
        value: {
          title: string;
          description: string;
        };
      };
      initial_deposit: {
        denom: string;
        amount: string;
      }[];
      proposer: string;
    };
  };
  toWeb3Gw(): {
    content: {
      title: string;
      description: string;
      '@type': string;
    };
    initial_deposit: {
      denom: string;
      amount: string;
    }[];
    proposer: string;
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgSubmitProposal$1;
  };
  toBinary(): Uint8Array;
  private getContent;
}
//#endregion
//#region src/core/modules/gov/msgs/MsgSubmitGenericProposal.d.ts
declare namespace MsgSubmitGenericProposal {
  interface Params {
    title: string;
    summary: string;
    expedited?: boolean;
    proposer: string;
    metadata?: string;
    messages: Msgs[];
    deposit: {
      amount: string;
      denom: string;
    };
  }
  type Proto = MsgSubmitProposal$2;
}
/**
 * @category Messages
 */
declare class MsgSubmitGenericProposal extends MsgBase<MsgSubmitGenericProposal.Params, MsgSubmitGenericProposal.Proto> {
  static fromJSON(params: MsgSubmitGenericProposal.Params): MsgSubmitGenericProposal;
  toProto(): MsgSubmitProposal$2;
  toData(): {
    messages: Any[];
    initialDeposit: Coin$1[];
    proposer: string;
    metadata: string;
    title: string;
    summary: string;
    expedited: boolean;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: any;
  };
  toWeb3Gw(): any;
  toEip712(): {
    type: string;
    value: any;
  };
  toDirectSign(): {
    type: "/cosmos.gov.v1.MsgSubmitProposal";
    message: MsgSubmitProposal$2;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/cosmos/distribution/v1beta1/distribution_pb.d.ts
/**
 * Params defines the set of params for the distribution module.
 *
 * @generated from protobuf message cosmos.distribution.v1beta1.Params
 */
interface Params$2 {
  /**
   * @generated from protobuf field: string community_tax = 1
   */
  communityTax: string;
  /**
   * Deprecated: The base_proposer_reward field is deprecated and is no longer used
   * in the x/distribution module's reward mechanism.
   *
   * @deprecated
   * @generated from protobuf field: string base_proposer_reward = 2 [deprecated = true]
   */
  baseProposerReward: string;
  /**
   * Deprecated: The bonus_proposer_reward field is deprecated and is no longer used
   * in the x/distribution module's reward mechanism.
   *
   * @deprecated
   * @generated from protobuf field: string bonus_proposer_reward = 3 [deprecated = true]
   */
  bonusProposerReward: string;
  /**
   * @generated from protobuf field: bool withdraw_addr_enabled = 4
   */
  withdrawAddrEnabled: boolean;
}
/**
 * DelegationDelegatorReward represents the properties
 * of a delegator's delegation reward.
 *
 * @generated from protobuf message cosmos.distribution.v1beta1.DelegationDelegatorReward
 */
interface DelegationDelegatorReward {
  /**
   * @generated from protobuf field: string validator_address = 1
   */
  validatorAddress: string;
  /**
   * @generated from protobuf field: repeated cosmos.base.v1beta1.DecCoin reward = 2
   */
  reward: DecCoin[];
}
/**
 * @generated MessageType for protobuf message cosmos.distribution.v1beta1.Params
 */
declare const Params$2 = new Params$Type();
/**
 * @generated MessageType for protobuf message cosmos.distribution.v1beta1.DelegationDelegatorReward
 */
declare const DelegationDelegatorReward = new DelegationDelegatorReward$Type();
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/injective/exchange/v1beta1/proposal_pb.d.ts
/**
 * @generated from protobuf message injective.exchange.v1beta1.SpotMarketParamUpdateProposal
 */
interface SpotMarketParamUpdateProposal {
  /**
   * @generated from protobuf field: string title = 1
   */
  title: string;
  /**
   * @generated from protobuf field: string description = 2
   */
  description: string;
  /**
   * @generated from protobuf field: string market_id = 3
   */
  marketId: string;
  /**
   * maker_fee_rate defines the trade fee rate for makers on the spot market
   *
   * @generated from protobuf field: string maker_fee_rate = 4
   */
  makerFeeRate: string;
  /**
   * taker_fee_rate defines the trade fee rate for takers on the spot market
   *
   * @generated from protobuf field: string taker_fee_rate = 5
   */
  takerFeeRate: string;
  /**
   * relayer_fee_share_rate defines the relayer fee share rate for the spot
   * market
   *
   * @generated from protobuf field: string relayer_fee_share_rate = 6
   */
  relayerFeeShareRate: string;
  /**
   * min_price_tick_size defines the minimum tick size of the order's price and
   * margin
   *
   * @generated from protobuf field: string min_price_tick_size = 7
   */
  minPriceTickSize: string;
  /**
   * min_quantity_tick_size defines the minimum tick size of the order's
   * quantity
   *
   * @generated from protobuf field: string min_quantity_tick_size = 8
   */
  minQuantityTickSize: string;
  /**
   * @generated from protobuf field: injective.exchange.v1beta1.MarketStatus status = 9
   */
  status: MarketStatus;
  /**
   * @generated from protobuf field: string ticker = 10
   */
  ticker: string;
  /**
   * min_notional defines the minimum notional (in quote asset) required for
   * orders in the market
   *
   * @generated from protobuf field: string min_notional = 11
   */
  minNotional: string;
  /**
   * @generated from protobuf field: injective.exchange.v1beta1.AdminInfo admin_info = 12
   */
  adminInfo?: AdminInfo$1;
  /**
   * base token decimals
   *
   * @generated from protobuf field: uint32 base_decimals = 13
   */
  baseDecimals: number;
  /**
   * quote token decimals
   *
   * @generated from protobuf field: uint32 quote_decimals = 14
   */
  quoteDecimals: number;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.ExchangeEnableProposal
 */
interface ExchangeEnableProposal {
  /**
   * @generated from protobuf field: string title = 1
   */
  title: string;
  /**
   * @generated from protobuf field: string description = 2
   */
  description: string;
  /**
   * @generated from protobuf field: injective.exchange.v1beta1.ExchangeType exchangeType = 3
   */
  exchangeType: ExchangeType;
}
/**
 * SpotMarketLaunchProposal defines a SDK message for proposing a new spot
 * market through governance
 *
 * @generated from protobuf message injective.exchange.v1beta1.SpotMarketLaunchProposal
 */
interface SpotMarketLaunchProposal {
  /**
   * @generated from protobuf field: string title = 1
   */
  title: string;
  /**
   * @generated from protobuf field: string description = 2
   */
  description: string;
  /**
   * Ticker for the spot market.
   *
   * @generated from protobuf field: string ticker = 3
   */
  ticker: string;
  /**
   * type of coin to use as the base currency
   *
   * @generated from protobuf field: string base_denom = 4
   */
  baseDenom: string;
  /**
   * type of coin to use as the quote currency
   *
   * @generated from protobuf field: string quote_denom = 5
   */
  quoteDenom: string;
  /**
   * min_price_tick_size defines the minimum tick size of the order's price
   *
   * @generated from protobuf field: string min_price_tick_size = 6
   */
  minPriceTickSize: string;
  /**
   * min_quantity_tick_size defines the minimum tick size of the order's
   * quantity
   *
   * @generated from protobuf field: string min_quantity_tick_size = 7
   */
  minQuantityTickSize: string;
  /**
   * maker_fee_rate defines the fee percentage makers pay when trading
   *
   * @generated from protobuf field: string maker_fee_rate = 8
   */
  makerFeeRate: string;
  /**
   * taker_fee_rate defines the fee percentage takers pay when trading
   *
   * @generated from protobuf field: string taker_fee_rate = 9
   */
  takerFeeRate: string;
  /**
   * min_notional defines the minimum notional for orders in the market
   *
   * @generated from protobuf field: string min_notional = 10
   */
  minNotional: string;
  /**
   * @generated from protobuf field: injective.exchange.v1beta1.AdminInfo admin_info = 11
   */
  adminInfo?: AdminInfo$1;
  /**
   * base token decimals
   *
   * @generated from protobuf field: uint32 base_decimals = 14
   */
  baseDecimals: number;
  /**
   * quote token decimals
   *
   * @generated from protobuf field: uint32 quote_decimals = 15
   */
  quoteDecimals: number;
}
/**
 * PerpetualMarketLaunchProposal defines a SDK message for proposing a new
 * perpetual futures market through governance
 *
 * @generated from protobuf message injective.exchange.v1beta1.PerpetualMarketLaunchProposal
 */
interface PerpetualMarketLaunchProposal$1 {
  /**
   * @generated from protobuf field: string title = 1
   */
  title: string;
  /**
   * @generated from protobuf field: string description = 2
   */
  description: string;
  /**
   * Ticker for the derivative market.
   *
   * @generated from protobuf field: string ticker = 3
   */
  ticker: string;
  /**
   * type of coin to use as the base currency
   *
   * @generated from protobuf field: string quote_denom = 4
   */
  quoteDenom: string;
  /**
   * Oracle base currency
   *
   * @generated from protobuf field: string oracle_base = 5
   */
  oracleBase: string;
  /**
   * Oracle quote currency
   *
   * @generated from protobuf field: string oracle_quote = 6
   */
  oracleQuote: string;
  /**
   * Scale factor for oracle prices.
   *
   * @generated from protobuf field: uint32 oracle_scale_factor = 7
   */
  oracleScaleFactor: number;
  /**
   * Oracle type
   *
   * @generated from protobuf field: injective.oracle.v1beta1.OracleType oracle_type = 8
   */
  oracleType: OracleType;
  /**
   * initial_margin_ratio defines the initial margin ratio for the derivative
   * market
   *
   * @generated from protobuf field: string initial_margin_ratio = 9
   */
  initialMarginRatio: string;
  /**
   * maintenance_margin_ratio defines the maintenance margin ratio for the
   * derivative market
   *
   * @generated from protobuf field: string maintenance_margin_ratio = 10
   */
  maintenanceMarginRatio: string;
  /**
   * maker_fee_rate defines the exchange trade fee for makers for the derivative
   * market
   *
   * @generated from protobuf field: string maker_fee_rate = 11
   */
  makerFeeRate: string;
  /**
   * taker_fee_rate defines the exchange trade fee for takers for the derivative
   * market
   *
   * @generated from protobuf field: string taker_fee_rate = 12
   */
  takerFeeRate: string;
  /**
   * min_price_tick_size defines the minimum tick size of the order's price and
   * margin
   *
   * @generated from protobuf field: string min_price_tick_size = 13
   */
  minPriceTickSize: string;
  /**
   * min_quantity_tick_size defines the minimum tick size of the order's
   * quantity
   *
   * @generated from protobuf field: string min_quantity_tick_size = 14
   */
  minQuantityTickSize: string;
  /**
   * min_notional defines the minimum notional (in quote asset) required for
   * orders in the market
   *
   * @generated from protobuf field: string min_notional = 15
   */
  minNotional: string;
  /**
   * @generated from protobuf field: injective.exchange.v1beta1.AdminInfo admin_info = 16
   */
  adminInfo?: AdminInfo$1;
}
/**
 * ExpiryFuturesMarketLaunchProposal defines a SDK message for proposing a new
 * expiry futures market through governance
 *
 * @generated from protobuf message injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal
 */
interface ExpiryFuturesMarketLaunchProposal {
  /**
   * @generated from protobuf field: string title = 1
   */
  title: string;
  /**
   * @generated from protobuf field: string description = 2
   */
  description: string;
  /**
   * Ticker for the derivative market.
   *
   * @generated from protobuf field: string ticker = 3
   */
  ticker: string;
  /**
   * type of coin to use as the quote currency
   *
   * @generated from protobuf field: string quote_denom = 4
   */
  quoteDenom: string;
  /**
   * Oracle base currency
   *
   * @generated from protobuf field: string oracle_base = 5
   */
  oracleBase: string;
  /**
   * Oracle quote currency
   *
   * @generated from protobuf field: string oracle_quote = 6
   */
  oracleQuote: string;
  /**
   * Scale factor for oracle prices.
   *
   * @generated from protobuf field: uint32 oracle_scale_factor = 7
   */
  oracleScaleFactor: number;
  /**
   * Oracle type
   *
   * @generated from protobuf field: injective.oracle.v1beta1.OracleType oracle_type = 8
   */
  oracleType: OracleType;
  /**
   * Expiration time of the market
   *
   * @generated from protobuf field: int64 expiry = 9
   */
  expiry: bigint;
  /**
   * initial_margin_ratio defines the initial margin ratio for the derivative
   * market
   *
   * @generated from protobuf field: string initial_margin_ratio = 10
   */
  initialMarginRatio: string;
  /**
   * maintenance_margin_ratio defines the maintenance margin ratio for the
   * derivative market
   *
   * @generated from protobuf field: string maintenance_margin_ratio = 11
   */
  maintenanceMarginRatio: string;
  /**
   * maker_fee_rate defines the exchange trade fee for makers for the derivative
   * market
   *
   * @generated from protobuf field: string maker_fee_rate = 12
   */
  makerFeeRate: string;
  /**
   * taker_fee_rate defines the exchange trade fee for takers for the derivative
   * market
   *
   * @generated from protobuf field: string taker_fee_rate = 13
   */
  takerFeeRate: string;
  /**
   * min_price_tick_size defines the minimum tick size of the order's price and
   * margin
   *
   * @generated from protobuf field: string min_price_tick_size = 14
   */
  minPriceTickSize: string;
  /**
   * min_quantity_tick_size defines the minimum tick size of the order's
   * quantity
   *
   * @generated from protobuf field: string min_quantity_tick_size = 15
   */
  minQuantityTickSize: string;
  /**
   * min_notional defines the minimum notional (in quote asset) required for
   * orders in the market
   *
   * @generated from protobuf field: string min_notional = 16
   */
  minNotional: string;
  /**
   * @generated from protobuf field: injective.exchange.v1beta1.AdminInfo admin_info = 17
   */
  adminInfo?: AdminInfo$1;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal
 */
interface DerivativeMarketParamUpdateProposal {
  /**
   * @generated from protobuf field: string title = 1
   */
  title: string;
  /**
   * @generated from protobuf field: string description = 2
   */
  description: string;
  /**
   * @generated from protobuf field: string market_id = 3
   */
  marketId: string;
  /**
   * initial_margin_ratio defines the initial margin ratio for the derivative
   * market
   *
   * @generated from protobuf field: string initial_margin_ratio = 4
   */
  initialMarginRatio: string;
  /**
   * maintenance_margin_ratio defines the maintenance margin ratio for the
   * derivative market
   *
   * @generated from protobuf field: string maintenance_margin_ratio = 5
   */
  maintenanceMarginRatio: string;
  /**
   * maker_fee_rate defines the exchange trade fee for makers for the derivative
   * market
   *
   * @generated from protobuf field: string maker_fee_rate = 6
   */
  makerFeeRate: string;
  /**
   * taker_fee_rate defines the exchange trade fee for takers for the derivative
   * market
   *
   * @generated from protobuf field: string taker_fee_rate = 7
   */
  takerFeeRate: string;
  /**
   * relayer_fee_share_rate defines the relayer fee share rate for the
   * derivative market
   *
   * @generated from protobuf field: string relayer_fee_share_rate = 8
   */
  relayerFeeShareRate: string;
  /**
   * min_price_tick_size defines the minimum tick size of the order's price and
   * margin
   *
   * @generated from protobuf field: string min_price_tick_size = 9
   */
  minPriceTickSize: string;
  /**
   * min_quantity_tick_size defines the minimum tick size of the order's
   * quantity
   *
   * @generated from protobuf field: string min_quantity_tick_size = 10
   */
  minQuantityTickSize: string;
  /**
   * hourly_interest_rate defines the hourly interest rate
   *
   * @generated from protobuf field: string HourlyInterestRate = 11
   */
  hourlyInterestRate: string;
  /**
   * hourly_funding_rate_cap defines the maximum absolute value of the hourly
   * funding rate
   *
   * @generated from protobuf field: string HourlyFundingRateCap = 12
   */
  hourlyFundingRateCap: string;
  /**
   * @generated from protobuf field: injective.exchange.v1beta1.MarketStatus status = 13
   */
  status: MarketStatus;
  /**
   * @generated from protobuf field: injective.exchange.v1beta1.OracleParams oracle_params = 14
   */
  oracleParams?: OracleParams;
  /**
   * @generated from protobuf field: string ticker = 15
   */
  ticker: string;
  /**
   * min_notional defines the minimum notional (in quote asset) required for
   * orders in the market
   *
   * @generated from protobuf field: string min_notional = 16
   */
  minNotional: string;
  /**
   * @generated from protobuf field: injective.exchange.v1beta1.AdminInfo admin_info = 17
   */
  adminInfo?: AdminInfo$1;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.AdminInfo
 */
interface AdminInfo$1 {
  /**
   * @generated from protobuf field: string admin = 1
   */
  admin: string;
  /**
   * @generated from protobuf field: uint32 admin_permissions = 2
   */
  adminPermissions: number;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.OracleParams
 */
interface OracleParams {
  /**
   * Oracle base currency
   *
   * @generated from protobuf field: string oracle_base = 1
   */
  oracleBase: string;
  /**
   * Oracle quote currency
   *
   * @generated from protobuf field: string oracle_quote = 2
   */
  oracleQuote: string;
  /**
   * Scale factor for oracle prices.
   *
   * @generated from protobuf field: uint32 oracle_scale_factor = 3
   */
  oracleScaleFactor: number;
  /**
   * Oracle type
   *
   * @generated from protobuf field: injective.oracle.v1beta1.OracleType oracle_type = 4
   */
  oracleType: OracleType;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.TradingRewardCampaignLaunchProposal
 */
interface TradingRewardCampaignLaunchProposal {
  /**
   * @generated from protobuf field: string title = 1
   */
  title: string;
  /**
   * @generated from protobuf field: string description = 2
   */
  description: string;
  /**
   * @generated from protobuf field: injective.exchange.v1beta1.TradingRewardCampaignInfo campaign_info = 3
   */
  campaignInfo?: TradingRewardCampaignInfo$1;
  /**
   * @generated from protobuf field: repeated injective.exchange.v1beta1.CampaignRewardPool campaign_reward_pools = 4
   */
  campaignRewardPools: CampaignRewardPool$1[];
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.TradingRewardCampaignUpdateProposal
 */
interface TradingRewardCampaignUpdateProposal {
  /**
   * @generated from protobuf field: string title = 1
   */
  title: string;
  /**
   * @generated from protobuf field: string description = 2
   */
  description: string;
  /**
   * @generated from protobuf field: injective.exchange.v1beta1.TradingRewardCampaignInfo campaign_info = 3
   */
  campaignInfo?: TradingRewardCampaignInfo$1;
  /**
   * @generated from protobuf field: repeated injective.exchange.v1beta1.CampaignRewardPool campaign_reward_pools_additions = 4
   */
  campaignRewardPoolsAdditions: CampaignRewardPool$1[];
  /**
   * @generated from protobuf field: repeated injective.exchange.v1beta1.CampaignRewardPool campaign_reward_pools_updates = 5
   */
  campaignRewardPoolsUpdates: CampaignRewardPool$1[];
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.FeeDiscountProposal
 */
interface FeeDiscountProposal {
  /**
   * @generated from protobuf field: string title = 1
   */
  title: string;
  /**
   * @generated from protobuf field: string description = 2
   */
  description: string;
  /**
   * @generated from protobuf field: injective.exchange.v1beta1.FeeDiscountSchedule schedule = 3
   */
  schedule?: FeeDiscountSchedule$1;
}
/**
 * @generated from protobuf enum injective.exchange.v1beta1.ExchangeType
 */
declare enum ExchangeType {
  /**
   * @generated from protobuf enum value: EXCHANGE_UNSPECIFIED = 0;
   */
  EXCHANGE_UNSPECIFIED = 0,
  /**
   * @generated from protobuf enum value: SPOT = 1;
   */
  SPOT = 1,
  /**
   * @generated from protobuf enum value: DERIVATIVES = 2;
   */
  DERIVATIVES = 2,
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.SpotMarketParamUpdateProposal
 */
declare const SpotMarketParamUpdateProposal = new SpotMarketParamUpdateProposal$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.ExchangeEnableProposal
 */
declare const ExchangeEnableProposal = new ExchangeEnableProposal$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.SpotMarketLaunchProposal
 */
declare const SpotMarketLaunchProposal = new SpotMarketLaunchProposal$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.PerpetualMarketLaunchProposal
 */
declare const PerpetualMarketLaunchProposal$1 = new PerpetualMarketLaunchProposal$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal
 */
declare const ExpiryFuturesMarketLaunchProposal = new ExpiryFuturesMarketLaunchProposal$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal
 */
declare const DerivativeMarketParamUpdateProposal = new DerivativeMarketParamUpdateProposal$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.AdminInfo
 */
declare const AdminInfo$1 = new AdminInfo$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.OracleParams
 */
declare const OracleParams = new OracleParams$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.TradingRewardCampaignLaunchProposal
 */
declare const TradingRewardCampaignLaunchProposal = new TradingRewardCampaignLaunchProposal$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.TradingRewardCampaignUpdateProposal
 */
declare const TradingRewardCampaignUpdateProposal = new TradingRewardCampaignUpdateProposal$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.FeeDiscountProposal
 */
declare const FeeDiscountProposal = new FeeDiscountProposal$Type();
//#endregion
//#region src/core/modules/gov/msgs/MsgSubmitProposalSpotMarketLaunch.d.ts
declare namespace MsgSubmitProposalSpotMarketLaunch {
  interface Params {
    market: {
      title: string;
      description: string;
      ticker: string;
      baseDenom: string;
      quoteDenom: string;
      minPriceTickSize: string;
      minQuantityTickSize: string;
      makerFeeRate: string;
      takerFeeRate: string;
      minNotional: string;
      adminInfo?: {
        admin: string;
        adminPermissions: number;
      };
      baseDecimals: number;
      quoteDecimals: number;
    };
    proposer: string;
    deposit: {
      amount: string;
      denom: string;
    };
  }
  type Proto = MsgSubmitProposal$1;
  type Object = Omit<MsgSubmitProposal$1, 'content'> & {
    content: {
      type_url: string;
      value: any;
    };
  };
}
/**
 * @category Messages
 */
declare class MsgSubmitProposalSpotMarketLaunch extends MsgBase<MsgSubmitProposalSpotMarketLaunch.Params, MsgSubmitProposalSpotMarketLaunch.Proto> {
  static fromJSON(params: MsgSubmitProposalSpotMarketLaunch.Params): MsgSubmitProposalSpotMarketLaunch;
  toProto(): MsgSubmitProposalSpotMarketLaunch.Proto;
  toData(): {
    content?: Any;
    initialDeposit: Coin$1[];
    proposer: string;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      content: {
        type: string;
        value: {
          title: string;
          description: string;
          ticker: string;
          base_denom: string;
          quote_denom: string;
          min_price_tick_size: string;
          min_quantity_tick_size: string;
          maker_fee_rate: string;
          taker_fee_rate: string;
          min_notional: string;
          admin_info: AdminInfo$1 | null;
          base_decimals: number;
          quote_decimals: number;
        };
      };
      initial_deposit: {
        denom: string;
        amount: string;
      }[];
      proposer: string;
    };
  };
  toWeb3Gw(): {
    content: {
      title: string;
      description: string;
      ticker: string;
      base_denom: string;
      quote_denom: string;
      min_price_tick_size: string;
      min_quantity_tick_size: string;
      maker_fee_rate: string;
      taker_fee_rate: string;
      min_notional: string;
      admin_info: AdminInfo$1 | null;
      base_decimals: number;
      quote_decimals: number;
      '@type': string;
    };
    initial_deposit: {
      denom: string;
      amount: string;
    }[];
    proposer: string;
    '@type': string;
  };
  toEip712(): {
    type: string;
    value: {
      content: {
        type: string;
        value: {
          maker_fee_rate: any;
          taker_fee_rate: any;
          min_price_tick_size: any;
          min_notional: any;
          min_quantity_tick_size: any;
          title: string;
          description: string;
          ticker: string;
          base_denom: string;
          quote_denom: string;
          admin_info: AdminInfo$1 | null;
          base_decimals: number;
          quote_decimals: number;
        };
      };
      initial_deposit: {
        denom: string;
        amount: string;
      }[];
      proposer: string;
    };
  };
  toEip712V2(): {
    content: any;
    initial_deposit: {
      denom: string;
      amount: string;
    }[];
    proposer: string;
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgSubmitProposal$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/gov/msgs/MsgSubmitProposalPerpetualMarketLaunch.d.ts
declare namespace MsgSubmitProposalPerpetualMarketLaunch {
  interface Params {
    market: {
      title: string;
      description: string;
      ticker: string;
      quoteDenom: string;
      oracleBase: string;
      oracleQuote: string;
      oracleScaleFactor: number;
      oracleType: OracleType;
      initialMarginRatio: string;
      maintenanceMarginRatio: string;
      makerFeeRate: string;
      takerFeeRate: string;
      minPriceTickSize: string;
      minQuantityTickSize: string;
      minNotional: string;
      adminInfo?: {
        admin: string;
        adminPermissions: number;
      };
    };
    proposer: string;
    deposit: {
      amount: string;
      denom: string;
    };
  }
  type Proto = MsgSubmitProposal$1;
  type Object = Omit<MsgSubmitProposal$1, 'content'> & {
    content: {
      type_url: string;
      value: any;
    };
  };
}
/**
 * @category Messages
 */
declare class MsgSubmitProposalPerpetualMarketLaunch extends MsgBase<MsgSubmitProposalPerpetualMarketLaunch.Params, MsgSubmitProposalPerpetualMarketLaunch.Proto> {
  static fromJSON(params: MsgSubmitProposalPerpetualMarketLaunch.Params): MsgSubmitProposalPerpetualMarketLaunch;
  toProto(): MsgSubmitProposal$1;
  toData(): {
    content?: Any;
    initialDeposit: Coin$1[];
    proposer: string;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      content: {
        type: string;
        value: {
          title: string;
          description: string;
          ticker: string;
          quote_denom: string;
          oracle_base: string;
          oracle_quote: string;
          oracle_scale_factor: number;
          oracle_type: OracleType;
          initial_margin_ratio: string;
          maintenance_margin_ratio: string;
          maker_fee_rate: string;
          taker_fee_rate: string;
          min_price_tick_size: string;
          min_quantity_tick_size: string;
          min_notional: string;
          admin_info: {
            admin: string;
            admin_permissions: number;
          } | null;
        };
      };
      initial_deposit: {
        denom: string;
        amount: string;
      }[];
      proposer: string;
    };
  };
  toWeb3Gw(): {
    content: {
      title: string;
      description: string;
      ticker: string;
      quote_denom: string;
      oracle_base: string;
      oracle_quote: string;
      oracle_scale_factor: number;
      oracle_type: OracleType;
      initial_margin_ratio: string;
      maintenance_margin_ratio: string;
      maker_fee_rate: string;
      taker_fee_rate: string;
      min_price_tick_size: string;
      min_quantity_tick_size: string;
      min_notional: string;
      admin_info: {
        admin: string;
        admin_permissions: number;
      } | null;
      '@type': string;
    };
    initial_deposit: {
      denom: string;
      amount: string;
    }[];
    proposer: string;
    '@type': string;
  };
  toEip712(): {
    type: string;
    value: {
      content: {
        type: string;
        value: {
          initial_margin_ratio: any;
          maintenance_margin_ratio: any;
          maker_fee_rate: any;
          taker_fee_rate: any;
          min_price_tick_size: any;
          min_notional: any;
          min_quantity_tick_size: any;
          title: string;
          description: string;
          ticker: string;
          quote_denom: string;
          oracle_base: string;
          oracle_quote: string;
          oracle_scale_factor: number;
          oracle_type: OracleType;
          admin_info: {
            admin: string;
            admin_permissions: number;
          } | null;
        };
      };
      initial_deposit: {
        denom: string;
        amount: string;
      }[];
      proposer: string;
    };
  };
  toEip712V2(): {
    content: any;
    initial_deposit: {
      denom: string;
      amount: string;
    }[];
    proposer: string;
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgSubmitProposal$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/gov/msgs/MsgSubmitProposalSpotMarketParamUpdate.d.ts
declare namespace MsgSubmitProposalSpotMarketParamUpdate {
  interface Params {
    market: {
      title: string;
      description: string;
      marketId: string;
      makerFeeRate: string;
      takerFeeRate: string;
      relayerFeeShareRate: string;
      minPriceTickSize: string;
      minQuantityTickSize: string;
      minNotional: string;
      ticker: string;
      baseDecimals: number;
      quoteDecimals: number;
      adminInfo?: {
        admin: string;
        adminPermissions: number;
      };
      status: MarketStatus;
    };
    proposer: string;
    deposit: {
      amount: string;
      denom: string;
    };
  }
  type Proto = MsgSubmitProposal$1;
  type Object = Omit<MsgSubmitProposal$1, 'content'> & {
    content: {
      type_url: string;
      value: any;
    };
  };
}
/**
 * @category Messages
 */
declare class MsgSubmitProposalSpotMarketParamUpdate extends MsgBase<MsgSubmitProposalSpotMarketParamUpdate.Params, MsgSubmitProposalSpotMarketParamUpdate.Proto> {
  static fromJSON(params: MsgSubmitProposalSpotMarketParamUpdate.Params): MsgSubmitProposalSpotMarketParamUpdate;
  toProto(): MsgSubmitProposal$1;
  toData(): {
    content?: Any;
    initialDeposit: Coin$1[];
    proposer: string;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      content: {
        type: string;
        value: {
          title: string;
          description: string;
          market_id: string;
          maker_fee_rate: string;
          taker_fee_rate: string;
          relayer_fee_share_rate: string;
          min_price_tick_size: string;
          min_quantity_tick_size: string;
          status: MarketStatus;
          ticker: string;
          min_notional: string;
          admin_info: AdminInfo$1 | null;
          base_decimals: number;
          quote_decimals: number;
        };
      };
      initial_deposit: {
        denom: string;
        amount: string;
      }[];
      proposer: string;
    };
  };
  toWeb3Gw(): {
    content: {
      title: string;
      description: string;
      market_id: string;
      maker_fee_rate: string;
      taker_fee_rate: string;
      relayer_fee_share_rate: string;
      min_price_tick_size: string;
      min_quantity_tick_size: string;
      status: MarketStatus;
      ticker: string;
      min_notional: string;
      admin_info: AdminInfo$1 | null;
      base_decimals: number;
      quote_decimals: number;
      '@type': string;
    };
    initial_deposit: {
      denom: string;
      amount: string;
    }[];
    proposer: string;
    '@type': string;
  };
  toEip712(): {
    type: string;
    value: {
      content: {
        type: string;
        value: {
          admin_info: {
            admin: string;
            admin_permissions: number;
          } | null;
          relayer_fee_share_rate: any;
          maker_fee_rate: any;
          taker_fee_rate: any;
          min_price_tick_size: any;
          min_notional: any;
          min_quantity_tick_size: any;
          title: string;
          description: string;
          market_id: string;
          status: MarketStatus;
          ticker: string;
          base_decimals: number;
          quote_decimals: number;
        };
      };
      initial_deposit: {
        denom: string;
        amount: string;
      }[];
      proposer: string;
    };
  };
  toEip712V2(): {
    content: any;
    initial_deposit: {
      denom: string;
      amount: string;
    }[];
    proposer: string;
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgSubmitProposal$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/injective/exchange/v2/market_pb.d.ts
/**
 * @generated from protobuf message injective.exchange.v2.OpenNotionalCap
 */
interface OpenNotionalCap$1 {
  /**
   * @generated from protobuf oneof: cap
   */
  cap: {
    oneofKind: "uncapped";
    /**
     * @generated from protobuf field: injective.exchange.v2.OpenNotionalCapUncapped uncapped = 1
     */
    uncapped: OpenNotionalCapUncapped;
  } | {
    oneofKind: "capped";
    /**
     * @generated from protobuf field: injective.exchange.v2.OpenNotionalCapCapped capped = 2
     */
    capped: OpenNotionalCapCapped;
  } | {
    oneofKind: undefined;
  };
}
/**
 * @generated from protobuf message injective.exchange.v2.OpenNotionalCapUncapped
 */
interface OpenNotionalCapUncapped {}
/**
 * @generated from protobuf message injective.exchange.v2.OpenNotionalCapCapped
 */
interface OpenNotionalCapCapped {
  /**
   * @generated from protobuf field: string value = 1
   */
  value: string;
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.OpenNotionalCap
 */
declare const OpenNotionalCap$1 = new OpenNotionalCap$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v2.OpenNotionalCapUncapped
 */
declare const OpenNotionalCapUncapped = new OpenNotionalCapUncapped$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v2.OpenNotionalCapCapped
 */
declare const OpenNotionalCapCapped = new OpenNotionalCapCapped$Type();
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/injective/exchange/v2/proposal_pb.d.ts
/**
 * PerpetualMarketLaunchProposal defines a SDK message for proposing a new
 * perpetual futures market through governance
 *
 * @generated from protobuf message injective.exchange.v2.PerpetualMarketLaunchProposal
 */
interface PerpetualMarketLaunchProposal {
  /**
   * @generated from protobuf field: string title = 1
   */
  title: string;
  /**
   * @generated from protobuf field: string description = 2
   */
  description: string;
  /**
   * Ticker for the derivative market.
   *
   * @generated from protobuf field: string ticker = 3
   */
  ticker: string;
  /**
   * type of coin to use as the base currency
   *
   * @generated from protobuf field: string quote_denom = 4
   */
  quoteDenom: string;
  /**
   * Oracle base currency
   *
   * @generated from protobuf field: string oracle_base = 5
   */
  oracleBase: string;
  /**
   * Oracle quote currency
   *
   * @generated from protobuf field: string oracle_quote = 6
   */
  oracleQuote: string;
  /**
   * Scale factor for oracle prices.
   *
   * @generated from protobuf field: uint32 oracle_scale_factor = 7
   */
  oracleScaleFactor: number;
  /**
   * Oracle type
   *
   * @generated from protobuf field: injective.oracle.v1beta1.OracleType oracle_type = 8
   */
  oracleType: OracleType;
  /**
   * initial_margin_ratio defines the initial margin ratio for the derivative
   * market
   *
   * @generated from protobuf field: string initial_margin_ratio = 9
   */
  initialMarginRatio: string;
  /**
   * maintenance_margin_ratio defines the maintenance margin ratio for the
   * derivative market
   *
   * @generated from protobuf field: string maintenance_margin_ratio = 10
   */
  maintenanceMarginRatio: string;
  /**
   * maker_fee_rate defines the exchange trade fee for makers for the derivative
   * market
   *
   * @generated from protobuf field: string maker_fee_rate = 11
   */
  makerFeeRate: string;
  /**
   * taker_fee_rate defines the exchange trade fee for takers for the derivative
   * market
   *
   * @generated from protobuf field: string taker_fee_rate = 12
   */
  takerFeeRate: string;
  /**
   * min_price_tick_size defines the minimum tick size of the order's price and
   * margin
   *
   * @generated from protobuf field: string min_price_tick_size = 13
   */
  minPriceTickSize: string;
  /**
   * min_quantity_tick_size defines the minimum tick size of the order's
   * quantity
   *
   * @generated from protobuf field: string min_quantity_tick_size = 14
   */
  minQuantityTickSize: string;
  /**
   * min_notional defines the minimum notional (in quote asset) required for
   * orders in the market
   *
   * @generated from protobuf field: string min_notional = 15
   */
  minNotional: string;
  /**
   * @generated from protobuf field: injective.exchange.v2.AdminInfo admin_info = 16
   */
  adminInfo?: AdminInfo;
  /**
   * reduce_margin_ratio defines the ratio of the margin that is reduced
   *
   * @generated from protobuf field: string reduce_margin_ratio = 17
   */
  reduceMarginRatio: string;
  /**
   * open_notional_cap defines the maximum open notional for the market
   *
   * @generated from protobuf field: injective.exchange.v2.OpenNotionalCap open_notional_cap = 18
   */
  openNotionalCap?: OpenNotionalCap$1;
}
/**
 * @generated from protobuf message injective.exchange.v2.AdminInfo
 */
interface AdminInfo {
  /**
   * @generated from protobuf field: string admin = 1
   */
  admin: string;
  /**
   * @generated from protobuf field: uint32 admin_permissions = 2
   */
  adminPermissions: number;
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.PerpetualMarketLaunchProposal
 */
declare const PerpetualMarketLaunchProposal = new PerpetualMarketLaunchProposal$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v2.AdminInfo
 */
declare const AdminInfo = new AdminInfo$Type();
//#endregion
//#region src/core/modules/gov/msgs/MsgSubmitProposalPerpetualMarketLaunchV2.d.ts
declare namespace MsgSubmitProposalPerpetualMarketLaunchV2 {
  interface Params {
    market: {
      title: string;
      description: string;
      ticker: string;
      quoteDenom: string;
      oracleBase: string;
      oracleQuote: string;
      oracleScaleFactor: number;
      oracleType: OracleType;
      initialMarginRatio: string;
      maintenanceMarginRatio: string;
      makerFeeRate: string;
      takerFeeRate: string;
      minPriceTickSize: string;
      minQuantityTickSize: string;
      minNotional: string;
      reduceMarginRatio: string;
      adminInfo?: {
        admin: string;
        adminPermissions: number;
      };
    };
    proposer: string;
    deposit: {
      amount: string;
      denom: string;
    };
  }
  type Proto = MsgSubmitProposal$1;
  type Object = Omit<MsgSubmitProposal$1, 'content'> & {
    content: {
      type_url: string;
      value: any;
    };
  };
}
/**
 * @category Messages
 */
declare class MsgSubmitProposalPerpetualMarketLaunchV2 extends MsgBase<MsgSubmitProposalPerpetualMarketLaunchV2.Params, MsgSubmitProposalPerpetualMarketLaunchV2.Proto> {
  static fromJSON(params: MsgSubmitProposalPerpetualMarketLaunchV2.Params): MsgSubmitProposalPerpetualMarketLaunchV2;
  toProto(): MsgSubmitProposal$1;
  toData(): {
    content?: Any;
    initialDeposit: Coin$1[];
    proposer: string;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      content: {
        type: string;
        value: {
          title: string;
          description: string;
          ticker: string;
          quote_denom: string;
          oracle_base: string;
          oracle_quote: string;
          oracle_scale_factor: number;
          oracle_type: OracleType;
          initial_margin_ratio: string;
          maintenance_margin_ratio: string;
          maker_fee_rate: string;
          taker_fee_rate: string;
          min_price_tick_size: string;
          min_quantity_tick_size: string;
          min_notional: string;
          admin_info: AdminInfo | null;
          reduce_margin_ratio: string;
          open_notional_cap: {
            uncapped: {};
          };
        };
      };
      initial_deposit: {
        denom: string;
        amount: string;
      }[];
      proposer: string;
    };
  };
  toWeb3Gw(): {
    content: {
      title: string;
      description: string;
      ticker: string;
      quote_denom: string;
      oracle_base: string;
      oracle_quote: string;
      oracle_scale_factor: number;
      oracle_type: OracleType;
      initial_margin_ratio: string;
      maintenance_margin_ratio: string;
      maker_fee_rate: string;
      taker_fee_rate: string;
      min_price_tick_size: string;
      min_quantity_tick_size: string;
      min_notional: string;
      admin_info: AdminInfo | null;
      reduce_margin_ratio: string;
      open_notional_cap: {
        uncapped: {};
      };
      '@type': string;
    };
    initial_deposit: {
      denom: string;
      amount: string;
    }[];
    proposer: string;
    '@type': string;
  };
  toEip712(): {
    type: string;
    value: {
      content: {
        type: string;
        value: {
          initial_margin_ratio: any;
          maintenance_margin_ratio: any;
          maker_fee_rate: any;
          taker_fee_rate: any;
          min_price_tick_size: any;
          min_notional: any;
          min_quantity_tick_size: any;
          reduce_margin_ratio: any;
          open_notional_cap: {
            uncapped: {};
          };
          title: string;
          description: string;
          ticker: string;
          quote_denom: string;
          oracle_base: string;
          oracle_quote: string;
          oracle_scale_factor: number;
          oracle_type: OracleType;
          admin_info: AdminInfo | null;
        };
      };
      initial_deposit: {
        denom: string;
        amount: string;
      }[];
      proposer: string;
    };
  };
  toEip712V2(): {
    content: any;
    initial_deposit: {
      denom: string;
      amount: string;
    }[];
    proposer: string;
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgSubmitProposal$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/gov/msgs/MsgSubmitProposalExpiryFuturesMarketLaunch.d.ts
declare namespace MsgSubmitProposalExpiryFuturesMarketLaunch {
  interface Params {
    market: {
      title: string;
      description: string;
      ticker: string;
      quoteDenom: string;
      oracleBase: string;
      oracleQuote: string;
      expiry: number;
      oracleScaleFactor: number;
      oracleType: OracleType;
      initialMarginRatio: string;
      maintenanceMarginRatio: string;
      makerFeeRate: string;
      takerFeeRate: string;
      minPriceTickSize: string;
      minQuantityTickSize: string;
      minNotional: string;
      adminInfo?: {
        admin: string;
        adminPermissions: number;
      };
    };
    proposer: string;
    deposit: {
      amount: string;
      denom: string;
    };
  }
  type Proto = MsgSubmitProposal$1;
  type Object = Omit<MsgSubmitProposal$1, 'content'> & {
    content: {
      type_url: string;
      value: any;
    };
  };
}
/**
 * @category Messages
 */
declare class MsgSubmitProposalExpiryFuturesMarketLaunch extends MsgBase<MsgSubmitProposalExpiryFuturesMarketLaunch.Params, MsgSubmitProposalExpiryFuturesMarketLaunch.Proto> {
  static fromJSON(params: MsgSubmitProposalExpiryFuturesMarketLaunch.Params): MsgSubmitProposalExpiryFuturesMarketLaunch;
  toProto(): MsgSubmitProposal$1;
  toData(): {
    content?: Any;
    initialDeposit: Coin$1[];
    proposer: string;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      content: {
        type: string;
        value: {
          title: string;
          description: string;
          ticker: string;
          quote_denom: string;
          oracle_base: string;
          oracle_quote: string;
          oracle_scale_factor: number;
          oracle_type: OracleType;
          expiry: bigint;
          initial_margin_ratio: string;
          maintenance_margin_ratio: string;
          maker_fee_rate: string;
          taker_fee_rate: string;
          min_price_tick_size: string;
          min_quantity_tick_size: string;
          min_notional: string;
          admin_info: {
            admin: string;
            admin_permissions: number;
          } | null;
        };
      };
      initial_deposit: {
        denom: string;
        amount: string;
      }[];
      proposer: string;
    };
  };
  toWeb3Gw(): {
    content: {
      title: string;
      description: string;
      ticker: string;
      quote_denom: string;
      oracle_base: string;
      oracle_quote: string;
      oracle_scale_factor: number;
      oracle_type: OracleType;
      expiry: bigint;
      initial_margin_ratio: string;
      maintenance_margin_ratio: string;
      maker_fee_rate: string;
      taker_fee_rate: string;
      min_price_tick_size: string;
      min_quantity_tick_size: string;
      min_notional: string;
      admin_info: {
        admin: string;
        admin_permissions: number;
      } | null;
      '@type': string;
    };
    initial_deposit: {
      denom: string;
      amount: string;
    }[];
    proposer: string;
    '@type': string;
  };
  toEip712(): {
    type: string;
    value: {
      content: {
        type: string;
        value: {
          expiry: string;
          initial_margin_ratio: any;
          maintenance_margin_ratio: any;
          maker_fee_rate: any;
          taker_fee_rate: any;
          min_price_tick_size: any;
          min_notional: any;
          min_quantity_tick_size: any;
          title: string;
          description: string;
          ticker: string;
          quote_denom: string;
          oracle_base: string;
          oracle_quote: string;
          oracle_scale_factor: number;
          oracle_type: OracleType;
          admin_info: {
            admin: string;
            admin_permissions: number;
          } | null;
        };
      };
      initial_deposit: {
        denom: string;
        amount: string;
      }[];
      proposer: string;
    };
  };
  toEip712V2(): {
    content: any;
    initial_deposit: {
      denom: string;
      amount: string;
    }[];
    proposer: string;
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgSubmitProposal$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/cosmos/params/v1beta1/params_pb.d.ts
/**
 * ParameterChangeProposal defines a proposal to change one or more parameters.
 *
 * @generated from protobuf message cosmos.params.v1beta1.ParameterChangeProposal
 */
interface ParameterChangeProposal {
  /**
   * @generated from protobuf field: string title = 1
   */
  title: string;
  /**
   * @generated from protobuf field: string description = 2
   */
  description: string;
  /**
   * @generated from protobuf field: repeated cosmos.params.v1beta1.ParamChange changes = 3
   */
  changes: ParamChange[];
}
/**
 * ParamChange defines an individual parameter change, for use in
 * ParameterChangeProposal.
 *
 * @generated from protobuf message cosmos.params.v1beta1.ParamChange
 */
interface ParamChange {
  /**
   * @generated from protobuf field: string subspace = 1
   */
  subspace: string;
  /**
   * @generated from protobuf field: string key = 2
   */
  key: string;
  /**
   * @generated from protobuf field: string value = 3
   */
  value: string;
}
/**
 * @generated MessageType for protobuf message cosmos.params.v1beta1.ParameterChangeProposal
 */
declare const ParameterChangeProposal = new ParameterChangeProposal$Type();
/**
 * @generated MessageType for protobuf message cosmos.params.v1beta1.ParamChange
 */
declare const ParamChange = new ParamChange$Type();
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/cosmos/upgrade/v1beta1/upgrade_pb.d.ts
/**
 * Plan specifies information about a planned upgrade and when it should occur.
 *
 * @generated from protobuf message cosmos.upgrade.v1beta1.Plan
 */
interface Plan {
  /**
   * Sets the name for the upgrade. This name will be used by the upgraded
   * version of the software to apply any special "on-upgrade" commands during
   * the first BeginBlock method after the upgrade is applied. It is also used
   * to detect whether a software version can handle a given upgrade. If no
   * upgrade handler with this name has been set in the software, it will be
   * assumed that the software is out-of-date when the upgrade Time or Height is
   * reached and the software will exit.
   *
   * @generated from protobuf field: string name = 1
   */
  name: string;
  /**
   * Deprecated: Time based upgrades have been deprecated. Time based upgrade logic
   * has been removed from the SDK.
   * If this field is not empty, an error will be thrown.
   *
   * @deprecated
   * @generated from protobuf field: google.protobuf.Timestamp time = 2 [deprecated = true]
   */
  time?: Timestamp;
  /**
   * The height at which the upgrade must be performed.
   *
   * @generated from protobuf field: int64 height = 3
   */
  height: bigint;
  /**
   * Any application specific upgrade info to be included on-chain
   * such as a git commit that validators could automatically upgrade to
   *
   * @generated from protobuf field: string info = 4
   */
  info: string;
  /**
   * Deprecated: UpgradedClientState field has been deprecated. IBC upgrade logic has been
   * moved to the IBC module in the sub module 02-client.
   * If this field is not empty, an error will be thrown.
   *
   * @deprecated
   * @generated from protobuf field: google.protobuf.Any upgraded_client_state = 5 [deprecated = true]
   */
  upgradedClientState?: Any;
}
/**
 * SoftwareUpgradeProposal is a gov Content type for initiating a software
 * upgrade.
 * Deprecated: This legacy proposal is deprecated in favor of Msg-based gov
 * proposals, see MsgSoftwareUpgrade.
 *
 * @deprecated
 * @generated from protobuf message cosmos.upgrade.v1beta1.SoftwareUpgradeProposal
 */
interface SoftwareUpgradeProposal {
  /**
   * title of the proposal
   *
   * @generated from protobuf field: string title = 1
   */
  title: string;
  /**
   * description of the proposal
   *
   * @generated from protobuf field: string description = 2
   */
  description: string;
  /**
   * plan of the proposal
   *
   * @generated from protobuf field: cosmos.upgrade.v1beta1.Plan plan = 3
   */
  plan?: Plan;
}
/**
 * @generated MessageType for protobuf message cosmos.upgrade.v1beta1.Plan
 */
declare const Plan = new Plan$Type();
/**
 * @deprecated
 * @generated MessageType for protobuf message cosmos.upgrade.v1beta1.SoftwareUpgradeProposal
 */
declare const SoftwareUpgradeProposal = new SoftwareUpgradeProposal$Type();
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/injective/oracle/v1beta1/proposal_pb.d.ts
/**
 * @generated from protobuf message injective.oracle.v1beta1.GrantBandOraclePrivilegeProposal
 */
interface GrantBandOraclePrivilegeProposal {
  /**
   * @generated from protobuf field: string title = 1
   */
  title: string;
  /**
   * @generated from protobuf field: string description = 2
   */
  description: string;
  /**
   * @generated from protobuf field: repeated string relayers = 3
   */
  relayers: string[];
}
/**
 * @generated from protobuf message injective.oracle.v1beta1.RevokeBandOraclePrivilegeProposal
 */
interface RevokeBandOraclePrivilegeProposal {
  /**
   * @generated from protobuf field: string title = 1
   */
  title: string;
  /**
   * @generated from protobuf field: string description = 2
   */
  description: string;
  /**
   * @generated from protobuf field: repeated string relayers = 3
   */
  relayers: string[];
}
/**
 * @generated from protobuf message injective.oracle.v1beta1.GrantPriceFeederPrivilegeProposal
 */
interface GrantPriceFeederPrivilegeProposal {
  /**
   * @generated from protobuf field: string title = 1
   */
  title: string;
  /**
   * @generated from protobuf field: string description = 2
   */
  description: string;
  /**
   * @generated from protobuf field: string base = 3
   */
  base: string;
  /**
   * @generated from protobuf field: string quote = 4
   */
  quote: string;
  /**
   * @generated from protobuf field: repeated string relayers = 5
   */
  relayers: string[];
}
/**
 * @generated from protobuf message injective.oracle.v1beta1.RevokePriceFeederPrivilegeProposal
 */
interface RevokePriceFeederPrivilegeProposal {
  /**
   * @generated from protobuf field: string title = 1
   */
  title: string;
  /**
   * @generated from protobuf field: string description = 2
   */
  description: string;
  /**
   * @generated from protobuf field: string base = 3
   */
  base: string;
  /**
   * @generated from protobuf field: string quote = 4
   */
  quote: string;
  /**
   * @generated from protobuf field: repeated string relayers = 5
   */
  relayers: string[];
}
/**
 * @generated from protobuf message injective.oracle.v1beta1.AuthorizeBandOracleRequestProposal
 */
interface AuthorizeBandOracleRequestProposal {
  /**
   * @generated from protobuf field: string title = 1
   */
  title: string;
  /**
   * @generated from protobuf field: string description = 2
   */
  description: string;
  /**
   * @generated from protobuf field: injective.oracle.v1beta1.BandOracleRequest request = 3
   */
  request?: BandOracleRequest;
}
/**
 * @generated from protobuf message injective.oracle.v1beta1.EnableBandIBCProposal
 */
interface EnableBandIBCProposal {
  /**
   * @generated from protobuf field: string title = 1
   */
  title: string;
  /**
   * @generated from protobuf field: string description = 2
   */
  description: string;
  /**
   * @generated from protobuf field: injective.oracle.v1beta1.BandIBCParams band_ibc_params = 3
   */
  bandIbcParams?: BandIBCParams;
}
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.GrantBandOraclePrivilegeProposal
 */
declare const GrantBandOraclePrivilegeProposal = new GrantBandOraclePrivilegeProposal$Type();
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.RevokeBandOraclePrivilegeProposal
 */
declare const RevokeBandOraclePrivilegeProposal = new RevokeBandOraclePrivilegeProposal$Type();
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.GrantPriceFeederPrivilegeProposal
 */
declare const GrantPriceFeederPrivilegeProposal = new GrantPriceFeederPrivilegeProposal$Type();
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.RevokePriceFeederPrivilegeProposal
 */
declare const RevokePriceFeederPrivilegeProposal = new RevokePriceFeederPrivilegeProposal$Type();
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.AuthorizeBandOracleRequestProposal
 */
declare const AuthorizeBandOracleRequestProposal = new AuthorizeBandOracleRequestProposal$Type();
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.EnableBandIBCProposal
 */
declare const EnableBandIBCProposal = new EnableBandIBCProposal$Type();
//#endregion
//#region src/core/modules/gov/ProposalContentDecomposer.d.ts
declare class ProposalDecomposer {
  static getMsgExecLegacyContent(content: Uint8Array): MsgExecLegacyContent;
  static grantBandOraclePrivilegeProposal(content: Uint8Array): GrantBandOraclePrivilegeProposal;
  static removeBandOraclePrivilegeProposal(content: Uint8Array): RevokeBandOraclePrivilegeProposal;
  static grantPriceFeederPrivilegeProposal(content: Uint8Array): GrantPriceFeederPrivilegeProposal;
  static removePriceFeederPrivilegeProposal(content: Uint8Array): RevokePriceFeederPrivilegeProposal;
  static textProposal(content: Uint8Array): TextProposal;
  static SoftwareUpgrade(content: Uint8Array): SoftwareUpgradeProposal;
  static spotMarketLaunch(content: Uint8Array): SpotMarketLaunchProposal;
  static exchangeEnableProposal(content: Uint8Array): ExchangeEnableProposal;
  static spotMarketUpdate(content: Uint8Array): SpotMarketParamUpdateProposal;
  static perpetualMarketLaunchV1Beta1(content: Uint8Array): PerpetualMarketLaunchProposal$1;
  static perpetualMarketLaunchV2(content: Uint8Array): PerpetualMarketLaunchProposal;
  static expiryFuturesMarketLaunch(content: Uint8Array): ExpiryFuturesMarketLaunchProposal;
  static derivativeMarketUpdate(content: Uint8Array): DerivativeMarketParamUpdateProposal;
  static FeeDiscount(content: Uint8Array): FeeDiscountProposal;
  static TradingRewardCampaignLaunch(content: Uint8Array): TradingRewardCampaignLaunchProposal;
  static TradingRewardCampaignUpdate(content: Uint8Array): TradingRewardCampaignUpdateProposal;
  static parametersChange(content: Uint8Array): ParameterChangeProposal;
  static EnableBandIBC(content: Uint8Array): EnableBandIBCProposal;
  static AuthorizeBandOracleRequest(content: Uint8Array): AuthorizeBandOracleRequestProposal;
}
//#endregion
//#region src/core/modules/gov/index.d.ts
type MsgSubmitProposal = MsgSubmitTextProposal | MsgSubmitGenericProposal | MsgSubmitProposalSpotMarketLaunch | MsgSubmitProposalPerpetualMarketLaunch | MsgSubmitProposalSpotMarketParamUpdate | MsgSubmitProposalPerpetualMarketLaunchV2 | MsgSubmitProposalExpiryFuturesMarketLaunch;
//#endregion
//#region src/core/modules/authz/msgs/MsgExec.d.ts
declare namespace MsgExec {
  interface Params {
    grantee: string;
    msgs: Msgs | Msgs[];
  }
  type Proto = MsgExec$1;
  type Object = Omit<MsgExec$1, 'msgs'> & {
    msgs: any;
  };
}
/**
 * @category Messages
 */
declare class MsgExec extends MsgBase<MsgExec.Params, MsgExec.Proto, MsgExec.Object> {
  static fromJSON(params: MsgExec.Params): MsgExec;
  toProto(): MsgExec$1;
  toData(): {
    grantee: string;
    msgs: Any[];
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: MsgExec.Object;
  };
  toEip712V2(): {
    '@type': string;
    grantee: string;
    msgs: any[];
  };
  toWeb3Gw(): {
    '@type': string;
    grantee: string;
    msgs: any[];
  };
  toDirectSign(): {
    type: "/cosmos.authz.v1beta1.MsgExec";
    message: MsgExec$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/ibc/core/client/v1/client_pb.d.ts
/**
 * Height is a monotonically increasing data type
 * that can be compared against another Height for the purposes of updating and
 * freezing clients
 *
 * Normally the RevisionHeight is incremented at each height while keeping
 * RevisionNumber the same. However some consensus algorithms may choose to
 * reset the height in certain conditions e.g. hard forks, state-machine
 * breaking changes In these cases, the RevisionNumber is incremented so that
 * height continues to be monitonically increasing even as the RevisionHeight
 * gets reset
 *
 * @generated from protobuf message ibc.core.client.v1.Height
 */
interface Height {
  /**
   * the revision that the client is currently on
   *
   * @generated from protobuf field: uint64 revision_number = 1
   */
  revisionNumber: bigint;
  /**
   * the height within the given revision
   *
   * @generated from protobuf field: uint64 revision_height = 2
   */
  revisionHeight: bigint;
}
/**
 * @generated MessageType for protobuf message ibc.core.client.v1.Height
 */
declare const Height = new Height$Type();
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/ibc/applications/transfer/v1/transfer_pb.d.ts
/**
 * DenomTrace contains the base denomination for ICS20 fungible tokens and the
 * source tracing information path.
 *
 * @generated from protobuf message ibc.applications.transfer.v1.DenomTrace
 */
interface DenomTrace {
  /**
   * path defines the chain of port/channel identifiers used for tracing the
   * source of the fungible token.
   *
   * @generated from protobuf field: string path = 1
   */
  path: string;
  /**
   * base denomination of the relayed fungible token.
   *
   * @generated from protobuf field: string base_denom = 2
   */
  baseDenom: string;
}
/**
 * @generated MessageType for protobuf message ibc.applications.transfer.v1.DenomTrace
 */
declare const DenomTrace = new DenomTrace$Type();
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/ibc/applications/transfer/v1/tx_pb.d.ts
/**
 * MsgTransfer defines a msg to transfer fungible tokens (i.e Coins) between
 * ICS20 enabled chains. See ICS Spec here:
 * https://github.com/cosmos/ibc/tree/master/spec/app/ics-020-fungible-token-transfer#data-structures
 *
 * @generated from protobuf message ibc.applications.transfer.v1.MsgTransfer
 */
interface MsgTransfer$1 {
  /**
   * the port on which the packet will be sent
   *
   * @generated from protobuf field: string source_port = 1
   */
  sourcePort: string;
  /**
   * the channel by which the packet will be sent
   *
   * @generated from protobuf field: string source_channel = 2
   */
  sourceChannel: string;
  /**
   * the tokens to be transferred
   *
   * @generated from protobuf field: cosmos.base.v1beta1.Coin token = 3
   */
  token?: Coin$1;
  /**
   * the sender address
   *
   * @generated from protobuf field: string sender = 4
   */
  sender: string;
  /**
   * the recipient address on the destination chain
   *
   * @generated from protobuf field: string receiver = 5
   */
  receiver: string;
  /**
   * Timeout height relative to the current block height.
   * The timeout is disabled when set to 0.
   *
   * @generated from protobuf field: ibc.core.client.v1.Height timeout_height = 6
   */
  timeoutHeight?: Height;
  /**
   * Timeout timestamp in absolute nanoseconds since unix epoch.
   * The timeout is disabled when set to 0.
   *
   * @generated from protobuf field: uint64 timeout_timestamp = 7
   */
  timeoutTimestamp: bigint;
  /**
   * optional memo
   *
   * @generated from protobuf field: string memo = 8
   */
  memo: string;
}
/**
 * @generated MessageType for protobuf message ibc.applications.transfer.v1.MsgTransfer
 */
declare const MsgTransfer$1 = new MsgTransfer$Type();
//#endregion
//#region src/core/modules/ibc/msgs/MsgTransfer.d.ts
declare namespace MsgTransfer {
  interface Params {
    amount: {
      denom: string;
      amount: string;
    };
    memo?: string;
    sender: string;
    port: string;
    receiver: string;
    channelId: string;
    timeout?: number;
    height?: {
      revisionHeight: number;
      revisionNumber: number;
    };
  }
  type Proto = MsgTransfer$1;
}
/**
 * @category Messages
 */
declare class MsgTransfer extends MsgBase<MsgTransfer.Params, MsgTransfer.Proto> {
  static fromJSON(params: MsgTransfer.Params): MsgTransfer;
  toProto(): MsgTransfer$1;
  toData(): {
    sourcePort: string;
    sourceChannel: string;
    token?: Coin$1;
    sender: string;
    receiver: string;
    timeoutHeight?: Height;
    timeoutTimestamp: bigint;
    memo: string;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      source_port: string;
      source_channel: string;
      token: Coin$1 | undefined;
      sender: string;
      receiver: string;
      timeout_height: {
        revision_number: string;
        revision_height: string;
      } | undefined;
      timeout_timestamp: string | undefined;
      memo: string;
    };
  };
  toWeb3Gw(): {
    source_port: string;
    source_channel: string;
    token: Coin$1 | undefined;
    sender: string;
    receiver: string;
    timeout_height: {
      revision_number: string;
      revision_height: string;
    } | undefined;
    timeout_timestamp: string | undefined;
    memo: string;
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgTransfer$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/injective/tokenfactory/v1beta1/params_pb.d.ts
/**
 * Params defines the parameters for the tokenfactory module.
 *
 * @generated from protobuf message injective.tokenfactory.v1beta1.Params
 */
interface Params$1 {
  /**
   * The denom creation fee
   *
   * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin denom_creation_fee = 1
   */
  denomCreationFee: Coin$1[];
}
/**
 * @generated MessageType for protobuf message injective.tokenfactory.v1beta1.Params
 */
declare const Params$1 = new Params$Type();
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/injective/tokenfactory/v1beta1/tx_pb.d.ts
/**
 * MsgCreateDenom defines the message structure for the CreateDenom gRPC service
 * method. It allows an account to create a new denom. It requires a sender
 * address and a sub denomination. The (sender_address, sub_denomination) tuple
 * must be unique and cannot be re-used.
 *
 * The resulting denom created is defined as
 * <factory/{creatorAddress}/{subdenom}>. The resulting denom's admin is
 * originally set to be the creator, but this can be changed later. The token
 * denom does not indicate the current admin.
 *
 * @generated from protobuf message injective.tokenfactory.v1beta1.MsgCreateDenom
 */
interface MsgCreateDenom$1 {
  /**
   * The sender's Injective address
   *
   * @generated from protobuf field: string sender = 1
   */
  sender: string;
  /**
   * subdenom can be up to 44 "alphanumeric" characters long.
   *
   * @generated from protobuf field: string subdenom = 2
   */
  subdenom: string;
  /**
   * The name
   *
   * @generated from protobuf field: string name = 3
   */
  name: string;
  /**
   * The symbol
   *
   * @generated from protobuf field: string symbol = 4
   */
  symbol: string;
  /**
   * The number of decimals
   *
   * @generated from protobuf field: uint32 decimals = 5
   */
  decimals: number;
  /**
   * true if admins are allowed to burn tokens from other addresses
   *
   * @generated from protobuf field: bool allow_admin_burn = 6
   */
  allowAdminBurn: boolean;
}
/**
 * MsgMint is the sdk.Msg type for allowing an admin account or other permitted
 * accounts to mint more of a token.
 *
 * @generated from protobuf message injective.tokenfactory.v1beta1.MsgMint
 */
interface MsgMint$1 {
  /**
   * The sender's Injective address
   *
   * @generated from protobuf field: string sender = 1
   */
  sender: string;
  /**
   * The amount of tokens to mint
   *
   * @generated from protobuf field: cosmos.base.v1beta1.Coin amount = 2
   */
  amount?: Coin$1;
  /**
   * The Injective address to receive the tokens
   *
   * @generated from protobuf field: string receiver = 3
   */
  receiver: string;
}
/**
 * MsgBurn is the sdk.Msg type for allowing an admin account to burn
 * a token.
 *
 * @generated from protobuf message injective.tokenfactory.v1beta1.MsgBurn
 */
interface MsgBurn$1 {
  /**
   * The sender's Injective address
   *
   * @generated from protobuf field: string sender = 1
   */
  sender: string;
  /**
   * The amount of tokens to burn
   *
   * @generated from protobuf field: cosmos.base.v1beta1.Coin amount = 2
   */
  amount?: Coin$1;
  /**
   * The Injective address to burn the tokens from
   *
   * @generated from protobuf field: string burnFromAddress = 3
   */
  burnFromAddress: string;
}
/**
 * MsgChangeAdmin is the sdk.Msg type for allowing an admin account to reassign
 * adminship of a denom to a new account
 *
 * @generated from protobuf message injective.tokenfactory.v1beta1.MsgChangeAdmin
 */
interface MsgChangeAdmin$1 {
  /**
   * The sender's Injective address
   *
   * @generated from protobuf field: string sender = 1
   */
  sender: string;
  /**
   * The denom
   *
   * @generated from protobuf field: string denom = 2
   */
  denom: string;
  /**
   * The new admin's Injective address
   *
   * @generated from protobuf field: string new_admin = 3
   */
  newAdmin: string;
}
/**
 * MsgSetDenomMetadata is the sdk.Msg type for allowing an admin account to set
 * the denom's bank metadata
 *
 * @generated from protobuf message injective.tokenfactory.v1beta1.MsgSetDenomMetadata
 */
interface MsgSetDenomMetadata$1 {
  /**
   * The sender's Injective address
   *
   * @generated from protobuf field: string sender = 1
   */
  sender: string;
  /**
   * The metadata
   *
   * @generated from protobuf field: cosmos.bank.v1beta1.Metadata metadata = 2
   */
  metadata?: Metadata$1;
  /**
   * @generated from protobuf field: injective.tokenfactory.v1beta1.MsgSetDenomMetadata.AdminBurnDisabled admin_burn_disabled = 3
   */
  adminBurnDisabled?: MsgSetDenomMetadata_AdminBurnDisabled;
}
/**
 * @generated from protobuf message injective.tokenfactory.v1beta1.MsgSetDenomMetadata.AdminBurnDisabled
 */
interface MsgSetDenomMetadata_AdminBurnDisabled {
  /**
   * true if the admin burn capability should be disabled
   *
   * @generated from protobuf field: bool should_disable = 1
   */
  shouldDisable: boolean;
}
/**
 * @generated MessageType for protobuf message injective.tokenfactory.v1beta1.MsgCreateDenom
 */
declare const MsgCreateDenom$1 = new MsgCreateDenom$Type();
/**
 * @generated MessageType for protobuf message injective.tokenfactory.v1beta1.MsgMint
 */
declare const MsgMint$1 = new MsgMint$Type();
/**
 * @generated MessageType for protobuf message injective.tokenfactory.v1beta1.MsgBurn
 */
declare const MsgBurn$1 = new MsgBurn$Type();
/**
 * @generated MessageType for protobuf message injective.tokenfactory.v1beta1.MsgChangeAdmin
 */
declare const MsgChangeAdmin$1 = new MsgChangeAdmin$Type();
/**
 * @generated MessageType for protobuf message injective.tokenfactory.v1beta1.MsgSetDenomMetadata
 */
declare const MsgSetDenomMetadata$1 = new MsgSetDenomMetadata$Type();
/**
 * @generated MessageType for protobuf message injective.tokenfactory.v1beta1.MsgSetDenomMetadata.AdminBurnDisabled
 */
declare const MsgSetDenomMetadata_AdminBurnDisabled = new MsgSetDenomMetadata_AdminBurnDisabled$Type();
//#endregion
//#region src/core/modules/tokenfactory/msgs/MsgBurn.d.ts
declare namespace MsgBurn {
  interface Params {
    sender: string;
    burnFromAddress?: string;
    amount: {
      amount: string;
      denom: string;
    };
  }
  type Proto = MsgBurn$1;
}
/**
 * @category Messages
 */
declare class MsgBurn extends MsgBase<MsgBurn.Params, MsgBurn.Proto> {
  static fromJSON(params: MsgBurn.Params): MsgBurn;
  toProto(): MsgBurn$1;
  toData(): {
    sender: string;
    amount?: Coin$1;
    burnFromAddress: string;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      burnFromAddress?: string | undefined;
      sender: string;
      amount: Coin$1 | undefined;
    };
  };
  toWeb3Gw(): {
    burnFromAddress?: string | undefined;
    sender: string;
    amount: Coin$1 | undefined;
    '@type': string;
  };
  toEip712Types(): Map<string, TypedDataField[]>;
  toDirectSign(): {
    type: string;
    message: MsgBurn$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/tokenfactory/msgs/MsgMint.d.ts
declare namespace MsgMint {
  interface Params {
    sender: string;
    receiver?: string;
    amount: {
      amount: string;
      denom: string;
    };
  }
  type Proto = MsgMint$1;
}
/**
 * @category Messages
 */
declare class MsgMint extends MsgBase<MsgMint.Params, MsgMint.Proto> {
  static fromJSON(params: MsgMint.Params): MsgMint;
  toProto(): MsgMint$1;
  toData(): {
    sender: string;
    amount?: Coin$1;
    receiver: string;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      receiver?: string | undefined;
      sender: string;
      amount: Coin$1 | undefined;
    };
  };
  toWeb3Gw(): {
    receiver?: string | undefined;
    sender: string;
    amount: Coin$1 | undefined;
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgMint$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/bank/msgs/MsgMultiSend.d.ts
declare namespace MsgMultiSend {
  interface Params {
    inputs: {
      address: string;
      coins: Coin$1[];
    }[];
    outputs: {
      address: string;
      coins: Coin$1[];
    }[];
  }
  type Proto = MsgMultiSend$1;
}
/**
 * @category Messages
 */
declare class MsgMultiSend extends MsgBase<MsgMultiSend.Params, MsgMultiSend.Proto> {
  static fromJSON(params: MsgMultiSend.Params): MsgMultiSend;
  toProto(): MsgMultiSend$1;
  toData(): {
    inputs: Input[];
    outputs: Output[];
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      inputs: Input[];
      outputs: Output[];
    };
  };
  toWeb3Gw(): {
    inputs: Input[];
    outputs: Output[];
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgMultiSend$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/injective/exchange/v1beta1/tx_pb.d.ts
/**
 * MsgDeposit defines a SDK message for transferring coins from the sender's
 * bank balance into the subaccount's exchange deposits
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgDeposit
 */
interface MsgDeposit$2 {
  /**
   * the sender's Injective address
   *
   * @generated from protobuf field: string sender = 1
   */
  sender: string;
  /**
   * (Optional) bytes32 subaccount ID to deposit funds into. If empty, the coin
   * will be deposited to the sender's default subaccount address
   *
   * @generated from protobuf field: string subaccount_id = 2
   */
  subaccountId: string;
  /**
   * the amount of the deposit (in chain format)
   *
   * @generated from protobuf field: cosmos.base.v1beta1.Coin amount = 3
   */
  amount?: Coin$1;
}
/**
 * MsgWithdraw defines a SDK message for withdrawing coins from a subaccount's
 * deposits to the user's bank balance
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgWithdraw
 */
interface MsgWithdraw$1 {
  /**
   * the sender's Injective address
   *
   * @generated from protobuf field: string sender = 1
   */
  sender: string;
  /**
   * the subaccount ID to withdraw funds from
   *
   * @generated from protobuf field: string subaccount_id = 2
   */
  subaccountId: string;
  /**
   * the amount of the withdrawal (in chain format)
   *
   * @generated from protobuf field: cosmos.base.v1beta1.Coin amount = 3
   */
  amount?: Coin$1;
}
/**
 * MsgCreateSpotLimitOrder defines a SDK message for creating a new spot limit
 * order.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgCreateSpotLimitOrder
 */
interface MsgCreateSpotLimitOrder$1 {
  /**
   * the sender's Injective address
   *
   * @generated from protobuf field: string sender = 1
   */
  sender: string;
  /**
   * the spot order to create
   *
   * @generated from protobuf field: injective.exchange.v1beta1.SpotOrder order = 2
   */
  order?: SpotOrder$1;
}
/**
 * MsgInstantSpotMarketLaunch defines a SDK message for creating a new spot
 * market by paying listing fee without governance
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgInstantSpotMarketLaunch
 */
interface MsgInstantSpotMarketLaunch$1 {
  /**
   * the sender's Injective address
   *
   * @generated from protobuf field: string sender = 1
   */
  sender: string;
  /**
   * the ticker for the spot market
   *
   * @generated from protobuf field: string ticker = 2
   */
  ticker: string;
  /**
   * the type of coin to use as the base currency
   *
   * @generated from protobuf field: string base_denom = 3
   */
  baseDenom: string;
  /**
   * type of coin to use as the quote currency
   *
   * @generated from protobuf field: string quote_denom = 4
   */
  quoteDenom: string;
  /**
   * min_price_tick_size defines the minimum tick size of the order's price
   *
   * @generated from protobuf field: string min_price_tick_size = 5
   */
  minPriceTickSize: string;
  /**
   * min_quantity_tick_size defines the minimum tick size of the order's
   * quantity
   *
   * @generated from protobuf field: string min_quantity_tick_size = 6
   */
  minQuantityTickSize: string;
  /**
   * min_notional defines the minimum notional (in quote asset) required for
   * orders in the market
   *
   * @generated from protobuf field: string min_notional = 7
   */
  minNotional: string;
  /**
   * base token decimals
   *
   * @generated from protobuf field: uint32 base_decimals = 8
   */
  baseDecimals: number;
  /**
   * quote token decimals
   *
   * @generated from protobuf field: uint32 quote_decimals = 9
   */
  quoteDecimals: number;
}
/**
 * MsgInstantBinaryOptionsMarketLaunch defines a SDK message for creating a new
 * perpetual futures market by paying listing fee without governance
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch
 */
interface MsgInstantBinaryOptionsMarketLaunch$1 {
  /**
   * the sender's Injective address
   *
   * @generated from protobuf field: string sender = 1
   */
  sender: string;
  /**
   * the ticker for the derivative contract
   *
   * @generated from protobuf field: string ticker = 2
   */
  ticker: string;
  /**
   * the oracle symbol
   *
   * @generated from protobuf field: string oracle_symbol = 3
   */
  oracleSymbol: string;
  /**
   * the oracle provider
   *
   * @generated from protobuf field: string oracle_provider = 4
   */
  oracleProvider: string;
  /**
   * Oracle type
   *
   * @generated from protobuf field: injective.oracle.v1beta1.OracleType oracle_type = 5
   */
  oracleType: OracleType;
  /**
   * Scale factor for oracle prices.
   *
   * @generated from protobuf field: uint32 oracle_scale_factor = 6
   */
  oracleScaleFactor: number;
  /**
   * maker_fee_rate defines the trade fee rate for makers on the perpetual
   * market
   *
   * @generated from protobuf field: string maker_fee_rate = 7
   */
  makerFeeRate: string;
  /**
   * taker_fee_rate defines the trade fee rate for takers on the perpetual
   * market
   *
   * @generated from protobuf field: string taker_fee_rate = 8
   */
  takerFeeRate: string;
  /**
   * expiration timestamp
   *
   * @generated from protobuf field: int64 expiration_timestamp = 9
   */
  expirationTimestamp: bigint;
  /**
   * expiration timestamp
   *
   * @generated from protobuf field: int64 settlement_timestamp = 10
   */
  settlementTimestamp: bigint;
  /**
   * admin of the market
   *
   * @generated from protobuf field: string admin = 11
   */
  admin: string;
  /**
   * Address of the quote currency denomination for the binary options contract
   *
   * @generated from protobuf field: string quote_denom = 12
   */
  quoteDenom: string;
  /**
   * min_price_tick_size defines the minimum tick size that the price and margin
   * required for orders in the market
   *
   * @generated from protobuf field: string min_price_tick_size = 13
   */
  minPriceTickSize: string;
  /**
   * min_quantity_tick_size defines the minimum tick size of the quantity
   * required for orders in the market
   *
   * @generated from protobuf field: string min_quantity_tick_size = 14
   */
  minQuantityTickSize: string;
  /**
   * min_notional defines the minimum notional (in quote asset) required for
   * orders in the market
   *
   * @generated from protobuf field: string min_notional = 15
   */
  minNotional: string;
}
/**
 * MsgCreateSpotMarketOrder defines a SDK message for creating a new spot market
 * order.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgCreateSpotMarketOrder
 */
interface MsgCreateSpotMarketOrder$1 {
  /**
   * @generated from protobuf field: string sender = 1
   */
  sender: string;
  /**
   * @generated from protobuf field: injective.exchange.v1beta1.SpotOrder order = 2
   */
  order?: SpotOrder$1;
}
/**
 * A Cosmos-SDK MsgCreateDerivativeLimitOrder
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgCreateDerivativeLimitOrder
 */
interface MsgCreateDerivativeLimitOrder$1 {
  /**
   * @generated from protobuf field: string sender = 1
   */
  sender: string;
  /**
   * @generated from protobuf field: injective.exchange.v1beta1.DerivativeOrder order = 2
   */
  order?: DerivativeOrder$1;
}
/**
 * A Cosmos-SDK MsgCreateBinaryOptionsLimitOrder
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgCreateBinaryOptionsLimitOrder
 */
interface MsgCreateBinaryOptionsLimitOrder$1 {
  /**
   * @generated from protobuf field: string sender = 1
   */
  sender: string;
  /**
   * @generated from protobuf field: injective.exchange.v1beta1.DerivativeOrder order = 2
   */
  order?: DerivativeOrder$1;
}
/**
 * MsgCancelSpotOrder defines the Msg/CancelSpotOrder response type.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgCancelSpotOrder
 */
interface MsgCancelSpotOrder$1 {
  /**
   * @generated from protobuf field: string sender = 1
   */
  sender: string;
  /**
   * @generated from protobuf field: string market_id = 2
   */
  marketId: string;
  /**
   * @generated from protobuf field: string subaccount_id = 3
   */
  subaccountId: string;
  /**
   * @generated from protobuf field: string order_hash = 4
   */
  orderHash: string;
  /**
   * @generated from protobuf field: string cid = 5
   */
  cid: string;
}
/**
 * MsgBatchCancelSpotOrders defines the Msg/BatchCancelSpotOrders response type.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgBatchCancelSpotOrders
 */
interface MsgBatchCancelSpotOrders$1 {
  /**
   * @generated from protobuf field: string sender = 1
   */
  sender: string;
  /**
   * @generated from protobuf field: repeated injective.exchange.v1beta1.OrderData data = 2
   */
  data: OrderData[];
}
/**
 * MsgBatchCancelBinaryOptionsOrders defines the
 * Msg/BatchCancelBinaryOptionsOrders response type.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgBatchCancelBinaryOptionsOrders
 */
interface MsgBatchCancelBinaryOptionsOrders$1 {
  /**
   * @generated from protobuf field: string sender = 1
   */
  sender: string;
  /**
   * @generated from protobuf field: repeated injective.exchange.v1beta1.OrderData data = 2
   */
  data: OrderData[];
}
/**
 * MsgBatchUpdateOrders defines the Msg/BatchUpdateOrders response type.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgBatchUpdateOrders
 */
interface MsgBatchUpdateOrders$1 {
  /**
   * the sender's Injective address
   *
   * @generated from protobuf field: string sender = 1
   */
  sender: string;
  /**
   * the subaccount ID only used for the spot_market_ids_to_cancel_all and
   * derivative_market_ids_to_cancel_all
   *
   * @generated from protobuf field: string subaccount_id = 2
   */
  subaccountId: string;
  /**
   * the spot market IDs to cancel all
   *
   * @generated from protobuf field: repeated string spot_market_ids_to_cancel_all = 3
   */
  spotMarketIdsToCancelAll: string[];
  /**
   * the derivative market IDs to cancel all
   *
   * @generated from protobuf field: repeated string derivative_market_ids_to_cancel_all = 4
   */
  derivativeMarketIdsToCancelAll: string[];
  /**
   * the spot orders to cancel
   *
   * @generated from protobuf field: repeated injective.exchange.v1beta1.OrderData spot_orders_to_cancel = 5
   */
  spotOrdersToCancel: OrderData[];
  /**
   * the derivative orders to cancel
   *
   * @generated from protobuf field: repeated injective.exchange.v1beta1.OrderData derivative_orders_to_cancel = 6
   */
  derivativeOrdersToCancel: OrderData[];
  /**
   * the spot orders to create
   *
   * @generated from protobuf field: repeated injective.exchange.v1beta1.SpotOrder spot_orders_to_create = 7
   */
  spotOrdersToCreate: SpotOrder$1[];
  /**
   * the derivative orders to create
   *
   * @generated from protobuf field: repeated injective.exchange.v1beta1.DerivativeOrder derivative_orders_to_create = 8
   */
  derivativeOrdersToCreate: DerivativeOrder$1[];
  /**
   * the binary options orders to cancel
   *
   * @generated from protobuf field: repeated injective.exchange.v1beta1.OrderData binary_options_orders_to_cancel = 9
   */
  binaryOptionsOrdersToCancel: OrderData[];
  /**
   * the binary options market IDs to cancel all
   *
   * @generated from protobuf field: repeated string binary_options_market_ids_to_cancel_all = 10
   */
  binaryOptionsMarketIdsToCancelAll: string[];
  /**
   * the binary options orders to create
   *
   * @generated from protobuf field: repeated injective.exchange.v1beta1.DerivativeOrder binary_options_orders_to_create = 11
   */
  binaryOptionsOrdersToCreate: DerivativeOrder$1[];
}
/**
 * A Cosmos-SDK MsgCreateDerivativeMarketOrder
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgCreateDerivativeMarketOrder
 */
interface MsgCreateDerivativeMarketOrder$1 {
  /**
   * @generated from protobuf field: string sender = 1
   */
  sender: string;
  /**
   * @generated from protobuf field: injective.exchange.v1beta1.DerivativeOrder order = 2
   */
  order?: DerivativeOrder$1;
}
/**
 * A Cosmos-SDK MsgCreateBinaryOptionsMarketOrder
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgCreateBinaryOptionsMarketOrder
 */
interface MsgCreateBinaryOptionsMarketOrder$1 {
  /**
   * @generated from protobuf field: string sender = 1
   */
  sender: string;
  /**
   * @generated from protobuf field: injective.exchange.v1beta1.DerivativeOrder order = 2
   */
  order?: DerivativeOrder$1;
}
/**
 * MsgCancelDerivativeOrder defines the Msg/CancelDerivativeOrder response type.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgCancelDerivativeOrder
 */
interface MsgCancelDerivativeOrder$1 {
  /**
   * the sender's Injective address
   *
   * @generated from protobuf field: string sender = 1
   */
  sender: string;
  /**
   * the market ID
   *
   * @generated from protobuf field: string market_id = 2
   */
  marketId: string;
  /**
   * the subaccount ID
   *
   * @generated from protobuf field: string subaccount_id = 3
   */
  subaccountId: string;
  /**
   * the order hash
   *
   * @generated from protobuf field: string order_hash = 4
   */
  orderHash: string;
  /**
   * the order mask
   *
   * @generated from protobuf field: int32 order_mask = 5
   */
  orderMask: number; // bitwise combination of OrderMask enum values
  /**
   * the client order ID
   *
   * @generated from protobuf field: string cid = 6
   */
  cid: string;
}
/**
 * MsgCancelBinaryOptionsOrder defines the Msg/CancelBinaryOptionsOrder response
 * type.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgCancelBinaryOptionsOrder
 */
interface MsgCancelBinaryOptionsOrder$1 {
  /**
   * the sender's Injective address
   *
   * @generated from protobuf field: string sender = 1
   */
  sender: string;
  /**
   * the market ID
   *
   * @generated from protobuf field: string market_id = 2
   */
  marketId: string;
  /**
   * the subaccount ID
   *
   * @generated from protobuf field: string subaccount_id = 3
   */
  subaccountId: string;
  /**
   * the order hash
   *
   * @generated from protobuf field: string order_hash = 4
   */
  orderHash: string;
  /**
   * the order mask (bitwise combination of OrderMask enum values)
   *
   * @generated from protobuf field: int32 order_mask = 5
   */
  orderMask: number;
  /**
   * the client order ID
   *
   * @generated from protobuf field: string cid = 6
   */
  cid: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.OrderData
 */
interface OrderData {
  /**
   * the market ID
   *
   * @generated from protobuf field: string market_id = 1
   */
  marketId: string;
  /**
   * the subaccount ID
   *
   * @generated from protobuf field: string subaccount_id = 2
   */
  subaccountId: string;
  /**
   * the order hash
   *
   * @generated from protobuf field: string order_hash = 3
   */
  orderHash: string;
  /**
   * the order mask (bitwise combination of OrderMask enum values)
   *
   * @generated from protobuf field: int32 order_mask = 4
   */
  orderMask: number;
  /**
   * the client order ID
   *
   * @generated from protobuf field: string cid = 5
   */
  cid: string;
}
/**
 * MsgBatchCancelDerivativeOrders defines the Msg/CancelDerivativeOrders
 * response type.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgBatchCancelDerivativeOrders
 */
interface MsgBatchCancelDerivativeOrders$1 {
  /**
   * the sender's Injective address
   *
   * @generated from protobuf field: string sender = 1
   */
  sender: string;
  /**
   * orders details
   *
   * @generated from protobuf field: repeated injective.exchange.v1beta1.OrderData data = 2
   */
  data: OrderData[];
}
/**
 * A Cosmos-SDK MsgExternalTransfer
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgExternalTransfer
 */
interface MsgExternalTransfer$1 {
  /**
   * @generated from protobuf field: string sender = 1
   */
  sender: string;
  /**
   * @generated from protobuf field: string source_subaccount_id = 2
   */
  sourceSubaccountId: string;
  /**
   * @generated from protobuf field: string destination_subaccount_id = 3
   */
  destinationSubaccountId: string;
  /**
   * @generated from protobuf field: cosmos.base.v1beta1.Coin amount = 4
   */
  amount?: Coin$1;
}
/**
 * A Cosmos-SDK MsgLiquidatePosition
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgLiquidatePosition
 */
interface MsgLiquidatePosition$1 {
  /**
   * the sender's Injective address
   *
   * @generated from protobuf field: string sender = 1
   */
  sender: string;
  /**
   * the subaccount ID
   *
   * @generated from protobuf field: string subaccount_id = 2
   */
  subaccountId: string;
  /**
   * the market ID
   *
   * @generated from protobuf field: string market_id = 3
   */
  marketId: string;
  /**
   * optional order to provide for liquidation
   *
   * @generated from protobuf field: injective.exchange.v1beta1.DerivativeOrder order = 4
   */
  order?: DerivativeOrder$1;
}
/**
 * A Cosmos-SDK MsgIncreasePositionMargin
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgIncreasePositionMargin
 */
interface MsgIncreasePositionMargin$1 {
  /**
   * the sender's Injective address
   *
   * @generated from protobuf field: string sender = 1
   */
  sender: string;
  /**
   * the subaccount ID sending the funds
   *
   * @generated from protobuf field: string source_subaccount_id = 2
   */
  sourceSubaccountId: string;
  /**
   * the subaccount ID the position belongs to
   *
   * @generated from protobuf field: string destination_subaccount_id = 3
   */
  destinationSubaccountId: string;
  /**
   * the market ID
   *
   * @generated from protobuf field: string market_id = 4
   */
  marketId: string;
  /**
   * amount defines the amount of margin to add to the position (in chain
   * format)
   *
   * @generated from protobuf field: string amount = 5
   */
  amount: string;
}
/**
 * MsgPrivilegedExecuteContract defines the Msg/Exec message type
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgPrivilegedExecuteContract
 */
interface MsgPrivilegedExecuteContract$1 {
  /**
   * @generated from protobuf field: string sender = 1
   */
  sender: string;
  /**
   * funds defines the user's bank coins used to fund the execution (e.g.
   * 100inj).
   *
   * @generated from protobuf field: string funds = 2
   */
  funds: string;
  /**
   * contract_address defines the contract address to execute
   *
   * @generated from protobuf field: string contract_address = 3
   */
  contractAddress: string;
  /**
   * data defines the call data used when executing the contract
   *
   * @generated from protobuf field: string data = 4
   */
  data: string;
}
/**
 * A Cosmos-SDK MsgRewardsOptOut
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgRewardsOptOut
 */
interface MsgRewardsOptOut$1 {
  /**
   * @generated from protobuf field: string sender = 1
   */
  sender: string;
}
/**
 * A Cosmos-SDK MsgReclaimLockedFunds
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgReclaimLockedFunds
 */
interface MsgReclaimLockedFunds$1 {
  /**
   * @generated from protobuf field: string sender = 1
   */
  sender: string;
  /**
   * @generated from protobuf field: bytes lockedAccountPubKey = 2
   */
  lockedAccountPubKey: Uint8Array;
  /**
   * @generated from protobuf field: bytes signature = 3
   */
  signature: Uint8Array;
}
/**
 * MsgSignData defines an arbitrary, general-purpose, off-chain message
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgSignData
 */
interface MsgSignData$1 {
  /**
   * Signer is the sdk.AccAddress of the message signer
   *
   * @generated from protobuf field: bytes Signer = 1
   */
  signer: Uint8Array;
  /**
   * Data represents the raw bytes of the content that is signed (text, json,
   * etc)
   *
   * @generated from protobuf field: bytes Data = 2
   */
  data: Uint8Array;
}
/**
 * MsgAdminUpdateBinaryOptionsMarket is used by the market Admin to operate the
 * market
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgAdminUpdateBinaryOptionsMarket
 */
interface MsgAdminUpdateBinaryOptionsMarket$1 {
  /**
   * @generated from protobuf field: string sender = 1
   */
  sender: string;
  /**
   * @generated from protobuf field: string market_id = 2
   */
  marketId: string;
  /**
   * new price at which market will be settled
   *
   * @generated from protobuf field: string settlement_price = 3
   */
  settlementPrice: string;
  /**
   * expiration timestamp
   *
   * @generated from protobuf field: int64 expiration_timestamp = 4
   */
  expirationTimestamp: bigint;
  /**
   * expiration timestamp
   *
   * @generated from protobuf field: int64 settlement_timestamp = 5
   */
  settlementTimestamp: bigint;
  /**
   * Status of the market
   *
   * @generated from protobuf field: injective.exchange.v1beta1.MarketStatus status = 6
   */
  status: MarketStatus;
}
/**
 * MsgAuthorizeStakeGrants grants stakes to grantees.
 *
 * @generated from protobuf message injective.exchange.v1beta1.MsgAuthorizeStakeGrants
 */
interface MsgAuthorizeStakeGrants$1 {
  /**
   * @generated from protobuf field: string sender = 1
   */
  sender: string;
  /**
   * @generated from protobuf field: repeated injective.exchange.v1beta1.GrantAuthorization grants = 2
   */
  grants: GrantAuthorization$2[];
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgDeposit
 */
declare const MsgDeposit$2 = new MsgDeposit$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgWithdraw
 */
declare const MsgWithdraw$1 = new MsgWithdraw$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgCreateSpotLimitOrder
 */
declare const MsgCreateSpotLimitOrder$1 = new MsgCreateSpotLimitOrder$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgInstantSpotMarketLaunch
 */
declare const MsgInstantSpotMarketLaunch$1 = new MsgInstantSpotMarketLaunch$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch
 */
declare const MsgInstantBinaryOptionsMarketLaunch$1 = new MsgInstantBinaryOptionsMarketLaunch$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgCreateSpotMarketOrder
 */
declare const MsgCreateSpotMarketOrder$1 = new MsgCreateSpotMarketOrder$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgCreateDerivativeLimitOrder
 */
declare const MsgCreateDerivativeLimitOrder$1 = new MsgCreateDerivativeLimitOrder$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgCreateBinaryOptionsLimitOrder
 */
declare const MsgCreateBinaryOptionsLimitOrder$1 = new MsgCreateBinaryOptionsLimitOrder$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgCancelSpotOrder
 */
declare const MsgCancelSpotOrder$1 = new MsgCancelSpotOrder$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgBatchCancelSpotOrders
 */
declare const MsgBatchCancelSpotOrders$1 = new MsgBatchCancelSpotOrders$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgBatchCancelBinaryOptionsOrders
 */
declare const MsgBatchCancelBinaryOptionsOrders$1 = new MsgBatchCancelBinaryOptionsOrders$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgBatchUpdateOrders
 */
declare const MsgBatchUpdateOrders$1 = new MsgBatchUpdateOrders$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgCreateDerivativeMarketOrder
 */
declare const MsgCreateDerivativeMarketOrder$1 = new MsgCreateDerivativeMarketOrder$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgCreateBinaryOptionsMarketOrder
 */
declare const MsgCreateBinaryOptionsMarketOrder$1 = new MsgCreateBinaryOptionsMarketOrder$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgCancelDerivativeOrder
 */
declare const MsgCancelDerivativeOrder$1 = new MsgCancelDerivativeOrder$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgCancelBinaryOptionsOrder
 */
declare const MsgCancelBinaryOptionsOrder$1 = new MsgCancelBinaryOptionsOrder$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.OrderData
 */
declare const OrderData = new OrderData$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgBatchCancelDerivativeOrders
 */
declare const MsgBatchCancelDerivativeOrders$1 = new MsgBatchCancelDerivativeOrders$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgExternalTransfer
 */
declare const MsgExternalTransfer$1 = new MsgExternalTransfer$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgLiquidatePosition
 */
declare const MsgLiquidatePosition$1 = new MsgLiquidatePosition$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgIncreasePositionMargin
 */
declare const MsgIncreasePositionMargin$1 = new MsgIncreasePositionMargin$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgPrivilegedExecuteContract
 */
declare const MsgPrivilegedExecuteContract$1 = new MsgPrivilegedExecuteContract$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgRewardsOptOut
 */
declare const MsgRewardsOptOut$1 = new MsgRewardsOptOut$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgReclaimLockedFunds
 */
declare const MsgReclaimLockedFunds$1 = new MsgReclaimLockedFunds$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgSignData
 */
declare const MsgSignData$1 = new MsgSignData$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgAdminUpdateBinaryOptionsMarket
 */
declare const MsgAdminUpdateBinaryOptionsMarket$1 = new MsgAdminUpdateBinaryOptionsMarket$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MsgAuthorizeStakeGrants
 */
declare const MsgAuthorizeStakeGrants$1 = new MsgAuthorizeStakeGrants$Type();
//#endregion
//#region src/core/modules/exchange/msgs/MsgDeposit.d.ts
declare namespace MsgDeposit {
  interface Params {
    subaccountId: string;
    injectiveAddress: string;
    amount: {
      amount: string;
      denom: string;
    };
  }
  type Proto = MsgDeposit$2;
}
/**
 * @category Messages
 */
declare class MsgDeposit extends MsgBase<MsgDeposit.Params, MsgDeposit.Proto> {
  static fromJSON(params: MsgDeposit.Params): MsgDeposit;
  toProto(): MsgDeposit$2;
  toData(): {
    sender: string;
    subaccountId: string;
    amount?: Coin$1;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      sender: string;
      subaccount_id: string;
      amount: Coin$1 | undefined;
    };
  };
  toWeb3Gw(): {
    sender: string;
    subaccount_id: string;
    amount: Coin$1 | undefined;
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgDeposit$2;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/cosmwasm/wasm/v1/tx_pb.d.ts
/**
 * MsgStoreCode submit Wasm code to the system
 *
 * @generated from protobuf message cosmwasm.wasm.v1.MsgStoreCode
 */
interface MsgStoreCode$1 {
  /**
   * Sender is the actor that signed the messages
   *
   * @generated from protobuf field: string sender = 1
   */
  sender: string;
  /**
   * WASMByteCode can be raw or gzip compressed
   *
   * @generated from protobuf field: bytes wasm_byte_code = 2
   */
  wasmByteCode: Uint8Array;
  /**
   * InstantiatePermission access control to apply on contract creation,
   * optional
   *
   * @generated from protobuf field: cosmwasm.wasm.v1.AccessConfig instantiate_permission = 5
   */
  instantiatePermission?: AccessConfig;
}
/**
 * MsgInstantiateContract create a new smart contract instance for the given
 * code id.
 *
 * @generated from protobuf message cosmwasm.wasm.v1.MsgInstantiateContract
 */
interface MsgInstantiateContract$1 {
  /**
   * Sender is the that actor that signed the messages
   *
   * @generated from protobuf field: string sender = 1
   */
  sender: string;
  /**
   * Admin is an optional address that can execute migrations
   *
   * @generated from protobuf field: string admin = 2
   */
  admin: string;
  /**
   * CodeID is the reference to the stored WASM code
   *
   * @generated from protobuf field: uint64 code_id = 3
   */
  codeId: bigint;
  /**
   * Label is optional metadata to be stored with a contract instance.
   *
   * @generated from protobuf field: string label = 4
   */
  label: string;
  /**
   * Msg json encoded message to be passed to the contract on instantiation
   *
   * @generated from protobuf field: bytes msg = 5
   */
  msg: Uint8Array;
  /**
   * Funds coins that are transferred to the contract on instantiation
   *
   * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin funds = 6
   */
  funds: Coin$1[];
}
/**
 * MsgExecuteContract submits the given message data to a smart contract
 *
 * @generated from protobuf message cosmwasm.wasm.v1.MsgExecuteContract
 */
interface MsgExecuteContract$1 {
  /**
   * Sender is the that actor that signed the messages
   *
   * @generated from protobuf field: string sender = 1
   */
  sender: string;
  /**
   * Contract is the address of the smart contract
   *
   * @generated from protobuf field: string contract = 2
   */
  contract: string;
  /**
   * Msg json encoded message to be passed to the contract
   *
   * @generated from protobuf field: bytes msg = 3
   */
  msg: Uint8Array;
  /**
   * Funds coins that are transferred to the contract on execution
   *
   * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin funds = 5
   */
  funds: Coin$1[];
}
/**
 * MsgMigrateContract runs a code upgrade/ downgrade for a smart contract
 *
 * @generated from protobuf message cosmwasm.wasm.v1.MsgMigrateContract
 */
interface MsgMigrateContract$1 {
  /**
   * Sender is the that actor that signed the messages
   *
   * @generated from protobuf field: string sender = 1
   */
  sender: string;
  /**
   * Contract is the address of the smart contract
   *
   * @generated from protobuf field: string contract = 2
   */
  contract: string;
  /**
   * CodeID references the new WASM code
   *
   * @generated from protobuf field: uint64 code_id = 3
   */
  codeId: bigint;
  /**
   * Msg json encoded message to be passed to the contract on migration
   *
   * @generated from protobuf field: bytes msg = 4
   */
  msg: Uint8Array;
}
/**
 * MsgUpdateAdmin sets a new admin for a smart contract
 *
 * @generated from protobuf message cosmwasm.wasm.v1.MsgUpdateAdmin
 */
interface MsgUpdateAdmin$1 {
  /**
   * Sender is the that actor that signed the messages
   *
   * @generated from protobuf field: string sender = 1
   */
  sender: string;
  /**
   * NewAdmin address to be set
   *
   * @generated from protobuf field: string new_admin = 2
   */
  newAdmin: string;
  /**
   * Contract is the address of the smart contract
   *
   * @generated from protobuf field: string contract = 3
   */
  contract: string;
}
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.MsgStoreCode
 */
declare const MsgStoreCode$1 = new MsgStoreCode$Type();
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.MsgInstantiateContract
 */
declare const MsgInstantiateContract$1 = new MsgInstantiateContract$Type();
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.MsgExecuteContract
 */
declare const MsgExecuteContract$1 = new MsgExecuteContract$Type();
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.MsgMigrateContract
 */
declare const MsgMigrateContract$1 = new MsgMigrateContract$Type();
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.MsgUpdateAdmin
 */
declare const MsgUpdateAdmin$1 = new MsgUpdateAdmin$Type();
//#endregion
//#region src/core/modules/wasm/msgs/MsgStoreCode.d.ts
declare namespace MsgStoreCode {
  interface Params {
    sender: string;
    wasmBytes: Uint8Array | string;
    instantiatePermission?: {
      permission: AccessType$1;
      addresses: string[];
    };
  }
  type Proto = MsgStoreCode$1;
}
/**
 * @category Messages
 */
declare class MsgStoreCode extends MsgBase<MsgStoreCode.Params, MsgStoreCode.Proto> {
  static fromJSON(params: MsgStoreCode.Params): MsgStoreCode;
  toProto(): MsgStoreCode$1;
  toData(): {
    sender: string;
    wasmByteCode: Uint8Array;
    instantiatePermission?: AccessConfig;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      sender: string;
      wasm_byte_code: string;
      instantiate_permission: {
        permission: string;
        addresses: string[];
      } | undefined;
    };
  };
  toWeb3Gw(): {
    sender: string;
    wasm_byte_code: string;
    instantiate_permission: {
      permission: string;
      addresses: string[];
    } | undefined;
    '@type': string;
  };
  toEip712(): never;
  toDirectSign(): {
    type: string;
    message: MsgStoreCode$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/injective/peggy/v1/params_pb.d.ts
// Params represent the peggy genesis and store parameters
// peggy_id:
// a random 32 byte value to prevent signature reuse, for example if the
// cosmos validators decided to use the same Ethereum keys for another chain
// also running Peggy we would not want it to be possible to play a deposit
// from chain A back on chain B's peggy. This value IS USED ON ETHEREUM so
// it must be set in your genesis.json before launch and not changed after
// deploying Peggy
// 
// contract_hash:
// the code hash of a known good version of the Peggy contract
// solidity code. This can be used to verify the correct version
// of the contract has been deployed. This is a reference value for
// goernance action only it is never read by any Peggy code
// 
// bridge_ethereum_address:
// is address of the bridge contract on the Ethereum side, this is a
// reference value for governance only and is not actually used by any
// Peggy code
// 
// bridge_chain_id:
// the unique identifier of the Ethereum chain, this is a reference value
// only and is not actually used by any Peggy code
// 
// These reference values may be used by future Peggy client implemetnations
// to allow for saftey features or convenience features like the peggy address
// in your relayer. A relayer would require a configured peggy address if
// governance had not set the address on the chain it was relaying for.
// 
// signed_valsets_window
// signed_batches_window
// signed_claims_window
// 
// These values represent the time in blocks that a validator has to submit
// a signature for a batch or valset, or to submit a claim for a particular
// attestation nonce. In the case of attestations this clock starts when the
// attestation is created, but only allows for slashing once the event has
// passed
// 
// target_batch_timeout:
// 
// This is the 'target' value for when batches time out, this is a target
// becuase Ethereum is a probabalistic chain and you can't say for sure what the
// block frequency is ahead of time.
// 
// average_block_time
// average_ethereum_block_time
// 
// These values are the average Cosmos block time and Ethereum block time
// repsectively and they are used to copute what the target batch timeout is. It
// is important that governance updates these in case of any major, prolonged
// change in the time it takes to produce a block
// 
// slash_fraction_valset
// slash_fraction_batch
// slash_fraction_claim
// slash_fraction_conflicting_claim
// 
// The slashing fractions for the various peggy related slashing conditions. The
// first three refer to not submitting a particular message, the third for
// submitting a different claim for the same Ethereum event
// 
// unbond_slashing_valsets_window
// 
// The unbond slashing valsets window is used to determine how many blocks after
// starting to unbond a validator needs to continue signing blocks. The goal of
// this paramater is that when a validator leaves the set, if their leaving
// creates enough change in the validator set to justify an update they will
// sign a validator set update for the Ethereum bridge that does not include
// themselves. Allowing us to remove them from the Ethereum bridge and replace
// them with the new set gracefully.
// 
// valset_reward
// 
// Valset rewards are the amount of tokens this chain issues to relayers of
// validator sets. These can be any ERC20 token in the bridge, but it's strongly
// advised that chains use only Cosmos originated tokens, which the bridge
// effectively mints on Ethereum. If you run out of the token you are using for
// validator set rewards valset updates will fail and the bridge will be
// vulnerable to highjacking. For these paramaters the zero values are special
// and indicate not to attempt any reward. This is the default for
// bootstrapping.

/**
 * @generated from protobuf message injective.peggy.v1.Params
 */
interface Params$8 {
  /**
   * @generated from protobuf field: string peggy_id = 1
   */
  peggyId: string;
  /**
   * @generated from protobuf field: string contract_source_hash = 2
   */
  contractSourceHash: string;
  /**
   * @generated from protobuf field: string bridge_ethereum_address = 3
   */
  bridgeEthereumAddress: string;
  /**
   * @generated from protobuf field: uint64 bridge_chain_id = 4
   */
  bridgeChainId: bigint;
  /**
   * @generated from protobuf field: uint64 signed_valsets_window = 5
   */
  signedValsetsWindow: bigint;
  /**
   * @generated from protobuf field: uint64 signed_batches_window = 6
   */
  signedBatchesWindow: bigint;
  /**
   * @generated from protobuf field: uint64 signed_claims_window = 7
   */
  signedClaimsWindow: bigint;
  /**
   * @generated from protobuf field: uint64 target_batch_timeout = 8
   */
  targetBatchTimeout: bigint;
  /**
   * @generated from protobuf field: uint64 average_block_time = 9
   */
  averageBlockTime: bigint;
  /**
   * @generated from protobuf field: uint64 average_ethereum_block_time = 10
   */
  averageEthereumBlockTime: bigint;
  /**
   * @generated from protobuf field: bytes slash_fraction_valset = 11
   */
  slashFractionValset: Uint8Array;
  /**
   * @generated from protobuf field: bytes slash_fraction_batch = 12
   */
  slashFractionBatch: Uint8Array;
  /**
   * @generated from protobuf field: bytes slash_fraction_claim = 13
   */
  slashFractionClaim: Uint8Array;
  /**
   * @generated from protobuf field: bytes slash_fraction_conflicting_claim = 14
   */
  slashFractionConflictingClaim: Uint8Array;
  /**
   * @generated from protobuf field: uint64 unbond_slashing_valsets_window = 15
   */
  unbondSlashingValsetsWindow: bigint;
  /**
   * @generated from protobuf field: bytes slash_fraction_bad_eth_signature = 16
   */
  slashFractionBadEthSignature: Uint8Array;
  /**
   * @generated from protobuf field: string cosmos_coin_denom = 17
   */
  cosmosCoinDenom: string;
  /**
   * @generated from protobuf field: string cosmos_coin_erc20_contract = 18
   */
  cosmosCoinErc20Contract: string;
  /**
   * @generated from protobuf field: bool claim_slashing_enabled = 19
   */
  claimSlashingEnabled: boolean;
  /**
   * @generated from protobuf field: uint64 bridge_contract_start_height = 20
   */
  bridgeContractStartHeight: bigint;
  /**
   * @generated from protobuf field: cosmos.base.v1beta1.Coin valset_reward = 21
   */
  valsetReward?: Coin$1;
  /**
   * @generated from protobuf field: repeated string admins = 22
   */
  admins: string[];
  /**
   * address for receiving Peggy Deposits from sanctioned Ethereum addresses
   *
   * @generated from protobuf field: string segregated_wallet_address = 23
   */
  segregatedWalletAddress: string;
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.Params
 */
declare const Params$8 = new Params$Type();
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/injective/peggy/v1/msgs_pb.d.ts
/**
 * MsgSendToEth
 * This is the message that a user calls when they want to bridge an asset
 * it will later be removed when it is included in a batch and successfully
 * submitted tokens are removed from the users balance immediately
 * -------------
 * AMOUNT:
 * the coin to send across the bridge, note the restriction that this is a
 * single coin not a set of coins that is normal in other Cosmos messages
 * FEE:
 * the fee paid for the bridge, distinct from the fee paid to the chain to
 * actually send this message in the first place. So a successful send has
 * two layers of fees for the user
 *
 * @generated from protobuf message injective.peggy.v1.MsgSendToEth
 */
interface MsgSendToEth$1 {
  /**
   * The sender's Injective address
   *
   * @generated from protobuf field: string sender = 1
   */
  sender: string;
  /**
   * The Ethereum address to send the tokens to
   *
   * @generated from protobuf field: string eth_dest = 2
   */
  ethDest: string;
  /**
   * The amount of tokens to send
   *
   * @generated from protobuf field: cosmos.base.v1beta1.Coin amount = 3
   */
  amount?: Coin$1;
  /**
   * The fee paid for the bridge, distinct from the fee paid to the chain to
   * actually send this message in the first place. So a successful send has
   * two layers of fees for the user
   *
   * @generated from protobuf field: cosmos.base.v1beta1.Coin bridge_fee = 4
   */
  bridgeFee?: Coin$1;
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.MsgSendToEth
 */
declare const MsgSendToEth$1 = new MsgSendToEth$Type();
//#endregion
//#region src/core/modules/peggy/msgs/MsgSendToEth.d.ts
declare namespace MsgSendToEth {
  interface Params {
    amount: {
      denom: string;
      amount: string;
    };
    bridgeFee?: {
      denom: string;
      amount: string;
    };
    address: string;
    injectiveAddress: string;
  }
  type Proto = MsgSendToEth$1;
}
/**
 * @category Messages
 */
declare class MsgSendToEth extends MsgBase<MsgSendToEth.Params, MsgSendToEth.Proto> {
  static fromJSON(params: MsgSendToEth.Params): MsgSendToEth;
  toProto(): MsgSendToEth$1;
  toData(): {
    sender: string;
    ethDest: string;
    amount?: Coin$1;
    bridgeFee?: Coin$1;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      sender: string;
      eth_dest: string;
      amount: Coin$1 | undefined;
      bridge_fee: Coin$1 | undefined;
    };
  };
  toWeb3Gw(): {
    sender: string;
    eth_dest: string;
    amount: Coin$1 | undefined;
    bridge_fee: Coin$1 | undefined;
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgSendToEth$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/cometbft/crypto/v1/keys_pb.d.ts
/**
 * PublicKey is a ED25519 or a secp256k1 public key.
 *
 * @generated from protobuf message cometbft.crypto.v1.PublicKey
 */
interface PublicKey$1 {
  /**
   * The type of key.
   *
   * @generated from protobuf oneof: sum
   */
  sum: {
    oneofKind: "ed25519";
    /**
     * @generated from protobuf field: bytes ed25519 = 1
     */
    ed25519: Uint8Array;
  } | {
    oneofKind: "secp256K1";
    /**
     * @generated from protobuf field: bytes secp256k1 = 2
     */
    secp256K1: Uint8Array;
  } | {
    oneofKind: "bls12381";
    /**
     * @generated from protobuf field: bytes bls12381 = 3
     */
    bls12381: Uint8Array;
  } | {
    oneofKind: undefined;
  };
}
/**
 * @generated MessageType for protobuf message cometbft.crypto.v1.PublicKey
 */
declare const PublicKey$1 = new PublicKey$Type();
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/cometbft/types/v1/validator_pb.d.ts
/**
 * ValidatorSet defines a set of validators.
 *
 * @generated from protobuf message cometbft.types.v1.ValidatorSet
 */
interface ValidatorSet {
  /**
   * @generated from protobuf field: repeated cometbft.types.v1.Validator validators = 1
   */
  validators: Validator$3[];
  /**
   * @generated from protobuf field: cometbft.types.v1.Validator proposer = 2
   */
  proposer?: Validator$3;
  /**
   * @generated from protobuf field: int64 total_voting_power = 3
   */
  totalVotingPower: bigint;
}
/**
 * Validator represents a node participating in the consensus protocol.
 *
 * @generated from protobuf message cometbft.types.v1.Validator
 */
interface Validator$3 {
  /**
   * @generated from protobuf field: bytes address = 1
   */
  address: Uint8Array;
  /**
   * @deprecated
   * @generated from protobuf field: cometbft.crypto.v1.PublicKey pub_key = 2 [deprecated = true]
   */
  pubKey?: PublicKey$1;
  /**
   * @generated from protobuf field: int64 voting_power = 3
   */
  votingPower: bigint;
  /**
   * @generated from protobuf field: int64 proposer_priority = 4
   */
  proposerPriority: bigint;
  /**
   * @generated from protobuf field: bytes pub_key_bytes = 5
   */
  pubKeyBytes: Uint8Array;
  /**
   * @generated from protobuf field: string pub_key_type = 6
   */
  pubKeyType: string;
}
/**
 * BlockIdFlag indicates which BlockID the signature is for
 *
 * @generated from protobuf enum cometbft.types.v1.BlockIDFlag
 */
declare enum BlockIDFlag {
  /**
   * Indicates an error condition
   *
   * @generated from protobuf enum value: BLOCK_ID_FLAG_UNKNOWN = 0;
   */
  BLOCK_ID_FLAG_UNKNOWN = 0,
  /**
   * The vote was not received
   *
   * @generated from protobuf enum value: BLOCK_ID_FLAG_ABSENT = 1;
   */
  BLOCK_ID_FLAG_ABSENT = 1,
  /**
   * Voted for the block that received the majority
   *
   * @generated from protobuf enum value: BLOCK_ID_FLAG_COMMIT = 2;
   */
  BLOCK_ID_FLAG_COMMIT = 2,
  /**
   * Voted for nil
   *
   * @generated from protobuf enum value: BLOCK_ID_FLAG_NIL = 3;
   */
  BLOCK_ID_FLAG_NIL = 3,
}
/**
 * @generated MessageType for protobuf message cometbft.types.v1.ValidatorSet
 */
declare const ValidatorSet = new ValidatorSet$Type();
/**
 * @generated MessageType for protobuf message cometbft.types.v1.Validator
 */
declare const Validator$3 = new Validator$Type();
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/cometbft/abci/v1/types_pb.d.ts

/**
 * Event allows application developers to attach additional information to
 * ResponseFinalizeBlock and ResponseCheckTx.
 * Up to 0.37, this could also be used in ResponseBeginBlock, ResponseEndBlock,
 * and ResponseDeliverTx.
 * Later, transactions may be queried using these events.
 *
 * @generated from protobuf message cometbft.abci.v1.Event
 */
interface Event$1 {
  /**
   * @generated from protobuf field: string type = 1
   */
  type: string;
  /**
   * @generated from protobuf field: repeated cometbft.abci.v1.EventAttribute attributes = 2
   */
  attributes: EventAttribute[];
}
/**
 * EventAttribute is a single key-value pair, associated with an event.
 *
 * @generated from protobuf message cometbft.abci.v1.EventAttribute
 */
interface EventAttribute {
  /**
   * @generated from protobuf field: string key = 1
   */
  key: string;
  /**
   * @generated from protobuf field: string value = 2
   */
  value: string;
  /**
   * @generated from protobuf field: bool index = 3
   */
  index: boolean; // nondeterministic
}
/**
 * @generated MessageType for protobuf message cometbft.abci.v1.Event
 */
declare const Event$1 = new Event$Type();
/**
 * @generated MessageType for protobuf message cometbft.abci.v1.EventAttribute
 */
declare const EventAttribute = new EventAttribute$Type();
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/cometbft/version/v1/types_pb.d.ts
/**
 * Consensus captures the consensus rules for processing a block in the blockchain,
 * including all blockchain data structures and the rules of the application's
 * state transition machine.
 *
 * @generated from protobuf message cometbft.version.v1.Consensus
 */
interface Consensus {
  /**
   * @generated from protobuf field: uint64 block = 1
   */
  block: bigint;
  /**
   * @generated from protobuf field: uint64 app = 2
   */
  app: bigint;
}
/**
 * @generated MessageType for protobuf message cometbft.version.v1.Consensus
 */
declare const Consensus = new Consensus$Type();
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/cometbft/types/v1/types_pb.d.ts
/**
 * Header of the parts set for a block.
 *
 * @generated from protobuf message cometbft.types.v1.PartSetHeader
 */
interface PartSetHeader {
  /**
   * @generated from protobuf field: uint32 total = 1
   */
  total: number;
  /**
   * @generated from protobuf field: bytes hash = 2
   */
  hash: Uint8Array;
}
/**
 * BlockID defines the unique ID of a block as its hash and its `PartSetHeader`.
 *
 * @generated from protobuf message cometbft.types.v1.BlockID
 */
interface BlockID {
  /**
   * @generated from protobuf field: bytes hash = 1
   */
  hash: Uint8Array;
  /**
   * @generated from protobuf field: cometbft.types.v1.PartSetHeader part_set_header = 2
   */
  partSetHeader?: PartSetHeader;
}
/**
 * Header defines the structure of a block header.
 *
 * @generated from protobuf message cometbft.types.v1.Header
 */
interface Header$1 {
  /**
   * basic block info
   *
   * @generated from protobuf field: cometbft.version.v1.Consensus version = 1
   */
  version?: Consensus;
  /**
   * @generated from protobuf field: string chain_id = 2
   */
  chainId: string;
  /**
   * @generated from protobuf field: int64 height = 3
   */
  height: bigint;
  /**
   * @generated from protobuf field: google.protobuf.Timestamp time = 4
   */
  time?: Timestamp;
  /**
   * prev block info
   *
   * @generated from protobuf field: cometbft.types.v1.BlockID last_block_id = 5
   */
  lastBlockId?: BlockID;
  /**
   * hashes of block data
   *
   * @generated from protobuf field: bytes last_commit_hash = 6
   */
  lastCommitHash: Uint8Array; // commit from validators from the last block
  /**
   * @generated from protobuf field: bytes data_hash = 7
   */
  dataHash: Uint8Array; // transactions
  /**
   * hashes from the app output from the prev block
   *
   * @generated from protobuf field: bytes validators_hash = 8
   */
  validatorsHash: Uint8Array; // validators for the current block
  /**
   * @generated from protobuf field: bytes next_validators_hash = 9
   */
  nextValidatorsHash: Uint8Array; // validators for the next block
  /**
   * @generated from protobuf field: bytes consensus_hash = 10
   */
  consensusHash: Uint8Array; // consensus params for current block
  /**
   * @generated from protobuf field: bytes app_hash = 11
   */
  appHash: Uint8Array; // state after txs from the previous block
  /**
   * @generated from protobuf field: bytes last_results_hash = 12
   */
  lastResultsHash: Uint8Array; // root hash of all results from the txs from the previous block
  /**
   * consensus info
   *
   * @generated from protobuf field: bytes evidence_hash = 13
   */
  evidenceHash: Uint8Array; // evidence included in the block
  /**
   * @generated from protobuf field: bytes proposer_address = 14
   */
  proposerAddress: Uint8Array; // original proposer of the block
}
/**
 * Data contains the set of transactions included in the block
 *
 * @generated from protobuf message cometbft.types.v1.Data
 */
interface Data {
  /**
   * Txs that will be applied by state @ block.Height+1.
   * NOTE: not all txs here are valid.  We're just agreeing on the order first.
   * This means that block.AppHash does not include these txs.
   *
   * @generated from protobuf field: repeated bytes txs = 1
   */
  txs: Uint8Array[];
}
/**
 * Vote represents a prevote or precommit vote from validators for
 * consensus.
 *
 * @generated from protobuf message cometbft.types.v1.Vote
 */
interface Vote$2 {
  /**
   * @generated from protobuf field: cometbft.types.v1.SignedMsgType type = 1
   */
  type: SignedMsgType;
  /**
   * @generated from protobuf field: int64 height = 2
   */
  height: bigint;
  /**
   * @generated from protobuf field: int32 round = 3
   */
  round: number;
  /**
   * @generated from protobuf field: cometbft.types.v1.BlockID block_id = 4
   */
  blockId?: BlockID; // zero if vote is nil.
  /**
   * @generated from protobuf field: google.protobuf.Timestamp timestamp = 5
   */
  timestamp?: Timestamp;
  /**
   * @generated from protobuf field: bytes validator_address = 6
   */
  validatorAddress: Uint8Array;
  /**
   * @generated from protobuf field: int32 validator_index = 7
   */
  validatorIndex: number;
  /**
   * Vote signature by the validator if they participated in consensus for the
   * associated block.
   *
   * @generated from protobuf field: bytes signature = 8
   */
  signature: Uint8Array;
  /**
   * Vote extension provided by the application. Only valid for precommit
   * messages.
   *
   * @generated from protobuf field: bytes extension = 9
   */
  extension: Uint8Array;
  /**
   * Vote extension signature by the validator if they participated in
   * consensus for the associated block.
   * Only valid for precommit messages.
   *
   * @generated from protobuf field: bytes extension_signature = 10
   */
  extensionSignature: Uint8Array;
}
/**
 * Commit contains the evidence that a block was committed by a set of validators.
 *
 * @generated from protobuf message cometbft.types.v1.Commit
 */
interface Commit {
  /**
   * @generated from protobuf field: int64 height = 1
   */
  height: bigint;
  /**
   * @generated from protobuf field: int32 round = 2
   */
  round: number;
  /**
   * @generated from protobuf field: cometbft.types.v1.BlockID block_id = 3
   */
  blockId?: BlockID;
  /**
   * @generated from protobuf field: repeated cometbft.types.v1.CommitSig signatures = 4
   */
  signatures: CommitSig[];
}
/**
 * CommitSig is a part of the Vote included in a Commit.
 *
 * @generated from protobuf message cometbft.types.v1.CommitSig
 */
interface CommitSig {
  /**
   * @generated from protobuf field: cometbft.types.v1.BlockIDFlag block_id_flag = 1
   */
  blockIdFlag: BlockIDFlag;
  /**
   * @generated from protobuf field: bytes validator_address = 2
   */
  validatorAddress: Uint8Array;
  /**
   * @generated from protobuf field: google.protobuf.Timestamp timestamp = 3
   */
  timestamp?: Timestamp;
  /**
   * @generated from protobuf field: bytes signature = 4
   */
  signature: Uint8Array;
}
/**
 * SignedHeader contains a Header(H) and Commit(H+1) with signatures of validators who signed it.
 *
 * @generated from protobuf message cometbft.types.v1.SignedHeader
 */
interface SignedHeader {
  /**
   * @generated from protobuf field: cometbft.types.v1.Header header = 1
   */
  header?: Header$1;
  /**
   * @generated from protobuf field: cometbft.types.v1.Commit commit = 2
   */
  commit?: Commit;
}
/**
 * LightBlock is a combination of SignedHeader and ValidatorSet. It is used by light clients.
 *
 * @generated from protobuf message cometbft.types.v1.LightBlock
 */
interface LightBlock {
  /**
   * @generated from protobuf field: cometbft.types.v1.SignedHeader signed_header = 1
   */
  signedHeader?: SignedHeader;
  /**
   * @generated from protobuf field: cometbft.types.v1.ValidatorSet validator_set = 2
   */
  validatorSet?: ValidatorSet;
}
/**
 * SignedMsgType is a type of signed message in the consensus.
 *
 * @generated from protobuf enum cometbft.types.v1.SignedMsgType
 */
declare enum SignedMsgType {
  /**
   * Unknown
   *
   * @generated from protobuf enum value: SIGNED_MSG_TYPE_UNKNOWN = 0;
   */
  UNKNOWN = 0,
  /**
   * Prevote
   *
   * @generated from protobuf enum value: SIGNED_MSG_TYPE_PREVOTE = 1;
   */
  PREVOTE = 1,
  /**
   * Precommit
   *
   * @generated from protobuf enum value: SIGNED_MSG_TYPE_PRECOMMIT = 2;
   */
  PRECOMMIT = 2,
  /**
   * Proposal
   *
   * @generated from protobuf enum value: SIGNED_MSG_TYPE_PROPOSAL = 32;
   */
  PROPOSAL = 32,
}
/**
 * @generated MessageType for protobuf message cometbft.types.v1.PartSetHeader
 */
declare const PartSetHeader = new PartSetHeader$Type();
/**
 * @generated MessageType for protobuf message cometbft.types.v1.BlockID
 */
declare const BlockID = new BlockID$Type();
/**
 * @generated MessageType for protobuf message cometbft.types.v1.Header
 */
declare const Header$1 = new Header$Type();
/**
 * @generated MessageType for protobuf message cometbft.types.v1.Data
 */
declare const Data = new Data$Type();
/**
 * @generated MessageType for protobuf message cometbft.types.v1.Vote
 */
declare const Vote$2 = new Vote$Type();
/**
 * @generated MessageType for protobuf message cometbft.types.v1.Commit
 */
declare const Commit = new Commit$Type();
/**
 * @generated MessageType for protobuf message cometbft.types.v1.CommitSig
 */
declare const CommitSig = new CommitSig$Type();
/**
 * @generated MessageType for protobuf message cometbft.types.v1.SignedHeader
 */
declare const SignedHeader = new SignedHeader$Type();
/**
 * @generated MessageType for protobuf message cometbft.types.v1.LightBlock
 */
declare const LightBlock = new LightBlock$Type();
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/cosmos/staking/v1beta1/staking_pb.d.ts
/**
 * CommissionRates defines the initial commission rates to be used for creating
 * a validator.
 *
 * @generated from protobuf message cosmos.staking.v1beta1.CommissionRates
 */
interface CommissionRates {
  /**
   * rate is the commission rate charged to delegators, as a fraction.
   *
   * @generated from protobuf field: string rate = 1
   */
  rate: string;
  /**
   * max_rate defines the maximum commission rate which validator can ever charge, as a fraction.
   *
   * @generated from protobuf field: string max_rate = 2
   */
  maxRate: string;
  /**
   * max_change_rate defines the maximum daily increase of the validator commission, as a fraction.
   *
   * @generated from protobuf field: string max_change_rate = 3
   */
  maxChangeRate: string;
}
/**
 * Commission defines commission parameters for a given validator.
 *
 * @generated from protobuf message cosmos.staking.v1beta1.Commission
 */
interface Commission {
  /**
   * commission_rates defines the initial commission rates to be used for creating a validator.
   *
   * @generated from protobuf field: cosmos.staking.v1beta1.CommissionRates commission_rates = 1
   */
  commissionRates?: CommissionRates;
  /**
   * update_time is the last time the commission rate was changed.
   *
   * @generated from protobuf field: google.protobuf.Timestamp update_time = 2
   */
  updateTime?: Timestamp;
}
/**
 * Description defines a validator description.
 *
 * @generated from protobuf message cosmos.staking.v1beta1.Description
 */
interface Description {
  /**
   * moniker defines a human-readable name for the validator.
   *
   * @generated from protobuf field: string moniker = 1
   */
  moniker: string;
  /**
   * identity defines an optional identity signature (ex. UPort or Keybase).
   *
   * @generated from protobuf field: string identity = 2
   */
  identity: string;
  /**
   * website defines an optional website link.
   *
   * @generated from protobuf field: string website = 3
   */
  website: string;
  /**
   * security_contact defines an optional email for security contact.
   *
   * @generated from protobuf field: string security_contact = 4
   */
  securityContact: string;
  /**
   * details define other optional details.
   *
   * @generated from protobuf field: string details = 5
   */
  details: string;
}
/**
 * Validator defines a validator, together with the total amount of the
 * Validator's bond shares and their exchange rate to coins. Slashing results in
 * a decrease in the exchange rate, allowing correct calculation of future
 * undelegations without iterating over delegators. When coins are delegated to
 * this validator, the validator is credited with a delegation whose number of
 * bond shares is based on the amount of coins delegated divided by the current
 * exchange rate. Voting power can be calculated as total bonded shares
 * multiplied by exchange rate.
 *
 * @generated from protobuf message cosmos.staking.v1beta1.Validator
 */
interface Validator$1 {
  /**
   * operator_address defines the address of the validator's operator; bech encoded in JSON.
   *
   * @generated from protobuf field: string operator_address = 1
   */
  operatorAddress: string;
  /**
   * consensus_pubkey is the consensus public key of the validator, as a Protobuf Any.
   *
   * @generated from protobuf field: google.protobuf.Any consensus_pubkey = 2
   */
  consensusPubkey?: Any;
  /**
   * jailed defined whether the validator has been jailed from bonded status or not.
   *
   * @generated from protobuf field: bool jailed = 3
   */
  jailed: boolean;
  /**
   * status is the validator status (bonded/unbonding/unbonded).
   *
   * @generated from protobuf field: cosmos.staking.v1beta1.BondStatus status = 4
   */
  status: BondStatus$1;
  /**
   * tokens define the delegated tokens (incl. self-delegation).
   *
   * @generated from protobuf field: string tokens = 5
   */
  tokens: string;
  /**
   * delegator_shares defines total shares issued to a validator's delegators.
   *
   * @generated from protobuf field: string delegator_shares = 6
   */
  delegatorShares: string;
  /**
   * description defines the description terms for the validator.
   *
   * @generated from protobuf field: cosmos.staking.v1beta1.Description description = 7
   */
  description?: Description;
  /**
   * unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.
   *
   * @generated from protobuf field: int64 unbonding_height = 8
   */
  unbondingHeight: bigint;
  /**
   * unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.
   *
   * @generated from protobuf field: google.protobuf.Timestamp unbonding_time = 9
   */
  unbondingTime?: Timestamp;
  /**
   * commission defines the commission parameters.
   *
   * @generated from protobuf field: cosmos.staking.v1beta1.Commission commission = 10
   */
  commission?: Commission;
  /**
   * min_self_delegation is the validator's self declared minimum self delegation.
   *
   * Since: cosmos-sdk 0.46
   *
   * @generated from protobuf field: string min_self_delegation = 11
   */
  minSelfDelegation: string;
  /**
   * strictly positive if this validator's unbonding has been stopped by external modules
   *
   * @generated from protobuf field: int64 unbonding_on_hold_ref_count = 12
   */
  unbondingOnHoldRefCount: bigint;
  /**
   * list of unbonding ids, each uniquely identifing an unbonding of this validator
   *
   * @generated from protobuf field: repeated uint64 unbonding_ids = 13
   */
  unbondingIds: bigint[];
}
/**
 * Delegation represents the bond with tokens held by an account. It is
 * owned by one delegator, and is associated with the voting power of one
 * validator.
 *
 * @generated from protobuf message cosmos.staking.v1beta1.Delegation
 */
interface Delegation$1 {
  /**
   * delegator_address is the encoded address of the delegator.
   *
   * @generated from protobuf field: string delegator_address = 1
   */
  delegatorAddress: string;
  /**
   * validator_address is the encoded address of the validator.
   *
   * @generated from protobuf field: string validator_address = 2
   */
  validatorAddress: string;
  /**
   * shares define the delegation shares received.
   *
   * @generated from protobuf field: string shares = 3
   */
  shares: string;
}
/**
 * UnbondingDelegation stores all of a single delegator's unbonding bonds
 * for a single validator in an time-ordered list.
 *
 * @generated from protobuf message cosmos.staking.v1beta1.UnbondingDelegation
 */
interface UnbondingDelegation {
  /**
   * delegator_address is the encoded address of the delegator.
   *
   * @generated from protobuf field: string delegator_address = 1
   */
  delegatorAddress: string;
  /**
   * validator_address is the encoded address of the validator.
   *
   * @generated from protobuf field: string validator_address = 2
   */
  validatorAddress: string;
  /**
   * entries are the unbonding delegation entries.
   *
   * @generated from protobuf field: repeated cosmos.staking.v1beta1.UnbondingDelegationEntry entries = 3
   */
  entries: UnbondingDelegationEntry[]; // unbonding delegation entries
}
/**
 * UnbondingDelegationEntry defines an unbonding object with relevant metadata.
 *
 * @generated from protobuf message cosmos.staking.v1beta1.UnbondingDelegationEntry
 */
interface UnbondingDelegationEntry {
  /**
   * creation_height is the height which the unbonding took place.
   *
   * @generated from protobuf field: int64 creation_height = 1
   */
  creationHeight: bigint;
  /**
   * completion_time is the unix time for unbonding completion.
   *
   * @generated from protobuf field: google.protobuf.Timestamp completion_time = 2
   */
  completionTime?: Timestamp;
  /**
   * initial_balance defines the tokens initially scheduled to receive at completion.
   *
   * @generated from protobuf field: string initial_balance = 3
   */
  initialBalance: string;
  /**
   * balance defines the tokens to receive at completion.
   *
   * @generated from protobuf field: string balance = 4
   */
  balance: string;
  /**
   * Incrementing id that uniquely identifies this entry
   *
   * @generated from protobuf field: uint64 unbonding_id = 5
   */
  unbondingId: bigint;
  /**
   * Strictly positive if this entry's unbonding has been stopped by external modules
   *
   * @generated from protobuf field: int64 unbonding_on_hold_ref_count = 6
   */
  unbondingOnHoldRefCount: bigint;
}
/**
 * RedelegationEntry defines a redelegation object with relevant metadata.
 *
 * @generated from protobuf message cosmos.staking.v1beta1.RedelegationEntry
 */
interface RedelegationEntry {
  /**
   * creation_height  defines the height which the redelegation took place.
   *
   * @generated from protobuf field: int64 creation_height = 1
   */
  creationHeight: bigint;
  /**
   * completion_time defines the unix time for redelegation completion.
   *
   * @generated from protobuf field: google.protobuf.Timestamp completion_time = 2
   */
  completionTime?: Timestamp;
  /**
   * initial_balance defines the initial balance when redelegation started.
   *
   * @generated from protobuf field: string initial_balance = 3
   */
  initialBalance: string;
  /**
   * shares_dst is the amount of destination-validator shares created by redelegation.
   *
   * @generated from protobuf field: string shares_dst = 4
   */
  sharesDst: string;
  /**
   * Incrementing id that uniquely identifies this entry
   *
   * @generated from protobuf field: uint64 unbonding_id = 5
   */
  unbondingId: bigint;
  /**
   * Strictly positive if this entry's unbonding has been stopped by external modules
   *
   * @generated from protobuf field: int64 unbonding_on_hold_ref_count = 6
   */
  unbondingOnHoldRefCount: bigint;
}
/**
 * Redelegation contains the list of a particular delegator's redelegating bonds
 * from a particular source validator to a particular destination validator.
 *
 * @generated from protobuf message cosmos.staking.v1beta1.Redelegation
 */
interface Redelegation {
  /**
   * delegator_address is the bech32-encoded address of the delegator.
   *
   * @generated from protobuf field: string delegator_address = 1
   */
  delegatorAddress: string;
  /**
   * validator_src_address is the validator redelegation source operator address.
   *
   * @generated from protobuf field: string validator_src_address = 2
   */
  validatorSrcAddress: string;
  /**
   * validator_dst_address is the validator redelegation destination operator address.
   *
   * @generated from protobuf field: string validator_dst_address = 3
   */
  validatorDstAddress: string;
  /**
   * entries are the redelegation entries.
   *
   * @generated from protobuf field: repeated cosmos.staking.v1beta1.RedelegationEntry entries = 4
   */
  entries: RedelegationEntry[]; // redelegation entries
}
/**
 * Params defines the parameters for the x/staking module.
 *
 * @generated from protobuf message cosmos.staking.v1beta1.Params
 */
interface Params$4 {
  /**
   * unbonding_time is the time duration of unbonding.
   *
   * @generated from protobuf field: google.protobuf.Duration unbonding_time = 1
   */
  unbondingTime?: Duration;
  /**
   * max_validators is the maximum number of validators.
   *
   * @generated from protobuf field: uint32 max_validators = 2
   */
  maxValidators: number;
  /**
   * max_entries is the max entries for either unbonding delegation or redelegation (per pair/trio).
   *
   * @generated from protobuf field: uint32 max_entries = 3
   */
  maxEntries: number;
  /**
   * historical_entries is the number of historical entries to persist.
   *
   * @generated from protobuf field: uint32 historical_entries = 4
   */
  historicalEntries: number;
  /**
   * bond_denom defines the bondable coin denomination.
   *
   * @generated from protobuf field: string bond_denom = 5
   */
  bondDenom: string;
  /**
   * min_commission_rate is the chain-wide minimum commission rate that a validator can charge their delegators
   *
   * @generated from protobuf field: string min_commission_rate = 6
   */
  minCommissionRate: string;
}
/**
 * DelegationResponse is equivalent to Delegation except that it contains a
 * balance in addition to shares which is more suitable for client responses.
 *
 * @generated from protobuf message cosmos.staking.v1beta1.DelegationResponse
 */
interface DelegationResponse {
  /**
   * @generated from protobuf field: cosmos.staking.v1beta1.Delegation delegation = 1
   */
  delegation?: Delegation$1;
  /**
   * @generated from protobuf field: cosmos.base.v1beta1.Coin balance = 2
   */
  balance?: Coin$1;
}
/**
 * RedelegationEntryResponse is equivalent to a RedelegationEntry except that it
 * contains a balance in addition to shares which is more suitable for client
 * responses.
 *
 * @generated from protobuf message cosmos.staking.v1beta1.RedelegationEntryResponse
 */
interface RedelegationEntryResponse {
  /**
   * @generated from protobuf field: cosmos.staking.v1beta1.RedelegationEntry redelegation_entry = 1
   */
  redelegationEntry?: RedelegationEntry;
  /**
   * @generated from protobuf field: string balance = 4
   */
  balance: string;
}
/**
 * RedelegationResponse is equivalent to a Redelegation except that its entries
 * contain a balance in addition to shares which is more suitable for client
 * responses.
 *
 * @generated from protobuf message cosmos.staking.v1beta1.RedelegationResponse
 */
interface RedelegationResponse {
  /**
   * @generated from protobuf field: cosmos.staking.v1beta1.Redelegation redelegation = 1
   */
  redelegation?: Redelegation;
  /**
   * @generated from protobuf field: repeated cosmos.staking.v1beta1.RedelegationEntryResponse entries = 2
   */
  entries: RedelegationEntryResponse[];
}
/**
 * Pool is used for tracking bonded and not-bonded token supply of the bond
 * denomination.
 *
 * @generated from protobuf message cosmos.staking.v1beta1.Pool
 */
interface Pool$1 {
  /**
   * @generated from protobuf field: string not_bonded_tokens = 1
   */
  notBondedTokens: string;
  /**
   * @generated from protobuf field: string bonded_tokens = 2
   */
  bondedTokens: string;
}
/**
 * BondStatus is the status of a validator.
 *
 * @generated from protobuf enum cosmos.staking.v1beta1.BondStatus
 */
declare enum BondStatus$1 {
  /**
   * UNSPECIFIED defines an invalid validator status.
   *
   * @generated from protobuf enum value: BOND_STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,
  /**
   * UNBONDED defines a validator that is not bonded.
   *
   * @generated from protobuf enum value: BOND_STATUS_UNBONDED = 1;
   */
  UNBONDED = 1,
  /**
   * UNBONDING defines a validator that is unbonding.
   *
   * @generated from protobuf enum value: BOND_STATUS_UNBONDING = 2;
   */
  UNBONDING = 2,
  /**
   * BONDED defines a validator that is bonded.
   *
   * @generated from protobuf enum value: BOND_STATUS_BONDED = 3;
   */
  BONDED = 3,
}
/**
 * @generated MessageType for protobuf message cosmos.staking.v1beta1.CommissionRates
 */
declare const CommissionRates = new CommissionRates$Type();
/**
 * @generated MessageType for protobuf message cosmos.staking.v1beta1.Commission
 */
declare const Commission = new Commission$Type();
/**
 * @generated MessageType for protobuf message cosmos.staking.v1beta1.Description
 */
declare const Description = new Description$Type();
/**
 * @generated MessageType for protobuf message cosmos.staking.v1beta1.Validator
 */
declare const Validator$1 = new Validator$Type();
/**
 * @generated MessageType for protobuf message cosmos.staking.v1beta1.Delegation
 */
declare const Delegation$1 = new Delegation$Type();
/**
 * @generated MessageType for protobuf message cosmos.staking.v1beta1.UnbondingDelegation
 */
declare const UnbondingDelegation = new UnbondingDelegation$Type();
/**
 * @generated MessageType for protobuf message cosmos.staking.v1beta1.UnbondingDelegationEntry
 */
declare const UnbondingDelegationEntry = new UnbondingDelegationEntry$Type();
/**
 * @generated MessageType for protobuf message cosmos.staking.v1beta1.RedelegationEntry
 */
declare const RedelegationEntry = new RedelegationEntry$Type();
/**
 * @generated MessageType for protobuf message cosmos.staking.v1beta1.Redelegation
 */
declare const Redelegation = new Redelegation$Type();
/**
 * @generated MessageType for protobuf message cosmos.staking.v1beta1.Params
 */
declare const Params$4 = new Params$Type();
/**
 * @generated MessageType for protobuf message cosmos.staking.v1beta1.DelegationResponse
 */
declare const DelegationResponse = new DelegationResponse$Type();
/**
 * @generated MessageType for protobuf message cosmos.staking.v1beta1.RedelegationEntryResponse
 */
declare const RedelegationEntryResponse = new RedelegationEntryResponse$Type();
/**
 * @generated MessageType for protobuf message cosmos.staking.v1beta1.RedelegationResponse
 */
declare const RedelegationResponse = new RedelegationResponse$Type();
/**
 * @generated MessageType for protobuf message cosmos.staking.v1beta1.Pool
 */
declare const Pool$1 = new Pool$Type();
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/cosmos/staking/v1beta1/tx_pb.d.ts
/**
 * MsgCreateValidator defines a SDK message for creating a new validator.
 *
 * @generated from protobuf message cosmos.staking.v1beta1.MsgCreateValidator
 */
interface MsgCreateValidator$1 {
  /**
   * @generated from protobuf field: cosmos.staking.v1beta1.Description description = 1
   */
  description?: Description;
  /**
   * @generated from protobuf field: cosmos.staking.v1beta1.CommissionRates commission = 2
   */
  commission?: CommissionRates;
  /**
   * @generated from protobuf field: string min_self_delegation = 3
   */
  minSelfDelegation: string;
  /**
   * Deprecated: Use of Delegator Address in MsgCreateValidator is deprecated.
   * The validator address bytes and delegator address bytes refer to the same account while creating validator (defer
   * only in bech32 notation).
   *
   * @deprecated
   * @generated from protobuf field: string delegator_address = 4 [deprecated = true]
   */
  delegatorAddress: string;
  /**
   * @generated from protobuf field: string validator_address = 5
   */
  validatorAddress: string;
  /**
   * @generated from protobuf field: google.protobuf.Any pubkey = 6
   */
  pubkey?: Any;
  /**
   * @generated from protobuf field: cosmos.base.v1beta1.Coin value = 7
   */
  value?: Coin$1;
}
/**
 * MsgEditValidator defines a SDK message for editing an existing validator.
 *
 * @generated from protobuf message cosmos.staking.v1beta1.MsgEditValidator
 */
interface MsgEditValidator$1 {
  /**
   * @generated from protobuf field: cosmos.staking.v1beta1.Description description = 1
   */
  description?: Description;
  /**
   * @generated from protobuf field: string validator_address = 2
   */
  validatorAddress: string;
  /**
   * We pass a reference to the new commission rate and min self delegation as
   * it's not mandatory to update. If not updated, the deserialized rate will be
   * zero with no way to distinguish if an update was intended.
   * REF: #2373
   *
   * @generated from protobuf field: string commission_rate = 3
   */
  commissionRate: string;
  /**
   * @generated from protobuf field: string min_self_delegation = 4
   */
  minSelfDelegation: string;
}
/**
 * MsgDelegate defines a SDK message for performing a delegation of coins
 * from a delegator to a validator.
 *
 * @generated from protobuf message cosmos.staking.v1beta1.MsgDelegate
 */
interface MsgDelegate$1 {
  /**
   * @generated from protobuf field: string delegator_address = 1
   */
  delegatorAddress: string;
  /**
   * @generated from protobuf field: string validator_address = 2
   */
  validatorAddress: string;
  /**
   * @generated from protobuf field: cosmos.base.v1beta1.Coin amount = 3
   */
  amount?: Coin$1;
}
/**
 * MsgTransferDelegation defines a SDK message for transferring a delegation of coins
 * from a delegator to another address.
 *
 * @generated from protobuf message cosmos.staking.v1beta1.MsgTransferDelegation
 */
interface MsgTransferDelegation$1 {
  /**
   * @generated from protobuf field: string delegator_address = 1
   */
  delegatorAddress: string;
  /**
   * @generated from protobuf field: string validator_address = 2
   */
  validatorAddress: string;
  /**
   * @generated from protobuf field: string receiver_address = 3
   */
  receiverAddress: string;
  /**
   * @generated from protobuf field: cosmos.base.v1beta1.Coin amount = 4
   */
  amount?: Coin$1;
}
/**
 * MsgBeginRedelegate defines a SDK message for performing a redelegation
 * of coins from a delegator and source validator to a destination validator.
 *
 * @generated from protobuf message cosmos.staking.v1beta1.MsgBeginRedelegate
 */
interface MsgBeginRedelegate$1 {
  /**
   * @generated from protobuf field: string delegator_address = 1
   */
  delegatorAddress: string;
  /**
   * @generated from protobuf field: string validator_src_address = 2
   */
  validatorSrcAddress: string;
  /**
   * @generated from protobuf field: string validator_dst_address = 3
   */
  validatorDstAddress: string;
  /**
   * @generated from protobuf field: cosmos.base.v1beta1.Coin amount = 4
   */
  amount?: Coin$1;
}
/**
 * MsgUndelegate defines a SDK message for performing an undelegation from a
 * delegate and a validator.
 *
 * @generated from protobuf message cosmos.staking.v1beta1.MsgUndelegate
 */
interface MsgUndelegate$1 {
  /**
   * @generated from protobuf field: string delegator_address = 1
   */
  delegatorAddress: string;
  /**
   * @generated from protobuf field: string validator_address = 2
   */
  validatorAddress: string;
  /**
   * @generated from protobuf field: cosmos.base.v1beta1.Coin amount = 3
   */
  amount?: Coin$1;
}
/**
 * MsgCancelUnbondingDelegation defines the SDK message for performing a cancel unbonding delegation for delegator
 *
 * Since: cosmos-sdk 0.46
 *
 * @generated from protobuf message cosmos.staking.v1beta1.MsgCancelUnbondingDelegation
 */
interface MsgCancelUnbondingDelegation$1 {
  /**
   * @generated from protobuf field: string delegator_address = 1
   */
  delegatorAddress: string;
  /**
   * @generated from protobuf field: string validator_address = 2
   */
  validatorAddress: string;
  /**
   * amount is always less than or equal to unbonding delegation entry balance
   *
   * @generated from protobuf field: cosmos.base.v1beta1.Coin amount = 3
   */
  amount?: Coin$1;
  /**
   * creation_height is the height which the unbonding took place.
   *
   * @generated from protobuf field: int64 creation_height = 4
   */
  creationHeight: bigint;
}
/**
 * @generated MessageType for protobuf message cosmos.staking.v1beta1.MsgCreateValidator
 */
declare const MsgCreateValidator$1 = new MsgCreateValidator$Type();
/**
 * @generated MessageType for protobuf message cosmos.staking.v1beta1.MsgEditValidator
 */
declare const MsgEditValidator$1 = new MsgEditValidator$Type();
/**
 * @generated MessageType for protobuf message cosmos.staking.v1beta1.MsgDelegate
 */
declare const MsgDelegate$1 = new MsgDelegate$Type();
/**
 * @generated MessageType for protobuf message cosmos.staking.v1beta1.MsgTransferDelegation
 */
declare const MsgTransferDelegation$1 = new MsgTransferDelegation$Type();
/**
 * @generated MessageType for protobuf message cosmos.staking.v1beta1.MsgBeginRedelegate
 */
declare const MsgBeginRedelegate$1 = new MsgBeginRedelegate$Type();
/**
 * @generated MessageType for protobuf message cosmos.staking.v1beta1.MsgUndelegate
 */
declare const MsgUndelegate$1 = new MsgUndelegate$Type();
/**
 * @generated MessageType for protobuf message cosmos.staking.v1beta1.MsgCancelUnbondingDelegation
 */
declare const MsgCancelUnbondingDelegation$1 = new MsgCancelUnbondingDelegation$Type();
//#endregion
//#region src/core/modules/staking/msgs/MsgDelegate.d.ts
declare namespace MsgDelegate {
  interface Params {
    amount: {
      denom: string;
      amount: string;
    };
    validatorAddress: string;
    injectiveAddress: string;
  }
  type Proto = MsgDelegate$1;
}
/**
 * @category Messages
 */
declare class MsgDelegate extends MsgBase<MsgDelegate.Params, MsgDelegate.Proto> {
  static fromJSON(params: MsgDelegate.Params): MsgDelegate;
  toProto(): MsgDelegate$1;
  toData(): {
    delegatorAddress: string;
    validatorAddress: string;
    amount?: Coin$1;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      delegator_address: string;
      validator_address: string;
      amount: Coin$1 | undefined;
    };
  };
  toWeb3Gw(): {
    delegator_address: string;
    validator_address: string;
    amount: Coin$1 | undefined;
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgDelegate$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/exchange/msgs/MsgSignData.d.ts
declare namespace MsgSignData {
  interface Params {
    sender: string;
    data: string;
  }
  type Proto = MsgSignData$1;
}
/**
 * @category Messages
 */
declare class MsgSignData extends MsgBase<MsgSignData.Params, MsgSignData.Proto> {
  static fromJSON(params: MsgSignData.Params): MsgSignData;
  toProto(): MsgSignData$1;
  toData(): {
    signer: Uint8Array;
    data: Uint8Array;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      signer: string;
      data: string;
    };
  };
  toWeb3Gw(): {
    signer: string;
    data: string;
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgSignData$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/exchange/msgs/MsgWithdraw.d.ts
declare namespace MsgWithdraw {
  interface Params {
    subaccountId: string;
    injectiveAddress: string;
    amount: {
      amount: string;
      denom: string;
    };
  }
  type Proto = MsgWithdraw$1;
}
/**
 * @category Messages
 */
declare class MsgWithdraw extends MsgBase<MsgWithdraw.Params, MsgWithdraw.Proto> {
  static fromJSON(params: MsgWithdraw.Params): MsgWithdraw;
  toProto(): MsgWithdraw$1;
  toData(): {
    sender: string;
    subaccountId: string;
    amount?: Coin$1;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      sender: string;
      subaccount_id: string;
      amount: Coin$1 | undefined;
    };
  };
  toWeb3Gw(): {
    sender: string;
    subaccount_id: string;
    amount: Coin$1 | undefined;
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgWithdraw$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/wasm/msgs/MsgUpdateAdmin.d.ts
declare namespace MsgUpdateAdmin {
  interface Params {
    sender: string;
    newAdmin: string;
    contract: string;
  }
  type Proto = MsgUpdateAdmin$1;
}
/**
 * @category Messages
 */
declare class MsgUpdateAdmin extends MsgBase<MsgUpdateAdmin.Params, MsgUpdateAdmin.Proto> {
  static fromJSON(params: MsgUpdateAdmin.Params): MsgUpdateAdmin;
  toProto(): MsgUpdateAdmin$1;
  toData(): {
    sender: string;
    newAdmin: string;
    contract: string;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      sender: string;
      new_admin: string;
      contract: string;
    };
  };
  toWeb3Gw(): {
    sender: string;
    new_admin: string;
    contract: string;
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgUpdateAdmin$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/staking/msgs/MsgUndelegate.d.ts
declare namespace MsgUndelegate {
  interface Params {
    amount: {
      denom: string;
      amount: string;
    };
    validatorAddress: string;
    injectiveAddress: string;
  }
  type Proto = MsgUndelegate$1;
}
/**
 * @category Messages
 */
declare class MsgUndelegate extends MsgBase<MsgUndelegate.Params, MsgUndelegate.Proto> {
  static fromJSON(params: MsgUndelegate.Params): MsgUndelegate;
  toProto(): MsgUndelegate$1;
  toData(): {
    delegatorAddress: string;
    validatorAddress: string;
    amount?: Coin$1;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      delegator_address: string;
      validator_address: string;
      amount: Coin$1 | undefined;
    };
  };
  toWeb3Gw(): {
    delegator_address: string;
    validator_address: string;
    amount: Coin$1 | undefined;
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgUndelegate$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/injective/insurance/v1beta1/insurance_pb.d.ts
/**
 * @generated from protobuf message injective.insurance.v1beta1.Params
 */
interface Params {
  /**
   * default_redemption_notice_period_duration defines the default minimum
   * notice period duration that must pass after an underwriter sends a
   * redemption request before the underwriter can claim his tokens
   *
   * @generated from protobuf field: google.protobuf.Duration default_redemption_notice_period_duration = 1
   */
  defaultRedemptionNoticePeriodDuration?: Duration;
}
/**
 * @generated from protobuf message injective.insurance.v1beta1.InsuranceFund
 */
interface InsuranceFund$1 {
  /**
   * deposit denomination for the given insurance fund
   *
   * @generated from protobuf field: string deposit_denom = 1
   */
  depositDenom: string;
  /**
   * insurance fund pool token denomination for the given insurance fund
   *
   * @generated from protobuf field: string insurance_pool_token_denom = 2
   */
  insurancePoolTokenDenom: string;
  /**
   * redemption_notice_period_duration defines the minimum notice period
   * duration that must pass after an underwriter sends a redemption request
   * before the underwriter can claim his tokens
   *
   * @generated from protobuf field: google.protobuf.Duration redemption_notice_period_duration = 3
   */
  redemptionNoticePeriodDuration?: Duration;
  /**
   * balance of fund
   *
   * @generated from protobuf field: string balance = 4
   */
  balance: string;
  /**
   * total share tokens minted
   *
   * @generated from protobuf field: string total_share = 5
   */
  totalShare: string;
  /**
   * marketID of the derivative market
   *
   * @generated from protobuf field: string market_id = 6
   */
  marketId: string;
  /**
   * ticker of the derivative market
   *
   * @generated from protobuf field: string market_ticker = 7
   */
  marketTicker: string;
  /**
   * Oracle base currency of the derivative market OR the oracle symbol for the
   * binary options market.
   *
   * @generated from protobuf field: string oracle_base = 8
   */
  oracleBase: string;
  /**
   * Oracle quote currency of the derivative market OR the oracle provider for
   * the binary options market.
   *
   * @generated from protobuf field: string oracle_quote = 9
   */
  oracleQuote: string;
  /**
   * Oracle type of the binary options or derivative market
   *
   * @generated from protobuf field: injective.oracle.v1beta1.OracleType oracle_type = 10
   */
  oracleType: OracleType;
  /**
   * Expiration time of the derivative market. Should be -1 for perpetual or -2
   * for binary options markets.
   *
   * @generated from protobuf field: int64 expiry = 11
   */
  expiry: bigint;
}
/**
 * @generated from protobuf message injective.insurance.v1beta1.RedemptionSchedule
 */
interface RedemptionSchedule$1 {
  /**
   * id of redemption schedule
   *
   * @generated from protobuf field: uint64 id = 1
   */
  id: bigint;
  /**
   * marketId of insurance fund for the redemption
   *
   * @generated from protobuf field: string marketId = 2
   */
  marketId: string;
  /**
   * address of the redeemer
   *
   * @generated from protobuf field: string redeemer = 3
   */
  redeemer: string;
  /**
   * the time after which the redemption can be claimed
   *
   * @generated from protobuf field: google.protobuf.Timestamp claimable_redemption_time = 4
   */
  claimableRedemptionTime?: Timestamp;
  /**
   * the insurance_pool_token amount to redeem
   *
   * @generated from protobuf field: cosmos.base.v1beta1.Coin redemption_amount = 5
   */
  redemptionAmount?: Coin$1;
}
/**
 * @generated MessageType for protobuf message injective.insurance.v1beta1.Params
 */
declare const Params = new Params$Type();
/**
 * @generated MessageType for protobuf message injective.insurance.v1beta1.InsuranceFund
 */
declare const InsuranceFund$1 = new InsuranceFund$Type();
/**
 * @generated MessageType for protobuf message injective.insurance.v1beta1.RedemptionSchedule
 */
declare const RedemptionSchedule$1 = new RedemptionSchedule$Type();
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/injective/insurance/v1beta1/tx_pb.d.ts
/**
 * MsgCreateInsuranceFund a message to create an insurance fund for a derivative
 * market.
 *
 * @generated from protobuf message injective.insurance.v1beta1.MsgCreateInsuranceFund
 */
interface MsgCreateInsuranceFund$1 {
  /**
   * Creator of the insurance fund.
   *
   * @generated from protobuf field: string sender = 1
   */
  sender: string;
  /**
   * Ticker for the derivative market.
   *
   * @generated from protobuf field: string ticker = 2
   */
  ticker: string;
  /**
   * Coin denom to use for the market quote denom
   *
   * @generated from protobuf field: string quote_denom = 3
   */
  quoteDenom: string;
  /**
   * Oracle base currency of the derivative market OR the oracle symbol for the
   * binary options market.
   *
   * @generated from protobuf field: string oracle_base = 4
   */
  oracleBase: string;
  /**
   * Oracle quote currency of the derivative market OR the oracle provider for
   * the binary options market.
   *
   * @generated from protobuf field: string oracle_quote = 5
   */
  oracleQuote: string;
  /**
   * Oracle type of the binary options or derivative market
   *
   * @generated from protobuf field: injective.oracle.v1beta1.OracleType oracle_type = 6
   */
  oracleType: OracleType;
  /**
   * Expiration time of the derivative market. Should be -1 for perpetual or -2
   * for binary options markets.
   *
   * @generated from protobuf field: int64 expiry = 7
   */
  expiry: bigint;
  /**
   * Initial deposit of the insurance fund
   *
   * @generated from protobuf field: cosmos.base.v1beta1.Coin initial_deposit = 8
   */
  initialDeposit?: Coin$1;
}
/**
 * MsgUnderwrite defines a message for depositing coins to underwrite an
 * insurance fund
 *
 * @generated from protobuf message injective.insurance.v1beta1.MsgUnderwrite
 */
interface MsgUnderwrite$1 {
  /**
   * Address of the underwriter.
   *
   * @generated from protobuf field: string sender = 1
   */
  sender: string;
  /**
   * MarketID of the insurance fund.
   *
   * @generated from protobuf field: string market_id = 2
   */
  marketId: string;
  /**
   * Amount of quote_denom to underwrite the insurance fund.
   *
   * @generated from protobuf field: cosmos.base.v1beta1.Coin deposit = 3
   */
  deposit?: Coin$1;
}
/**
 * MsgRequestRedemption defines a message for requesting a redemption of the
 * sender's insurance fund tokens
 *
 * @generated from protobuf message injective.insurance.v1beta1.MsgRequestRedemption
 */
interface MsgRequestRedemption$1 {
  /**
   * Address of the underwriter requesting a redemption.
   *
   * @generated from protobuf field: string sender = 1
   */
  sender: string;
  /**
   * MarketID of the insurance fund.
   *
   * @generated from protobuf field: string market_id = 2
   */
  marketId: string;
  /**
   * Insurance fund share token amount to be redeemed.
   *
   * @generated from protobuf field: cosmos.base.v1beta1.Coin amount = 3
   */
  amount?: Coin$1;
}
/**
 * @generated MessageType for protobuf message injective.insurance.v1beta1.MsgCreateInsuranceFund
 */
declare const MsgCreateInsuranceFund$1 = new MsgCreateInsuranceFund$Type();
/**
 * @generated MessageType for protobuf message injective.insurance.v1beta1.MsgUnderwrite
 */
declare const MsgUnderwrite$1 = new MsgUnderwrite$Type();
/**
 * @generated MessageType for protobuf message injective.insurance.v1beta1.MsgRequestRedemption
 */
declare const MsgRequestRedemption$1 = new MsgRequestRedemption$Type();
//#endregion
//#region src/core/modules/insurance/msgs/MsgUnderwrite.d.ts
declare namespace MsgUnderwrite {
  interface Params {
    marketId: string;
    amount: {
      denom: string;
      amount: string;
    };
    injectiveAddress: string;
  }
  type Proto = MsgUnderwrite$1;
}
/**
 * @category Messages
 */
declare class MsgUnderwrite extends MsgBase<MsgUnderwrite.Params, MsgUnderwrite.Proto> {
  static fromJSON(params: MsgUnderwrite.Params): MsgUnderwrite;
  toProto(): MsgUnderwrite$1;
  toData(): {
    sender: string;
    marketId: string;
    deposit?: Coin$1;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      sender: string;
      market_id: string;
      deposit: Coin$1 | undefined;
    };
  };
  toWeb3Gw(): {
    sender: string;
    market_id: string;
    deposit: Coin$1 | undefined;
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgUnderwrite$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/staking/msgs/MsgEditValidator.d.ts
declare namespace MsgEditValidator {
  interface Params {
    description: {
      moniker: string;
      identity: string;
      website: string;
      securityContact?: string;
      details: string;
    };
    validatorAddress: string;
    commissionRate?: string;
    minSelfDelegation?: string;
  }
  type Proto = MsgEditValidator$1;
}
/**
 * @category Messages
 */
declare class MsgEditValidator extends MsgBase<MsgEditValidator.Params, MsgEditValidator.Proto> {
  static fromJSON(params: MsgEditValidator.Params): MsgEditValidator;
  toProto(): MsgEditValidator$1;
  toData(): {
    description?: Description;
    validatorAddress: string;
    commissionRate: string;
    minSelfDelegation: string;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      description: {
        moniker: string | undefined;
        identity: string | undefined;
        website: string | undefined;
        security_contact: string | undefined;
        details: string | undefined;
      };
      validator_address: string;
      commission_rate: string;
      min_self_delegation: string;
    };
  };
  toWeb3Gw(): {
    description: {
      moniker: string | undefined;
      identity: string | undefined;
      website: string | undefined;
      security_contact: string | undefined;
      details: string | undefined;
    };
    validator_address: string;
    commission_rate: string;
    min_self_delegation: string;
    '@type': string;
  };
  toEip712(): {
    type: string;
    value: {
      commission_rate: any;
      description: {
        moniker: string | undefined;
        identity: string | undefined;
        website: string | undefined;
        security_contact: string | undefined;
        details: string | undefined;
      };
      validator_address: string;
      min_self_delegation: string;
    };
  };
  toEip712V2(): {
    commission_rate: string;
    description: {
      moniker: string | undefined;
      identity: string | undefined;
      website: string | undefined;
      security_contact: string | undefined;
      details: string | undefined;
    };
    validator_address: string;
    min_self_delegation: string;
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgEditValidator$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/wasm/msgs/MsgPrivilegedExecuteContract.d.ts
type SnakeCaseKeys$1<T extends Record<string, any> | readonly any[]> = snakecaseKeys.SnakeCaseKeys<T>;
declare namespace MsgPrivilegedExecuteContract {
  interface Params {
    sender: string;
    funds: string;
    contractAddress: string;
    data: ExecPrivilegedArgs;
  }
  type Proto = MsgPrivilegedExecuteContract$1;
}
/**
 * @category Messages
 */
declare class MsgPrivilegedExecuteContract extends MsgBase<MsgPrivilegedExecuteContract.Params, MsgPrivilegedExecuteContract.Proto> {
  static fromJSON(params: MsgPrivilegedExecuteContract.Params): MsgPrivilegedExecuteContract;
  toProto(): MsgPrivilegedExecuteContract.Proto;
  toData(): {
    sender: string;
    funds: string;
    contractAddress: string;
    data: string;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: SnakeCaseKeys$1<MsgPrivilegedExecuteContract$1>;
  };
  toWeb3Gw(): {
    sender: string;
    funds: string;
    contract_address: string;
    data: string;
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgPrivilegedExecuteContract$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/exchange/msgs/MsgRewardsOptOut.d.ts
declare namespace MsgRewardsOptOut {
  interface Params {
    sender: string;
  }
  type Proto = MsgRewardsOptOut$1;
}
/**
 * @category Messages
 */
declare class MsgRewardsOptOut extends MsgBase<MsgRewardsOptOut.Params, MsgRewardsOptOut.Proto> {
  static fromJSON(params: MsgRewardsOptOut.Params): MsgRewardsOptOut;
  toProto(): MsgRewardsOptOut$1;
  toData(): {
    sender: string;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      sender: string;
    };
  };
  toWeb3Gw(): {
    sender: string;
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgRewardsOptOut$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/tokenfactory/msgs/MsgChangeAdmin.d.ts
declare namespace MsgChangeAdmin {
  interface Params {
    sender: string;
    denom: string;
    newAdmin: string;
  }
  type Proto = MsgChangeAdmin$1;
}
/**
 * @category Messages
 */
declare class MsgChangeAdmin extends MsgBase<MsgChangeAdmin.Params, MsgChangeAdmin.Proto> {
  static fromJSON(params: MsgChangeAdmin.Params): MsgChangeAdmin;
  toProto(): MsgChangeAdmin$1;
  toData(): {
    sender: string;
    denom: string;
    newAdmin: string;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      sender: string;
      denom: string;
      new_admin: string;
    };
  };
  toWeb3Gw(): {
    sender: string;
    denom: string;
    new_admin: string;
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgChangeAdmin$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/tokenfactory/msgs/MsgCreateDenom.d.ts
declare namespace MsgCreateDenom {
  interface Params {
    sender: string;
    subdenom: string;
    decimals?: number;
    name?: string;
    symbol?: string;
    allowAdminBurn?: boolean;
  }
  type Proto = MsgCreateDenom$1;
}
/**
 * @category Messages
 */
declare class MsgCreateDenom extends MsgBase<MsgCreateDenom.Params, MsgCreateDenom.Proto> {
  static fromJSON(params: MsgCreateDenom.Params): MsgCreateDenom;
  toProto(): MsgCreateDenom$1;
  toData(): {
    sender: string;
    subdenom: string;
    name: string;
    symbol: string;
    decimals: number;
    allowAdminBurn: boolean;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      allow_admin_burn?: boolean | undefined;
      sender: string;
      subdenom: string;
      name: string;
      symbol: string;
      decimals: number;
    };
  };
  toWeb3Gw(): {
    allow_admin_burn?: boolean | undefined;
    sender: string;
    subdenom: string;
    name: string;
    symbol: string;
    decimals: number;
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgCreateDenom$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/wasm/msgs/MsgExecuteContract.d.ts
declare namespace MsgExecuteContract {
  interface Params {
    funds?: Coin | Coin[];
    sender: string;
    contractAddress: string;
    execArgs?: ExecArgs;
    exec?: {
      msg: object;
      action: string;
    };
    /**
     * Same as exec but you don't pass
     * the action as a separate property
     * but as a whole object
     */
    msg?: object;
  }
  type Proto = MsgExecuteContract$1;
  type Object = Omit<MsgExecuteContract$1, 'msg'> & {
    msg: any;
  };
}
/**
 * @category Messages
 */
declare class MsgExecuteContract extends MsgBase<MsgExecuteContract.Params, MsgExecuteContract.Proto, MsgExecuteContract.Object> {
  static fromJSON(params: MsgExecuteContract.Params): MsgExecuteContract;
  toProto(): MsgExecuteContract$1;
  toData(): {
    sender: string;
    contract: string;
    msg: Uint8Array;
    funds: Coin$1[];
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: MsgExecuteContract.Object;
  };
  toWeb3Gw(): {
    sender: string;
    contract: string;
    funds: Coin$1[];
    msg: any;
    '@type': string;
  };
  toEip712(): never;
  toDirectSign(): {
    type: string;
    message: MsgExecuteContract$1;
  };
  toBinary(): Uint8Array;
  private getMsgObject;
}
//#endregion
//#region src/core/modules/wasm/msgs/MsgMigrateContract.d.ts
declare namespace MsgMigrateContract {
  interface Params {
    sender: string;
    contract: string;
    codeId: number;
    msg: object;
  }
  type Proto = MsgMigrateContract$1;
  type Object = Omit<MsgMigrateContract$1, 'msg'> & {
    msg: any;
  };
}
/**
 * @category Messages
 */
declare class MsgMigrateContract extends MsgBase<MsgMigrateContract.Params, MsgMigrateContract.Proto, MsgMigrateContract.Object> {
  static fromJSON(params: MsgMigrateContract.Params): MsgMigrateContract;
  toProto(): MsgMigrateContract$1;
  toData(): {
    sender: string;
    contract: string;
    codeId: bigint;
    msg: Uint8Array;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: MsgMigrateContract.Object;
  };
  toWeb3Gw(): {
    sender: string;
    contract: string;
    codeId: bigint;
    msg: any;
    '@type': string;
  };
  toEip712(): never;
  toDirectSign(): {
    type: string;
    message: MsgMigrateContract$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/injective/erc20/v1beta1/erc20_pb.d.ts
/**
 * TokenPair defines an association of bank denom <-> EVM token (erc20 contract
 * address)
 *
 * @generated from protobuf message injective.erc20.v1beta1.TokenPair
 */
interface TokenPair$1 {
  /**
   * @generated from protobuf field: string bank_denom = 1
   */
  bankDenom: string; // bank denom
  /**
   * @generated from protobuf field: string erc20_address = 2
   */
  erc20Address: string; // address of erc20 smart contract that is backed by
}
/**
 * @generated MessageType for protobuf message injective.erc20.v1beta1.TokenPair
 */
declare const TokenPair$1 = new TokenPair$Type();
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/injective/erc20/v1beta1/params_pb.d.ts
/**
 * Params defines the parameters for the erc20 module.
 *
 * @generated from protobuf message injective.erc20.v1beta1.Params
 */
interface Params$7 {
  /**
   * @generated from protobuf field: cosmos.base.v1beta1.Coin denom_creation_fee = 1
   */
  denomCreationFee?: Coin$1;
}
/**
 * @generated MessageType for protobuf message injective.erc20.v1beta1.Params
 */
declare const Params$7 = new Params$Type();
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/injective/erc20/v1beta1/tx_pb.d.ts
/**
 * @generated from protobuf message injective.erc20.v1beta1.MsgCreateTokenPair
 */
interface MsgCreateTokenPair$1 {
  /**
   * @generated from protobuf field: string sender = 1
   */
  sender: string;
  /**
   * @generated from protobuf field: injective.erc20.v1beta1.TokenPair token_pair = 2
   */
  tokenPair?: TokenPair$1;
}
/**
 * @generated MessageType for protobuf message injective.erc20.v1beta1.MsgCreateTokenPair
 */
declare const MsgCreateTokenPair$1 = new MsgCreateTokenPair$Type();
//#endregion
//#region src/core/modules/erc20/msgs/MsgCreateTokenPair.d.ts
declare namespace MsgCreateTokenPair {
  interface Params {
    injectiveAddress: string;
    tokenPair: {
      denom: string;
      erc20Address: string;
    };
  }
  type Proto = MsgCreateTokenPair$1;
}
/**
 * @category Messages
 */
declare class MsgCreateTokenPair extends MsgBase<MsgCreateTokenPair.Params, MsgCreateTokenPair.Proto> {
  static fromJSON(params: MsgCreateTokenPair.Params): MsgCreateTokenPair;
  toProto(): MsgCreateTokenPair$1;
  toData(): {
    sender: string;
    tokenPair?: TokenPair$1;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      sender: string;
      token_pair: {
        bank_denom: string | undefined;
        erc20_address: string | undefined;
      };
    };
  };
  toDirectSign(): {
    type: string;
    message: MsgCreateTokenPair$1;
  };
  toWeb3Gw(): {
    sender: string;
    token_pair: {
      bank_denom: string | undefined;
      erc20_address: string | undefined;
    };
    '@type': string;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/cosmos/feegrant/v1beta1/tx_pb.d.ts
/**
 * MsgGrantAllowance adds permission for Grantee to spend up to Allowance
 * of fees from the account of Granter.
 *
 * @generated from protobuf message cosmos.feegrant.v1beta1.MsgGrantAllowance
 */
interface MsgGrantAllowance$1 {
  /**
   * granter is the address of the user granting an allowance of their funds.
   *
   * @generated from protobuf field: string granter = 1
   */
  granter: string;
  /**
   * grantee is the address of the user being granted an allowance of another user's funds.
   *
   * @generated from protobuf field: string grantee = 2
   */
  grantee: string;
  /**
   * allowance can be any of basic, periodic, allowed fee allowance.
   *
   * @generated from protobuf field: google.protobuf.Any allowance = 3
   */
  allowance?: Any;
}
/**
 * MsgRevokeAllowance removes any existing Allowance from Granter to Grantee.
 *
 * @generated from protobuf message cosmos.feegrant.v1beta1.MsgRevokeAllowance
 */
interface MsgRevokeAllowance$1 {
  /**
   * granter is the address of the user granting an allowance of their funds.
   *
   * @generated from protobuf field: string granter = 1
   */
  granter: string;
  /**
   * grantee is the address of the user being granted an allowance of another user's funds.
   *
   * @generated from protobuf field: string grantee = 2
   */
  grantee: string;
}
/**
 * @generated MessageType for protobuf message cosmos.feegrant.v1beta1.MsgGrantAllowance
 */
declare const MsgGrantAllowance$1 = new MsgGrantAllowance$Type();
/**
 * @generated MessageType for protobuf message cosmos.feegrant.v1beta1.MsgRevokeAllowance
 */
declare const MsgRevokeAllowance$1 = new MsgRevokeAllowance$Type();
//#endregion
//#region src/core/modules/feegrant/msgs/MsgGrantAllowance.d.ts
declare namespace MsgGrantAllowance {
  interface Params {
    granter: string;
    grantee: string;
    allowance: {
      spendLimit: Coin[];
      expiration: number | undefined;
    };
  }
  type Proto = MsgGrantAllowance$1;
  type Object = Omit<MsgGrantAllowance$1, 'allowance'> & {
    allowance: any;
  };
}
/**
 * @category Messages
 */
declare class MsgGrantAllowance extends MsgBase<MsgGrantAllowance.Params, MsgGrantAllowance.Proto> {
  static fromJSON(params: MsgGrantAllowance.Params): MsgGrantAllowance;
  toProto(): MsgGrantAllowance$1;
  toData(): {
    granter: string;
    grantee: string;
    allowance?: Any;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: MsgGrantAllowance.Object;
  };
  toDirectSign(): {
    type: string;
    message: MsgGrantAllowance$1;
  };
  toWeb3Gw(): {
    granter: string;
    grantee: string;
    allowance: {
      '@type': string;
      spendLimit: {
        denom: string;
        amount: string;
      }[];
      expiration: string;
    };
    '@type': string;
  };
  toEip712V2(): {
    allowance: {
      '@type': string;
      spend_limit: {
        denom: string;
        amount: string;
      }[];
      expiration: string;
    };
    granter: string;
    grantee: string;
    '@type': string;
  };
  private getTimestamp;
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/staking/msgs/MsgBeginRedelegate.d.ts
declare namespace MsgBeginRedelegate {
  interface Params {
    amount: {
      denom: string;
      amount: string;
    };
    srcValidatorAddress: string;
    dstValidatorAddress: string;
    injectiveAddress: string;
  }
  type Proto = MsgBeginRedelegate$1;
}
/**
 * @category Messages
 */
declare class MsgBeginRedelegate extends MsgBase<MsgBeginRedelegate.Params, MsgBeginRedelegate.Proto> {
  static fromJSON(params: MsgBeginRedelegate.Params): MsgBeginRedelegate;
  toProto(): MsgBeginRedelegate.Proto;
  toData(): {
    delegatorAddress: string;
    validatorSrcAddress: string;
    validatorDstAddress: string;
    amount?: Coin$1;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      delegator_address: string;
      validator_src_address: string;
      validator_dst_address: string;
      amount: Coin$1 | undefined;
    };
  };
  toWeb3Gw(): {
    delegator_address: string;
    validator_src_address: string;
    validator_dst_address: string;
    amount: Coin$1 | undefined;
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgBeginRedelegate$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/staking/msgs/MsgCreateValidator.d.ts
declare namespace MsgCreateValidator {
  interface Params {
    description: {
      moniker: string;
      identity: string;
      website: string;
      securityContact?: string;
      details: string;
    };
    value: {
      amount: string;
      denom: string;
    };
    pubKey: {
      type: string;
      value: string;
    };
    delegatorAddress: string;
    validatorAddress: string;
    commission: {
      maxChangeRate: string;
      rate: string;
      maxRate: string;
    };
    minSelfDelegation?: string;
  }
  type Proto = MsgCreateValidator$1;
  type Object = Omit<MsgCreateValidator$1, 'pubKey'> & {
    pubKey: any;
  };
}
/**
 * @category Messages
 */
declare class MsgCreateValidator extends MsgBase<MsgCreateValidator.Params, MsgCreateValidator.Proto, MsgCreateValidator.Object> {
  static fromJSON(params: MsgCreateValidator.Params): MsgCreateValidator;
  toProto(): MsgCreateValidator$1;
  toData(): {
    description?: Description;
    commission?: CommissionRates;
    minSelfDelegation: string;
    delegatorAddress: string;
    validatorAddress: string;
    pubkey?: Any;
    value?: Coin$1;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: MsgCreateValidator.Object;
  };
  toWeb3Gw(): {
    value?: Coin$1 | undefined;
    description?: Description | undefined;
    commission?: CommissionRates | undefined;
    minSelfDelegation: string;
    delegatorAddress: string;
    validatorAddress: string;
    pubkey?: Any | undefined;
    pubKey: any;
    '@type': string;
  };
  toEip712(): never;
  toEip712V2(): MsgCreateValidator.Object;
  toDirectSign(): {
    type: string;
    message: MsgCreateValidator$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/exchange/msgs/MsgCancelSpotOrder.d.ts
declare namespace MsgCancelSpotOrder {
  interface Params {
    marketId: string;
    subaccountId: string;
    injectiveAddress: string;
    orderHash?: string;
    cid?: string;
  }
  type Proto = MsgCancelSpotOrder$1;
}
/**
 * @category Messages
 */
declare class MsgCancelSpotOrder extends MsgBase<MsgCancelSpotOrder.Params, MsgCancelSpotOrder.Proto> {
  static fromJSON(params: MsgCancelSpotOrder.Params): MsgCancelSpotOrder;
  toProto(): MsgCancelSpotOrder$1;
  toData(): {
    sender: string;
    marketId: string;
    subaccountId: string;
    orderHash: string;
    cid: string;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      sender: string;
      market_id: string;
      subaccount_id: string;
      order_hash: string;
      cid: string;
    };
  };
  toWeb3Gw(): {
    sender: string;
    market_id: string;
    subaccount_id: string;
    order_hash: string;
    cid: string;
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgCancelSpotOrder$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/feegrant/msgs/MsgRevokeAllowance.d.ts
declare namespace MsgRevokeAllowance {
  interface Params {
    granter: string;
    grantee: string;
  }
  type Proto = MsgRevokeAllowance$1;
}
/**
 * @category Messages
 */
declare class MsgRevokeAllowance extends MsgBase<MsgRevokeAllowance.Params, MsgRevokeAllowance.Proto> {
  static fromJSON(params: MsgRevokeAllowance.Params): MsgRevokeAllowance;
  toProto(): MsgRevokeAllowance$1;
  toData(): {
    granter: string;
    grantee: string;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      granter: string;
      grantee: string;
    };
  };
  toWeb3Gw(): {
    granter: string;
    grantee: string;
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgRevokeAllowance$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/exchange/msgs/MsgExternalTransfer.d.ts
declare namespace MsgExternalTransfer {
  interface Params {
    srcSubaccountId: string;
    dstSubaccountId: string;
    injectiveAddress: string;
    amount: {
      amount: string;
      denom: string;
    };
  }
  type Proto = MsgExternalTransfer$1;
}
/**
 * @category Messages
 */
declare class MsgExternalTransfer extends MsgBase<MsgExternalTransfer.Params, MsgExternalTransfer.Proto> {
  static fromJSON(params: MsgExternalTransfer.Params): MsgExternalTransfer;
  toProto(): MsgExternalTransfer$1;
  toData(): {
    sender: string;
    sourceSubaccountId: string;
    destinationSubaccountId: string;
    amount?: Coin$1;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      sender: string;
      source_subaccount_id: string;
      destination_subaccount_id: string;
      amount: Coin$1 | undefined;
    };
  };
  toWeb3Gw(): {
    sender: string;
    source_subaccount_id: string;
    destination_subaccount_id: string;
    amount: Coin$1 | undefined;
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgExternalTransfer$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/exchange/msgs/MsgBatchUpdateOrders.d.ts
type SnakeCaseKeys<T extends Record<string, any> | readonly any[]> = T;
interface SpotOrderToCreate {
  orderType: OrderType$1;
  triggerPrice?: string;
  marketId: string;
  feeRecipient: string;
  price: string;
  quantity: string;
  cid?: string;
}
interface DerivativeOrderToCreate {
  orderType: OrderType$1;
  triggerPrice?: string;
  feeRecipient: string;
  marketId: string;
  price: string;
  margin: string;
  quantity: string;
  cid?: string;
}
interface BinaryOptionOrderToCreate {
  orderType: OrderType$1;
  triggerPrice?: string;
  feeRecipient: string;
  marketId: string;
  price: string;
  margin: string;
  quantity: string;
  cid?: string;
}
declare namespace MsgBatchUpdateOrders {
  interface Params {
    subaccountId: string;
    spotMarketIdsToCancelAll?: string[];
    derivativeMarketIdsToCancelAll?: string[];
    binaryOptionsMarketIdsToCancelAll?: string[];
    spotOrdersToCancel?: {
      marketId: string;
      subaccountId: string;
      orderHash?: string;
      cid?: string;
    }[];
    derivativeOrdersToCancel?: {
      marketId: string;
      subaccountId: string;
      orderHash?: string;
      cid?: string;
    }[];
    binaryOptionsOrdersToCancel?: {
      marketId: string;
      subaccountId: string;
      orderHash?: string;
      cid?: string;
    }[];
    spotOrdersToCreate?: SpotOrderToCreate[];
    derivativeOrdersToCreate?: DerivativeOrderToCreate[];
    binaryOptionsOrdersToCreate?: BinaryOptionOrderToCreate[];
    injectiveAddress: string;
  }
  type Proto = MsgBatchUpdateOrders$1;
}
/**
 * @category Messages
 */
declare class MsgBatchUpdateOrders extends MsgBase<MsgBatchUpdateOrders.Params, MsgBatchUpdateOrders.Proto> {
  static fromJSON(params: MsgBatchUpdateOrders.Params): MsgBatchUpdateOrders;
  toProto(): MsgBatchUpdateOrders$1;
  toData(): {
    sender: string;
    subaccountId: string;
    spotMarketIdsToCancelAll: string[];
    derivativeMarketIdsToCancelAll: string[];
    spotOrdersToCancel: OrderData[];
    derivativeOrdersToCancel: OrderData[];
    spotOrdersToCreate: SpotOrder$1[];
    derivativeOrdersToCreate: DerivativeOrder$1[];
    binaryOptionsOrdersToCancel: OrderData[];
    binaryOptionsMarketIdsToCancelAll: string[];
    binaryOptionsOrdersToCreate: DerivativeOrder$1[];
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: SnakeCaseKeys<MsgBatchUpdateOrders$1>;
  };
  toWeb3Gw(): {
    sender: string;
    subaccountId: string;
    spotMarketIdsToCancelAll: string[];
    derivativeMarketIdsToCancelAll: string[];
    spotOrdersToCancel: OrderData[];
    derivativeOrdersToCancel: OrderData[];
    spotOrdersToCreate: SpotOrder$1[];
    derivativeOrdersToCreate: DerivativeOrder$1[];
    binaryOptionsOrdersToCancel: OrderData[];
    binaryOptionsMarketIdsToCancelAll: string[];
    binaryOptionsOrdersToCreate: DerivativeOrder$1[];
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgBatchUpdateOrders$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/exchange/msgs/MsgLiquidatePosition.d.ts
declare namespace MsgLiquidatePosition {
  interface Params {
    subaccountId: string;
    injectiveAddress: string;
    marketId: string;
    /** optional order to provide for liquidation */
    order?: {
      marketId: string;
      subaccountId: string;
      orderType: OrderType$1;
      triggerPrice?: string;
      feeRecipient: string;
      price: string;
      margin: string;
      quantity: string;
      cid?: string;
    };
  }
  type Proto = MsgLiquidatePosition$1;
}
/**
 * @category Messages
 */
declare class MsgLiquidatePosition extends MsgBase<MsgLiquidatePosition.Params, MsgLiquidatePosition.Proto> {
  static fromJSON(params: MsgLiquidatePosition.Params): MsgLiquidatePosition;
  toProto(): MsgLiquidatePosition$1;
  toData(): {
    sender: string;
    subaccountId: string;
    marketId: string;
    order?: DerivativeOrder$1;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      sender: string;
      subaccount_id: string;
      market_id: string;
      order: {
        market_id: string;
        order_info: {
          subaccount_id: string | undefined;
          fee_recipient: string | undefined;
          price: string | undefined;
          quantity: string | undefined;
          cid: string | undefined;
        };
        order_type: OrderType$1;
        margin: string;
        trigger_price: string;
      } | undefined;
    };
  };
  toWeb3Gw(): {
    sender: string;
    subaccount_id: string;
    market_id: string;
    order: {
      market_id: string;
      order_info: {
        subaccount_id: string | undefined;
        fee_recipient: string | undefined;
        price: string | undefined;
        quantity: string | undefined;
        cid: string | undefined;
      };
      order_type: OrderType$1;
      margin: string;
      trigger_price: string;
    } | undefined;
    '@type': string;
  };
  toEip712V2(): {
    order: any;
    sender: string;
    subaccount_id: string;
    market_id: string;
    '@type': string;
  };
  toEip712(): {
    type: string;
    value: {
      order: any;
      sender: string;
      subaccount_id: string;
      market_id: string;
    };
  };
  toDirectSign(): {
    type: string;
    message: MsgLiquidatePosition$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/wasm/msgs/MsgInstantiateContract.d.ts
declare namespace MsgInstantiateContract {
  interface Params {
    sender: string;
    admin: string;
    codeId: number;
    label: string;
    msg: Object;
    amount?: {
      denom: string;
      amount: string;
    };
  }
  type Proto = MsgInstantiateContract$1;
}
/**
 * @category Messages
 */
declare class MsgInstantiateContract extends MsgBase<MsgInstantiateContract.Params, MsgInstantiateContract.Proto> {
  static fromJSON(params: MsgInstantiateContract.Params): MsgInstantiateContract;
  toProto(): MsgInstantiateContract$1;
  toData(): {
    sender: string;
    admin: string;
    codeId: bigint;
    label: string;
    msg: Uint8Array;
    funds: Coin$1[];
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      sender: string;
      admin: string;
      code_id: string;
      label: string;
      msg: Uint8Array<ArrayBufferLike>;
      funds: Coin$1[];
    };
  };
  toWeb3Gw(): {
    sender: string;
    admin: string;
    code_id: string;
    label: string;
    msg: Uint8Array<ArrayBufferLike>;
    funds: Coin$1[];
    '@type': string;
  };
  toEip712(): never;
  toDirectSign(): {
    type: string;
    message: MsgInstantiateContract$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/insurance/msgs/MsgRequestRedemption.d.ts
declare namespace MsgRequestRedemption {
  interface Params {
    marketId: string;
    amount: {
      denom: string;
      amount: string;
    };
    injectiveAddress: string;
  }
  type Proto = MsgRequestRedemption$1;
}
/**
 * @category Messages
 */
declare class MsgRequestRedemption extends MsgBase<MsgRequestRedemption.Params, MsgRequestRedemption.Proto> {
  static fromJSON(params: MsgRequestRedemption.Params): MsgRequestRedemption;
  toProto(): MsgRequestRedemption$1;
  toData(): {
    sender: string;
    marketId: string;
    amount?: Coin$1;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      sender: string;
      market_id: string;
      amount: Coin$1 | undefined;
    };
  };
  toWeb3Gw(): {
    sender: string;
    market_id: string;
    amount: Coin$1 | undefined;
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgRequestRedemption$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/staking/msgs/MsgTransferDelegation.d.ts
declare namespace MsgTransferDelegation {
  interface Params {
    amount: {
      denom: string;
      amount: string;
    };
    injectiveAddress: string;
    validatorAddress: string;
    receiverAddress: string;
  }
  type Proto = MsgTransferDelegation$1;
}
/**
 * @category Messages
 */
declare class MsgTransferDelegation extends MsgBase<MsgTransferDelegation.Params, MsgTransferDelegation.Proto> {
  static fromJSON(params: MsgTransferDelegation.Params): MsgTransferDelegation;
  toProto(): MsgTransferDelegation$1;
  toData(): {
    delegatorAddress: string;
    validatorAddress: string;
    receiverAddress: string;
    amount?: Coin$1;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      delegator_address: string;
      validator_address: string;
      receiver_address: string;
      amount: Coin$1 | undefined;
    };
  };
  toWeb3Gw(): {
    delegator_address: string;
    validator_address: string;
    receiver_address: string;
    amount: Coin$1 | undefined;
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgTransferDelegation$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/exchange/msgs/MsgReclaimLockedFunds.d.ts
declare namespace MsgReclaimLockedFunds {
  interface Params {
    sender: string;
    lockedAccountPubKey: string;
    signature: Uint8Array;
  }
  type Proto = MsgReclaimLockedFunds$1;
}
/**
 * @category Messages
 */
declare class MsgReclaimLockedFunds extends MsgBase<MsgReclaimLockedFunds.Params, MsgReclaimLockedFunds.Proto> {
  static fromJSON(params: MsgReclaimLockedFunds.Params): MsgReclaimLockedFunds;
  toProto(): MsgReclaimLockedFunds$1;
  toData(): {
    sender: string;
    lockedAccountPubKey: Uint8Array;
    signature: Uint8Array;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      sender: string;
      lockedAccountPubKey: string;
      signature: string;
    };
  };
  toWeb3Gw(): never;
  toEip712(): never;
  toEip712V2(): never;
  toDirectSign(): {
    type: string;
    message: MsgReclaimLockedFunds$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/injective/exchange/v2/tx_pb.d.ts
/**
 * @generated from protobuf message injective.exchange.v2.MsgUpdateSpotMarket
 */
interface MsgUpdateSpotMarket {
  /**
   * current admin address of the associated market
   *
   * @generated from protobuf field: string admin = 1
   */
  admin: string;
  /**
   * id of the market to be updated
   *
   * @generated from protobuf field: string market_id = 2
   */
  marketId: string;
  /**
   * (optional) updated ticker value
   *
   * @generated from protobuf field: string new_ticker = 3
   */
  newTicker: string;
  /**
   * (optional) updated min price tick size value (in human readable format)
   *
   * @generated from protobuf field: string new_min_price_tick_size = 4
   */
  newMinPriceTickSize: string;
  /**
   * (optional) updated min quantity tick size value (in human readable format)
   *
   * @generated from protobuf field: string new_min_quantity_tick_size = 5
   */
  newMinQuantityTickSize: string;
  /**
   * (optional) updated min notional (in human readable format)
   *
   * @generated from protobuf field: string new_min_notional = 6
   */
  newMinNotional: string;
}
/**
 * @generated from protobuf message injective.exchange.v2.MsgUpdateDerivativeMarket
 */
interface MsgUpdateDerivativeMarket {
  /**
   * current admin address of the associated market
   *
   * @generated from protobuf field: string admin = 1
   */
  admin: string;
  /**
   * id of the market to be updated
   *
   * @generated from protobuf field: string market_id = 2
   */
  marketId: string;
  /**
   * (optional) updated value for ticker
   *
   * @generated from protobuf field: string new_ticker = 3
   */
  newTicker: string;
  /**
   * (optional) updated value for min_price_tick_size (in human readable format)
   *
   * @generated from protobuf field: string new_min_price_tick_size = 4
   */
  newMinPriceTickSize: string;
  /**
   * (optional) updated value min_quantity_tick_size (in human readable format)
   *
   * @generated from protobuf field: string new_min_quantity_tick_size = 5
   */
  newMinQuantityTickSize: string;
  /**
   * (optional) updated min notional (in human readable format)
   *
   * @generated from protobuf field: string new_min_notional = 6
   */
  newMinNotional: string;
  /**
   * (optional) updated value for initial_margin_ratio
   *
   * @generated from protobuf field: string new_initial_margin_ratio = 7
   */
  newInitialMarginRatio: string;
  /**
   * (optional) updated value for maintenance_margin_ratio
   *
   * @generated from protobuf field: string new_maintenance_margin_ratio = 8
   */
  newMaintenanceMarginRatio: string;
  /**
   * (optional) updated value for reduce_margin_ratio
   *
   * @generated from protobuf field: string new_reduce_margin_ratio = 9
   */
  newReduceMarginRatio: string;
  /**
   * (optional) updated value for open_notional_cap
   *
   * @generated from protobuf field: injective.exchange.v2.OpenNotionalCap new_open_notional_cap = 10
   */
  newOpenNotionalCap?: OpenNotionalCap$1;
}
/**
 * MsgCancelPostOnlyMode defines a message for canceling post-only mode
 *
 * @generated from protobuf message injective.exchange.v2.MsgCancelPostOnlyMode
 */
interface MsgCancelPostOnlyMode {
  /**
   * the sender's Injective address
   *
   * @generated from protobuf field: string sender = 1
   */
  sender: string;
}
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgUpdateSpotMarket
 */
declare const MsgUpdateSpotMarket = new MsgUpdateSpotMarket$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgUpdateDerivativeMarket
 */
declare const MsgUpdateDerivativeMarket = new MsgUpdateDerivativeMarket$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v2.MsgCancelPostOnlyMode
 */
declare const MsgCancelPostOnlyMode = new MsgCancelPostOnlyMode$Type();
//#endregion
//#region src/core/modules/exchange/msgs/MsgUpdateSpotMarketV2.d.ts
declare namespace MsgUpdateSpotMarketV2 {
  interface Params {
    admin: string;
    marketId: string;
    newTicker?: string;
    newMinNotional?: string;
    newMinPriceTickSize?: string;
    newMinQuantityTickSize?: string;
  }
  type Proto = MsgUpdateSpotMarket;
}
/**
 * @category Messages
 */
declare class MsgUpdateSpotMarketV2 extends MsgBase<MsgUpdateSpotMarketV2.Params, MsgUpdateSpotMarketV2.Proto> {
  static fromJSON(params: MsgUpdateSpotMarketV2.Params): MsgUpdateSpotMarketV2;
  toProto(): MsgUpdateSpotMarket;
  toData(): {
    admin: string;
    marketId: string;
    newTicker: string;
    newMinPriceTickSize: string;
    newMinQuantityTickSize: string;
    newMinNotional: string;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      admin: string;
      market_id: string;
      new_ticker: string;
      new_min_notional: string | undefined;
      new_min_price_tick_size: string | undefined;
      new_min_quantity_tick_size: string | undefined;
    };
  };
  toWeb3Gw(): {
    admin: string;
    market_id: string;
    new_ticker: string;
    new_min_notional: string | undefined;
    new_min_price_tick_size: string | undefined;
    new_min_quantity_tick_size: string | undefined;
    '@type': string;
  };
  toEip712(): {
    type: string;
    value: {
      admin: string;
      market_id: string;
      new_ticker: string;
      new_min_notional: string | undefined;
      new_min_price_tick_size: string | undefined;
      new_min_quantity_tick_size: string | undefined;
    };
  };
  toEip712V2(): {
    '@type': string;
    admin: string;
    market_id: string;
    new_ticker: string;
    new_min_price_tick_size: string;
    new_min_quantity_tick_size: string;
    new_min_notional: string;
  };
  toDirectSign(): {
    type: string;
    message: MsgUpdateSpotMarket;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/tokenfactory/msgs/MsgSetDenomMetadata.d.ts
declare namespace MsgSetDenomMetadata {
  interface Params {
    sender: string;
    metadata: Metadata$1;
    adminBurnDisabled?: boolean;
  }
  type Proto = MsgSetDenomMetadata$1;
}
/**
 * @category Messages
 */
declare class MsgSetDenomMetadata extends MsgBase<MsgSetDenomMetadata.Params, MsgSetDenomMetadata.Proto> {
  static fromJSON(params: MsgSetDenomMetadata.Params): MsgSetDenomMetadata;
  toProto(): MsgSetDenomMetadata$1;
  toData(): {
    sender: string;
    metadata?: Metadata$1;
    adminBurnDisabled?: MsgSetDenomMetadata_AdminBurnDisabled;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      admin_burn_disabled?: {
        should_disable: boolean;
      } | undefined;
      sender: string;
      metadata: {
        description: string;
        denom_units: DenomUnit[];
        base: string;
        display: string;
        name: string;
        symbol: string;
        uri: string;
        uri_hash: string;
        decimals: string | number;
      };
    };
  };
  toWeb3Gw(): {
    admin_burn_disabled?: {
      should_disable: boolean;
    } | undefined;
    sender: string;
    metadata: {
      description: string;
      denom_units: DenomUnit[];
      base: string;
      display: string;
      name: string;
      symbol: string;
      uri: string;
      uri_hash: string;
      decimals: string | number;
    };
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgSetDenomMetadata$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/cosmos/distribution/v1beta1/tx_pb.d.ts
/**
 * MsgWithdrawDelegatorReward represents delegation withdrawal to a delegator
 * from a single validator.
 *
 * @generated from protobuf message cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward
 */
interface MsgWithdrawDelegatorReward$1 {
  /**
   * @generated from protobuf field: string delegator_address = 1
   */
  delegatorAddress: string;
  /**
   * @generated from protobuf field: string validator_address = 2
   */
  validatorAddress: string;
}
/**
 * MsgWithdrawValidatorCommission withdraws the full commission to the validator
 * address.
 *
 * @generated from protobuf message cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission
 */
interface MsgWithdrawValidatorCommission$1 {
  /**
   * @generated from protobuf field: string validator_address = 1
   */
  validatorAddress: string;
}
/**
 * MsgFundCommunityPool allows an account to directly
 * fund the community pool.
 *
 * @generated from protobuf message cosmos.distribution.v1beta1.MsgFundCommunityPool
 */
interface MsgFundCommunityPool$1 {
  /**
   * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin amount = 1
   */
  amount: Coin$1[];
  /**
   * @generated from protobuf field: string depositor = 2
   */
  depositor: string;
}
/**
 * @generated MessageType for protobuf message cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward
 */
declare const MsgWithdrawDelegatorReward$1 = new MsgWithdrawDelegatorReward$Type();
/**
 * @generated MessageType for protobuf message cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission
 */
declare const MsgWithdrawValidatorCommission$1 = new MsgWithdrawValidatorCommission$Type();
/**
 * @generated MessageType for protobuf message cosmos.distribution.v1beta1.MsgFundCommunityPool
 */
declare const MsgFundCommunityPool$1 = new MsgFundCommunityPool$Type();
//#endregion
//#region src/core/modules/distribution/msgs/MsgFundCommunityPool.d.ts
declare namespace MsgFundCommunityPool {
  interface Params {
    amount: Coin | Coin[];
    depositor: string;
  }
  type Proto = MsgFundCommunityPool$1;
}
/**
 * @category Messages
 */
declare class MsgFundCommunityPool extends MsgBase<MsgFundCommunityPool.Params, MsgFundCommunityPool.Proto> {
  static fromJSON(params: MsgFundCommunityPool.Params): MsgFundCommunityPool;
  toProto(): MsgFundCommunityPool$1;
  toData(): {
    amount: Coin$1[];
    depositor: string;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      depositor: string;
      amount: Coin$1[];
    };
  };
  toWeb3Gw(): {
    depositor: string;
    amount: Coin$1[];
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgFundCommunityPool$1;
  };
  toBinary(): Uint8Array;
  toEip712Types(): Map<string, TypedDataField[]>;
  toEip712V2(): any;
}
//#endregion
//#region src/core/modules/insurance/msgs/MsgCreateInsuranceFund.d.ts
declare namespace MsgCreateInsuranceFund {
  interface Params {
    fund: {
      ticker: string;
      quoteDenom: string;
      oracleBase: string;
      oracleQuote: string;
      oracleType: OracleType;
      expiry?: number;
    };
    deposit: {
      amount: string;
      denom: string;
    };
    injectiveAddress: string;
  }
  type Proto = MsgCreateInsuranceFund$1;
}
/**
 * @category Messages
 */
declare class MsgCreateInsuranceFund extends MsgBase<MsgCreateInsuranceFund.Params, MsgCreateInsuranceFund.Proto> {
  static fromJSON(params: MsgCreateInsuranceFund.Params): MsgCreateInsuranceFund;
  toProto(): MsgCreateInsuranceFund$1;
  toData(): {
    sender: string;
    ticker: string;
    quoteDenom: string;
    oracleBase: string;
    oracleQuote: string;
    oracleType: OracleType;
    expiry: bigint;
    initialDeposit?: Coin$1;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      sender: string;
      ticker: string;
      quote_denom: string;
      oracle_base: string;
      oracle_quote: string;
      oracle_type: OracleType;
      expiry: string;
      initial_deposit: Coin$1 | undefined;
    };
  };
  toWeb3Gw(): {
    sender: string;
    ticker: string;
    quote_denom: string;
    oracle_base: string;
    oracle_quote: string;
    oracle_type: OracleType;
    expiry: string;
    initial_deposit: Coin$1 | undefined;
    '@type': string;
  };
  toEip712V2(): {
    oracle_type: string;
    sender: string;
    ticker: string;
    quote_denom: string;
    oracle_base: string;
    oracle_quote: string;
    expiry: string;
    initial_deposit: Coin$1 | undefined;
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgCreateInsuranceFund$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/exchange/msgs/MsgAuthorizeStakeGrants.d.ts
declare namespace MsgAuthorizeStakeGrants {
  interface Params {
    grantee: string;
    injectiveAddress: string;
    amount: string;
  }
  type Proto = MsgAuthorizeStakeGrants$1;
}
/**
 * @category Messages
 */
declare class MsgAuthorizeStakeGrants extends MsgBase<MsgAuthorizeStakeGrants.Params, MsgAuthorizeStakeGrants.Proto> {
  static fromJSON(params: MsgAuthorizeStakeGrants.Params): MsgAuthorizeStakeGrants;
  toProto(): MsgAuthorizeStakeGrants$1;
  toData(): {
    sender: string;
    grants: GrantAuthorization$2[];
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      sender: string;
      grants: GrantAuthorization$2[];
    };
  };
  toWeb3Gw(): {
    sender: string;
    grants: GrantAuthorization$2[];
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgAuthorizeStakeGrants$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/exchange/msgs/MsgCreateSpotLimitOrder.d.ts
declare namespace MsgCreateSpotLimitOrder {
  interface Params {
    marketId: string;
    subaccountId: string;
    injectiveAddress: string;
    orderType: OrderType$1;
    triggerPrice?: string;
    feeRecipient: string;
    price: string;
    quantity: string;
    cid?: string;
  }
  type Proto = MsgCreateSpotLimitOrder$1;
}
/**
 * @category Messages
 */
declare class MsgCreateSpotLimitOrder extends MsgBase<MsgCreateSpotLimitOrder.Params, MsgCreateSpotLimitOrder.Proto> {
  static fromJSON(params: MsgCreateSpotLimitOrder.Params): MsgCreateSpotLimitOrder;
  toProto(): MsgCreateSpotLimitOrder$1;
  toData(): {
    sender: string;
    order?: SpotOrder$1;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      sender: string;
      order: {
        market_id: string;
        order_info: {
          subaccount_id: string;
          fee_recipient: string;
          price: string;
          quantity: string;
          cid: string;
        };
        order_type: OrderType$1;
        trigger_price: string;
      };
    };
  };
  toWeb3Gw(): {
    sender: string;
    order: {
      market_id: string;
      order_info: {
        subaccount_id: string;
        fee_recipient: string;
        price: string;
        quantity: string;
        cid: string;
      };
      order_type: OrderType$1;
      trigger_price: string;
    };
    '@type': string;
  };
  toEip712V2(): {
    order: any;
    sender: string;
    '@type': string;
  };
  toEip712(): {
    type: string;
    value: {
      order: {
        order_info: {
          price: any;
          quantity: any;
          subaccount_id: string;
          fee_recipient: string;
          cid: string;
        };
        trigger_price: any;
        market_id: string;
        order_type: OrderType$1;
      };
      sender: string;
    };
  };
  toDirectSign(): {
    type: string;
    message: MsgCreateSpotLimitOrder$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/exchange/msgs/MsgCancelPostOnlyModeV2.d.ts
declare namespace MsgCancelPostOnlyModeV2 {
  interface Params {
    sender: string;
  }
  type Proto = MsgCancelPostOnlyMode;
}
/**
 * @category Messages
 */
declare class MsgCancelPostOnlyModeV2 extends MsgBase<MsgCancelPostOnlyModeV2.Params, MsgCancelPostOnlyModeV2.Proto> {
  static fromJSON(params: MsgCancelPostOnlyModeV2.Params): MsgCancelPostOnlyModeV2;
  toProto(): MsgCancelPostOnlyMode;
  toData(): {
    sender: string;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      sender: string;
    };
  };
  toWeb3Gw(): {
    sender: string;
    '@type': string;
  };
  toEip712(): {
    type: string;
    value: {
      sender: string;
    };
  };
  toEip712V2(): {
    sender: string;
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgCancelPostOnlyMode;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/authz/msgs/authorizations/Base.d.ts
declare abstract class BaseAuthorization<Params$18, Proto, DataRepresentation> {
  params: Params$18;
  constructor(params: Params$18);
  abstract toAny(): Any;
  abstract toAmino(): DataRepresentation;
  abstract toWeb3(): DataRepresentation;
  abstract toProto(): Proto;
}
//#endregion
//#region src/core/modules/authz/msgs/MsgGrantWithAuthorization.d.ts
declare namespace MsgGrantWithAuthorization {
  interface Params {
    authorization: BaseAuthorization<unknown, unknown, unknown>;
    grantee: string;
    granter: string;
    expiration?: number;
    expiryInYears?: number;
    expiryInSeconds?: number;
  }
  type Proto = MsgGrant$1;
  type Object = Omit<MsgGrant$1, 'msgs'> & {
    msgs: any;
  };
}
/**
 * @category Messages
 */
declare class MsgGrantWithAuthorization extends MsgBase<MsgGrantWithAuthorization.Params, MsgGrantWithAuthorization.Proto> {
  static fromJSON(params: MsgGrantWithAuthorization.Params): MsgGrantWithAuthorization;
  toProto(): MsgGrant$1;
  toData(): {
    granter: string;
    grantee: string;
    grant?: Grant;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: MsgGrantWithAuthorization.Object;
  };
  toDirectSign(): {
    type: string;
    message: MsgGrant$1;
  };
  toWeb3Gw(): {
    granter: string;
    grantee: string;
    grant: {
      authorization: unknown;
      expiration: string;
    };
    '@type': string;
  };
  toEip712(): never;
  private getTimestamp;
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/exchange/msgs/MsgBatchCancelSpotOrders.d.ts
declare namespace MsgBatchCancelSpotOrders {
  interface Params {
    injectiveAddress: string;
    orders: {
      marketId: string;
      subaccountId: string;
      orderHash?: string;
      orderMask?: OrderMask;
      cid?: string;
    }[];
  }
  type Proto = MsgBatchCancelSpotOrders$1;
}
/**
 * @category Messages
 */
declare class MsgBatchCancelSpotOrders extends MsgBase<MsgBatchCancelSpotOrders.Params, MsgBatchCancelSpotOrders.Proto> {
  static fromJSON(params: MsgBatchCancelSpotOrders.Params): MsgBatchCancelSpotOrders;
  toProto(): MsgBatchCancelSpotOrders$1;
  toData(): {
    sender: string;
    data: OrderData[];
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      sender: string;
      data: {
        market_id: string;
        subaccount_id: string;
        order_hash: string;
        order_mask: number;
        cid: string;
      }[];
    };
  };
  toWeb3Gw(): {
    sender: string;
    data: {
      market_id: string;
      subaccount_id: string;
      order_hash: string;
      order_mask: number;
      cid: string;
    }[];
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgBatchCancelSpotOrders$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/exchange/msgs/MsgCancelDerivativeOrder.d.ts
declare namespace MsgCancelDerivativeOrder {
  interface Params {
    marketId: string;
    subaccountId: string;
    injectiveAddress: string;
    orderHash?: string;
    orderMask?: OrderMask;
    cid?: string;
  }
  type Proto = MsgCancelDerivativeOrder$1;
}
declare class MsgCancelDerivativeOrder extends MsgBase<MsgCancelDerivativeOrder.Params, MsgCancelDerivativeOrder.Proto> {
  static fromJSON(params: MsgCancelDerivativeOrder.Params): MsgCancelDerivativeOrder;
  toProto(): MsgCancelDerivativeOrder$1;
  toData(): {
    sender: string;
    marketId: string;
    subaccountId: string;
    orderHash: string;
    orderMask: number;
    cid: string;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      sender: string;
      market_id: string;
      subaccount_id: string;
      order_hash: string;
      order_mask: number;
      cid: string;
    };
  };
  toWeb3Gw(): {
    sender: string;
    market_id: string;
    subaccount_id: string;
    order_hash: string;
    order_mask: number;
    cid: string;
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgCancelDerivativeOrder$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/exchange/msgs/MsgCreateSpotMarketOrder.d.ts
declare namespace MsgCreateSpotMarketOrder {
  interface Params {
    marketId: string;
    subaccountId: string;
    injectiveAddress: string;
    orderType: OrderType$1;
    triggerPrice?: string;
    feeRecipient: string;
    price: string;
    quantity: string;
    cid?: string;
  }
  type Proto = MsgCreateSpotMarketOrder$1;
}
/**
 * @category Messages
 */
declare class MsgCreateSpotMarketOrder extends MsgBase<MsgCreateSpotMarketOrder.Params, MsgCreateSpotMarketOrder.Proto> {
  static fromJSON(params: MsgCreateSpotMarketOrder.Params): MsgCreateSpotMarketOrder;
  toProto(): MsgCreateSpotMarketOrder$1;
  toData(): {
    sender: string;
    order?: SpotOrder$1;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      sender: string;
      order: {
        market_id: string;
        order_info: {
          subaccount_id: string;
          fee_recipient: string;
          price: string;
          quantity: string;
          cid: string;
        };
        order_type: OrderType$1;
        trigger_price: string;
      };
    };
  };
  toWeb3Gw(): {
    sender: string;
    order: {
      market_id: string;
      order_info: {
        subaccount_id: string;
        fee_recipient: string;
        price: string;
        quantity: string;
        cid: string;
      };
      order_type: OrderType$1;
      trigger_price: string;
    };
    '@type': string;
  };
  toEip712V2(): {
    order: any;
    sender: string;
    '@type': string;
  };
  toEip712(): {
    type: string;
    value: {
      order: {
        order_info: {
          price: any;
          quantity: any;
          subaccount_id: string;
          fee_recipient: string;
          cid: string;
        };
        trigger_price: any;
        market_id: string;
        order_type: OrderType$1;
      };
      sender: string;
    };
  };
  toDirectSign(): {
    type: string;
    message: MsgCreateSpotMarketOrder$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/exchange/msgs/MsgIncreasePositionMargin.d.ts
declare namespace MsgIncreasePositionMargin {
  interface Params {
    marketId: string;
    injectiveAddress: string;
    srcSubaccountId: string;
    dstSubaccountId: string;
    amount: string;
  }
  type Proto = MsgIncreasePositionMargin$1;
}
/**
 * @category Messages
 */
declare class MsgIncreasePositionMargin extends MsgBase<MsgIncreasePositionMargin.Params, MsgIncreasePositionMargin.Proto> {
  static fromJSON(params: MsgIncreasePositionMargin.Params): MsgIncreasePositionMargin;
  toProto(): MsgIncreasePositionMargin$1;
  toData(): {
    sender: string;
    sourceSubaccountId: string;
    destinationSubaccountId: string;
    marketId: string;
    amount: string;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      sender: string;
      source_subaccount_id: string;
      destination_subaccount_id: string;
      market_id: string;
      amount: string;
    };
  };
  toWeb3Gw(): {
    sender: string;
    source_subaccount_id: string;
    destination_subaccount_id: string;
    market_id: string;
    amount: string;
    '@type': string;
  };
  toEip712(): {
    type: string;
    value: {
      amount: any;
      sender: string;
      source_subaccount_id: string;
      destination_subaccount_id: string;
      market_id: string;
    };
  };
  toEip712V2(): {
    amount: string;
    sender: string;
    source_subaccount_id: string;
    destination_subaccount_id: string;
    market_id: string;
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgIncreasePositionMargin$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/exchange/msgs/MsgInstantSpotMarketLaunch.d.ts
declare namespace MsgInstantSpotMarketLaunch {
  interface Params {
    proposer: string;
    market: {
      sender: string;
      ticker: string;
      baseDenom: string;
      quoteDenom: string;
      minNotional: string;
      baseDecimals: number;
      quoteDecimals: number;
      minPriceTickSize: string;
      minQuantityTickSize: string;
    };
  }
  type Proto = MsgInstantSpotMarketLaunch$1;
}
/**
 * @category Messages
 */
declare class MsgInstantSpotMarketLaunch extends MsgBase<MsgInstantSpotMarketLaunch.Params, MsgInstantSpotMarketLaunch.Proto> {
  static fromJSON(params: MsgInstantSpotMarketLaunch.Params): MsgInstantSpotMarketLaunch;
  toProto(): MsgInstantSpotMarketLaunch$1;
  toData(): {
    sender: string;
    ticker: string;
    baseDenom: string;
    quoteDenom: string;
    minPriceTickSize: string;
    minQuantityTickSize: string;
    minNotional: string;
    baseDecimals: number;
    quoteDecimals: number;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      sender: string;
      ticker: string;
      base_denom: string;
      quote_denom: string;
      min_price_tick_size: string;
      min_quantity_tick_size: string;
      min_notional: string;
      base_decimals: number;
      quote_decimals: number;
    };
  };
  toWeb3Gw(): {
    sender: string;
    ticker: string;
    base_denom: string;
    quote_denom: string;
    min_price_tick_size: string;
    min_quantity_tick_size: string;
    min_notional: string;
    base_decimals: number;
    quote_decimals: number;
    '@type': string;
  };
  toEip712(): {
    type: string;
    value: {
      min_price_tick_size: any;
      min_quantity_tick_size: any;
      min_notional: any;
      sender: string;
      ticker: string;
      base_denom: string;
      quote_denom: string;
      base_decimals: number;
      quote_decimals: number;
    };
  };
  toEip712V2(): {
    min_price_tick_size: string;
    min_quantity_tick_size: string;
    min_notional: string;
    sender: string;
    ticker: string;
    base_denom: string;
    quote_denom: string;
    base_decimals: number;
    quote_decimals: number;
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgInstantSpotMarketLaunch$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/exchange/msgs/MsgCancelBinaryOptionsOrder.d.ts
declare namespace MsgCancelBinaryOptionsOrder {
  interface Params {
    marketId: string;
    subaccountId: string;
    injectiveAddress: string;
    orderHash?: string;
    orderMask?: OrderMask;
    cid?: string;
  }
  type Proto = MsgCancelBinaryOptionsOrder$1;
}
/**
 * @category Messages
 */
declare class MsgCancelBinaryOptionsOrder extends MsgBase<MsgCancelBinaryOptionsOrder.Params, MsgCancelBinaryOptionsOrder.Proto> {
  static fromJSON(params: MsgCancelBinaryOptionsOrder.Params): MsgCancelBinaryOptionsOrder;
  toProto(): MsgCancelBinaryOptionsOrder$1;
  toData(): {
    sender: string;
    marketId: string;
    subaccountId: string;
    orderHash: string;
    orderMask: number;
    cid: string;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      sender: string;
      market_id: string;
      subaccount_id: string;
      order_hash: string;
      order_mask: number;
      cid: string;
    };
  };
  toWeb3Gw(): {
    sender: string;
    market_id: string;
    subaccount_id: string;
    order_hash: string;
    order_mask: number;
    cid: string;
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgCancelBinaryOptionsOrder$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/exchange/msgs/MsgUpdateDerivativeMarketV2.d.ts
declare namespace MsgUpdateDerivativeMarketV2 {
  interface Params {
    admin: string;
    marketId: string;
    newTicker?: string;
    newMinNotional?: string;
    newMinPriceTickSize?: string;
    newMinQuantityTickSize?: string;
    newInitialMarginRatio?: string;
    newMaintenanceMarginRatio?: string;
    newReduceMarginRatio?: string;
  }
  type Proto = MsgUpdateDerivativeMarket;
}
/**
 * @category Messages
 */
declare class MsgUpdateDerivativeMarketV2 extends MsgBase<MsgUpdateDerivativeMarketV2.Params, MsgUpdateDerivativeMarketV2.Proto> {
  static fromJSON(params: MsgUpdateDerivativeMarketV2.Params): MsgUpdateDerivativeMarketV2;
  toProto(): MsgUpdateDerivativeMarket;
  toData(): {
    admin: string;
    marketId: string;
    newTicker: string;
    newMinPriceTickSize: string;
    newMinQuantityTickSize: string;
    newMinNotional: string;
    newInitialMarginRatio: string;
    newMaintenanceMarginRatio: string;
    newReduceMarginRatio: string;
    newOpenNotionalCap?: OpenNotionalCap$1;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      admin: string;
      market_id: string;
      new_ticker: string;
      new_min_notional: string | undefined;
      new_min_price_tick_size: string | undefined;
      new_min_quantity_tick_size: string | undefined;
      new_initial_margin_ratio: string | undefined;
      new_maintenance_margin_ratio: string | undefined;
      new_reduce_margin_ratio: string | undefined;
    };
  };
  toWeb3Gw(): {
    admin: string;
    market_id: string;
    new_ticker: string;
    new_min_notional: string | undefined;
    new_min_price_tick_size: string | undefined;
    new_min_quantity_tick_size: string | undefined;
    new_initial_margin_ratio: string | undefined;
    new_maintenance_margin_ratio: string | undefined;
    new_reduce_margin_ratio: string | undefined;
    '@type': string;
  };
  toEip712(): {
    type: string;
    value: {
      admin: string;
      market_id: string;
      new_ticker: string;
      new_min_notional: string | undefined;
      new_min_price_tick_size: string | undefined;
      new_min_quantity_tick_size: string | undefined;
      new_initial_margin_ratio: string | undefined;
      new_maintenance_margin_ratio: string | undefined;
      new_reduce_margin_ratio: string | undefined;
    };
  };
  toEip712V2(): {
    '@type': string;
    admin: string;
    market_id: string;
    new_ticker: string;
    new_min_price_tick_size: string;
    new_min_quantity_tick_size: string;
    new_min_notional: string;
    new_initial_margin_ratio: string;
    new_maintenance_margin_ratio: string;
    new_reduce_margin_ratio: string;
    new_open_notional_cap: {};
  };
  toDirectSign(): {
    type: string;
    message: MsgUpdateDerivativeMarket;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/staking/msgs/MsgCancelUnbondingDelegation.d.ts
declare namespace MsgCancelUnbondingDelegation {
  interface Params {
    amount: {
      denom: string;
      amount: string;
    };
    validatorAddress: string;
    delegatorAddress: string;
    creationHeight: string;
  }
  type Proto = MsgCancelUnbondingDelegation$1;
}
/**
 * @category Messages
 */
declare class MsgCancelUnbondingDelegation extends MsgBase<MsgCancelUnbondingDelegation.Params, MsgCancelUnbondingDelegation.Proto> {
  static fromJSON(params: MsgCancelUnbondingDelegation.Params): MsgCancelUnbondingDelegation;
  toProto(): MsgCancelUnbondingDelegation$1;
  toData(): {
    delegatorAddress: string;
    validatorAddress: string;
    amount?: Coin$1;
    creationHeight: bigint;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      delegator_address: string;
      validator_address: string;
      amount: Coin$1 | undefined;
      creation_height: string;
    };
  };
  toWeb3Gw(): {
    delegator_address: string;
    validator_address: string;
    amount: Coin$1 | undefined;
    creation_height: string;
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgCancelUnbondingDelegation$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/distribution/msgs/MsgWithdrawDelegatorReward.d.ts
declare namespace MsgWithdrawDelegatorReward {
  interface Params {
    delegatorAddress: string;
    validatorAddress: string;
  }
  type Proto = MsgWithdrawDelegatorReward$1;
}
/**
 * @category Messages
 */
declare class MsgWithdrawDelegatorReward extends MsgBase<MsgWithdrawDelegatorReward.Params, MsgWithdrawDelegatorReward.Proto> {
  static fromJSON(params: MsgWithdrawDelegatorReward.Params): MsgWithdrawDelegatorReward;
  toProto(): MsgWithdrawDelegatorReward$1;
  toData(): {
    delegatorAddress: string;
    validatorAddress: string;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      delegator_address: string;
      validator_address: string;
    };
  };
  toWeb3Gw(): {
    delegator_address: string;
    validator_address: string;
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgWithdrawDelegatorReward$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/exchange/msgs/MsgCreateDerivativeLimitOrder.d.ts
declare namespace MsgCreateDerivativeLimitOrder {
  interface Params {
    marketId: string;
    subaccountId: string;
    injectiveAddress: string;
    orderType: OrderType$1;
    triggerPrice?: string;
    feeRecipient: string;
    price: string;
    margin: string;
    quantity: string;
    cid?: string;
  }
  type Proto = MsgCreateDerivativeLimitOrder$1;
}
/**
 * @category Messages
 */
declare class MsgCreateDerivativeLimitOrder extends MsgBase<MsgCreateDerivativeLimitOrder.Params, MsgCreateDerivativeLimitOrder.Proto> {
  static fromJSON(params: MsgCreateDerivativeLimitOrder.Params): MsgCreateDerivativeLimitOrder;
  toProto(): MsgCreateDerivativeLimitOrder$1;
  toData(): {
    sender: string;
    order?: DerivativeOrder$1;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      sender: string;
      order: {
        market_id: string;
        order_info: {
          subaccount_id: string;
          fee_recipient: string;
          price: string;
          quantity: string;
          cid: string;
        };
        order_type: OrderType$1;
        margin: string;
        trigger_price: string;
      };
    };
  };
  toWeb3Gw(): {
    sender: string;
    order: {
      market_id: string;
      order_info: {
        subaccount_id: string;
        fee_recipient: string;
        price: string;
        quantity: string;
        cid: string;
      };
      order_type: OrderType$1;
      margin: string;
      trigger_price: string;
    };
    '@type': string;
  };
  toEip712V2(): {
    order: any;
    sender: string;
    '@type': string;
  };
  toEip712(): {
    type: string;
    value: {
      order: {
        order_info: {
          price: any;
          quantity: any;
          subaccount_id: string;
          fee_recipient: string;
          cid: string;
        };
        margin: any;
        trigger_price: any;
        market_id: string;
        order_type: OrderType$1;
      };
      sender: string;
    };
  };
  toDirectSign(): {
    type: string;
    message: MsgCreateDerivativeLimitOrder$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/exchange/msgs/MsgBatchCancelDerivativeOrders.d.ts
declare namespace MsgBatchCancelDerivativeOrders {
  interface Params {
    injectiveAddress: string;
    orders: {
      marketId: string;
      subaccountId: string;
      orderHash?: string;
      orderMask?: OrderMask;
      cid?: string;
    }[];
  }
  type Proto = MsgBatchCancelDerivativeOrders$1;
}
/**
 * @category Messages
 */
declare class MsgBatchCancelDerivativeOrders extends MsgBase<MsgBatchCancelDerivativeOrders.Params, MsgBatchCancelDerivativeOrders.Proto> {
  static fromJSON(params: MsgBatchCancelDerivativeOrders.Params): MsgBatchCancelDerivativeOrders;
  toProto(): MsgBatchCancelDerivativeOrders$1;
  toData(): {
    sender: string;
    data: OrderData[];
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      sender: string;
      data: {
        market_id: string;
        subaccount_id: string;
        order_hash: string;
        order_mask: number;
        cid: string;
      }[];
    };
  };
  toWeb3Gw(): {
    sender: string;
    data: {
      market_id: string;
      subaccount_id: string;
      order_hash: string;
      order_mask: number;
      cid: string;
    }[];
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgBatchCancelDerivativeOrders$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/exchange/msgs/MsgCreateDerivativeMarketOrder.d.ts
declare namespace MsgCreateDerivativeMarketOrder {
  interface Params {
    marketId: string;
    subaccountId: string;
    injectiveAddress: string;
    orderType: OrderType$1;
    triggerPrice?: string;
    feeRecipient: string;
    price: string;
    margin: string;
    quantity: string;
    cid?: string;
  }
  type Proto = MsgCreateDerivativeMarketOrder$1;
}
/**
 * @category Messages
 */
declare class MsgCreateDerivativeMarketOrder extends MsgBase<MsgCreateDerivativeMarketOrder.Params, MsgCreateDerivativeMarketOrder.Proto> {
  static fromJSON(params: MsgCreateDerivativeMarketOrder.Params): MsgCreateDerivativeMarketOrder;
  toProto(): MsgCreateDerivativeMarketOrder$1;
  toData(): {
    sender: string;
    order?: DerivativeOrder$1;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      sender: string;
      order: {
        market_id: string;
        order_info: {
          subaccount_id: string;
          fee_recipient: string;
          price: string;
          quantity: string;
          cid: string;
        };
        order_type: OrderType$1;
        margin: string;
        trigger_price: string;
      };
    };
  };
  toWeb3Gw(): {
    sender: string;
    order: {
      market_id: string;
      order_info: {
        subaccount_id: string;
        fee_recipient: string;
        price: string;
        quantity: string;
        cid: string;
      };
      order_type: OrderType$1;
      margin: string;
      trigger_price: string;
    };
    '@type': string;
  };
  toEip712V2(): {
    order: any;
    sender: string;
    '@type': string;
  };
  toEip712(): {
    type: string;
    value: {
      order: {
        order_info: {
          price: any;
          quantity: any;
          subaccount_id: string;
          fee_recipient: string;
          cid: string;
        };
        margin: any;
        trigger_price: any;
        market_id: string;
        order_type: OrderType$1;
      };
      sender: string;
    };
  };
  toDirectSign(): {
    type: string;
    message: MsgCreateDerivativeMarketOrder$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/distribution/msgs/MsgWithdrawValidatorCommission.d.ts
declare namespace MsgWithdrawValidatorCommission {
  interface Params {
    validatorAddress: string;
  }
  type Proto = MsgWithdrawValidatorCommission$1;
}
/**
 * @category Messages
 */
declare class MsgWithdrawValidatorCommission extends MsgBase<MsgWithdrawValidatorCommission.Params, MsgWithdrawValidatorCommission.Proto> {
  static fromJSON(params: MsgWithdrawValidatorCommission.Params): MsgWithdrawValidatorCommission;
  toProto(): MsgWithdrawValidatorCommission$1;
  toData(): {
    validatorAddress: string;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      validator_address: string;
    };
  };
  toWeb3Gw(): {
    validator_address: string;
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgWithdrawValidatorCommission$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/exchange/msgs/MsgCreateBinaryOptionsLimitOrder.d.ts
declare namespace MsgCreateBinaryOptionsLimitOrder {
  interface Params {
    marketId: string;
    subaccountId: string;
    injectiveAddress: string;
    orderType: OrderType$1;
    triggerPrice?: string;
    feeRecipient: string;
    price: string;
    margin: string;
    quantity: string;
    cid?: string;
  }
  type Proto = MsgCreateBinaryOptionsLimitOrder$1;
}
/**
 * @category Messages
 */
declare class MsgCreateBinaryOptionsLimitOrder extends MsgBase<MsgCreateBinaryOptionsLimitOrder.Params, MsgCreateBinaryOptionsLimitOrder.Proto> {
  static fromJSON(params: MsgCreateBinaryOptionsLimitOrder.Params): MsgCreateBinaryOptionsLimitOrder;
  toProto(): MsgCreateBinaryOptionsLimitOrder$1;
  toData(): {
    sender: string;
    order?: DerivativeOrder$1;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      sender: string;
      order: {
        market_id: string;
        order_info: {
          subaccount_id: string;
          fee_recipient: string;
          price: string;
          quantity: string;
          cid: string;
        };
        order_type: OrderType$1;
        margin: string;
        trigger_price: string;
      };
    };
  };
  toWeb3Gw(): {
    sender: string;
    order: {
      market_id: string;
      order_info: {
        subaccount_id: string;
        fee_recipient: string;
        price: string;
        quantity: string;
        cid: string;
      };
      order_type: OrderType$1;
      margin: string;
      trigger_price: string;
    };
    '@type': string;
  };
  toEip712V2(): {
    order: any;
    sender: string;
    '@type': string;
  };
  toEip712(): {
    type: string;
    value: {
      order: {
        order_info: {
          price: any;
          quantity: any;
          subaccount_id: string;
          fee_recipient: string;
          cid: string;
        };
        margin: any;
        trigger_price: any;
        market_id: string;
        order_type: OrderType$1;
      };
      sender: string;
    };
  };
  toDirectSign(): {
    type: string;
    message: MsgCreateBinaryOptionsLimitOrder$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/client/chain/types/gov.d.ts
interface GovModuleStateParams {
  votingParams: {
    votingPeriod: number;
    expeditedVotingPeriod: number;
  };
  tallyParams: {
    quorum: string;
    threshold: string;
    vetoThreshold: string;
    expeditedThreshold: string;
  };
  depositParams: {
    minDeposit: Coin[];
    maxDepositPeriod: number;
    expeditedMinDeposit: Coin[];
  };
}
interface Proposal {
  proposalId: number;
  title: string;
  summary: string;
  proposer: string;
  content: any;
  type: string;
  status: ProposalStatus$1;
  expedited: boolean;
  failedReason: string;
  submitTime: number;
  finalTallyResult: GrpcTallyResult | undefined;
  totalDeposits: Coin[];
  votingStartTime: number;
  votingEndTime: number;
  depositEndTime: number;
}
type WeightedVoteOption = {
  option: VoteOption$1;
  weight: string;
};
type Vote = {
  proposalId: number;
  voter: string;
  options: WeightedVoteOption[];
  metadata: string;
};
type TallyResult = {
  yesCount: string;
  abstainCount: string;
  noCount: string;
  noWithVetoCount: string;
};
type ProposalDeposit = {
  depositor: string;
  amounts: Coin[];
};
type GrpcProposal = Proposal$1;
type GrpcProposalDeposit = Deposit;
type GrpcGovernanceTallyParams = Params$13;
type GrpcGovernanceVotingParams = Params$13;
type GrpcGovernanceDepositParams = Params$13;
type GrpcTallyResult = TallyResult$1;
type GrpcVote = Vote$1;
type VoteOption = VoteOption$1;
type ProposalStatus = ProposalStatus$1;
declare const VoteOptionMap: typeof VoteOption$1;
declare const ProposalStatusMap: typeof ProposalStatus$1;
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/cosmos/base/query/v1beta1/pagination_pb.d.ts
/**
 * PageRequest is to be embedded in gRPC request messages for efficient
 * pagination. Ex:
 *
 *  message SomeRequest {
 *          Foo some_parameter = 1;
 *          PageRequest pagination = 2;
 *  }
 *
 * @generated from protobuf message cosmos.base.query.v1beta1.PageRequest
 */
interface PageRequest {
  /**
   * key is a value returned in PageResponse.next_key to begin
   * querying the next page most efficiently. Only one of offset or key
   * should be set.
   *
   * @generated from protobuf field: bytes key = 1
   */
  key: Uint8Array;
  /**
   * offset is a numeric offset that can be used when key is unavailable.
   * It is less efficient than using key. Only one of offset or key should
   * be set.
   *
   * @generated from protobuf field: uint64 offset = 2
   */
  offset: bigint;
  /**
   * limit is the total number of results to be returned in the result page.
   * If left empty it will default to a value to be set by each app.
   *
   * @generated from protobuf field: uint64 limit = 3
   */
  limit: bigint;
  /**
   * count_total is set to true  to indicate that the result set should include
   * a count of the total number of items available for pagination in UIs.
   * count_total is only respected when offset is used. It is ignored when key
   * is set.
   *
   * @generated from protobuf field: bool count_total = 4
   */
  countTotal: boolean;
  /**
   * reverse is set to true if results are to be returned in the descending order.
   *
   * Since: cosmos-sdk 0.43
   *
   * @generated from protobuf field: bool reverse = 5
   */
  reverse: boolean;
}
/**
 * PageResponse is to be embedded in gRPC response messages where the
 * corresponding request message has used PageRequest.
 *
 *  message SomeResponse {
 *          repeated Bar results = 1;
 *          PageResponse page = 2;
 *  }
 *
 * @generated from protobuf message cosmos.base.query.v1beta1.PageResponse
 */
interface PageResponse {
  /**
   * next_key is the key to be passed to PageRequest.key to
   * query the next page most efficiently. It will be empty if
   * there are no more results.
   *
   * @generated from protobuf field: bytes next_key = 1
   */
  nextKey: Uint8Array;
  /**
   * total is total number of results available if PageRequest.count_total
   * was set, its value is undefined otherwise
   *
   * @generated from protobuf field: uint64 total = 2
   */
  total: bigint;
}
/**
 * @generated MessageType for protobuf message cosmos.base.query.v1beta1.PageRequest
 */
declare const PageRequest = new PageRequest$Type();
/**
 * @generated MessageType for protobuf message cosmos.base.query.v1beta1.PageResponse
 */
declare const PageResponse = new PageResponse$Type();
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/cosmwasm/wasm/v1/query_pb.d.ts
/**
 * QueryContractHistoryResponse is the response type for the
 * Query/ContractHistory RPC method
 *
 * @generated from protobuf message cosmwasm.wasm.v1.QueryContractHistoryResponse
 */
interface QueryContractHistoryResponse {
  /**
   * @generated from protobuf field: repeated cosmwasm.wasm.v1.ContractCodeHistoryEntry entries = 1
   */
  entries: ContractCodeHistoryEntry$1[];
  /**
   * pagination defines the pagination in the response.
   *
   * @generated from protobuf field: cosmos.base.query.v1beta1.PageResponse pagination = 2
   */
  pagination?: PageResponse;
}
/**
 * QueryContractsByCodeResponse is the response type for the
 * Query/ContractsByCode RPC method
 *
 * @generated from protobuf message cosmwasm.wasm.v1.QueryContractsByCodeResponse
 */
interface QueryContractsByCodeResponse {
  /**
   * contracts are a set of contract addresses
   *
   * @generated from protobuf field: repeated string contracts = 1
   */
  contracts: string[];
  /**
   * pagination defines the pagination in the response.
   *
   * @generated from protobuf field: cosmos.base.query.v1beta1.PageResponse pagination = 2
   */
  pagination?: PageResponse;
}
/**
 * QueryAllContractStateResponse is the response type for the
 * Query/AllContractState RPC method
 *
 * @generated from protobuf message cosmwasm.wasm.v1.QueryAllContractStateResponse
 */
interface QueryAllContractStateResponse {
  /**
   * @generated from protobuf field: repeated cosmwasm.wasm.v1.Model models = 1
   */
  models: Model[];
  /**
   * pagination defines the pagination in the response.
   *
   * @generated from protobuf field: cosmos.base.query.v1beta1.PageResponse pagination = 2
   */
  pagination?: PageResponse;
}
/**
 * QueryRawContractStateResponse is the response type for the
 * Query/RawContractState RPC method
 *
 * @generated from protobuf message cosmwasm.wasm.v1.QueryRawContractStateResponse
 */
interface QueryRawContractStateResponse {
  /**
   * Data contains the raw store data
   *
   * @generated from protobuf field: bytes data = 1
   */
  data: Uint8Array;
}
/**
 * QuerySmartContractStateResponse is the response type for the
 * Query/SmartContractState RPC method
 *
 * @generated from protobuf message cosmwasm.wasm.v1.QuerySmartContractStateResponse
 */
interface QuerySmartContractStateResponse {
  /**
   * Data contains the json data returned from the smart contract
   *
   * @generated from protobuf field: bytes data = 1
   */
  data: Uint8Array;
}
/**
 * CodeInfoResponse contains code meta data from CodeInfo
 *
 * @generated from protobuf message cosmwasm.wasm.v1.CodeInfoResponse
 */
interface CodeInfoResponse$1 {
  /**
   * @generated from protobuf field: uint64 code_id = 1
   */
  codeId: bigint; // id for legacy support
  /**
   * @generated from protobuf field: string creator = 2
   */
  creator: string;
  /**
   * @generated from protobuf field: bytes data_hash = 3
   */
  dataHash: Uint8Array;
  /**
   * @generated from protobuf field: cosmwasm.wasm.v1.AccessConfig instantiate_permission = 6
   */
  instantiatePermission?: AccessConfig;
}
/**
 * QueryCodeResponse is the response type for the Query/Code RPC method
 *
 * @generated from protobuf message cosmwasm.wasm.v1.QueryCodeResponse
 */
interface QueryCodeResponse {
  /**
   * @generated from protobuf field: cosmwasm.wasm.v1.CodeInfoResponse code_info = 1
   */
  codeInfo?: CodeInfoResponse$1;
  /**
   * @generated from protobuf field: bytes data = 2
   */
  data: Uint8Array;
}
/**
 * QueryCodesResponse is the response type for the Query/Codes RPC method
 *
 * @generated from protobuf message cosmwasm.wasm.v1.QueryCodesResponse
 */
interface QueryCodesResponse {
  /**
   * @generated from protobuf field: repeated cosmwasm.wasm.v1.CodeInfoResponse code_infos = 1
   */
  codeInfos: CodeInfoResponse$1[];
  /**
   * pagination defines the pagination in the response.
   *
   * @generated from protobuf field: cosmos.base.query.v1beta1.PageResponse pagination = 2
   */
  pagination?: PageResponse;
}
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.QueryContractHistoryResponse
 */
declare const QueryContractHistoryResponse = new QueryContractHistoryResponse$Type();
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.QueryContractsByCodeResponse
 */
declare const QueryContractsByCodeResponse = new QueryContractsByCodeResponse$Type();
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.QueryAllContractStateResponse
 */
declare const QueryAllContractStateResponse = new QueryAllContractStateResponse$Type();
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.QueryRawContractStateResponse
 */
declare const QueryRawContractStateResponse = new QueryRawContractStateResponse$Type();
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.QuerySmartContractStateResponse
 */
declare const QuerySmartContractStateResponse = new QuerySmartContractStateResponse$Type();
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.CodeInfoResponse
 */
declare const CodeInfoResponse$1 = new CodeInfoResponse$Type();
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.QueryCodeResponse
 */
declare const QueryCodeResponse = new QueryCodeResponse$Type();
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.QueryCodesResponse
 */
declare const QueryCodesResponse = new QueryCodesResponse$Type();
//#endregion
//#region src/client/chain/types/wasm.d.ts
interface AbsoluteTxPosition {
  blockHeight: number;
  txIndex: number;
}
interface GoogleProtoBufAny {
  typeUrl: string;
  value: Uint8Array | string;
}
interface ContractAccountBalance {
  account: string;
  balance: string;
}
interface ContractInfo {
  codeId: number;
  creator: string;
  admin: string;
  label: string;
  created?: AbsoluteTxPosition;
  ibcPortId: string;
  extension?: GoogleProtoBufAny;
}
interface TokenInfo$1 {
  name: string;
  symbol: string;
  decimals: number;
  total_supply: string;
  mint: string;
}
interface MarketingInfo {
  project: string;
  description: string;
  logo: {
    url: string;
  };
  marketing: string;
}
interface ContractAccountsBalanceWithPagination {
  tokenInfo: TokenInfo$1;
  contractInfo: ContractInfo;
  marketingInfo: MarketingInfo;
  contractAccountsBalance: ContractAccountBalance[];
  pagination?: Pagination;
}
interface ContractStateWithPagination {
  tokenInfo: TokenInfo$1;
  contractInfo: ContractInfo;
  marketingInfo: MarketingInfo;
  contractAccountsBalance: ContractAccountBalance[];
  pagination?: Pagination;
}
interface AbsoluteTxPosition {
  blockHeight: number;
  txIndex: number;
}
interface ContractCodeHistoryEntry {
  operation: ContractCodeHistoryOperationType$1;
  codeId: number;
  updated?: AbsoluteTxPosition;
  msg: Uint8Array | string;
}
interface CodeInfoResponse {
  codeId: number;
  creator: string;
  dataHash: Uint8Array | string;
}
type GrpcCodeInfoResponse = CodeInfoResponse$1;
type grpcContractInfo = ContractInfo$1;
type GrpcContractInfo = ContractInfo$1;
type GrpcContractCodeHistoryEntry = ContractCodeHistoryEntry$1;
type GrpcAbsoluteTxPosition = AbsoluteTxPosition$1;
type ContractCodeHistoryOperationType = ContractCodeHistoryOperationType$1;
declare const ContractCodeHistoryOperationTypeMap: typeof ContractCodeHistoryOperationType$1;
//#endregion
//#region src/client/chain/types/staking.d.ts
interface StakingModuleParams extends Omit<GrpcStakingParams, 'unbondingTime'> {
  unbondingTime: number;
}
interface Delegation {
  delegation: {
    delegatorAddress: string;
    validatorAddress: string;
    shares: string;
  };
  balance: {
    denom: string;
    amount: string;
  };
}
interface ReDelegation {
  delegation: {
    delegatorAddress: string;
    sourceValidatorAddress: string;
    completionTime: number;
    destinationValidatorAddress: string;
  };
  balance: string;
}
interface UnBondingDelegation {
  delegatorAddress: string;
  validatorAddress: string;
  creationHeight: number;
  completionTime: number;
  initialBalance: string;
  balance: string;
}
interface Pool {
  notBondedTokens: string;
  bondedTokens: string;
}
type BondStatus = 'UnBonded' | 'UnBonding' | 'Bonded';
declare const BondStatus: {
  readonly UnBonded: "UnBonded";
  readonly UnBonding: "UnBonding";
  readonly Bonded: "Bonded";
};
interface ValidatorDescription {
  moniker: string;
  identity: string;
  website: string;
  securityContact: string;
  details: string;
}
interface ValidatorCommission {
  commissionRates: {
    rate: string;
    maxRate: string;
    maxChangeRate: string;
  };
  updateTime: Date;
}
interface Validator {
  operatorAddress: string;
  consensusPubKey?: string;
  jailed: boolean;
  status: BondStatus;
  tokens: string;
  delegatorShares: string;
  description: ValidatorDescription;
  unbondingHeight: number;
  unbondingTime: any;
  commission: ValidatorCommission;
  minSelfDelegation: string;
}
type GrpcValidator = Validator$1;
type GrpcDelegation = Delegation$1;
type GrpcValidatorDescription = Description;
type GrpcValidatorCommission = Commission;
type GrpcValidatorCommissionRates = CommissionRates;
type GrpcUnbondingDelegation = UnbondingDelegation;
type GrpcUnbondingDelegationEntry = UnbondingDelegationEntry;
type GrpcReDelegation = Redelegation;
type GrpcDelegationResponse = DelegationResponse;
type GrpcReDelegationResponse = RedelegationResponse;
type GrpcReDelegationEntryResponse = RedelegationEntryResponse;
type GrpcStakingParams = Params$4;
type GrpcPool = Pool$1;
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/injective/exchange/v1beta1/genesis_pb.d.ts
/**
 * GenesisState defines the exchange module's genesis state.
 *
 * @generated from protobuf message injective.exchange.v1beta1.GenesisState
 */
interface GenesisState$4 {
  /**
   * params defines all the parameters of related to exchange.
   *
   * @generated from protobuf field: injective.exchange.v1beta1.Params params = 1
   */
  params?: Params$16;
  /**
   * spot_markets is an array containing the genesis trade pairs
   *
   * @generated from protobuf field: repeated injective.exchange.v1beta1.SpotMarket spot_markets = 2
   */
  spotMarkets: SpotMarket$1[];
  /**
   * derivative_markets is an array containing the genesis derivative markets
   *
   * @generated from protobuf field: repeated injective.exchange.v1beta1.DerivativeMarket derivative_markets = 3
   */
  derivativeMarkets: DerivativeMarket$1[];
  /**
   * spot_orderbook defines the spot exchange limit orderbook active at genesis.
   *
   * @generated from protobuf field: repeated injective.exchange.v1beta1.SpotOrderBook spot_orderbook = 4
   */
  spotOrderbook: SpotOrderBook[];
  /**
   * derivative_orderbook defines the derivative exchange limit orderbook active
   * at genesis.
   *
   * @generated from protobuf field: repeated injective.exchange.v1beta1.DerivativeOrderBook derivative_orderbook = 5
   */
  derivativeOrderbook: DerivativeOrderBook[];
  /**
   * balances defines the exchange users balances active at genesis.
   *
   * @generated from protobuf field: repeated injective.exchange.v1beta1.Balance balances = 6
   */
  balances: Balance[];
  /**
   * positions defines the exchange derivative positions at genesis
   *
   * @generated from protobuf field: repeated injective.exchange.v1beta1.DerivativePosition positions = 7
   */
  positions: DerivativePosition$2[];
  /**
   * subaccount_trade_nonces defines the subaccount trade nonces for the
   * subaccounts at genesis
   *
   * @generated from protobuf field: repeated injective.exchange.v1beta1.SubaccountNonce subaccount_trade_nonces = 8
   */
  subaccountTradeNonces: SubaccountNonce[];
  /**
   * expiry_futures_market_info defines the market info for the expiry futures
   * markets at genesis
   *
   * @generated from protobuf field: repeated injective.exchange.v1beta1.ExpiryFuturesMarketInfoState expiry_futures_market_info_state = 9
   */
  expiryFuturesMarketInfoState: ExpiryFuturesMarketInfoState[];
  /**
   * perpetual_market_info defines the market info for the perpetual derivative
   * markets at genesis
   *
   * @generated from protobuf field: repeated injective.exchange.v1beta1.PerpetualMarketInfo perpetual_market_info = 10
   */
  perpetualMarketInfo: PerpetualMarketInfo$2[];
  /**
   * perpetual_market_funding_state defines the funding state for the perpetual
   * derivative markets at genesis
   *
   * @generated from protobuf field: repeated injective.exchange.v1beta1.PerpetualMarketFundingState perpetual_market_funding_state = 11
   */
  perpetualMarketFundingState: PerpetualMarketFundingState[];
  /**
   * derivative_market_settlement_scheduled defines the scheduled markets for
   * settlement at genesis
   *
   * @generated from protobuf field: repeated injective.exchange.v1beta1.DerivativeMarketSettlementInfo derivative_market_settlement_scheduled = 12
   */
  derivativeMarketSettlementScheduled: DerivativeMarketSettlementInfo[];
  /**
   * sets spot markets as enabled
   *
   * @generated from protobuf field: bool is_spot_exchange_enabled = 13
   */
  isSpotExchangeEnabled: boolean;
  /**
   * sets derivative markets as enabled
   *
   * @generated from protobuf field: bool is_derivatives_exchange_enabled = 14
   */
  isDerivativesExchangeEnabled: boolean;
  /**
   * the current trading reward campaign info
   *
   * @generated from protobuf field: injective.exchange.v1beta1.TradingRewardCampaignInfo trading_reward_campaign_info = 15
   */
  tradingRewardCampaignInfo?: TradingRewardCampaignInfo$1;
  /**
   * the current and upcoming trading reward campaign pools
   *
   * @generated from protobuf field: repeated injective.exchange.v1beta1.CampaignRewardPool trading_reward_pool_campaign_schedule = 16
   */
  tradingRewardPoolCampaignSchedule: CampaignRewardPool$1[];
  /**
   * the current trading reward account points
   *
   * @generated from protobuf field: repeated injective.exchange.v1beta1.TradingRewardCampaignAccountPoints trading_reward_campaign_account_points = 17
   */
  tradingRewardCampaignAccountPoints: TradingRewardCampaignAccountPoints[];
  /**
   * the fee discount schedule
   *
   * @generated from protobuf field: injective.exchange.v1beta1.FeeDiscountSchedule fee_discount_schedule = 18
   */
  feeDiscountSchedule?: FeeDiscountSchedule$1;
  /**
   * the cached fee discount account tiers with TTL
   *
   * @generated from protobuf field: repeated injective.exchange.v1beta1.FeeDiscountAccountTierTTL fee_discount_account_tier_ttl = 19
   */
  feeDiscountAccountTierTtl: FeeDiscountAccountTierTTL[];
  /**
   * the fee discount paid by accounts in all buckets
   *
   * @generated from protobuf field: repeated injective.exchange.v1beta1.FeeDiscountBucketVolumeAccounts fee_discount_bucket_volume_accounts = 20
   */
  feeDiscountBucketVolumeAccounts: FeeDiscountBucketVolumeAccounts[];
  /**
   * sets the first fee cycle as finished
   *
   * @generated from protobuf field: bool is_first_fee_cycle_finished = 21
   */
  isFirstFeeCycleFinished: boolean;
  /**
   * the current and upcoming trading reward campaign pending pools
   *
   * @generated from protobuf field: repeated injective.exchange.v1beta1.CampaignRewardPool pending_trading_reward_pool_campaign_schedule = 22
   */
  pendingTradingRewardPoolCampaignSchedule: CampaignRewardPool$1[];
  /**
   * the pending trading reward account points
   *
   * @generated from protobuf field: repeated injective.exchange.v1beta1.TradingRewardCampaignAccountPendingPoints pending_trading_reward_campaign_account_points = 23
   */
  pendingTradingRewardCampaignAccountPoints: TradingRewardCampaignAccountPendingPoints[];
  /**
   * the addresses opting out of trading rewards
   *
   * @generated from protobuf field: repeated string rewards_opt_out_addresses = 24
   */
  rewardsOptOutAddresses: string[];
  /**
   * @generated from protobuf field: repeated injective.exchange.v1beta1.TradeRecords historical_trade_records = 25
   */
  historicalTradeRecords: TradeRecords[];
  /**
   * binary_options_markets is an array containing the genesis binary options
   * markets
   *
   * @generated from protobuf field: repeated injective.exchange.v1beta1.BinaryOptionsMarket binary_options_markets = 26
   */
  binaryOptionsMarkets: BinaryOptionsMarket$1[];
  /**
   * binary_options_markets_scheduled_for_settlement contains the marketIDs of
   * binary options markets scheduled for next-block settlement
   *
   * @generated from protobuf field: repeated string binary_options_market_ids_scheduled_for_settlement = 27
   */
  binaryOptionsMarketIdsScheduledForSettlement: string[];
  /**
   * spot_market_ids_scheduled_to_force_close defines the scheduled markets for
   * forced closings at genesis
   *
   * @generated from protobuf field: repeated string spot_market_ids_scheduled_to_force_close = 28
   */
  spotMarketIdsScheduledToForceClose: string[];
  /**
   * denom_decimals defines the denom decimals for the exchange.
   *
   * @generated from protobuf field: repeated injective.exchange.v1beta1.DenomDecimals denom_decimals = 29
   */
  denomDecimals: DenomDecimals[];
  /**
   * conditional_derivative_orderbook contains conditional orderbooks for all
   * markets (both lmit and market conditional orders)
   *
   * @generated from protobuf field: repeated injective.exchange.v1beta1.ConditionalDerivativeOrderBook conditional_derivative_orderbooks = 30
   */
  conditionalDerivativeOrderbooks: ConditionalDerivativeOrderBook[];
  /**
   * market_fee_multipliers contains any non-default atomic order fee
   * multipliers
   *
   * @generated from protobuf field: repeated injective.exchange.v1beta1.MarketFeeMultiplier market_fee_multipliers = 31
   */
  marketFeeMultipliers: MarketFeeMultiplier[];
  /**
   * @generated from protobuf field: repeated injective.exchange.v1beta1.OrderbookSequence orderbook_sequences = 32
   */
  orderbookSequences: OrderbookSequence[];
  /**
   * @generated from protobuf field: repeated injective.exchange.v1beta1.AggregateSubaccountVolumeRecord subaccount_volumes = 33
   */
  subaccountVolumes: AggregateSubaccountVolumeRecord[];
  /**
   * @generated from protobuf field: repeated injective.exchange.v1beta1.MarketVolume market_volumes = 34
   */
  marketVolumes: MarketVolume[];
  /**
   * @generated from protobuf field: repeated injective.exchange.v1beta1.FullGrantAuthorizations grant_authorizations = 35
   */
  grantAuthorizations: FullGrantAuthorizations[];
  /**
   * @generated from protobuf field: repeated injective.exchange.v1beta1.FullActiveGrant active_grants = 36
   */
  activeGrants: FullActiveGrant[];
  /**
   * @generated from protobuf field: repeated injective.exchange.v1beta1.DenomMinNotional denom_min_notionals = 37
   */
  denomMinNotionals: DenomMinNotional[];
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.OrderbookSequence
 */
interface OrderbookSequence {
  /**
   * @generated from protobuf field: uint64 sequence = 1
   */
  sequence: bigint;
  /**
   * @generated from protobuf field: string market_id = 2
   */
  marketId: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.FeeDiscountAccountTierTTL
 */
interface FeeDiscountAccountTierTTL {
  /**
   * @generated from protobuf field: string account = 1
   */
  account: string;
  /**
   * @generated from protobuf field: injective.exchange.v1beta1.FeeDiscountTierTTL tier_ttl = 2
   */
  tierTtl?: FeeDiscountTierTTL$1;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.FeeDiscountBucketVolumeAccounts
 */
interface FeeDiscountBucketVolumeAccounts {
  /**
   * @generated from protobuf field: int64 bucket_start_timestamp = 1
   */
  bucketStartTimestamp: bigint;
  /**
   * @generated from protobuf field: repeated injective.exchange.v1beta1.AccountVolume account_volume = 2
   */
  accountVolume: AccountVolume[];
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.AccountVolume
 */
interface AccountVolume {
  /**
   * @generated from protobuf field: string account = 1
   */
  account: string;
  /**
   * @generated from protobuf field: string volume = 2
   */
  volume: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.TradingRewardCampaignAccountPoints
 */
interface TradingRewardCampaignAccountPoints {
  /**
   * @generated from protobuf field: string account = 1
   */
  account: string;
  /**
   * @generated from protobuf field: string points = 2
   */
  points: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.TradingRewardCampaignAccountPendingPoints
 */
interface TradingRewardCampaignAccountPendingPoints {
  /**
   * @generated from protobuf field: int64 reward_pool_start_timestamp = 1
   */
  rewardPoolStartTimestamp: bigint;
  /**
   * @generated from protobuf field: repeated injective.exchange.v1beta1.TradingRewardCampaignAccountPoints account_points = 2
   */
  accountPoints: TradingRewardCampaignAccountPoints[];
}
/**
 * Spot Exchange Limit Orderbook
 *
 * @generated from protobuf message injective.exchange.v1beta1.SpotOrderBook
 */
interface SpotOrderBook {
  /**
   * @generated from protobuf field: string market_id = 1
   */
  marketId: string;
  /**
   * @generated from protobuf field: bool isBuySide = 2
   */
  isBuySide: boolean;
  /**
   * @generated from protobuf field: repeated injective.exchange.v1beta1.SpotLimitOrder orders = 3
   */
  orders: SpotLimitOrder$2[];
}
/**
 * Derivative Exchange Limit Orderbook
 *
 * @generated from protobuf message injective.exchange.v1beta1.DerivativeOrderBook
 */
interface DerivativeOrderBook {
  /**
   * @generated from protobuf field: string market_id = 1
   */
  marketId: string;
  /**
   * @generated from protobuf field: bool isBuySide = 2
   */
  isBuySide: boolean;
  /**
   * @generated from protobuf field: repeated injective.exchange.v1beta1.DerivativeLimitOrder orders = 3
   */
  orders: DerivativeLimitOrder$2[];
}
/**
 * Orderbook containing limit & market conditional orders
 *
 * @generated from protobuf message injective.exchange.v1beta1.ConditionalDerivativeOrderBook
 */
interface ConditionalDerivativeOrderBook {
  /**
   * @generated from protobuf field: string market_id = 1
   */
  marketId: string;
  /**
   * @generated from protobuf field: repeated injective.exchange.v1beta1.DerivativeLimitOrder limit_buy_orders = 2
   */
  limitBuyOrders: DerivativeLimitOrder$2[];
  /**
   * @generated from protobuf field: repeated injective.exchange.v1beta1.DerivativeMarketOrder market_buy_orders = 3
   */
  marketBuyOrders: DerivativeMarketOrder[];
  /**
   * @generated from protobuf field: repeated injective.exchange.v1beta1.DerivativeLimitOrder limit_sell_orders = 4
   */
  limitSellOrders: DerivativeLimitOrder$2[];
  /**
   * @generated from protobuf field: repeated injective.exchange.v1beta1.DerivativeMarketOrder market_sell_orders = 5
   */
  marketSellOrders: DerivativeMarketOrder[];
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.Balance
 */
interface Balance {
  /**
   * the subaccount ID
   *
   * @generated from protobuf field: string subaccount_id = 1
   */
  subaccountId: string;
  /**
   * the denom of the balance
   *
   * @generated from protobuf field: string denom = 2
   */
  denom: string;
  /**
   * the token deposits details
   *
   * @generated from protobuf field: injective.exchange.v1beta1.Deposit deposits = 3
   */
  deposits?: Deposit$1;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.DerivativePosition
 */
interface DerivativePosition$2 {
  /**
   * the subaccount ID
   *
   * @generated from protobuf field: string subaccount_id = 1
   */
  subaccountId: string;
  /**
   * the market ID
   *
   * @generated from protobuf field: string market_id = 2
   */
  marketId: string;
  /**
   * the position details
   *
   * @generated from protobuf field: injective.exchange.v1beta1.Position position = 3
   */
  position?: Position$1;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.SubaccountNonce
 */
interface SubaccountNonce {
  /**
   * the subaccount ID
   *
   * @generated from protobuf field: string subaccount_id = 1
   */
  subaccountId: string;
  /**
   * the subaccount trade nonce
   *
   * @generated from protobuf field: injective.exchange.v1beta1.SubaccountTradeNonce subaccount_trade_nonce = 2
   */
  subaccountTradeNonce?: SubaccountTradeNonce;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.ExpiryFuturesMarketInfoState
 */
interface ExpiryFuturesMarketInfoState {
  /**
   * @generated from protobuf field: string market_id = 1
   */
  marketId: string;
  /**
   * @generated from protobuf field: injective.exchange.v1beta1.ExpiryFuturesMarketInfo market_info = 2
   */
  marketInfo?: ExpiryFuturesMarketInfo$2;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.PerpetualMarketFundingState
 */
interface PerpetualMarketFundingState {
  /**
   * @generated from protobuf field: string market_id = 1
   */
  marketId: string;
  /**
   * @generated from protobuf field: injective.exchange.v1beta1.PerpetualMarketFunding funding = 2
   */
  funding?: PerpetualMarketFunding$2;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.FullGrantAuthorizations
 */
interface FullGrantAuthorizations {
  /**
   * @generated from protobuf field: string granter = 1
   */
  granter: string;
  /**
   * @generated from protobuf field: string total_grant_amount = 2
   */
  totalGrantAmount: string;
  /**
   * @generated from protobuf field: int64 last_delegations_checked_time = 3
   */
  lastDelegationsCheckedTime: bigint;
  /**
   * @generated from protobuf field: repeated injective.exchange.v1beta1.GrantAuthorization grants = 4
   */
  grants: GrantAuthorization$2[];
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.FullActiveGrant
 */
interface FullActiveGrant {
  /**
   * @generated from protobuf field: string grantee = 1
   */
  grantee: string;
  /**
   * @generated from protobuf field: injective.exchange.v1beta1.ActiveGrant active_grant = 2
   */
  activeGrant?: ActiveGrant;
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.GenesisState
 */
declare const GenesisState$4 = new GenesisState$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.OrderbookSequence
 */
declare const OrderbookSequence = new OrderbookSequence$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.FeeDiscountAccountTierTTL
 */
declare const FeeDiscountAccountTierTTL = new FeeDiscountAccountTierTTL$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.FeeDiscountBucketVolumeAccounts
 */
declare const FeeDiscountBucketVolumeAccounts = new FeeDiscountBucketVolumeAccounts$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.AccountVolume
 */
declare const AccountVolume = new AccountVolume$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.TradingRewardCampaignAccountPoints
 */
declare const TradingRewardCampaignAccountPoints = new TradingRewardCampaignAccountPoints$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.TradingRewardCampaignAccountPendingPoints
 */
declare const TradingRewardCampaignAccountPendingPoints = new TradingRewardCampaignAccountPendingPoints$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.SpotOrderBook
 */
declare const SpotOrderBook = new SpotOrderBook$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.DerivativeOrderBook
 */
declare const DerivativeOrderBook = new DerivativeOrderBook$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.ConditionalDerivativeOrderBook
 */
declare const ConditionalDerivativeOrderBook = new ConditionalDerivativeOrderBook$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.Balance
 */
declare const Balance = new Balance$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.DerivativePosition
 */
declare const DerivativePosition$2 = new DerivativePosition$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.SubaccountNonce
 */
declare const SubaccountNonce = new SubaccountNonce$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.ExpiryFuturesMarketInfoState
 */
declare const ExpiryFuturesMarketInfoState = new ExpiryFuturesMarketInfoState$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.PerpetualMarketFundingState
 */
declare const PerpetualMarketFundingState = new PerpetualMarketFundingState$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.FullGrantAuthorizations
 */
declare const FullGrantAuthorizations = new FullGrantAuthorizations$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.FullActiveGrant
 */
declare const FullActiveGrant = new FullActiveGrant$Type();
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/injective/exchange/v1beta1/query_pb.d.ts
/**
 * QueryExchangeParamsRequest is the response type for the Query/ExchangeParams
 * RPC method.
 *
 * @generated from protobuf message injective.exchange.v1beta1.QueryExchangeParamsResponse
 */
interface QueryExchangeParamsResponse {
  /**
   * @generated from protobuf field: injective.exchange.v1beta1.Params params = 1
   */
  params?: Params$16;
}
/**
 * QueryDenomDecimalsRequest is the response type for the Query/DenomDecimals
 * RPC method.
 *
 * @generated from protobuf message injective.exchange.v1beta1.QueryDenomDecimalsResponse
 */
interface QueryDenomDecimalsResponse {
  /**
   * @generated from protobuf field: repeated injective.exchange.v1beta1.DenomDecimals denom_decimals = 1
   */
  denomDecimals: DenomDecimals[];
}
/**
 * QuerySpotMarketsResponse is the response type for the Query/SpotMarkets RPC
 * method.
 *
 * @generated from protobuf message injective.exchange.v1beta1.QuerySpotMarketsResponse
 */
interface QuerySpotMarketsResponse {
  /**
   * @generated from protobuf field: repeated injective.exchange.v1beta1.SpotMarket markets = 1
   */
  markets: SpotMarket$1[];
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.FullSpotMarket
 */
interface FullSpotMarket {
  /**
   * @generated from protobuf field: injective.exchange.v1beta1.SpotMarket market = 1
   */
  market?: SpotMarket$1;
  /**
   * mid_price_and_tob defines the mid price for this market and the best ask
   * and bid orders
   *
   * @generated from protobuf field: injective.exchange.v1beta1.MidPriceAndTOB mid_price_and_tob = 2
   */
  midPriceAndTob?: MidPriceAndTOB;
}
/**
 * QueryFullSpotMarketsResponse is the response type for the
 * Query/FullSpotMarkets RPC method.
 *
 * @generated from protobuf message injective.exchange.v1beta1.QueryFullSpotMarketsResponse
 */
interface QueryFullSpotMarketsResponse {
  /**
   * @generated from protobuf field: repeated injective.exchange.v1beta1.FullSpotMarket markets = 1
   */
  markets: FullSpotMarket[];
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.PerpetualMarketState
 */
interface PerpetualMarketState {
  /**
   * @generated from protobuf field: injective.exchange.v1beta1.PerpetualMarketInfo market_info = 1
   */
  marketInfo?: PerpetualMarketInfo$2;
  /**
   * @generated from protobuf field: injective.exchange.v1beta1.PerpetualMarketFunding funding_info = 2
   */
  fundingInfo?: PerpetualMarketFunding$2;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.FullDerivativeMarket
 */
interface FullDerivativeMarket {
  /**
   * derivative market details
   *
   * @generated from protobuf field: injective.exchange.v1beta1.DerivativeMarket market = 1
   */
  market?: DerivativeMarket$1;
  /**
   * perpetual market state or expiry futures market state
   *
   * @generated from protobuf oneof: info
   */
  info: {
    oneofKind: "perpetualInfo";
    /**
     * perpetual market info
     *
     * @generated from protobuf field: injective.exchange.v1beta1.PerpetualMarketState perpetual_info = 2
     */
    perpetualInfo: PerpetualMarketState;
  } | {
    oneofKind: "futuresInfo";
    /**
     * expiry futures market info
     *
     * @generated from protobuf field: injective.exchange.v1beta1.ExpiryFuturesMarketInfo futures_info = 3
     */
    futuresInfo: ExpiryFuturesMarketInfo$2;
  } | {
    oneofKind: undefined;
  };
  /**
   * mark price (in chain format)
   *
   * @generated from protobuf field: string mark_price = 4
   */
  markPrice: string;
  /**
   * mid_price_and_tob defines the mid price for this market and the best ask
   * and bid orders
   *
   * @generated from protobuf field: injective.exchange.v1beta1.MidPriceAndTOB mid_price_and_tob = 5
   */
  midPriceAndTob?: MidPriceAndTOB;
}
/**
 * QueryDerivativeMarketsResponse is the response type for the
 * Query/DerivativeMarkets RPC method.
 *
 * @generated from protobuf message injective.exchange.v1beta1.QueryDerivativeMarketsResponse
 */
interface QueryDerivativeMarketsResponse {
  /**
   * @generated from protobuf field: repeated injective.exchange.v1beta1.FullDerivativeMarket markets = 1
   */
  markets: FullDerivativeMarket[];
}
/**
 * QuerySubaccountTradeNonceResponse is the response type for the
 * Query/SubaccountTradeNonce RPC method.
 *
 * @generated from protobuf message injective.exchange.v1beta1.QuerySubaccountTradeNonceResponse
 */
interface QuerySubaccountTradeNonceResponse {
  /**
   * @generated from protobuf field: uint32 nonce = 1
   */
  nonce: number;
}
/**
 * QueryPositionsResponse is the response type for the Query/Positions RPC
 * method.
 *
 * @generated from protobuf message injective.exchange.v1beta1.QueryPositionsResponse
 */
interface QueryPositionsResponse {
  /**
   * @generated from protobuf field: repeated injective.exchange.v1beta1.DerivativePosition state = 1
   */
  state: DerivativePosition$2[];
}
/**
 * QueryTradeRewardCampaignResponse is the response type for the
 * Query/TradeRewardCampaign RPC method.
 *
 * @generated from protobuf message injective.exchange.v1beta1.QueryTradeRewardCampaignResponse
 */
interface QueryTradeRewardCampaignResponse {
  /**
   * @generated from protobuf field: injective.exchange.v1beta1.TradingRewardCampaignInfo trading_reward_campaign_info = 1
   */
  tradingRewardCampaignInfo?: TradingRewardCampaignInfo$1;
  /**
   * @generated from protobuf field: repeated injective.exchange.v1beta1.CampaignRewardPool trading_reward_pool_campaign_schedule = 2
   */
  tradingRewardPoolCampaignSchedule: CampaignRewardPool$1[];
  /**
   * @generated from protobuf field: string total_trade_reward_points = 3
   */
  totalTradeRewardPoints: string;
  /**
   * @generated from protobuf field: repeated injective.exchange.v1beta1.CampaignRewardPool pending_trading_reward_pool_campaign_schedule = 4
   */
  pendingTradingRewardPoolCampaignSchedule: CampaignRewardPool$1[];
  /**
   * @generated from protobuf field: repeated string pending_total_trade_reward_points = 5
   */
  pendingTotalTradeRewardPoints: string[];
}
/**
 * QueryIsRegisteredDMMResponse is the response type for the
 * Query/IsRegisteredDMM RPC method.
 *
 * @generated from protobuf message injective.exchange.v1beta1.QueryIsOptedOutOfRewardsResponse
 */
interface QueryIsOptedOutOfRewardsResponse {
  /**
   * @generated from protobuf field: bool is_opted_out = 1
   */
  isOptedOut: boolean;
}
/**
 * QueryFeeDiscountAccountInfoResponse is the response type for the
 * Query/FeeDiscountAccountInfo RPC method.
 *
 * @generated from protobuf message injective.exchange.v1beta1.QueryFeeDiscountAccountInfoResponse
 */
interface QueryFeeDiscountAccountInfoResponse {
  /**
   * @generated from protobuf field: uint64 tier_level = 1
   */
  tierLevel: bigint;
  /**
   * @generated from protobuf field: injective.exchange.v1beta1.FeeDiscountTierInfo account_info = 2
   */
  accountInfo?: FeeDiscountTierInfo$1;
  /**
   * @generated from protobuf field: injective.exchange.v1beta1.FeeDiscountTierTTL account_ttl = 3
   */
  accountTtl?: FeeDiscountTierTTL$1;
}
/**
 * QueryFeeDiscountScheduleResponse is the response type for the
 * Query/FeeDiscountSchedule RPC method.
 *
 * @generated from protobuf message injective.exchange.v1beta1.QueryFeeDiscountScheduleResponse
 */
interface QueryFeeDiscountScheduleResponse {
  /**
   * @generated from protobuf field: injective.exchange.v1beta1.FeeDiscountSchedule fee_discount_schedule = 1
   */
  feeDiscountSchedule?: FeeDiscountSchedule$1;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.QueryActiveStakeGrantResponse
 */
interface QueryActiveStakeGrantResponse {
  /**
   * @generated from protobuf field: injective.exchange.v1beta1.ActiveGrant grant = 1
   */
  grant?: ActiveGrant;
  /**
   * @generated from protobuf field: injective.exchange.v1beta1.EffectiveGrant effective_grant = 2
   */
  effectiveGrant?: EffectiveGrant;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.QueryDenomMinNotionalResponse
 */
interface QueryDenomMinNotionalResponse {
  /**
   * the minimum notional amount for the denom (in chain format)
   *
   * @generated from protobuf field: string amount = 1
   */
  amount: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.QueryDenomMinNotionalsResponse
 */
interface QueryDenomMinNotionalsResponse {
  /**
   * @generated from protobuf field: repeated injective.exchange.v1beta1.DenomMinNotional denom_min_notionals = 1
   */
  denomMinNotionals: DenomMinNotional[];
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.QueryExchangeParamsResponse
 */
declare const QueryExchangeParamsResponse = new QueryExchangeParamsResponse$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.QueryDenomDecimalsResponse
 */
declare const QueryDenomDecimalsResponse = new QueryDenomDecimalsResponse$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.QuerySpotMarketsResponse
 */
declare const QuerySpotMarketsResponse = new QuerySpotMarketsResponse$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.FullSpotMarket
 */
declare const FullSpotMarket = new FullSpotMarket$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.QueryFullSpotMarketsResponse
 */
declare const QueryFullSpotMarketsResponse = new QueryFullSpotMarketsResponse$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.PerpetualMarketState
 */
declare const PerpetualMarketState = new PerpetualMarketState$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.FullDerivativeMarket
 */
declare const FullDerivativeMarket = new FullDerivativeMarket$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.QueryDerivativeMarketsResponse
 */
declare const QueryDerivativeMarketsResponse = new QueryDerivativeMarketsResponse$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.QuerySubaccountTradeNonceResponse
 */
declare const QuerySubaccountTradeNonceResponse = new QuerySubaccountTradeNonceResponse$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.QueryPositionsResponse
 */
declare const QueryPositionsResponse = new QueryPositionsResponse$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.QueryTradeRewardCampaignResponse
 */
declare const QueryTradeRewardCampaignResponse = new QueryTradeRewardCampaignResponse$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.QueryIsOptedOutOfRewardsResponse
 */
declare const QueryIsOptedOutOfRewardsResponse = new QueryIsOptedOutOfRewardsResponse$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.QueryFeeDiscountAccountInfoResponse
 */
declare const QueryFeeDiscountAccountInfoResponse = new QueryFeeDiscountAccountInfoResponse$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.QueryFeeDiscountScheduleResponse
 */
declare const QueryFeeDiscountScheduleResponse = new QueryFeeDiscountScheduleResponse$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.QueryActiveStakeGrantResponse
 */
declare const QueryActiveStakeGrantResponse = new QueryActiveStakeGrantResponse$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.QueryDenomMinNotionalResponse
 */
declare const QueryDenomMinNotionalResponse = new QueryDenomMinNotionalResponse$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.QueryDenomMinNotionalsResponse
 */
declare const QueryDenomMinNotionalsResponse = new QueryDenomMinNotionalsResponse$Type();
//#endregion
//#region src/client/chain/types/exchange.d.ts
interface DepositProposalParams {
  amount: string;
  denom: string;
}
interface FeeDiscountTierInfo {
  makerDiscountRate: string;
  takerDiscountRate: string;
  stakedAmount: string;
  volume: string;
}
interface FeeDiscountSchedule {
  bucketCount: number;
  bucketDuration: number;
  quoteDenomsList: Array<string>;
  tierInfosList: Array<FeeDiscountTierInfo>;
  disqualifiedMarketIdsList: Array<string>;
}
interface PointsMultiplier {
  makerPointsMultiplier: string;
  takerPointsMultiplier: string;
}
interface TradingRewardCampaignBoostInfo {
  boostedSpotMarketIdsList: Array<string>;
  spotMarketMultipliersList: Array<PointsMultiplier>;
  boostedDerivativeMarketIdsList: Array<string>;
  derivativeMarketMultipliersList: Array<PointsMultiplier>;
}
interface TradingRewardCampaignInfo {
  campaignDurationSeconds: number;
  quoteDenomsList: Array<string>;
  tradingRewardBoostInfo?: TradingRewardCampaignBoostInfo;
  disqualifiedMarketIdsList: Array<string>;
}
interface CampaignRewardPool {
  startTimestamp: number;
  maxCampaignRewardsList: Coin[];
}
interface FeeDiscountTierTTL {
  tier: number;
  ttlTimestamp: number;
}
interface FeeDiscountAccountInfo {
  tierLevel: number;
  accountInfo?: FeeDiscountTierInfo;
  accountTtl?: FeeDiscountTierTTL;
}
interface TradeRewardCampaign {
  tradingRewardCampaignInfo?: TradingRewardCampaignInfo;
  tradingRewardPoolCampaignScheduleList: CampaignRewardPool[];
  totalTradeRewardPoints: string;
  pendingTradingRewardPoolCampaignScheduleList: CampaignRewardPool[];
  pendingTotalTradeRewardPointsList: string[];
}
interface IsOptedOutOfRewards {
  isOptedOut: boolean;
}
interface ExchangeParams {
  spotMarketInstantListingFee?: Coin;
  derivativeMarketInstantListingFee?: Coin;
  defaultSpotMakerFeeRate: string;
  defaultSpotTakerFeeRate: string;
  defaultDerivativeMakerFeeRate: string;
  defaultDerivativeTakerFeeRate: string;
  defaultInitialMarginRatio: string;
  defaultMaintenanceMarginRatio: string;
  defaultFundingInterval: number;
  fundingMultiple: number;
  relayerFeeShareRate: string;
  defaultHourlyFundingRateCap: string;
  defaultHourlyInterestRate: string;
  maxDerivativeOrderSideCount: number;
  injRewardStakedRequirementThreshold: string;
  tradingRewardsVestingDuration: number;
  liquidatorRewardShareRate: string;
  binaryOptionsMarketInstantListingFee?: Coin;
  atomicMarketOrderAccessLevel: string;
  spotAtomicMarketOrderFeeMultiplier: string;
  derivativeAtomicMarketOrderFeeMultiplier: string;
  binaryOptionsAtomicMarketOrderFeeMultiplier: string;
  minimalProtocolFeeRate: string;
  isInstantDerivativeMarketLaunchEnabled: boolean;
  postOnlyModeHeightThreshold: string;
  marginDecreasePriceTimestampThresholdSeconds: string;
  exchangeAdmins: string[];
}
interface ExchangeModuleParams extends ExchangeParams {}
interface ChainPosition {
  islong: boolean;
  quantity: string;
  entryPrice: string;
  margin: string;
  cumulativeFundingEntry: string;
}
interface ChainDerivativePosition {
  subaccountId: string;
  marketId: string;
  position?: ChainPosition;
}
interface ChainDenomDecimal {
  denom: string;
  decimals: string;
}
interface ChainDenomMinNotional {
  denom: string;
  minNotional: string;
}
type GrpcOrderInfo = OrderInfo$1;
type GrpcSpotMarket = SpotMarket$1;
type GrpcSpotMarketOrder = SpotMarketOrder;
type GrpcSpotOrder = SpotOrder$1;
type GrpcExchangeParams = Params$16;
type GrpcFeeDiscountTierInfo = FeeDiscountTierInfo$1;
type GrpcFeeDiscountTierTTL = FeeDiscountTierTTL$1;
type GrpcFeeDiscountSchedule = FeeDiscountSchedule$1;
type GrpcPointsMultiplier = PointsMultiplier$1;
type GrpcTradingRewardCampaignBoostInfo = TradingRewardCampaignBoostInfo$1;
type GrpcTradingRewardCampaignInfo = TradingRewardCampaignInfo$1;
type GrpcCampaignRewardPool = CampaignRewardPool$1;
type GrpcChainPosition = Position$1;
type GrpcChainDerivativePosition = DerivativePosition$2;
type GrpcFeeDiscountAccountInfo = QueryFeeDiscountAccountInfoResponse;
type GrpcTradeRewardCampaign = QueryTradeRewardCampaignResponse;
type GrpcDenomDecimals = DenomDecimals;
type GrpcDenomMinNotional = DenomMinNotional;
type GrpcChainFullDerivativeMarket = FullDerivativeMarket;
type GrpcChainFullSpotMarket = FullSpotMarket;
type GrpcChainDerivativeMarket = DerivativeMarket$1;
type GrpcChainSpotMarket = SpotMarket$1;
type GrpcOrderType = OrderType$1;
declare const GrpcOrderTypeMap: typeof OrderType$1;
type OrderType = OrderType$1;
declare const OrderTypeMap: typeof OrderType$1;
type GrpcMarketStatus = MarketStatus;
declare const GrpcMarketStatusMap: typeof MarketStatus;
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/injective/evm/v1/log_pb.d.ts
/**
 * Log represents an protobuf compatible Ethereum Log that defines a contract
 * log event. These events are generated by the LOG opcode and stored/indexed by
 * the node.
 *
 * NOTE: address, topics and data are consensus fields. The rest of the fields
 * are derived, i.e. filled in by the nodes, but not secured by consensus.
 *
 * @generated from protobuf message injective.evm.v1.Log
 */
interface Log {
  /**
   * address of the contract that generated the event
   *
   * @generated from protobuf field: string address = 1
   */
  address: string;
  /**
   * topics is a list of topics provided by the contract.
   *
   * @generated from protobuf field: repeated string topics = 2
   */
  topics: string[];
  /**
   * data which is supplied by the contract, usually ABI-encoded
   *
   * @generated from protobuf field: bytes data = 3
   */
  data: Uint8Array;
  /**
   * block_number of the block in which the transaction was included
   *
   * @generated from protobuf field: uint64 block_number = 4
   */
  blockNumber: bigint;
  /**
   * tx_hash is the transaction hash
   *
   * @generated from protobuf field: string tx_hash = 5
   */
  txHash: string;
  /**
   * tx_index of the transaction in the block
   *
   * @generated from protobuf field: uint64 tx_index = 6
   */
  txIndex: bigint;
  /**
   * block_hash of the block in which the transaction was included
   *
   * @generated from protobuf field: string block_hash = 7
   */
  blockHash: string;
  /**
   * index of the log in the block
   *
   * @generated from protobuf field: uint64 index = 8
   */
  index: bigint;
  /**
   * removed is true if this log was reverted due to a chain
   * reorganisation. You must pay attention to this field if you receive logs
   * through a filter query.
   *
   * @generated from protobuf field: bool removed = 9
   */
  removed: boolean;
}
/**
 * @generated MessageType for protobuf message injective.evm.v1.Log
 */
declare const Log = new Log$Type();
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/injective/evm/v1/chain_config_pb.d.ts
/**
 * ChainConfig defines the Ethereum ChainConfig parameters using *sdkmath.Int
 * values instead of *big.Int.
 *
 * @generated from protobuf message injective.evm.v1.ChainConfig
 */
interface ChainConfig {
  /**
   * homestead_block switch (nil no fork, 0 = already homestead)
   *
   * @generated from protobuf field: string homestead_block = 1
   */
  homesteadBlock: string;
  /**
   * dao_fork_block corresponds to TheDAO hard-fork switch block (nil no fork)
   *
   * @generated from protobuf field: string dao_fork_block = 2
   */
  daoForkBlock: string;
  /**
   * dao_fork_support defines whether the nodes supports or opposes the DAO
   * hard-fork
   *
   * @generated from protobuf field: bool dao_fork_support = 3
   */
  daoForkSupport: boolean;
  /**
   * eip150_block: EIP150 implements the Gas price changes
   * (https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (nil no fork)
   *
   * @generated from protobuf field: string eip150_block = 4
   */
  eip150Block: string;
  /**
   * eip150_hash: EIP150 HF hash (needed for header only clients as only gas
   * pricing changed)
   *
   * @generated from protobuf field: string eip150_hash = 5
   */
  eip150Hash: string;
  /**
   * eip155_block: EIP155Block HF block
   *
   * @generated from protobuf field: string eip155_block = 6
   */
  eip155Block: string;
  /**
   * eip158_block: EIP158 HF block
   *
   * @generated from protobuf field: string eip158_block = 7
   */
  eip158Block: string;
  /**
   * byzantium_block: Byzantium switch block (nil no fork, 0 = already on
   * byzantium)
   *
   * @generated from protobuf field: string byzantium_block = 8
   */
  byzantiumBlock: string;
  /**
   * constantinople_block: Constantinople switch block (nil no fork, 0 = already
   * activated)
   *
   * @generated from protobuf field: string constantinople_block = 9
   */
  constantinopleBlock: string;
  /**
   * petersburg_block: Petersburg switch block (nil same as Constantinople)
   *
   * @generated from protobuf field: string petersburg_block = 10
   */
  petersburgBlock: string;
  /**
   * istanbul_block: Istanbul switch block (nil no fork, 0 = already on
   * istanbul)
   *
   * @generated from protobuf field: string istanbul_block = 11
   */
  istanbulBlock: string;
  /**
   * muir_glacier_block: Eip-2384 (bomb delay) switch block (nil no fork, 0 =
   * already activated)
   *
   * @generated from protobuf field: string muir_glacier_block = 12
   */
  muirGlacierBlock: string;
  /**
   * berlin_block: Berlin switch block (nil = no fork, 0 = already on berlin)
   *
   * @generated from protobuf field: string berlin_block = 13
   */
  berlinBlock: string;
  /**
   * london_block: London switch block (nil = no fork, 0 = already on london)
   *
   * @generated from protobuf field: string london_block = 17
   */
  londonBlock: string;
  /**
   * arrow_glacier_block: Eip-4345 (bomb delay) switch block (nil = no fork, 0 =
   * already activated)
   *
   * @generated from protobuf field: string arrow_glacier_block = 18
   */
  arrowGlacierBlock: string;
  /**
   * gray_glacier_block: EIP-5133 (bomb delay) switch block (nil = no fork, 0 =
   * already activated)
   *
   * @generated from protobuf field: string gray_glacier_block = 20
   */
  grayGlacierBlock: string;
  /**
   * merge_netsplit_block: Virtual fork after The Merge to use as a network
   * splitter
   *
   * @generated from protobuf field: string merge_netsplit_block = 21
   */
  mergeNetsplitBlock: string;
  /**
   * shanghai switch time (nil = no fork, 0 = already on shanghai)
   *
   * @generated from protobuf field: string shanghai_time = 22
   */
  shanghaiTime: string;
  /**
   * cancun switch time (nil = no fork, 0 = already on cancun)
   *
   * @generated from protobuf field: string cancun_time = 23
   */
  cancunTime: string;
  /**
   * prague switch time (nil = no fork, 0 = already on prague)
   *
   * @generated from protobuf field: string prague_time = 24
   */
  pragueTime: string;
  /**
   * eip155_chain_id: identifies the chain and is used for replay protection
   *
   * @generated from protobuf field: string eip155_chain_id = 25
   */
  eip155ChainId: string;
  /**
   * eip7840: per-fork schedule of max and target blob counts in client
   * configuration files
   *
   * @generated from protobuf field: injective.evm.v1.BlobScheduleConfig blob_schedule_config = 26
   */
  blobScheduleConfig?: BlobScheduleConfig;
}
/**
 * @generated from protobuf message injective.evm.v1.BlobScheduleConfig
 */
interface BlobScheduleConfig {
  /**
   * @generated from protobuf field: injective.evm.v1.BlobConfig cancun = 1
   */
  cancun?: BlobConfig;
  /**
   * @generated from protobuf field: injective.evm.v1.BlobConfig prague = 2
   */
  prague?: BlobConfig;
  /**
   * @generated from protobuf field: injective.evm.v1.BlobConfig osaka = 3
   */
  osaka?: BlobConfig;
  /**
   * @generated from protobuf field: injective.evm.v1.BlobConfig verkle = 4
   */
  verkle?: BlobConfig;
}
/**
 * @generated from protobuf message injective.evm.v1.BlobConfig
 */
interface BlobConfig {
  /**
   * @generated from protobuf field: uint64 target = 1
   */
  target: bigint;
  /**
   * @generated from protobuf field: uint64 max = 2
   */
  max: bigint;
  /**
   * @generated from protobuf field: uint64 base_fee_update_fraction = 3
   */
  baseFeeUpdateFraction: bigint;
}
/**
 * @generated MessageType for protobuf message injective.evm.v1.ChainConfig
 */
declare const ChainConfig = new ChainConfig$Type();
/**
 * @generated MessageType for protobuf message injective.evm.v1.BlobScheduleConfig
 */
declare const BlobScheduleConfig = new BlobScheduleConfig$Type();
/**
 * @generated MessageType for protobuf message injective.evm.v1.BlobConfig
 */
declare const BlobConfig = new BlobConfig$Type();
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/injective/evm/v1/params_pb.d.ts
/**
 * Params defines the EVM module parameters
 *
 * @generated from protobuf message injective.evm.v1.Params
 */
interface Params$12 {
  /**
   * evm_denom represents the token denomination used to run the EVM state
   * transitions.
   *
   * @generated from protobuf field: string evm_denom = 1
   */
  evmDenom: string;
  /**
   * enable_create toggles state transitions that use the vm.Create function
   *
   * @generated from protobuf field: bool enable_create = 2
   */
  enableCreate: boolean;
  /**
   * enable_call toggles state transitions that use the vm.Call function
   *
   * @generated from protobuf field: bool enable_call = 3
   */
  enableCall: boolean;
  /**
   * extra_eips defines the additional EIPs for the vm.Config
   *
   * @generated from protobuf field: repeated int64 extra_eips = 4
   */
  extraEips: bigint[];
  /**
   * chain_config defines the EVM chain configuration parameters
   *
   * @generated from protobuf field: injective.evm.v1.ChainConfig chain_config = 5
   */
  chainConfig?: ChainConfig;
  /**
   * allow_unprotected_txs defines if replay-protected (i.e non EIP155
   * signed) transactions can be executed on the state machine.
   *
   * @generated from protobuf field: bool allow_unprotected_txs = 6
   */
  allowUnprotectedTxs: boolean;
  /**
   * list of ETH addresses that are allowed to deploy contracts. Only relevant
   * if permissioned is true.
   *
   * @generated from protobuf field: repeated string authorized_deployers = 7
   */
  authorizedDeployers: string[];
  /**
   * make contract deployment permissioned, such that only accounts listed in
   * authorized_deployers are allowed to deploy contracts.
   *
   * @generated from protobuf field: bool permissioned = 8
   */
  permissioned: boolean;
}
/**
 * @generated MessageType for protobuf message injective.evm.v1.Params
 */
declare const Params$12 = new Params$Type();
//#endregion
//#region src/client/chain/types/evm.d.ts
interface EvmLog {
  address: string;
  topics: string[];
  data: Uint8Array;
  blockNumber: string;
  txHash: string;
  txIndex: string;
  blockHash: string;
  index: string;
  removed: boolean;
}
interface EvmBlobConfig {
  target: string;
  max: string;
  baseFeeUpdateFraction: string;
}
interface EvmBlobScheduleConfig {
  cancun?: EvmBlobConfig;
  prague?: EvmBlobConfig;
  osaka?: EvmBlobConfig;
  verkle?: EvmBlobConfig;
}
interface EvmChainConfig {
  homesteadBlock: string;
  daoForkBlock: string;
  daoForkSupport: boolean;
  eip150Block: string;
  eip150Hash: string;
  eip155Block: string;
  eip158Block: string;
  byzantiumBlock: string;
  constantinopleBlock: string;
  petersburgBlock: string;
  istanbulBlock: string;
  muirGlacierBlock: string;
  berlinBlock: string;
  londonBlock: string;
  arrowGlacierBlock: string;
  grayGlacierBlock: string;
  mergeNetsplitBlock: string;
  shanghaiTime: string;
  cancunTime: string;
  pragueTime: string;
  eip155ChainId: string;
  blobScheduleConfig?: EvmBlobScheduleConfig;
}
interface EvmParams {
  evmDenom: string;
  enableCreate: boolean;
  enableCall: boolean;
  extraEips: string[];
  chainConfig?: EvmChainConfig;
  allowUnprotectedTxs: boolean;
  authorizedDeployers: string[];
  permissioned: boolean;
}
type GrpcEvmLog = Log;
type GrpcEvmParams = Params$12;
type GrpcEvmChainConfig = ChainConfig;
type GrpcEvmBlobScheduleConfig = BlobScheduleConfig;
type GrpcEvmBlobConfig = BlobConfig;
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/cosmos/auth/v1beta1/auth_pb.d.ts
/**
 * BaseAccount defines a base account type. It contains all the necessary fields
 * for basic account functionality. Any custom account type should extend this
 * type for additional functionality (e.g. vesting).
 *
 * @generated from protobuf message cosmos.auth.v1beta1.BaseAccount
 */
interface BaseAccount$1 {
  /**
   * @generated from protobuf field: string address = 1
   */
  address: string;
  /**
   * @generated from protobuf field: google.protobuf.Any pub_key = 2
   */
  pubKey?: Any;
  /**
   * @generated from protobuf field: uint64 account_number = 3
   */
  accountNumber: bigint;
  /**
   * @generated from protobuf field: uint64 sequence = 4
   */
  sequence: bigint;
}
/**
 * Params defines the parameters for the auth module.
 *
 * @generated from protobuf message cosmos.auth.v1beta1.Params
 */
interface Params$11 {
  /**
   * @generated from protobuf field: uint64 max_memo_characters = 1
   */
  maxMemoCharacters: bigint;
  /**
   * @generated from protobuf field: uint64 tx_sig_limit = 2
   */
  txSigLimit: bigint;
  /**
   * @generated from protobuf field: uint64 tx_size_cost_per_byte = 3
   */
  txSizeCostPerByte: bigint;
  /**
   * @generated from protobuf field: uint64 sig_verify_cost_ed25519 = 4
   */
  sigVerifyCostEd25519: bigint;
  /**
   * @generated from protobuf field: uint64 sig_verify_cost_secp256k1 = 5
   */
  sigVerifyCostSecp256K1: bigint;
}
/**
 * @generated MessageType for protobuf message cosmos.auth.v1beta1.BaseAccount
 */
declare const BaseAccount$1 = new BaseAccount$Type();
/**
 * @generated MessageType for protobuf message cosmos.auth.v1beta1.Params
 */
declare const Params$11 = new Params$Type();
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/injective/types/v1beta1/account_pb.d.ts
/**
 * EthAccount implements the authtypes.AccountI interface and embeds an
 * authtypes.BaseAccount type. It is compatible with the auth AccountKeeper.
 *
 * @generated from protobuf message injective.types.v1beta1.EthAccount
 */
interface EthAccount$1 {
  /**
   * @generated from protobuf field: cosmos.auth.v1beta1.BaseAccount base_account = 1
   */
  baseAccount?: BaseAccount$1;
  /**
   * @generated from protobuf field: bytes code_hash = 2
   */
  codeHash: Uint8Array;
}
/**
 * @generated MessageType for protobuf message injective.types.v1beta1.EthAccount
 */
declare const EthAccount$1 = new EthAccount$Type();
//#endregion
//#region src/client/chain/types/auth.d.ts
interface AuthModuleParams {
  maxMemoCharacters: number;
  txSigLimit: number;
  txSizeCostPerByte: number;
  sigVerifyCostEd25519: number;
  sigVerifyCostSecp256k1: number;
}
interface PubKey$1 {
  key: string;
  typeUrl: string;
}
interface AuthBaseAccount {
  address: string;
  pubKey?: PubKey$1;
  accountNumber: number;
  sequence: number;
}
interface Account {
  codeHash: string;
  baseAccount: AuthBaseAccount;
}
type EthAccount = EthAccount$1;
//#endregion
//#region src/client/chain/types/bank.d.ts
interface BankModuleParams {
  sendEnabledList: Array<SendEnabled>;
  defaultSendEnabled: boolean;
}
interface TotalSupply extends Array<Coin> {}
type GrpcSupply = Supply;
type GrpcBankParams = Params$10;
type SendEnabled = SendEnabled$1;
type Metadata = Metadata$1;
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/cosmos/mint/v1beta1/mint_pb.d.ts
/**
 * Params defines the parameters for the x/mint module.
 *
 * @generated from protobuf message cosmos.mint.v1beta1.Params
 */
interface Params$9 {
  /**
   * type of coin to mint
   *
   * @generated from protobuf field: string mint_denom = 1
   */
  mintDenom: string;
  /**
   * maximum annual change in inflation rate
   *
   * @generated from protobuf field: string inflation_rate_change = 2
   */
  inflationRateChange: string;
  /**
   * maximum inflation rate
   *
   * @generated from protobuf field: string inflation_max = 3
   */
  inflationMax: string;
  /**
   * minimum inflation rate
   *
   * @generated from protobuf field: string inflation_min = 4
   */
  inflationMin: string;
  /**
   * goal of percent bonded atoms
   *
   * @generated from protobuf field: string goal_bonded = 5
   */
  goalBonded: string;
  /**
   * expected blocks per year
   *
   * @generated from protobuf field: uint64 blocks_per_year = 6
   */
  blocksPerYear: bigint;
}
/**
 * @generated MessageType for protobuf message cosmos.mint.v1beta1.Params
 */
declare const Params$9 = new Params$Type();
//#endregion
//#region src/client/chain/types/mint.d.ts
type GrpcMintParams = Params$9;
interface MinModuleParams extends GrpcMintParams {}
//#endregion
//#region src/client/chain/types/insurance.d.ts
interface InsuranceModuleParams {
  defaultRedemptionNoticePeriodDuration: number;
}
interface InsuranceFund {
  depositDenom: string;
  insurancePoolTokenDenom: string;
  redemptionNoticePeriodDuration?: number;
  balance: string;
  totalShare: string;
  marketId: string;
  marketTicker: string;
  oracleBase: string;
  oracleQuote: string;
  oracleType: OracleType;
  expiry: number;
}
type GrpcInsuranceParams = Params;
type GrpcInsuranceFund = InsuranceFund$1;
type GrpcRedemptionSchedule = RedemptionSchedule$1;
declare const OracleTypeMap: typeof OracleType;
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/injective/exchange/v1beta1/authz_pb.d.ts
/**
 * spot authz messages
 *
 * @generated from protobuf message injective.exchange.v1beta1.CreateSpotLimitOrderAuthz
 */
interface CreateSpotLimitOrderAuthz$1 {
  /**
   * the subaccount ID
   *
   * @generated from protobuf field: string subaccount_id = 1
   */
  subaccountId: string;
  /**
   * the market IDs
   *
   * @generated from protobuf field: repeated string market_ids = 2
   */
  marketIds: string[];
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.CreateSpotMarketOrderAuthz
 */
interface CreateSpotMarketOrderAuthz$1 {
  /**
   * the subaccount ID
   *
   * @generated from protobuf field: string subaccount_id = 1
   */
  subaccountId: string;
  /**
   * the market IDs
   *
   * @generated from protobuf field: repeated string market_ids = 2
   */
  marketIds: string[];
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.BatchCreateSpotLimitOrdersAuthz
 */
interface BatchCreateSpotLimitOrdersAuthz$1 {
  /**
   * the subaccount ID
   *
   * @generated from protobuf field: string subaccount_id = 1
   */
  subaccountId: string;
  /**
   * the market IDs
   *
   * @generated from protobuf field: repeated string market_ids = 2
   */
  marketIds: string[];
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.CancelSpotOrderAuthz
 */
interface CancelSpotOrderAuthz$1 {
  /**
   * the subaccount ID
   *
   * @generated from protobuf field: string subaccount_id = 1
   */
  subaccountId: string;
  /**
   * the market IDs
   *
   * @generated from protobuf field: repeated string market_ids = 2
   */
  marketIds: string[];
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.BatchCancelSpotOrdersAuthz
 */
interface BatchCancelSpotOrdersAuthz$1 {
  /**
   * the subaccount ID
   *
   * @generated from protobuf field: string subaccount_id = 1
   */
  subaccountId: string;
  /**
   * the market IDs
   *
   * @generated from protobuf field: repeated string market_ids = 2
   */
  marketIds: string[];
}
/**
 * derivative authz messages
 *
 * @generated from protobuf message injective.exchange.v1beta1.CreateDerivativeLimitOrderAuthz
 */
interface CreateDerivativeLimitOrderAuthz$1 {
  /**
   * the subaccount ID
   *
   * @generated from protobuf field: string subaccount_id = 1
   */
  subaccountId: string;
  /**
   * the market IDs
   *
   * @generated from protobuf field: repeated string market_ids = 2
   */
  marketIds: string[];
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.CreateDerivativeMarketOrderAuthz
 */
interface CreateDerivativeMarketOrderAuthz$1 {
  /**
   * the subaccount ID
   *
   * @generated from protobuf field: string subaccount_id = 1
   */
  subaccountId: string;
  /**
   * the market IDs
   *
   * @generated from protobuf field: repeated string market_ids = 2
   */
  marketIds: string[];
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.BatchCreateDerivativeLimitOrdersAuthz
 */
interface BatchCreateDerivativeLimitOrdersAuthz$1 {
  /**
   * the subaccount ID
   *
   * @generated from protobuf field: string subaccount_id = 1
   */
  subaccountId: string;
  /**
   * the market IDs
   *
   * @generated from protobuf field: repeated string market_ids = 2
   */
  marketIds: string[];
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.CancelDerivativeOrderAuthz
 */
interface CancelDerivativeOrderAuthz$1 {
  /**
   * @generated from protobuf field: string subaccount_id = 1
   */
  subaccountId: string;
  /**
   * @generated from protobuf field: repeated string market_ids = 2
   */
  marketIds: string[];
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.BatchCancelDerivativeOrdersAuthz
 */
interface BatchCancelDerivativeOrdersAuthz$1 {
  /**
   * @generated from protobuf field: string subaccount_id = 1
   */
  subaccountId: string;
  /**
   * @generated from protobuf field: repeated string market_ids = 2
   */
  marketIds: string[];
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.CreateSpotLimitOrderAuthz
 */
declare const CreateSpotLimitOrderAuthz$1 = new CreateSpotLimitOrderAuthz$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.CreateSpotMarketOrderAuthz
 */
declare const CreateSpotMarketOrderAuthz$1 = new CreateSpotMarketOrderAuthz$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.BatchCreateSpotLimitOrdersAuthz
 */
declare const BatchCreateSpotLimitOrdersAuthz$1 = new BatchCreateSpotLimitOrdersAuthz$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.CancelSpotOrderAuthz
 */
declare const CancelSpotOrderAuthz$1 = new CancelSpotOrderAuthz$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.BatchCancelSpotOrdersAuthz
 */
declare const BatchCancelSpotOrdersAuthz$1 = new BatchCancelSpotOrdersAuthz$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.CreateDerivativeLimitOrderAuthz
 */
declare const CreateDerivativeLimitOrderAuthz$1 = new CreateDerivativeLimitOrderAuthz$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.CreateDerivativeMarketOrderAuthz
 */
declare const CreateDerivativeMarketOrderAuthz$1 = new CreateDerivativeMarketOrderAuthz$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.BatchCreateDerivativeLimitOrdersAuthz
 */
declare const BatchCreateDerivativeLimitOrdersAuthz$1 = new BatchCreateDerivativeLimitOrdersAuthz$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.CancelDerivativeOrderAuthz
 */
declare const CancelDerivativeOrderAuthz$1 = new CancelDerivativeOrderAuthz$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.BatchCancelDerivativeOrdersAuthz
 */
declare const BatchCancelDerivativeOrdersAuthz$1 = new BatchCancelDerivativeOrdersAuthz$Type();
//#endregion
//#region src/client/chain/types/authZ.d.ts
type Grant$1 = Grant;
type GrantAuthorization$1 = GrantAuthorization;
type GenericAuthorization$1 = GenericAuthorization$2;
type CreateSpotLimitOrderAuthz = CreateSpotLimitOrderAuthz$1;
type CreateSpotMarketOrderAuthz = CreateSpotMarketOrderAuthz$1;
type BatchCreateSpotLimitOrdersAuthz = BatchCreateSpotLimitOrdersAuthz$1;
type CancelSpotOrderAuthz = CancelSpotOrderAuthz$1;
type BatchCancelSpotOrdersAuthz = BatchCancelSpotOrdersAuthz$1;
type CreateDerivativeLimitOrderAuthz = CreateDerivativeLimitOrderAuthz$1;
type CreateDerivativeMarketOrderAuthz = CreateDerivativeMarketOrderAuthz$1;
type BatchCreateDerivativeLimitOrdersAuthz = BatchCreateDerivativeLimitOrdersAuthz$1;
type CancelDerivativeOrderAuthz = CancelDerivativeOrderAuthz$1;
type BatchCancelDerivativeOrdersAuthz = BatchCancelDerivativeOrdersAuthz$1;
interface GrantWithDecodedAuthorization extends Omit<Grant$1, 'authorization'> {
  authorization: GenericAuthorization$1 | undefined; /** Todo: add more authorizations */
  authorizationType: string;
}
interface GrantAuthorizationWithDecodedAuthorization extends Omit<GrantAuthorization$1, 'authorization'> {
  authorization: GenericAuthorization$1 | undefined; /** Todo: add more authorizations */
  authorizationType: string;
}
//#endregion
//#region src/client/chain/types/peggy.d.ts
type GrpcPeggyParams = {
  peggyId: string;
  contractSourceHash: string;
  bridgeEthereumAddress: string;
  bridgeChainId: string;
  signedValsetsWindow: string;
  signedBatchesWindow: string;
  signedClaimsWindow: string;
  targetBatchTimeout: string;
  averageBlockTime: string;
  averageEthereumBlockTime: string;
  slashFractionValset: Uint8Array;
  slashFractionBatch: Uint8Array;
  slashFractionClaim: Uint8Array;
  slashFractionConflictingClaim: Uint8Array;
  unbondSlashingValsetsWindow: string;
  slashFractionBadEthSignature: Uint8Array;
  cosmosCoinDenom: string;
  cosmosCoinErc20Contract: string;
  claimSlashingEnabled: boolean;
  bridgeContractStartHeight: string;
  valsetReward: Coin | undefined;
};
interface PeggyModuleParams extends GrpcPeggyParams {
  valsetReward: Coin;
}
//#endregion
//#region src/client/chain/types/erc20.d.ts
interface TokenPair {
  /** bank denom */
  bankDenom: string;
  /** address of erc20 smart contract that is backed by */
  erc20Address: string;
}
interface Params$6 {
  denomCreationFee?: Coin;
}
type GrpcParams = Params$7;
type GrpcTokenPair = TokenPair$1;
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/injective/txfees/v1beta1/txfees_pb.d.ts
/**
 * @generated from protobuf message injective.txfees.v1beta1.Params
 */
interface Params$15 {
  /**
   * @generated from protobuf field: uint64 max_gas_wanted_per_tx = 1
   */
  maxGasWantedPerTx: bigint;
  /**
   * @generated from protobuf field: uint64 high_gas_tx_threshold = 2
   */
  highGasTxThreshold: bigint;
  /**
   * @generated from protobuf field: string min_gas_price_for_high_gas_tx = 3
   */
  minGasPriceForHighGasTx: string;
  /**
   * @generated from protobuf field: bool mempool1559_enabled = 4
   */
  mempool1559Enabled: boolean;
  /**
   * @generated from protobuf field: string min_gas_price = 5
   */
  minGasPrice: string;
  /**
   * @generated from protobuf field: string default_base_fee_multiplier = 6
   */
  defaultBaseFeeMultiplier: string;
  /**
   * @generated from protobuf field: string max_base_fee_multiplier = 7
   */
  maxBaseFeeMultiplier: string;
  /**
   * @generated from protobuf field: int64 reset_interval = 8
   */
  resetInterval: bigint;
  /**
   * @generated from protobuf field: string max_block_change_rate = 9
   */
  maxBlockChangeRate: string;
  /**
   * @generated from protobuf field: string target_block_space_percent_rate = 10
   */
  targetBlockSpacePercentRate: string;
  /**
   * @generated from protobuf field: string recheck_fee_low_base_fee = 11
   */
  recheckFeeLowBaseFee: string;
  /**
   * @generated from protobuf field: string recheck_fee_high_base_fee = 12
   */
  recheckFeeHighBaseFee: string;
  /**
   * @generated from protobuf field: string recheck_fee_base_fee_threshold_multiplier = 13
   */
  recheckFeeBaseFeeThresholdMultiplier: string;
}
/**
 * @generated MessageType for protobuf message injective.txfees.v1beta1.Params
 */
declare const Params$15 = new Params$Type();
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/injective/txfees/v1beta1/query_pb.d.ts
/**
 * @generated from protobuf message injective.txfees.v1beta1.EipBaseFee
 */
interface EipBaseFee {
  /**
   * The current chain gas price
   *
   * @generated from protobuf field: string base_fee = 1
   */
  baseFee: string;
}
/**
 * QueryParamsResponse is the response type for the Query/Params RPC method.
 *
 * @generated from protobuf message injective.txfees.v1beta1.QueryParamsResponse
 */
interface QueryParamsResponse$11 {
  /**
   * params defines the parameters of the module.
   *
   * @generated from protobuf field: injective.txfees.v1beta1.Params params = 1
   */
  params?: Params$15;
}
/**
 * @generated from protobuf message injective.txfees.v1beta1.QueryEipBaseFeeResponse
 */
interface QueryEipBaseFeeResponse {
  /**
   * @generated from protobuf field: injective.txfees.v1beta1.EipBaseFee base_fee = 1
   */
  baseFee?: EipBaseFee;
}
/**
 * @generated MessageType for protobuf message injective.txfees.v1beta1.EipBaseFee
 */
declare const EipBaseFee = new EipBaseFee$Type();
/**
 * @generated MessageType for protobuf message injective.txfees.v1beta1.QueryParamsResponse
 */
declare const QueryParamsResponse$11 = new QueryParamsResponse$Type();
/**
 * @generated MessageType for protobuf message injective.txfees.v1beta1.QueryEipBaseFeeResponse
 */
declare const QueryEipBaseFeeResponse = new QueryEipBaseFeeResponse$Type();
//#endregion
//#region src/client/chain/types/txFees.d.ts
interface TxFeesModuleStateParams {
  maxGasWantedPerTx: string;
  highGasTxThreshold: string;
  minGasPriceForHighGasTx: string;
  mempool1559Enabled: boolean;
  minGasPrice: string;
  defaultBaseFeeMultiplier: string;
  maxBaseFeeMultiplier: string;
  resetInterval: string;
  maxBlockChangeRate: string;
  targetBlockSpacePercentRate: string;
  recheckFeeLowBaseFee: string;
  recheckFeeHighBaseFee: string;
  recheckFeeBaseFeeThresholdMultiplier: string;
}
interface TxFeesEipBaseFee {
  baseFee?: string;
}
type GrpcTxFeesParams = Params$15;
type GrpcTxFeesEipBaseFee = EipBaseFee;
//#endregion
//#region src/client/chain/types/oracle.d.ts
type GrpcOracleParams = Params$17;
interface OracleModuleParams extends GrpcOracleParams {}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/injective/permissions/v1beta1/permissions_pb.d.ts
/**
 * Namespace defines a permissions namespace
 *
 * @generated from protobuf message injective.permissions.v1beta1.Namespace
 */
interface Namespace {
  /**
   * The tokenfactory denom to which this namespace applies to
   *
   * @generated from protobuf field: string denom = 1
   */
  denom: string;
  /**
   * The address of smart contract to apply code-based restrictions
   *
   * @generated from protobuf field: string contract_hook = 2
   */
  contractHook: string;
  /**
   * permissions for each role
   *
   * @generated from protobuf field: repeated injective.permissions.v1beta1.Role role_permissions = 3
   */
  rolePermissions: Role[];
  /**
   * roles for each actor
   *
   * @generated from protobuf field: repeated injective.permissions.v1beta1.ActorRoles actor_roles = 4
   */
  actorRoles: ActorRoles[];
  /**
   * managers for each role
   *
   * @generated from protobuf field: repeated injective.permissions.v1beta1.RoleManager role_managers = 5
   */
  roleManagers: RoleManager[];
  /**
   * status for each policy
   *
   * @generated from protobuf field: repeated injective.permissions.v1beta1.PolicyStatus policy_statuses = 6
   */
  policyStatuses: PolicyStatus[];
  /**
   * capabilities for each manager for each policy
   *
   * @generated from protobuf field: repeated injective.permissions.v1beta1.PolicyManagerCapability policy_manager_capabilities = 7
   */
  policyManagerCapabilities: PolicyManagerCapability[];
}
/**
 * AddressRoles defines roles for an actor
 *
 * @generated from protobuf message injective.permissions.v1beta1.ActorRoles
 */
interface ActorRoles {
  /**
   * The actor name
   *
   * @generated from protobuf field: string actor = 1
   */
  actor: string;
  /**
   * The roles for the actor
   *
   * @generated from protobuf field: repeated string roles = 2
   */
  roles: string[];
}
/**
 * RoleActors defines actors for a role
 *
 * @generated from protobuf message injective.permissions.v1beta1.RoleActors
 */
interface RoleActors {
  /**
   * The role name
   *
   * @generated from protobuf field: string role = 1
   */
  role: string;
  /**
   * List of actor names associated with the role
   *
   * @generated from protobuf field: repeated string actors = 2
   */
  actors: string[];
}
/**
 * RoleManager defines roles for a manager address
 *
 * @generated from protobuf message injective.permissions.v1beta1.RoleManager
 */
interface RoleManager {
  /**
   * The manager name
   *
   * @generated from protobuf field: string manager = 1
   */
  manager: string;
  /**
   * List of roles associated with the manager
   *
   * @generated from protobuf field: repeated string roles = 2
   */
  roles: string[];
}
/**
 * PolicyStatus defines the status of a policy
 *
 * @generated from protobuf message injective.permissions.v1beta1.PolicyStatus
 */
interface PolicyStatus {
  /**
   * The action code number
   *
   * @generated from protobuf field: injective.permissions.v1beta1.Action action = 1
   */
  action: Action;
  /**
   * Whether the policy is disabled
   *
   * @generated from protobuf field: bool is_disabled = 2
   */
  isDisabled: boolean;
  /**
   * Whether the policy is sealed
   *
   * @generated from protobuf field: bool is_sealed = 3
   */
  isSealed: boolean;
}
/**
 * Role is only used for storage
 *
 * @generated from protobuf message injective.permissions.v1beta1.Role
 */
interface Role {
  /**
   * The role name
   *
   * @generated from protobuf field: string name = 1
   */
  name: string;
  /**
   * The role ID
   *
   * @generated from protobuf field: uint32 role_id = 2
   */
  roleId: number;
  /**
   * Integer representing the bitwise combination of all actions assigned to the
   * role
   *
   * @generated from protobuf field: uint32 permissions = 3
   */
  permissions: number;
}
/**
 * PolicyManagerCapability defines the capabilities of a manager for a policy
 *
 * @generated from protobuf message injective.permissions.v1beta1.PolicyManagerCapability
 */
interface PolicyManagerCapability {
  /**
   * The manager name
   *
   * @generated from protobuf field: string manager = 1
   */
  manager: string;
  /**
   * The action code number
   *
   * @generated from protobuf field: injective.permissions.v1beta1.Action action = 2
   */
  action: Action;
  /**
   * Whether the manager can disable the policy
   *
   * @generated from protobuf field: bool can_disable = 3
   */
  canDisable: boolean;
  /**
   * Whether the manager can seal the policy
   *
   * @generated from protobuf field: bool can_seal = 4
   */
  canSeal: boolean;
}
/**
 * used in storage
 *
 * @generated from protobuf message injective.permissions.v1beta1.RoleIDs
 */
interface RoleIDs {
  /**
   * @generated from protobuf field: repeated uint32 role_ids = 1
   */
  roleIds: number[];
}
/**
 * AddressVoucher is used to represent a voucher for a specific address
 *
 * @generated from protobuf message injective.permissions.v1beta1.AddressVoucher
 */
interface AddressVoucher {
  /**
   * The Injective address that the voucher is for
   *
   * @generated from protobuf field: string address = 1
   */
  address: string;
  /**
   * The voucher amount
   *
   * @generated from protobuf field: cosmos.base.v1beta1.Coin voucher = 2
   */
  voucher?: Coin$1;
}
/**
 * each Action enum value should be a power of two
 *
 * @generated from protobuf enum injective.permissions.v1beta1.Action
 */
declare enum Action {
  /**
   * 0 is reserved for ACTION_UNSPECIFIED
   *
   * @generated from protobuf enum value: UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,
  /**
   * 1 is reserved for MINT
   *
   * @generated from protobuf enum value: MINT = 1;
   */
  MINT = 1,
  /**
   * 2 is reserved for RECEIVE
   *
   * @generated from protobuf enum value: RECEIVE = 2;
   */
  RECEIVE = 2,
  /**
   * 4 is reserved for BURN
   *
   * @generated from protobuf enum value: BURN = 4;
   */
  BURN = 4,
  /**
   * 8 is reserved for SEND
   *
   * @generated from protobuf enum value: SEND = 8;
   */
  SEND = 8,
  /**
   * 16 is reserved for SUPER_BURN
   *
   * @generated from protobuf enum value: SUPER_BURN = 16;
   */
  SUPER_BURN = 16,
  /**
   * 2^27 is reserved for MODIFY_POLICY_MANAGERS
   *
   * 2^27 or 134217728
   *
   * @generated from protobuf enum value: MODIFY_POLICY_MANAGERS = 134217728;
   */
  MODIFY_POLICY_MANAGERS = 134217728,
  /**
   * 2^28 is reserved for MODIFY_CONTRACT_HOOK
   *
   * 2^28 or 268435456
   *
   * @generated from protobuf enum value: MODIFY_CONTRACT_HOOK = 268435456;
   */
  MODIFY_CONTRACT_HOOK = 268435456,
  /**
   * 2^29 is reserved for MODIFY_ROLE_PERMISSIONS
   *
   * 2^29 or 536870912
   *
   * @generated from protobuf enum value: MODIFY_ROLE_PERMISSIONS = 536870912;
   */
  MODIFY_ROLE_PERMISSIONS = 536870912,
  /**
   * 2^30 is reserved for MODIFY_ROLE_MANAGERS
   *
   * 2^30 or 1073741824
   *
   * @generated from protobuf enum value: MODIFY_ROLE_MANAGERS = 1073741824;
   */
  MODIFY_ROLE_MANAGERS = 1073741824,
}
/**
 * @generated MessageType for protobuf message injective.permissions.v1beta1.Namespace
 */
declare const Namespace = new Namespace$Type();
/**
 * @generated MessageType for protobuf message injective.permissions.v1beta1.ActorRoles
 */
declare const ActorRoles = new ActorRoles$Type();
/**
 * @generated MessageType for protobuf message injective.permissions.v1beta1.RoleActors
 */
declare const RoleActors = new RoleActors$Type();
/**
 * @generated MessageType for protobuf message injective.permissions.v1beta1.RoleManager
 */
declare const RoleManager = new RoleManager$Type();
/**
 * @generated MessageType for protobuf message injective.permissions.v1beta1.PolicyStatus
 */
declare const PolicyStatus = new PolicyStatus$Type();
/**
 * @generated MessageType for protobuf message injective.permissions.v1beta1.Role
 */
declare const Role = new Role$Type();
/**
 * @generated MessageType for protobuf message injective.permissions.v1beta1.PolicyManagerCapability
 */
declare const PolicyManagerCapability = new PolicyManagerCapability$Type();
/**
 * @generated MessageType for protobuf message injective.permissions.v1beta1.RoleIDs
 */
declare const RoleIDs = new RoleIDs$Type();
/**
 * @generated MessageType for protobuf message injective.permissions.v1beta1.AddressVoucher
 */
declare const AddressVoucher = new AddressVoucher$Type();
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/injective/permissions/v1beta1/params_pb.d.ts
/**
 * Params defines the parameters for the permissions module.
 *
 * @generated from protobuf message injective.permissions.v1beta1.Params
 */
interface Params$3 {
  /**
   * Max amount of gas allowed for wasm hook queries
   *
   * @generated from protobuf field: uint64 wasm_hook_query_max_gas = 1
   */
  wasmHookQueryMaxGas: bigint;
}
/**
 * @generated MessageType for protobuf message injective.permissions.v1beta1.Params
 */
declare const Params$3 = new Params$Type();
//#endregion
//#region src/client/chain/types/permissions.d.ts
interface PermissionParams {
  wasmHookQueryMaxGas: string;
}
interface PermissionRole {
  name: string;
  roleId: number;
  permissions: number;
}
interface PermissionActorRoles {
  actor: string;
  roles: string[];
}
interface PermissionRoleManager {
  manager: string;
  roles: string[];
}
interface PermissionPolicyStatus {
  action: Action;
  isDisabled: boolean;
  isSealed: boolean;
}
interface PermissionPolicyManagerCapability {
  manager: string;
  action: Action;
  canDisable: boolean;
  canSeal: boolean;
}
interface PermissionRoleActors {
  role: string;
  actors: string[];
}
interface PermissionRoleIDs {
  roleIds: number[];
}
interface PermissionAddressVoucher {
  address: string;
  voucher?: Coin;
}
interface PermissionNamespace {
  denom: string;
  contractHook: string;
  rolePermissions: PermissionRole[];
  actorRoles: PermissionActorRoles[];
  roleManagers: PermissionRoleManager[];
  policyStatuses: PermissionPolicyStatus[];
  policyManagerCapabilities: PermissionPolicyManagerCapability[];
}
interface PermissionsModuleParams {
  wasmHookQueryMaxGas: string;
}
interface PermissionAddressRoles {
  address: string;
  roles: string[];
}
interface PermissionRoleIDs {
  roleIds: number[];
}
interface PermissionVoucher {
  coins: Coin[];
}
interface PermissionAddressVoucher {
  address: string;
  voucher?: Coin;
}
interface PermissionGenesisState {
  params?: PermissionParams;
  namespaces: PermissionNamespace[];
  vouchers: PermissionAddressVoucher[];
}
type GrpcPermissionNamespace = Namespace;
type GrpcPermissionRoleIDs = RoleIDs;
type GrpcPermissionsNamespace = Namespace;
type GrpcPermissionRoleActors = RoleActors;
type GrpcPermissionActorRoles = ActorRoles;
type GrpcPermissionRoleManager = RoleManager;
type GrpcPermissionPolicyStatus = PolicyStatus;
type GrpcPermissionAddressVoucher = AddressVoucher;
type GrpcPermissionPolicyStatusManagerCapability = PolicyManagerCapability;
type GrpcPermissionsParams = Params$3;
type GrpcPermissionRole = Role;
declare const PermissionActionMap: typeof Action;
//#endregion
//#region src/client/chain/types/auction.d.ts
interface AuctionParams {
  auctionPeriod: number;
  minNextBidIncrementRate: string;
  injBasketMaxCap: string;
}
interface AuctionBid {
  bidder: string;
  amount?: Coin;
}
interface AuctionLastAuctionResult {
  winner: string;
  amount?: Coin;
  round: string;
}
interface AuctionEventBid {
  bidder: string;
  amount?: Coin;
  round: string;
}
interface AuctionEventAuctionResult {
  winner: string;
  amount?: Coin;
  round: string;
}
interface AuctionEventAuctionStart {
  round: string;
  endingTimestamp: string;
  newBasket: Coin[];
}
interface AuctionCurrentBasket {
  amountList: Coin[];
  auctionRound: number;
  auctionClosingTime: number;
  highestBidder: string;
  highestBidAmount: string;
}
interface AuctionModuleParams {
  auctionPeriod: number;
  minNextBidIncrementRate: string;
}
interface AuctionModuleStateParams {
  auctionPeriod: number;
  minNextBidIncrementRate: string;
}
interface AuctionModuleState {
  params?: AuctionModuleStateParams;
  auctionRound: number;
  highestBid?: AuctionBid;
  auctionEndingTimestamp: number;
  lastAuctionResult?: AuctionLastAuctionResult;
}
interface AuctionModuleStateResponse {
  params?: AuctionParams;
  auctionRound: string;
  highestBid?: AuctionBid;
  auctionEndingTimestamp: string;
  lastAuctionResult?: AuctionLastAuctionResult;
}
type GrpcAuctionParams = Params$5;
type GrpcAuctionBid = Bid;
type GrpcAuctionLastAuctionResult = LastAuctionResult;
type GrpcAuctionEventBid = EventBid;
type GrpcAuctionEventAuctionResult = EventAuctionResult;
type GrpcAuctionEventAuctionStart = EventAuctionStart;
//#endregion
//#region src/client/chain/types/auth-rest.d.ts
interface AccountsResponse {
  accounts: {
    '@type': string;
    code_hash: string;
    base_account: {
      address: string;
      account_number: string;
      sequence: string;
      pub_key: {
        '@type': string;
        key: string;
      };
    };
  }[];
  pagination: {
    nextKey?: string;
    total: string;
  };
}
interface AccountResponse {
  account: {
    '@type': string;
    code_hash: string;
    base_account: {
      address: string;
      account_number: string;
      sequence: string;
      pub_key: {
        '@type': string;
        key: string;
      };
    };
  };
}
interface CosmosAccountRestResponse {
  account: {
    address: string;
    account_number: string;
    sequence: string;
    pub_key: {
      '@type': string;
      key: string;
    };
  };
}
interface BaseAccountRestResponse {
  address: string;
  account_number: string;
  sequence: string;
  pub_key: {
    '@type': string;
    key: string;
  };
}
//#endregion
//#region src/client/chain/types/bank-rest.d.ts
interface DenomBalance {
  denom: string;
  amount: string;
}
interface BalancesResponse {
  balances: DenomBalance[];
}
interface DenomOwnersResponse {
  denom_owners: {
    address: string;
    balance: {
      denom: string;
      amount: string;
    };
  }[];
}
//#endregion
//#region src/client/chain/types/distribution.d.ts
interface DistributionModuleParams {
  communityTax: string;
  baseProposerReward: string;
  bonusProposerReward: string;
  withdrawAddrEnabled: boolean;
}
interface ValidatorRewards {
  rewards: Coin[];
  validatorAddress: string;
}
type GrpcDelegationDelegatorReward = DelegationDelegatorReward;
type GrpcDistributionParams = Params$2;
type GrpcDecCoin = DecCoin;
//#endregion
//#region src/client/chain/types/tokenfactory.d.ts
interface TokenFactoryModuleParams {
  denomCreationFee: Coin[];
}
interface TokenFactoryModuleState {
  denomCreationFee: Coin[];
  factoryDenoms: FactoryDenomWithMetadata[];
}
interface FactoryDenomWithMetadata {
  denom: string;
  authorityMetadata: AuthorityMetadata;
}
interface AuthorityMetadata {
  admin: string | undefined;
}
//#endregion
//#region src/client/chain/types/tendermint-rest.d.ts
interface BlockLatestRestResponse {
  block_id: {
    hash: string;
    part_set_header: {
      total: number;
      hash: string;
    };
  };
  block: {
    header: {
      version: {
        block: string;
        app: string;
      };
      chain_id: string;
      height: string;
      time: Date;
      last_block_id: {
        hash: string;
        part_set_header: {
          total: 0;
          hash: string;
        };
      };
      last_commit_hash: string;
      data_hash: string;
      validators_hash: string;
      next_validators_hash: string;
      consensus_hash: string;
      app_hash: string;
      last_results_hash: string;
      evidence_hash: string;
      proposer_address: string;
    };
  };
  sdk_block: {
    header: {
      version: {
        block: string;
        app: string;
      };
      chain_id: string;
      height: string;
      time: Date;
      last_block_id: {
        hash: string;
        part_set_header: {
          total: 0;
          hash: string;
        };
      };
      last_commit_hash: string;
      data_hash: string;
      validators_hash: string;
      next_validators_hash: string;
      consensus_hash: string;
      app_hash: string;
      last_results_hash: string;
      evidence_hash: string;
      proposer_address: string;
    };
  };
}
interface NodeInfoRestResponse {
  default_node_info: {
    protocol_version: {
      p2p: string;
      block: string;
      app: string;
    };
    default_node_id: string;
    listen_addr: string;
    network: string;
    version: string;
    channels: string;
    moniker: string;
    other: {
      tx_index: string;
      rpc_address: string;
    };
  };
  application_version: {
    name: string;
    app_name: string;
    version: string;
    git_commit: string;
    build_tags: string;
    go_version: string;
    build_deps: [{
      path: string;
      version: string;
      sum: string;
    }];
    cosmos_sdk_version: string;
  };
}
//#endregion
//#region src/client/chain/types/index.d.ts
interface RestApiResponse<T> {
  data: T;
}
declare const ChainModule: {
  Gov: "chain-gov";
  Ibc: "chain-ibc";
  Evm: "chain-evm";
  Auth: "chain-auth";
  Bank: "chain-bank";
  Mint: "chain-mint";
  Wasm: "chain-wasm";
  Authz: "chain-authz";
  Peggy: "chain-peggy";
  WasmX: "chain-wasmx";
  Erc20: "chain-erc20";
  Oracle: "chain-oracle";
  TxFees: "chain-tx-fees";
  Auction: "chain-auction";
  Staking: "chain-staking";
  Exchange: "chain-exchange";
  Tendermint: "chain-tendermint";
  InsuranceFund: "chain-insurance";
  Permissions: "chain-permissions";
  Distribution: "chain-distribution";
};
//#endregion
//#region src/core/modules/exchange/msgs/MsgAdminUpdateBinaryOptionsMarket.d.ts
declare namespace MsgAdminUpdateBinaryOptionsMarket {
  interface Params {
    sender: string;
    marketId: string;
    settlementPrice: string;
    expirationTimestamp: string;
    settlementTimestamp: string;
    status: GrpcMarketStatus;
  }
  type Proto = MsgAdminUpdateBinaryOptionsMarket$1;
}
/**
 * @category Messages
 */
declare class MsgAdminUpdateBinaryOptionsMarket extends MsgBase<MsgAdminUpdateBinaryOptionsMarket.Params, MsgAdminUpdateBinaryOptionsMarket.Proto> {
  static fromJSON(params: MsgAdminUpdateBinaryOptionsMarket.Params): MsgAdminUpdateBinaryOptionsMarket;
  toProto(): MsgAdminUpdateBinaryOptionsMarket$1;
  toData(): {
    sender: string;
    marketId: string;
    settlementPrice: string;
    expirationTimestamp: bigint;
    settlementTimestamp: bigint;
    status: MarketStatus;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      sender: string;
      market_id: string;
      settlement_price: string;
      expiration_timestamp: string;
      settlement_timestamp: string;
      status: MarketStatus;
    };
  };
  toWeb3Gw(): {
    sender: string;
    market_id: string;
    settlement_price: string;
    expiration_timestamp: string;
    settlement_timestamp: string;
    status: MarketStatus;
    '@type': string;
  };
  toEip712(): {
    type: string;
    value: {
      settlement_price: any;
      sender: string;
      market_id: string;
      expiration_timestamp: string;
      settlement_timestamp: string;
      status: MarketStatus;
    };
  };
  toEip712V2(): {
    settlement_price: string;
    status: string;
    sender: string;
    market_id: string;
    expiration_timestamp: string;
    settlement_timestamp: string;
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgAdminUpdateBinaryOptionsMarket$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/exchange/msgs/MsgBatchCancelBinaryOptionsOrders.d.ts
declare namespace MsgBatchCancelBinaryOptionsOrders {
  interface Params {
    injectiveAddress: string;
    orders: {
      marketId: string;
      subaccountId: string;
      orderHash?: string;
      orderMask?: OrderMask;
      cid?: string;
    }[];
  }
  type Proto = MsgBatchCancelBinaryOptionsOrders$1;
}
/**
 * @category Messages
 */
declare class MsgBatchCancelBinaryOptionsOrders extends MsgBase<MsgBatchCancelBinaryOptionsOrders.Params, MsgBatchCancelBinaryOptionsOrders.Proto> {
  static fromJSON(params: MsgBatchCancelBinaryOptionsOrders.Params): MsgBatchCancelBinaryOptionsOrders;
  toProto(): MsgBatchCancelBinaryOptionsOrders$1;
  toData(): {
    sender: string;
    data: OrderData[];
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      sender: string;
      data: {
        market_id: string;
        subaccount_id: string;
        order_hash: string | undefined;
        order_mask: OrderMask | undefined;
        cid: string | undefined;
      }[];
    };
  };
  toWeb3Gw(): {
    sender: string;
    data: {
      market_id: string;
      subaccount_id: string;
      order_hash: string | undefined;
      order_mask: OrderMask | undefined;
      cid: string | undefined;
    }[];
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgBatchCancelBinaryOptionsOrders$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/exchange/msgs/MsgCreateBinaryOptionsMarketOrder.d.ts
declare namespace MsgCreateBinaryOptionsMarketOrder {
  interface Params {
    marketId: string;
    subaccountId: string;
    injectiveAddress: string;
    orderType: OrderType$1;
    triggerPrice?: string;
    feeRecipient: string;
    price: string;
    margin: string;
    quantity: string;
    cid?: string;
  }
  type Proto = MsgCreateBinaryOptionsMarketOrder$1;
}
/**
 * @category Messages
 */
declare class MsgCreateBinaryOptionsMarketOrder extends MsgBase<MsgCreateBinaryOptionsMarketOrder.Params, MsgCreateBinaryOptionsMarketOrder.Proto> {
  static fromJSON(params: MsgCreateBinaryOptionsMarketOrder.Params): MsgCreateBinaryOptionsMarketOrder;
  toProto(): MsgCreateBinaryOptionsMarketOrder$1;
  toData(): {
    sender: string;
    order?: DerivativeOrder$1;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      sender: string;
      order: {
        market_id: string;
        order_info: {
          subaccount_id: string;
          fee_recipient: string;
          price: string;
          quantity: string;
          cid: string;
        };
        order_type: OrderType$1;
        margin: string;
        trigger_price: string;
      };
    };
  };
  toWeb3Gw(): {
    sender: string;
    order: {
      market_id: string;
      order_info: {
        subaccount_id: string;
        fee_recipient: string;
        price: string;
        quantity: string;
        cid: string;
      };
      order_type: OrderType$1;
      margin: string;
      trigger_price: string;
    };
    '@type': string;
  };
  toEip712V2(): {
    order: any;
    sender: string;
    '@type': string;
  };
  toEip712(): {
    type: string;
    value: {
      order: {
        order_info: {
          price: any;
          quantity: any;
          subaccount_id: string;
          fee_recipient: string;
          cid: string;
        };
        margin: any;
        trigger_price: any;
        market_id: string;
        order_type: OrderType$1;
      };
      sender: string;
    };
  };
  toDirectSign(): {
    type: string;
    message: MsgCreateBinaryOptionsMarketOrder$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/exchange/msgs/MsgSetDelegationTransferReceivers.d.ts
declare namespace MsgSetDelegationTransferReceivers {
  interface Params {
    sender: string;
    receivers: string[];
  }
  type Proto = {
    sender: string;
    receivers: string[];
  };
}
/**
 * @category Messages
 */
declare class MsgSetDelegationTransferReceivers extends MsgBase<MsgSetDelegationTransferReceivers.Params, MsgSetDelegationTransferReceivers.Proto> {
  static fromJSON(params: MsgSetDelegationTransferReceivers.Params): MsgSetDelegationTransferReceivers;
  toProto(): {
    sender: string;
    receivers: string[];
  };
  toData(): {
    sender: string;
    receivers: string[];
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      sender: string;
      receivers: string[];
    };
  };
  toWeb3Gw(): {
    sender: string;
    receivers: string[];
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: {
      sender: string;
      receivers: string[];
    };
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/msgs.d.ts
type Erc20Msgs = MsgCreateTokenPair;
type AuctionMsgs = MsgBid;
type AuthzMsgs = MsgGrant | MsgRevoke | MsgExec | MsgGrantWithAuthorization;
type BankMsgs = MsgSend | MsgMultiSend;
type DistributionMsgs = MsgFundCommunityPool | MsgWithdrawDelegatorReward | MsgWithdrawValidatorCommission;
type ExchangeV1Msgs = MsgDeposit | MsgSignData | MsgWithdraw | MsgRewardsOptOut | MsgCancelSpotOrder | MsgExternalTransfer | MsgBatchUpdateOrders | MsgLiquidatePosition | MsgReclaimLockedFunds | MsgAuthorizeStakeGrants | MsgCreateSpotLimitOrder | MsgBatchCancelSpotOrders | MsgCancelDerivativeOrder | MsgCreateSpotMarketOrder | MsgIncreasePositionMargin | MsgInstantSpotMarketLaunch | MsgCancelBinaryOptionsOrder | MsgCreateDerivativeLimitOrder | MsgBatchCancelDerivativeOrders | MsgCreateDerivativeMarketOrder | MsgCreateBinaryOptionsLimitOrder | MsgAdminUpdateBinaryOptionsMarket | MsgBatchCancelBinaryOptionsOrders | MsgCreateBinaryOptionsMarketOrder | MsgSetDelegationTransferReceivers;
type ExchangeV2Msgs = MsgUpdateSpotMarketV2 | MsgCancelPostOnlyModeV2 | MsgUpdateDerivativeMarketV2;
type FeegrantMsgs = MsgGrantAllowance | MsgRevokeAllowance;
type GovMsgs = MsgVote | MsgSubmitProposal | MsgDeposit$1;
type IbcMsgs = MsgTransfer;
type InsuranceMsgs = MsgUnderwrite | MsgRequestRedemption | MsgCreateInsuranceFund;
type PeggyMsgs = MsgSendToEth;
type StakingMsgs = MsgDelegate | MsgUndelegate | MsgEditValidator | MsgBeginRedelegate | MsgCreateValidator | MsgTransferDelegation | MsgCancelUnbondingDelegation;
type TokenFactoryMsgs = MsgBurn | MsgMint | MsgChangeAdmin | MsgCreateDenom | MsgSetDenomMetadata;
type WasmMsgs = MsgStoreCode | MsgUpdateAdmin | MsgPrivilegedExecuteContract | MsgExecuteContract | MsgMigrateContract | MsgInstantiateContract | MsgExecuteContractCompat;
type Msgs = AuctionMsgs | AuthzMsgs | BankMsgs | DistributionMsgs | ExchangeV1Msgs | ExchangeV2Msgs | FeegrantMsgs | GovMsgs | IbcMsgs | InsuranceMsgs | PeggyMsgs | StakingMsgs | TokenFactoryMsgs | WasmMsgs | Erc20Msgs;
type ExchangeMsgs = ExchangeV1Msgs | ExchangeV2Msgs;
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/cometbft/types/v1/evidence_pb.d.ts
/**
 * Evidence is a generic type for wrapping evidence of misbehavior by a validator.
 *
 * @generated from protobuf message cometbft.types.v1.Evidence
 */
interface Evidence {
  /**
   * The type of evidence.
   *
   * @generated from protobuf oneof: sum
   */
  sum: {
    oneofKind: "duplicateVoteEvidence";
    /**
     * @generated from protobuf field: cometbft.types.v1.DuplicateVoteEvidence duplicate_vote_evidence = 1
     */
    duplicateVoteEvidence: DuplicateVoteEvidence;
  } | {
    oneofKind: "lightClientAttackEvidence";
    /**
     * @generated from protobuf field: cometbft.types.v1.LightClientAttackEvidence light_client_attack_evidence = 2
     */
    lightClientAttackEvidence: LightClientAttackEvidence;
  } | {
    oneofKind: undefined;
  };
}
/**
 * DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes.
 *
 * @generated from protobuf message cometbft.types.v1.DuplicateVoteEvidence
 */
interface DuplicateVoteEvidence {
  /**
   * @generated from protobuf field: cometbft.types.v1.Vote vote_a = 1
   */
  voteA?: Vote$2;
  /**
   * @generated from protobuf field: cometbft.types.v1.Vote vote_b = 2
   */
  voteB?: Vote$2;
  /**
   * @generated from protobuf field: int64 total_voting_power = 3
   */
  totalVotingPower: bigint;
  /**
   * @generated from protobuf field: int64 validator_power = 4
   */
  validatorPower: bigint;
  /**
   * @generated from protobuf field: google.protobuf.Timestamp timestamp = 5
   */
  timestamp?: Timestamp;
}
/**
 * LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client.
 *
 * @generated from protobuf message cometbft.types.v1.LightClientAttackEvidence
 */
interface LightClientAttackEvidence {
  /**
   * @generated from protobuf field: cometbft.types.v1.LightBlock conflicting_block = 1
   */
  conflictingBlock?: LightBlock;
  /**
   * @generated from protobuf field: int64 common_height = 2
   */
  commonHeight: bigint;
  /**
   * @generated from protobuf field: repeated cometbft.types.v1.Validator byzantine_validators = 3
   */
  byzantineValidators: Validator$3[];
  /**
   * @generated from protobuf field: int64 total_voting_power = 4
   */
  totalVotingPower: bigint;
  /**
   * @generated from protobuf field: google.protobuf.Timestamp timestamp = 5
   */
  timestamp?: Timestamp;
}
/**
 * EvidenceList is a list of evidence.
 *
 * @generated from protobuf message cometbft.types.v1.EvidenceList
 */
interface EvidenceList {
  /**
   * @generated from protobuf field: repeated cometbft.types.v1.Evidence evidence = 1
   */
  evidence: Evidence[];
}
/**
 * @generated MessageType for protobuf message cometbft.types.v1.Evidence
 */
declare const Evidence = new Evidence$Type();
/**
 * @generated MessageType for protobuf message cometbft.types.v1.DuplicateVoteEvidence
 */
declare const DuplicateVoteEvidence = new DuplicateVoteEvidence$Type();
/**
 * @generated MessageType for protobuf message cometbft.types.v1.LightClientAttackEvidence
 */
declare const LightClientAttackEvidence = new LightClientAttackEvidence$Type();
/**
 * @generated MessageType for protobuf message cometbft.types.v1.EvidenceList
 */
declare const EvidenceList = new EvidenceList$Type();
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/cometbft/types/v1/block_pb.d.ts
/**
 * Block defines the structure of a block in the CometBFT blockchain.
 *
 * @generated from protobuf message cometbft.types.v1.Block
 */
interface Block$2 {
  /**
   * @generated from protobuf field: cometbft.types.v1.Header header = 1
   */
  header?: Header$1;
  /**
   * @generated from protobuf field: cometbft.types.v1.Data data = 2
   */
  data?: Data;
  /**
   * @generated from protobuf field: cometbft.types.v1.EvidenceList evidence = 3
   */
  evidence?: EvidenceList;
  /**
   * @generated from protobuf field: cometbft.types.v1.Commit last_commit = 4
   */
  lastCommit?: Commit;
}
/**
 * @generated MessageType for protobuf message cometbft.types.v1.Block
 */
declare const Block$2 = new Block$Type();
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/cosmos/tx/v1beta1/service_pb.d.ts
/**
 * BroadcastMode specifies the broadcast mode for the TxService.Broadcast RPC
 * method.
 *
 * @generated from protobuf enum cosmos.tx.v1beta1.BroadcastMode
 */
declare enum BroadcastMode$1 {
  /**
   * zero-value for mode ordering
   *
   * @generated from protobuf enum value: BROADCAST_MODE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,
  /**
   * DEPRECATED: use BROADCAST_MODE_SYNC instead,
   * BROADCAST_MODE_BLOCK is not supported by the SDK from v0.47.x onwards.
   *
   * @deprecated
   * @generated from protobuf enum value: BROADCAST_MODE_BLOCK = 1 [deprecated = true];
   */
  BLOCK = 1,
  /**
   * BROADCAST_MODE_SYNC defines a tx broadcasting mode where the client waits
   * for a CheckTx execution response only.
   *
   * @generated from protobuf enum value: BROADCAST_MODE_SYNC = 2;
   */
  SYNC = 2,
  /**
   * BROADCAST_MODE_ASYNC defines a tx broadcasting mode where the client
   * returns immediately.
   *
   * @generated from protobuf enum value: BROADCAST_MODE_ASYNC = 3;
   */
  ASYNC = 3,
}
//#endregion
//#region src/core/tx/types/tx.d.ts
interface TxClientBroadcastOptions {
  mode?: BroadcastMode$1;
  timeout?: number;
  txTimeout?: number;
}
interface TxClientBroadcastResponse {
  height: number;
  txHash: string;
  codespace: string;
  code: number;
  data?: string;
  rawLog: string;
  logs?: any[];
  info?: string;
  gasWanted: number;
  gasUsed: number;
  timestamp: string;
  events?: any[];
}
interface TxClientSimulateResponse {
  result: {
    data: Uint8Array | string;
    log: string;
    eventsList: any[];
  };
  gasInfo: {
    gasWanted: number;
    gasUsed: number;
  };
}
interface TxConcreteApi {
  broadcast(txRaw: TxRaw, options?: TxClientBroadcastOptions): Promise<TxClientBroadcastResponse>;
  broadcastBlock(txRaw: TxRaw): Promise<TxClientBroadcastResponse>;
  fetchTx(txHash: string): Promise<TxClientBroadcastResponse | undefined>;
  fetchTxPoll(txHash: string): Promise<TxClientBroadcastResponse | undefined>;
  simulate(txRaw: TxRaw): Promise<TxClientSimulateResponse>;
}
declare const TxClientMode: {
  readonly gRpc: "grpc";
  readonly rest: "rest";
};
type TxClientMode = (typeof TxClientMode)[keyof typeof TxClientMode];
type MsgArg = {
  type: string;
  message: any;
};
interface SignerDetails {
  pubKey: string | Any;
  sequence: number;
  accountNumber: number;
}
/** @type {CreateTransactionWithSignersArgs} */
interface CreateTransactionWithSignersArgs {
  fee?: StdFee | string;
  memo?: string;
  chainId: string;
  message: Msgs | Msgs[];
  signers: SignerDetails | SignerDetails[];
  signMode?: SignMode;
  timeoutHeight?: number;
}
/** @type {CreateTransactionArgs} */
interface CreateTransactionArgs {
  fee?: StdFee;
  memo?: string;
  chainId: string;
  message: Msgs | Msgs[];
  pubKey: string;
  sequence: number;
  accountNumber: number;
  signMode?: SignMode;
  timeoutHeight?: number;
}
/** @type {CreateTransactionResult} */
interface CreateTransactionResult {
  txRaw: TxRaw;
  signDoc: SignDoc;
  bodyBytes: Uint8Array;
  signers: SignerDetails | SignerDetails[];
  signer: SignerDetails;
  authInfoBytes: Uint8Array;
  signBytes: Uint8Array;
  signHashedBytes: Uint8Array;
}
interface TxResponse {
  height: number;
  txHash: string;
  codespace: string;
  code: number;
  data?: string;
  rawLog: string;
  logs?: any[];
  info?: string;
  gasWanted: number;
  gasUsed: number;
  timestamp: string;
  events?: any[];
}
//#endregion
//#region src/core/tx/types/tx-rest-client.d.ts
interface RestSignerInfo {
  public_key: PublicKey$1 | null;
  mode_info: ModeInfo;
  sequence: string;
}
interface RestAuthInfo {
  signer_infos: RestSignerInfo[];
  fee: Fee;
}
interface RestTxBody {
  messages: any[];
  memo: string;
  timeout_height: string;
}
interface RestTx {
  body: RestTxBody;
  auth_info: RestAuthInfo;
  signatures: string[];
}
interface RestTxLog {
  msg_index: number;
  log: string;
  events: {
    type: string;
    attributes: {
      key: string;
      value: string;
    }[];
  }[];
}
interface TxInfoResponse {
  height: string;
  txhash: string;
  codespace: string;
  code: number;
  data: string;
  raw_log: string;
  logs: RestTxLog[];
  info: string;
  gas_wanted: string;
  gas_used: string;
  tx: RestTx;
  timestamp: string;
}
interface TxInfo {
  height: string;
  txhash: string;
  codespace: string;
  code: number;
  data: string;
  rawLog: string;
  gasWanted: string;
  gasUsed: string;
  logs: RestTxLog[];
  info: string;
  tx: RestTx;
  timestamp: string;
}
declare const BroadcastMode: {
  readonly Sync: "BROADCAST_MODE_SYNC";
  readonly Async: "BROADCAST_MODE_ASYNC";
  readonly Block: "BROADCAST_MODE_BLOCK";
};
type BroadcastMode = (typeof BroadcastMode)[keyof typeof BroadcastMode];
declare const BroadcastModeKeplr: {
  readonly Sync: "sync";
  readonly Async: "async";
  readonly Block: "block";
};
type BroadcastModeKeplr = (typeof BroadcastModeKeplr)[keyof typeof BroadcastModeKeplr];
interface TxResultResponse {
  tx: RestTx;
  tx_response: TxInfoResponse;
}
interface TxResult {
  tx: RestTx;
  txResponse: TxInfo;
}
interface TxSearchResult {
  pagination: any;
  txs: TxInfo[];
}
interface TxSearchResultParams {
  txs: RestTx[];
  tx_responses: TxInfo;
  pagination: any;
}
interface SimulationResponse {
  gas_info: {
    gas_wanted: string;
    gas_used: string;
  };
  result: {
    data: string;
    log: string;
    events: {
      type: string;
      attributes: {
        key: string;
        value: string;
      }[];
    }[];
  };
}
//#endregion
//#region src/core/tx/tx.d.ts
/**
 * @typedef {Object} CreateTransactionWithSignersArgs
 * @param {CreateTransactionWithSignersArgs} params
 * @property {Msg | Msg[]} message - the Cosmos messages to wrap them in a transaction
 * @property {string} memo - the memo to attach to the transaction
 * @property {StdFee} fee - the fee to attach to the transaction
 * @property {SignerDetails} signers - the signers of the transaction
 * @property {number} number - the account number to attach to the transaction
 * @property {number} chainId - the chain-id to attach to the transaction
 * @property {string} pubKey - the account pubKey to attach to the transaction (in base64)
 *
 * @typedef {Object} CreateTransactionResult
 * @property {TxRaw} txRaw  - the Tx raw that was created
 * @property {SignDoc} signDoc  - the SignDoc that was created - used for signing of the transaction
 * @property {SignerDetails} signers  - the signers of the transaction
 * @property {Uint8Array} bodyBytes  - the body bytes of the transaction
 * @property {Uint8Array} authInfoBytes  - the auth info bytes of the transaction
 * @property {Uint8Array} signBytes  - the sign bytes of the transaction (SignDoc serialized to binary)
 * @property {Uint8Array} signHashedBytes  - the sign bytes of the transaction (SignDoc serialized to binary) and hashed using keccak256
 * @returns {CreateTransactionResult} result
 */
declare const createTransactionWithSigners: ({
  signers,
  chainId,
  message,
  timeoutHeight,
  memo,
  fee,
  signMode
}: CreateTransactionWithSignersArgs) => CreateTransactionResult;
/**
 * @typedef {Object} CreateTransactionArgs
 * @param {CreateTransactionArgs} params
 * @property {MsgArg | MsgArg[]} message - the Cosmos messages to wrap them in a transaction
 * @property {string} memo - the memo to attach to the transaction
 * @property {StdFee} fee - the fee to attach to the transaction
 * @property {string} sequence - the account sequence to attach to the transaction
 * @property {number} number - the account number to attach to the transaction
 * @property {number} chainId - the chain-id to attach to the transaction
 * @property {string} pubKey - the account pubKey to attach to the transaction (in base64)
 *
 * @typedef {Object} CreateTransactionResult
 * @property {TxRaw} txRaw  // the Tx raw that was created
 * @property {SignDoc} signDoc  // the SignDoc that was created - used for signing of the transaction
 * @property {number} accountNumber  // the account number of the signer of the transaction
 * @property {Uint8Array} bodyBytes  // the body bytes of the transaction
 * @property {Uint8Array} authInfoBytes  // the auth info bytes of the transaction
 * @property {Uint8Array} signBytes  // the sign bytes of the transaction (SignDoc serialized to binary)
 * @property {Uint8Array} signHashedBytes  // the sign bytes of the transaction (SignDoc serialized to binary) and hashed using keccak256
 * @returns {CreateTransactionResult} result
 */
declare const createTransaction: (args: CreateTransactionArgs) => CreateTransactionResult;
/**
 * Used when we want to pass a Msg class instead of the {type, message}
 * object of the Message (using the toDirectSign() method)
 * @returns
 */
declare const createTransactionFromMsg: (params: Omit<CreateTransactionArgs, "message"> & {
  message: Msgs | Msgs[];
}) => CreateTransactionResult;
/**
 * Used when we get a DirectSignResponse from
 * Cosmos native wallets like Keplr, Leap, etc after
 * the TxRaw has been signed.
 *
 * The reason why we need to create a new TxRaw and
 * not use the one that we passed to signing is that the users
 * can change the gas fees and that will alter the original
 * TxRaw which will cause signature miss match if we broadcast
 * that transaction on chain
 * @returns TxRaw
 */
declare const createTxRawFromSigResponse: (response: TxRaw | DirectSignResponse) => TxRaw;
/**
 * Used when we don't have account details and block details
 * and we pass the message and the user's address only
 * @returns
 */
declare const createTransactionForAddressAndMsg: (params: Omit<CreateTransactionArgs, "message" | "sequence" | "pubKey" | "accountNumber"> & {
  message: Msgs | Msgs[];
  address: string;
  pubKey?: string;
  endpoint: string;
}) => Promise<CreateTransactionResult>;
declare const createTransactionAndCosmosSignDoc: (args: CreateTransactionArgs) => {
  cosmosSignDoc: SignDoc;
  txRaw: TxRaw;
  signDoc: SignDoc;
  bodyBytes: Uint8Array;
  signers: SignerDetails | SignerDetails[];
  signer: SignerDetails;
  authInfoBytes: Uint8Array;
  signBytes: Uint8Array;
  signHashedBytes: Uint8Array;
};
declare const createTransactionAndCosmosSignDocForAddressAndMsg: (params: Omit<CreateTransactionArgs, "message" | "sequence" | "pubKey" | "accountNumber"> & {
  message: Msgs | Msgs[];
  address: string;
  pubKey?: string;
  endpoint: string;
}) => Promise<{
  cosmosSignDoc: SignDoc;
  txRaw: TxRaw;
  signDoc: SignDoc;
  bodyBytes: Uint8Array;
  signers: SignerDetails | SignerDetails[];
  signer: SignerDetails;
  authInfoBytes: Uint8Array;
  signBytes: Uint8Array;
  signHashedBytes: Uint8Array;
}>;
declare const getTxRawFromTxRawOrDirectSignResponse: (txRawOrDirectSignResponse: TxRaw | DirectSignResponse) => TxRaw;
//#endregion
//#region src/core/tx/api/utils.d.ts
declare const waitTxBroadcasted: (txHash: string, options: {
  endpoints: {
    grpc?: string;
    rest: string;
  };
  txTimeout?: number;
}) => Promise<TxResponse>;
//#endregion
//#region src/core/tx/api/TxGrpcApi.d.ts
declare class TxGrpcApi extends BaseGrpcConsumer implements TxConcreteApi {
  protected module: string;
  private get client();
  fetchTx(hash: string): Promise<TxResponse>;
  fetchTxPoll(txHash: string, timeout?: number): Promise<TxResponse>;
  simulate(txRaw: TxRaw): Promise<{
    result: {
      data: string | Uint8Array<ArrayBufferLike>;
      log: string;
      eventsList: Event$1[];
      events?: Event$1[] | undefined;
      msgResponses?: Any[] | undefined;
    };
    gasInfo: {
      gasWanted: number;
      gasUsed: number;
    };
  }>;
  broadcast(txRaw: TxRaw, options?: TxClientBroadcastOptions): Promise<TxResponse>;
  /** @deprecated - the BLOCK mode broadcasting is deprecated now, use either sync or async */
  broadcastBlock(txRaw: TxRaw): Promise<TxClientBroadcastResponse>;
}
//#endregion
//#region src/core/tx/api/TxRestApi.d.ts
/**
 * It is recommended to use TxGrpcClient instead of TxRestApi
 */
declare class TxRestApi implements TxConcreteApi {
  httpClient: HttpClient;
  constructor(endpoint: string, options?: {
    timeout?: number;
  });
  fetchTx(txHash: string, params?: any): Promise<TxResponse>;
  fetchTxPoll(txHash: string, timeout?: number): Promise<TxResponse>;
  simulate(txRaw: TxRaw): Promise<{
    result: {
      data: string;
      log: string;
      eventsList: {
        type: string;
        attributes: {
          key: string;
          value: string;
        }[];
      }[];
    };
    gasInfo: {
      gasWanted: number;
      gasUsed: number;
    };
  }>;
  broadcast(tx: TxRaw, options?: TxClientBroadcastOptions): Promise<TxResponse>;
  /**
   * Broadcast the transaction using the "block" mode, waiting for its inclusion in the blockchain.
   * @param tx transaction to broadcast
   *
   * @deprecated - the BLOCk mode broadcasting is deprecated now, use either sync or async
   */
  broadcastBlock(tx: TxRaw): Promise<{
    txHash: string;
    rawLog: string;
    gasWanted: number;
    gasUsed: number;
    height: number;
    logs: RestTxLog[];
    code: number;
    codespace: string;
    data: string;
    info: string;
    timestamp: string;
  }>;
  private broadcastTx;
  private getRaw;
  private postRaw;
}
//#endregion
//#region src/core/tx/arbitrary.d.ts
declare const generateArbitrarySignDoc: (message: string, signer: string) => {
  signDoc: {
    account_number: string;
    chain_id: string;
    fee: {
      amount: never[];
      gas: string;
    };
    memo: string;
    msgs: {
      type: string;
      value: {
        data: string;
        signer: string;
      };
    }[];
    sequence: string;
  };
  signDocBuff: Uint8Array<ArrayBufferLike>;
  stringifiedSignDoc: string;
};
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/injective/types/v1beta1/tx_ext_pb.d.ts
/**
 * @generated from protobuf message injective.types.v1beta1.ExtensionOptionsWeb3Tx
 */
interface ExtensionOptionsWeb3Tx {
  /**
   * typedDataChainID used only in EIP712 Domain and should match
   * Ethereum network ID in a Web3 provider (e.g. Metamask).
   *
   * @generated from protobuf field: uint64 typedDataChainID = 1
   */
  typedDataChainID: bigint;
  /**
   * feePayer is an account address for the fee payer. It will be validated
   * during EIP712 signature checking.
   *
   * @generated from protobuf field: string feePayer = 2
   */
  feePayer: string;
  /**
   * feePayerSig is a signature data from the fee paying account,
   * allows to perform fee delegation when using EIP712 Domain.
   *
   * @generated from protobuf field: bytes feePayerSig = 3
   */
  feePayerSig: Uint8Array;
}
/**
 * @generated MessageType for protobuf message injective.types.v1beta1.ExtensionOptionsWeb3Tx
 */
declare const ExtensionOptionsWeb3Tx = new ExtensionOptionsWeb3Tx$Type();
//#endregion
//#region src/core/tx/utils/tx.d.ts
declare const getPublicKey: ({
  chainId,
  key
}: {
  chainId: string;
  key: string | Any;
}) => Any;
declare const createBody: ({
  message,
  memo,
  timeoutHeight
}: {
  message: Msgs | Msgs[];
  memo?: string;
  timeoutHeight?: number;
}) => TxBody;
declare const createFee: ({
  fee,
  payer,
  granter,
  gasLimit
}: {
  fee: {
    amount: string;
    denom: string;
  };
  payer?: string;
  granter?: string;
  gasLimit: number;
}) => Fee;
declare const createSigners: ({
  chainId,
  mode,
  signers
}: {
  chainId: string;
  signers: {
    pubKey: string | Any;
    sequence: number;
  }[];
  mode: SignMode;
}) => SignerInfo[];
declare const createSignerInfo: ({
  chainId,
  publicKey,
  sequence,
  mode
}: {
  chainId: string;
  publicKey: string | Any;
  sequence: number;
  mode: SignMode;
}) => SignerInfo;
declare const createAuthInfo: ({
  signerInfo,
  fee
}: {
  signerInfo: SignerInfo[];
  fee: Fee;
}) => AuthInfo;
declare const createSignDoc: ({
  bodyBytes,
  authInfoBytes,
  chainId,
  accountNumber
}: {
  bodyBytes: Uint8Array;
  authInfoBytes: Uint8Array;
  chainId: string;
  accountNumber: number;
}) => SignDoc;
declare const createSignDocFromTransaction: (args: {
  txRaw: TxRaw;
  chainId: string;
  accountNumber: number;
}) => SignDoc;
declare const createTxRawEIP712: (txRaw: TxRaw, extension: ExtensionOptionsWeb3Tx, nonCriticalExtension?: Any | Any[]) => TxRaw;
declare const createWeb3Extension: ({
  evmChainId,
  feePayer,
  feePayerSig
}: {
  evmChainId: EvmChainId;
  feePayer?: string;
  feePayerSig?: Uint8Array;
}) => ExtensionOptionsWeb3Tx;
declare const createNonCriticalExtensionFromObject: (object: Record<string, unknown>) => Any;
declare const getTransactionPartsFromTxRaw: (txRaw: TxRaw) => {
  authInfo: AuthInfo;
  body: TxBody;
  signatures: Uint8Array[];
};
declare const getAminoStdSignDoc: ({
  memo,
  chainId,
  accountNumber,
  timeoutHeight,
  sequence,
  gas,
  msgs
}: {
  memo?: string;
  chainId: ChainId;
  timeoutHeight?: string;
  accountNumber: number;
  sequence: number;
  gas?: string;
  msgs: Msgs[];
}) => {
  chain_id: ChainId;
  timeout_height: string;
  account_number: string;
  sequence: string;
  fee: {
    amount: {
      denom: string;
      amount: string;
    }[];
    gas: string;
    payer: string | undefined;
    granter: string | undefined;
    feePayer: string | undefined;
  };
  msgs: {
    type: string;
    value: any;
  }[];
  memo: string;
};
//#endregion
//#region src/core/tx/utils/api.d.ts
declare const isTxNotFoundError: (error: any) => boolean;
declare const errorToErrorMessage: (error: any) => any;
//#endregion
//#region src/core/tx/utils/helpers.d.ts
declare const createAnyMessage: (msg: {
  type: string;
  value: Uint8Array;
}) => Any;
declare const createAny: (value: any, type: string) => Any;
declare const getInjectiveSignerAddress: (address: string | undefined) => string;
declare const getEthereumSignerAddress: (address: string | undefined) => string;
//#endregion
//#region src/core/tx/utils/constants.d.ts
declare const SIGN_DIRECT = CosmosTxSigningV1Beta1SigningPb.SignMode.DIRECT;
declare const SIGN_AMINO = CosmosTxSigningV1Beta1SigningPb.SignMode.LEGACY_AMINO_JSON;
declare const SIGN_EIP712 = CosmosTxSigningV1Beta1SigningPb.SignMode.LEGACY_AMINO_JSON;
declare const SIGN_EIP712_V2 = CosmosTxSigningV1Beta1SigningPb.SignMode.EIP712_V2;
//#endregion
//#region src/core/tx/utils/classes/TxClient.d.ts
declare class TxClient {
  /**
   * Encode a transaction to base64-encoded protobuf
   * @param tx transaction to encode
   */
  static encode(tx: TxRaw): string;
  /**
   * Decode a transaction from base64-encoded protobuf
   * @param tx transaction string to decode
   */
  static decode(encodedTx: string): TxRaw;
  /**
   * Get the transaction's hash
   * @param tx transaction to hash
   */
  static hash(tx: TxRaw): string;
}
//#endregion
//#region src/core/tx/eip712/maps.d.ts
/**
 * ONLY USED FOR EIP712_V1
 *
 * Function used to generate EIP712 types based on a message object
 * and its structure (recursive)
 */
declare const objectKeysToEip712Types: ({
  object,
  messageType,
  primaryType
}: {
  object: Record<string, any>;
  messageType?: string;
  primaryType?: string;
}) => Map<string, TypedDataField[]>;
/**
 * JavaScript doesn't know the exact number types that
 * we represent these fields on chain so we have to map
 * them in their chain representation from the number value
 * that is available in JavaScript
 */
declare const numberTypeToReflectionNumberType: (property?: string, messageType?: string) => "int32" | "uint32" | "int64" | "timeout_timestamp" | "uint64";
/**
 * JavaScript doesn't know the exact string types that
 * we represent these fields on chain so we have to map
 * them in their chain representation from the string value
 * that is available in JavaScript
 */
declare const stringTypeToReflectionStringType: (property?: string) => string;
declare const getObjectEip712PropertyType: ({
  property,
  parentProperty,
  messageType
}: {
  property: string;
  parentProperty: string;
  messageType?: string;
}) => string;
/**
 * Mapping a path type to amino type for messages
 */
declare const protoTypeToAminoType: (type: string) => string;
//#endregion
//#region src/core/tx/eip712/utils.d.ts
declare const getEip712Domain: (evmChainId: EvmChainId) => {
  domain: {
    name: string;
    version: string;
    chainId: string;
    salt: string;
    verifyingContract: string;
  };
};
declare const getEip712DomainV2: (evmChainId: EvmChainId) => {
  domain: {
    name: string;
    version: string;
    chainId: string;
    verifyingContract: string;
    salt: string;
  };
};
declare const getDefaultEip712Types: () => {
  types: {
    EIP712Domain: {
      name: string;
      type: string;
    }[];
    Tx: {
      name: string;
      type: string;
    }[];
    Fee: {
      name: string;
      type: string;
    }[];
    Coin: {
      name: string;
      type: string;
    }[];
    Msg: {
      name: string;
      type: string;
    }[];
  };
};
declare const getDefaultEip712TypesV2: () => {
  types: {
    EIP712Domain: {
      name: string;
      type: string;
    }[];
    Tx: {
      name: string;
      type: string;
    }[];
  };
};
declare const getEip712Fee: (params?: Eip712ConvertFeeArgs) => {
  fee: {
    amount: {
      amount: string;
      denom: string;
    }[];
    gas: string;
    feePayer?: string;
  };
};
declare const getEip712FeeV2: (params?: Eip712ConvertFeeArgs) => {
  fee: {
    amount: {
      denom: string;
      amount: string;
    }[];
    gas: number;
    payer?: string;
  };
};
declare const getTypesIncludingFeePayer: ({
  fee,
  types
}: {
  fee?: Eip712ConvertFeeArgs;
  types: ReturnType<typeof getDefaultEip712Types>;
}) => {
  types: {
    EIP712Domain: {
      name: string;
      type: string;
    }[];
    Tx: {
      name: string;
      type: string;
    }[];
    Fee: {
      name: string;
      type: string;
    }[];
    Coin: {
      name: string;
      type: string;
    }[];
    Msg: {
      name: string;
      type: string;
    }[];
  };
};
declare const getEipTxDetails: ({
  accountNumber,
  sequence,
  timeoutHeight,
  chainId,
  memo
}: Eip712ConvertTxArgs) => {
  account_number: string;
  chain_id: string;
  sequence: string;
  timeout_height: string;
  memo: string;
};
declare const getEipTxContext: ({
  accountNumber,
  sequence,
  fee,
  timeoutHeight,
  chainId,
  memo
}: Eip712ConvertTxArgs & {
  fee?: Eip712ConvertFeeArgs;
}) => {
  account_number: number;
  chain_id: string;
  sequence: number;
  fee: Record<string, any>;
  timeout_height: number;
  memo: string;
};
//#endregion
//#region src/core/tx/eip712/eip712.d.ts
declare const getEip712TypedData: ({
  msgs,
  tx,
  fee,
  evmChainId
}: {
  msgs: Msgs | Msgs[];
  tx: Eip712ConvertTxArgs;
  fee?: Eip712ConvertFeeArgs;
  evmChainId: EvmChainId;
}) => {
  message: {
    msgs: {
      type: string;
      value: any;
    }[];
    fee: {
      amount: {
        amount: string;
        denom: string;
      }[];
      gas: string;
      feePayer?: string;
    };
    account_number: string;
    chain_id: string;
    sequence: string;
    timeout_height: string;
    memo: string;
  };
  domain: {
    name: string;
    version: string;
    chainId: string;
    salt: string;
    verifyingContract: string;
  };
  primaryType: string;
  types: {
    EIP712Domain: {
      name: string;
      type: string;
    }[];
    Tx: {
      name: string;
      type: string;
    }[];
    Fee: {
      name: string;
      type: string;
    }[];
    Coin: {
      name: string;
      type: string;
    }[];
    Msg: {
      name: string;
      type: string;
    }[];
  };
};
declare const getEip712TypedDataV2: ({
  msgs,
  tx,
  fee,
  evmChainId
}: {
  msgs: Msgs | Msgs[];
  tx: Eip712ConvertTxArgs;
  fee?: Eip712ConvertFeeArgs;
  evmChainId: EvmChainId;
}) => {
  message: {
    context: string;
    msgs: string;
  };
  domain: {
    name: string;
    version: string;
    chainId: string;
    verifyingContract: string;
    salt: string;
  };
  primaryType: string;
  types: {
    EIP712Domain: {
      name: string;
      type: string;
    }[];
    Tx: {
      name: string;
      type: string;
    }[];
  };
};
//#endregion
//#region src/core/tx/eip712/MsgDecoder.d.ts
declare class MsgDecoder {
  static decode(message: Any): Msgs;
}
//#endregion
//#region src/core/accounts/Address.d.ts
/**
 * @category Utility Classes
 */
declare class Address {
  bech32Address: string;
  constructor(bech32Address: string);
  compare(address: Address): boolean;
  get address(): string;
  /**
   * Create an address instance from a bech32-encoded address and a prefix
   * @param {string} bech32 bech32-encoded address
   * @param {string} prefix
   * @return {Address}
   * @throws {Error} if bech is not a valid bech32-encoded address
   */
  static fromBech32(bech: string, prefix?: string): Address;
  /**
   * Create an address instance from an ethereum address
   * @param {string} hex Ethereum address
   * @param {string} prefix
   * @return {Address}
   * @throws {Error} if bech is not a valid bech32-encoded address
   */
  static fromHex(hex: string, prefix?: string): Address;
  /**
   * Convert an address instance to a bech32-encoded account address
   * @param {string} prefix
   * @returns {string}
   */
  toBech32(prefix?: string): string;
  /**
   * Return a bech32-encoded account address
   * @return {string}
   * @throws {Error} if this address is not a valid account address
   * */
  toAccountAddress(): string;
  /**
   * Return a bech32-encoded validator address
   * @return {string}
   * @throws {Error} if this address is not a valid validator address
   * */
  toValidatorAddress(): string;
  /**
   * Return a bech32-encoded consensus address
   * @return {string}
   * @throws {Error} if this address is not a valid consensus address
   * */
  toConsensusAddress(): string;
  /**
   * Return a hex representation of address
   * @return {string}
   * @throws {Error} if this address is not a valid account address
   * */
  toHex(): string;
  /**
   * Return a subaccount address from the given bech32 encoded address
   * @param {number} index the subaccount index
   * @return {string}
   * @throws {Error} if this address is not a valid account address
   * */
  getSubaccountId(index?: number): string;
  /**
   * Return a ethereum address from the given bech32 encoded address
   * @return {string}
   * @throws {Error} if this address is not a valid account address
   * */
  getEthereumAddress(): string;
}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/injective/crypto/v1beta1/ethsecp256k1/keys_pb.d.ts
/**
 * PubKey defines a type alias for an ecdsa.PublicKey that implements
 * Tendermint's PubKey interface. It represents the 33-byte compressed public
 * key format.
 *
 * @generated from protobuf message injective.crypto.v1beta1.ethsecp256k1.PubKey
 */
interface PubKey {
  /**
   * @generated from protobuf field: bytes key = 1
   */
  key: Uint8Array;
}
/**
 * @generated MessageType for protobuf message injective.crypto.v1beta1.ethsecp256k1.PubKey
 */
declare const PubKey = new PubKey$Type();
//#endregion
//#region src/core/accounts/PublicKey.d.ts
/**
 * @category Crypto Utility Classes
 */
declare class PublicKey {
  private type;
  private key;
  private constructor();
  static fromBase64(publicKey: string): PublicKey;
  static fromBytes(publicKey: Uint8Array): PublicKey;
  static fromHex(pubKey: string): PublicKey;
  static fromPrivateKeyHex(privateKey: string | Uint8Array): PublicKey;
  toPubKeyBytes(): Uint8Array;
  toBase64(): string;
  toHex(): string;
  /**
   * Convert the public key to a pubkey in bech32 format.
   * Note: this does not convert the public key to an address.
   */
  toBech32(): string;
  toAddress(): Address;
  toProto(): PubKey;
  toAny(): Any;
}
//#endregion
//#region ../../node_modules/.pnpm/abitype@1.1.0_typescript@5.9.2_zod@3.24.2/node_modules/abitype/dist/types/register.d.ts
interface Register {}
type ResolvedRegister = {
  /**
   * TypeScript type to use for `address` values
   * @default `0x${string}`
   */
  addressType: Register extends {
    addressType: infer type;
  } ? type : Register extends {
    AddressType: infer type;
  } ? type : DefaultRegister['addressType'];
  /**
   * TypeScript type to use for `int<M>` and `uint<M>` values, where `M > 48`
   * @default bigint
   */
  bigIntType: Register extends {
    bigIntType: infer type;
  } ? type : Register extends {
    BigIntType: infer type;
  } ? type : DefaultRegister['bigIntType'];
  /**
   * TypeScript type to use for `bytes` values
   * @default { inputs: `0x${string}`; outputs: `0x${string}`; }
   */
  bytesType: Register extends {
    bytesType: infer type extends {
      inputs: unknown;
      outputs: unknown;
    };
  } ? type : Register extends {
    BytesType: infer type extends {
      inputs: unknown;
      outputs: unknown;
    };
  } ? type : DefaultRegister['bytesType'];
  /**
   * TypeScript type to use for `int<M>` and `uint<M>` values, where `M <= 48`
   * @default number
   */
  intType: Register extends {
    intType: infer type;
  } ? type : Register extends {
    IntType: infer type;
  } ? type : DefaultRegister['intType'];
  /**
   * Maximum depth for nested array types (e.g. string[][])
   *
   * Note: You probably only want to set this to a specific number if parsed types are returning as `unknown`
   * and you want to figure out why. If you set this, you should probably also reduce `FixedArrayMaxLength`.
   *
   * @default false
   */
  arrayMaxDepth: Register extends {
    arrayMaxDepth: infer type extends number | false;
  } ? type : Register extends {
    ArrayMaxDepth: infer type extends number | false;
  } ? type : DefaultRegister['arrayMaxDepth'];
  /**
   * Lower bound for fixed array length
   * @default 1
   */
  fixedArrayMinLength: Register extends {
    fixedArrayMinLength: infer type extends number;
  } ? type : Register extends {
    FixedArrayMinLength: infer type extends number;
  } ? type : DefaultRegister['fixedArrayMinLength'];
  /**
   * Upper bound for fixed array length
   * @default 99
   */
  fixedArrayMaxLength: Register extends {
    fixedArrayMaxLength: infer type extends number;
  } ? type : Register extends {
    FixedArrayMaxLength: infer type extends number;
  } ? type : DefaultRegister['fixedArrayMaxLength'];
  /**
   * When set, validates {@link AbiParameter}'s `type` against {@link AbiType}
   *
   * Note: You probably only want to set this to `true` if parsed types are returning as `unknown`
   * and you want to figure out why.
   *
   * @default false
   */
  strictAbiType: Register extends {
    strictAbiType: infer type extends boolean;
  } ? type : Register extends {
    StrictAbiType: infer type extends boolean;
  } ? type : DefaultRegister['strictAbiType'];
  /** @deprecated Use `addressType` instead */
  AddressType: ResolvedRegister['addressType'];
  /** @deprecated Use `addressType` instead */
  BigIntType: ResolvedRegister['bigIntType'];
  /** @deprecated Use `bytesType` instead */
  BytesType: ResolvedRegister['bytesType'];
  /** @deprecated Use `intType` instead */
  IntType: ResolvedRegister['intType'];
  /** @deprecated Use `arrayMaxDepth` instead */
  ArrayMaxDepth: ResolvedRegister['arrayMaxDepth'];
  /** @deprecated Use `fixedArrayMinLength` instead */
  FixedArrayMinLength: ResolvedRegister['fixedArrayMinLength'];
  /** @deprecated Use `fixedArrayMaxLength` instead */
  FixedArrayMaxLength: ResolvedRegister['fixedArrayMaxLength'];
  /** @deprecated Use `strictAbiType` instead */
  StrictAbiType: ResolvedRegister['strictAbiType'];
};
type DefaultRegister = {
  /** Maximum depth for nested array types (e.g. string[][]) */
  arrayMaxDepth: false;
  /** Lower bound for fixed array length */
  fixedArrayMinLength: 1;
  /** Upper bound for fixed array length */
  fixedArrayMaxLength: 99;
  /** TypeScript type to use for `address` values */
  addressType: `0x${string}`;
  /** TypeScript type to use for `bytes` values */
  bytesType: {
    /** TypeScript type to use for `bytes` input values */
    inputs: `0x${string}`;
    /** TypeScript type to use for `bytes` output values */
    outputs: `0x${string}`;
  };
  /** TypeScript type to use for `int<M>` and `uint<M>` values, where `M > 48` */
  bigIntType: bigint;
  /** TypeScript type to use for `int<M>` and `uint<M>` values, where `M <= 48` */
  intType: number;
  /** When set, validates {@link AbiParameter}'s `type` against {@link AbiType} */
  strictAbiType: false;
  /** @deprecated Use `arrayMaxDepth` instead */
  ArrayMaxDepth: DefaultRegister['arrayMaxDepth'];
  /** @deprecated Use `fixedArrayMinLength` instead */
  FixedArrayMinLength: DefaultRegister['fixedArrayMinLength'];
  /** @deprecated Use `fixedArrayMaxLength` instead */
  FixedArrayMaxLength: DefaultRegister['fixedArrayMaxLength'];
  /** @deprecated Use `addressType` instead */
  AddressType: DefaultRegister['addressType'];
  /** @deprecated Use `bytesType` instead */
  BytesType: {
    inputs: DefaultRegister['bytesType']['inputs'];
    outputs: DefaultRegister['bytesType']['outputs'];
  };
  /** @deprecated Use `bigIntType` instead */
  BigIntType: DefaultRegister['bigIntType'];
  /** @deprecated Use `intType` instead */
  IntType: DefaultRegister['intType'];
  /** @deprecated Use `strictAbiType` instead */
  StrictAbiType: DefaultRegister['strictAbiType'];
};
//#endregion
//#region ../../node_modules/.pnpm/abitype@1.1.0_typescript@5.9.2_zod@3.24.2/node_modules/abitype/dist/types/types.d.ts
/**
 * Prints custom error message
 *
 * @param messages - Error message
 * @returns Custom error message
 *
 * @example
 * type Result = Error<'Custom error message'>
 * //   ^? type Result = ['Error: Custom error message']
 */
type Error<messages extends string | string[]> = messages extends string ? [`Error: ${messages}`] : { [key in keyof messages]: messages[key] extends infer message extends string ? `Error: ${message}` : never };
/**
 * Merges two object types into new type
 *
 * @param object1 - Object to merge into
 * @param object2 - Object to merge and override keys from {@link object1}
 * @returns New object type with keys from {@link object1} and {@link object2}. If a key exists in both {@link object1} and {@link object2}, the key from {@link object2} will be used.
 *
 * @example
 * type Result = Merge<{ foo: string }, { foo: number; bar: string }>
 * //   ^? type Result = { foo: number; bar: string }
 */
type Merge<object1, object2> = Omit<object1, keyof object2> & object2;
/**
 * Combines members of an intersection into a readable type.
 *
 * @link https://twitter.com/mattpocockuk/status/1622730173446557697?s=20&t=NdpAcmEFXY01xkqU3KO0Mg
 * @example
 * type Result = Pretty<{ a: string } | { b: string } | { c: number, d: bigint }>
 * //   ^? type Result = { a: string; b: string; c: number; d: bigint }
 */
type Pretty<type$1> = { [key in keyof type$1]: type$1[key] } & unknown;
/**
 * Creates range between two positive numbers using [tail recursion](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-5.html#tail-recursion-elimination-on-conditional-types).
 *
 * @param start - Number to start range
 * @param stop - Number to end range
 * @returns Array with inclusive range from {@link start} to {@link stop}
 *
 * @example
 * type Result = Range<1, 3>
 * //   ^? type Result = [1, 2, 3]
 */
type Range<start extends number, stop extends number, result extends number[] = [], padding extends 0[] = [], current extends number = [...padding, ...result]['length'] & number> = current extends stop ? current extends start ? [current] : result extends [] ? [] : [...result, current] : current extends start ? Range<start, stop, [current], padding> : result extends [] ? Range<start, stop, [], [...padding, 0]> : Range<start, stop, [...result, current], padding>;
/**
 * Create tuple of {@link type} type with {@link size} size
 *
 * @param Type - Type of tuple
 * @param Size - Size of tuple
 * @returns Tuple of {@link type} type with {@link size} size
 *
 * @example
 * type Result = Tuple<string, 2>
 * //   ^? type Result = [string, string]
 */
type Tuple<type$1, size$1 extends number> = size$1 extends size$1 ? number extends size$1 ? type$1[] : _TupleOf<type$1, size$1, []> : never;
type _TupleOf<length, size$1 extends number, acc extends readonly unknown[]> = acc['length'] extends size$1 ? acc : _TupleOf<length, size$1, readonly [length, ...acc]>;
//#endregion
//#region ../../node_modules/.pnpm/abitype@1.1.0_typescript@5.9.2_zod@3.24.2/node_modules/abitype/dist/types/abi.d.ts
type Address$1 = ResolvedRegister['addressType'];
type MBytes = '' | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 32;
type MBits = '' | 8 | 16 | 24 | 32 | 40 | 48 | 56 | 64 | 72 | 80 | 88 | 96 | 104 | 112 | 120 | 128 | 136 | 144 | 152 | 160 | 168 | 176 | 184 | 192 | 200 | 208 | 216 | 224 | 232 | 240 | 248 | 256;
type SolidityAddress = 'address';
type SolidityBool = 'bool';
type SolidityBytes = `bytes${MBytes}`;
type SolidityFunction = 'function';
type SolidityString = 'string';
type SolidityTuple = 'tuple';
type SolidityInt = `${'u' | ''}int${MBits}`;
type SolidityFixedArrayRange = Range<ResolvedRegister['fixedArrayMinLength'], ResolvedRegister['fixedArrayMaxLength']>[number];
type SolidityFixedArraySizeLookup = { [Prop in SolidityFixedArrayRange as `${Prop}`]: Prop };
/**
 * Recursively build arrays up to maximum depth
 * or use a more broad type when maximum depth is switched "off"
 */
type _BuildArrayTypes<T extends string, Depth extends readonly number[] = []> = ResolvedRegister['arrayMaxDepth'] extends false ? `${T}[${string}]` : Depth['length'] extends ResolvedRegister['arrayMaxDepth'] ? T : T extends `${any}[${SolidityFixedArrayRange | ''}]` ? _BuildArrayTypes<T | `${T}[${SolidityFixedArrayRange | ''}]`, [...Depth, 1]> : _BuildArrayTypes<`${T}[${SolidityFixedArrayRange | ''}]`, [...Depth, 1]>;
type SolidityArrayWithoutTuple = _BuildArrayTypes<SolidityAddress | SolidityBool | SolidityBytes | SolidityFunction | SolidityInt | SolidityString>;
type SolidityArrayWithTuple = _BuildArrayTypes<SolidityTuple>;
type SolidityArray = SolidityArrayWithoutTuple | SolidityArrayWithTuple;
type AbiType = SolidityArray | SolidityAddress | SolidityBool | SolidityBytes | SolidityFunction | SolidityInt | SolidityString | SolidityTuple;
type ResolvedAbiType = ResolvedRegister['strictAbiType'] extends true ? AbiType : string;
type AbiInternalType = ResolvedAbiType | `address ${string}` | `contract ${string}` | `enum ${string}` | `struct ${string}`;
type AbiParameter = Pretty<{
  type: ResolvedAbiType;
  name?: string | undefined;
  /** Representation used by Solidity compiler */
  internalType?: AbiInternalType | undefined;
} & ({
  type: Exclude<ResolvedAbiType, SolidityTuple | SolidityArrayWithTuple>;
} | {
  type: SolidityTuple | SolidityArrayWithTuple;
  components: readonly AbiParameter[];
})>;
/** Kind of {@link AbiParameter} */
type AbiParameterKind = 'inputs' | 'outputs';
type TypedDataDomain = {
  chainId?: number | bigint | undefined;
  name?: string | undefined;
  salt?: ResolvedRegister['bytesType']['outputs'] | undefined;
  verifyingContract?: Address$1 | undefined;
  version?: string | undefined;
};
type TypedDataType = Exclude<AbiType, SolidityFunction | SolidityTuple | SolidityArrayWithTuple | 'int' | 'uint'>;
type TypedDataParameter = {
  name: string;
  type: TypedDataType | keyof TypedData | `${keyof TypedData}[${string | ''}]`;
};
/**
 * [EIP-712](https://eips.ethereum.org/EIPS/eip-712#definition-of-typed-structured-data-%F0%9D%95%8A) Typed Data Specification
 */
type TypedData = Pretty<Record<string, readonly TypedDataParameter[]> & { [_ in TypedDataType]?: never }>;
//#endregion
//#region ../../node_modules/.pnpm/abitype@1.1.0_typescript@5.9.2_zod@3.24.2/node_modules/abitype/dist/types/utils.d.ts
/**
 * Converts {@link AbiType} to corresponding TypeScript primitive type.
 *
 * Does not include full array or tuple conversion. Use {@link AbiParameterToPrimitiveType} to fully convert arrays and tuples.
 *
 * @param abiType - {@link AbiType} to convert to TypeScript representation
 * @param abiParameterKind - Optional {@link AbiParameterKind} to narrow by parameter type
 * @returns TypeScript primitive type
 */
type AbiTypeToPrimitiveType<abiType extends AbiType, abiParameterKind extends AbiParameterKind = AbiParameterKind> = abiType extends SolidityBytes ? PrimitiveTypeLookup[abiType][abiParameterKind] : PrimitiveTypeLookup[abiType];
interface PrimitiveTypeLookup extends SolidityIntMap, SolidityByteMap, SolidityArrayMap {
  address: ResolvedRegister['addressType'];
  bool: boolean;
  function: `${ResolvedRegister['addressType']}${string}`;
  string: string;
  tuple: Record<string, unknown>;
}
type SolidityIntMap = { [_ in SolidityInt]: _ extends `${'u' | ''}int${infer bits extends keyof BitsTypeLookup}` ? BitsTypeLookup[bits] : never };
type SolidityByteMap = { [_ in SolidityBytes]: ResolvedRegister['bytesType'] };
type SolidityArrayMap = { [_ in SolidityArray]: readonly unknown[] };
type GreaterThan48Bits = Exclude<MBits, 8 | 16 | 24 | 32 | 40 | 48 | NoBits>;
type LessThanOrEqualTo48Bits = Exclude<MBits, GreaterThan48Bits | NoBits>;
type NoBits = '';
type BitsTypeLookup = { [key in MBits]: ResolvedRegister[key extends LessThanOrEqualTo48Bits ? 'intType' : 'bigIntType'] };
/**
 * Converts {@link AbiParameter} to corresponding TypeScript primitive type.
 *
 * @param abiParameter - {@link AbiParameter} to convert to TypeScript representation
 * @param abiParameterKind - Optional {@link AbiParameterKind} to narrow by parameter type
 * @returns TypeScript primitive type
 */
type AbiParameterToPrimitiveType<abiParameter extends AbiParameter | {
  name: string;
  type: unknown;
}, abiParameterKind extends AbiParameterKind = AbiParameterKind> = abiParameter['type'] extends AbiBasicType ? AbiTypeToPrimitiveType<abiParameter['type'], abiParameterKind> : abiParameter extends {
  type: SolidityTuple;
  components: infer components extends readonly AbiParameter[];
} ? AbiComponentsToPrimitiveType<components, abiParameterKind> : MaybeExtractArrayParameterType<abiParameter['type']> extends [infer head extends string, infer size] ? AbiArrayToPrimitiveType<abiParameter, abiParameterKind, head, size> : ResolvedRegister['strictAbiType'] extends true ? Error<`Unknown type '${abiParameter['type'] & string}'.`> : abiParameter extends {
  components: Error<string>;
} ? abiParameter['components'] : unknown;
type AbiBasicType = Exclude<AbiType, SolidityTuple | SolidityArray>;
type AbiComponentsToPrimitiveType<components$1 extends readonly AbiParameter[], abiParameterKind extends AbiParameterKind> = components$1 extends readonly [] ? [] : components$1[number]['name'] extends Exclude<components$1[number]['name'] & string, undefined | ''> ? { [component in components$1[number] as component['name'] & {}]: AbiParameterToPrimitiveType<component, abiParameterKind> } : { [key in keyof components$1]: AbiParameterToPrimitiveType<components$1[key], abiParameterKind> };
type MaybeExtractArrayParameterType<type$1> =
/**
 * First, infer `Head` against a known size type (either fixed-length array value or `""`).
 *
 * | Input           | Head         |
 * | --------------- | ------------ |
 * | `string[]`      | `string`     |
 * | `string[][][3]` | `string[][]` |
 */
type$1 extends `${infer head}[${'' | `${SolidityFixedArrayRange}`}]` ? type$1 extends `${head}[${infer size}]` ? [head, size] : undefined : undefined;
type AbiArrayToPrimitiveType<abiParameter extends AbiParameter | {
  name: string;
  type: unknown;
}, abiParameterKind extends AbiParameterKind, head$1 extends string, size$1> = size$1 extends keyof SolidityFixedArraySizeLookup ? Tuple<AbiParameterToPrimitiveType<Merge<abiParameter, {
  type: head$1;
}>, abiParameterKind>, SolidityFixedArraySizeLookup[size$1]> : readonly AbiParameterToPrimitiveType<Merge<abiParameter, {
  type: head$1;
}>, abiParameterKind>[];
/**
 * Converts array of {@link AbiParameter} to corresponding TypeScript primitive types.
 *
 * @param abiParameters - Array of {@link AbiParameter} to convert to TypeScript representations
 * @param abiParameterKind - Optional {@link AbiParameterKind} to narrow by parameter type
 * @returns Array of TypeScript primitive types
 */

/**
 * Converts {@link typedData} to corresponding TypeScript primitive types.
 *
 * @param typedData - {@link TypedData} to convert
 * @param abiParameterKind - Optional {@link AbiParameterKind} to narrow by parameter type
 * @returns Union of TypeScript primitive types
 */
type TypedDataToPrimitiveTypes<typedData extends TypedData, abiParameterKind extends AbiParameterKind = AbiParameterKind, keyReferences extends {
  [_: string]: unknown;
} | unknown = unknown> = { [key in keyof typedData]: { [key2 in typedData[key][number] as key2['name']]: key2['type'] extends key ? Error<`Cannot convert self-referencing struct '${key2['type']}' to primitive type.`> : key2['type'] extends keyof typedData ? key2['type'] extends keyof keyReferences ? Error<`Circular reference detected. '${key2['type']}' is a circular reference.`> : TypedDataToPrimitiveTypes<Exclude<typedData, key>, abiParameterKind, keyReferences & { [_ in key2['type'] | key]: true }>[key2['type']] : key2['type'] extends `${infer type extends keyof typedData & string}[${infer tail}]` ? AbiParameterToPrimitiveType<{
  name: key2['name'];
  type: `tuple[${tail}]`;
  components: _TypedDataParametersToAbiParameters<typedData[type], typedData, keyReferences & { [_ in type | key]: true }>;
}, abiParameterKind> : key2['type'] extends TypedDataType ? AbiParameterToPrimitiveType<key2, abiParameterKind> : Error<`Cannot convert unknown type '${key2['type']}' to primitive type.`> } } & unknown;
type _TypedDataParametersToAbiParameters<typedDataParameters extends readonly TypedDataParameter[], typedData extends TypedData, keyReferences extends {
  [_: string]: unknown;
} | unknown = unknown> = { [key in keyof typedDataParameters]: typedDataParameters[key] extends infer typedDataParameter extends {
  name: string;
  type: unknown;
} ? typedDataParameter['type'] extends keyof typedData & string ? {
  name: typedDataParameter['name'];
  type: 'tuple';
  components: typedDataParameter['type'] extends keyof keyReferences ? Error<`Circular reference detected. '${typedDataParameter['type']}' is a circular reference.`> : _TypedDataParametersToAbiParameters<typedData[typedDataParameter['type']], typedData, keyReferences & { [_ in typedDataParameter['type']]: true }>;
} : typedDataParameter['type'] extends `${infer type extends keyof typedData & string}[${infer tail}]` ? {
  name: typedDataParameter['name'];
  type: `tuple[${tail}]`;
  components: type extends keyof keyReferences ? Error<`Circular reference detected. '${typedDataParameter['type']}' is a circular reference.`> : _TypedDataParametersToAbiParameters<typedData[type], typedData, keyReferences & { [_ in type]: true }>;
} : typedDataParameter : never };
//#endregion
//#region ../../node_modules/.pnpm/viem@2.41.2_bufferutil@4.0.7_typescript@5.9.2_utf-8-validate@5.0.10_zod@3.24.2/node_modules/viem/_types/types/utils.d.ts
/**
 * @description Combines members of an intersection into a readable type.
 *
 * @see {@link https://twitter.com/mattpocockuk/status/1622730173446557697?s=20&t=NdpAcmEFXY01xkqU3KO0Mg}
 * @example
 * Prettify<{ a: string } & { b: string } & { c: number, d: bigint }>
 * => { a: string, b: string, c: number, d: bigint }
 */
type Prettify<T> = { [K in keyof T]: T[K] } & {};
//#endregion
//#region ../../node_modules/.pnpm/eventemitter3@5.0.1/node_modules/eventemitter3/index.d.ts
/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 */
declare class EventEmitter<EventTypes extends EventEmitter.ValidEventTypes = string | symbol, Context extends any = any> {
  static prefixed: string | boolean;

  /**
   * Return an array listing the events for which the emitter has registered
   * listeners.
   */
  eventNames(): Array<EventEmitter.EventNames<EventTypes>>;

  /**
   * Return the listeners registered for a given event.
   */
  listeners<T extends EventEmitter.EventNames<EventTypes>>(event: T): Array<EventEmitter.EventListener<EventTypes, T>>;

  /**
   * Return the number of listeners listening to a given event.
   */
  listenerCount(event: EventEmitter.EventNames<EventTypes>): number;

  /**
   * Calls each of the listeners registered for a given event.
   */
  emit<T extends EventEmitter.EventNames<EventTypes>>(event: T, ...args: EventEmitter.EventArgs<EventTypes, T>): boolean;

  /**
   * Add a listener for a given event.
   */
  on<T extends EventEmitter.EventNames<EventTypes>>(event: T, fn: EventEmitter.EventListener<EventTypes, T>, context?: Context): this;
  addListener<T extends EventEmitter.EventNames<EventTypes>>(event: T, fn: EventEmitter.EventListener<EventTypes, T>, context?: Context): this;

  /**
   * Add a one-time listener for a given event.
   */
  once<T extends EventEmitter.EventNames<EventTypes>>(event: T, fn: EventEmitter.EventListener<EventTypes, T>, context?: Context): this;

  /**
   * Remove the listeners of a given event.
   */
  removeListener<T extends EventEmitter.EventNames<EventTypes>>(event: T, fn?: EventEmitter.EventListener<EventTypes, T>, context?: Context, once?: boolean): this;
  off<T extends EventEmitter.EventNames<EventTypes>>(event: T, fn?: EventEmitter.EventListener<EventTypes, T>, context?: Context, once?: boolean): this;

  /**
   * Remove all listeners, or those of the specified event.
   */
  removeAllListeners(event?: EventEmitter.EventNames<EventTypes>): this;
}
declare namespace EventEmitter {
  export interface ListenerFn<Args extends any[] = any[]> {
    (...args: Args): void;
  }
  export interface EventEmitterStatic {
    new <EventTypes extends ValidEventTypes = string | symbol, Context = any>(): EventEmitter<EventTypes, Context>;
  }

  /**
   * `object` should be in either of the following forms:
   * ```
   * interface EventTypes {
   *   'event-with-parameters': any[]
   *   'event-with-example-handler': (...args: any[]) => void
   * }
   * ```
   */
  export type ValidEventTypes = string | symbol | object;
  export type EventNames<T extends ValidEventTypes> = T extends string | symbol ? T : keyof T;
  export type ArgumentMap<T extends object> = { [K in keyof T]: T[K$1] extends ((...args: any[]) => void) ? Parameters<T[K$1]> : T[K$1] extends any[] ? T[K$1] : any[] };
  export type EventListener<T extends ValidEventTypes, K$1 extends EventNames<T>> = T extends string | symbol ? (...args: any[]) => void : (...args: ArgumentMap<Exclude<T, string | symbol>>[Extract<K$1, keyof T>]) => void;
  export type EventArgs<T extends ValidEventTypes, K$1 extends EventNames<T>> = Parameters<EventListener<T, K$1>>;
  export const EventEmitter: EventEmitterStatic;
}
//#endregion
//#region ../../node_modules/.pnpm/viem@2.41.2_bufferutil@4.0.7_typescript@5.9.2_utf-8-validate@5.0.10_zod@3.24.2/node_modules/viem/_types/types/typedData.d.ts
type TypedDataDefinition<typedData extends TypedData | Record<string, unknown> = TypedData, primaryType$1 extends keyof typedData | 'EIP712Domain' = keyof typedData, primaryTypes = (typedData extends TypedData ? keyof typedData : string)> = primaryType$1 extends 'EIP712Domain' ? EIP712DomainDefinition<typedData, primaryType$1> : MessageDefinition<typedData, primaryType$1, 'message', primaryTypes>;
type MessageDefinition<typedData extends TypedData | Record<string, unknown> = TypedData, primaryType$1 extends keyof typedData = keyof typedData, messageKey extends string = 'message', primaryTypes = (typedData extends TypedData ? keyof typedData : string), schema extends Record<string, unknown> = (typedData extends TypedData ? TypedDataToPrimitiveTypes<typedData> : Record<string, unknown>), message$1 = schema[primaryType$1 extends keyof schema ? primaryType$1 : keyof schema]> = {
  types: typedData;
} & {
  primaryType: primaryTypes | (primaryType$1 extends primaryTypes ? primaryType$1 : never);
  domain?: (schema extends {
    EIP712Domain: infer domain;
  } ? domain : Prettify<TypedDataDomain>) | undefined;
} & { [k in messageKey]: {
  [_: string]: any;
} extends message$1 ? Record<string, unknown> : message$1 };
type EIP712DomainDefinition<typedData extends TypedData | Record<string, unknown> = TypedData, primaryType$1 extends 'EIP712Domain' = 'EIP712Domain', schema extends Record<string, unknown> = (typedData extends TypedData ? TypedDataToPrimitiveTypes<typedData> : Record<string, unknown>)> = {
  types?: typedData | undefined;
} & {
  primaryType: 'EIP712Domain' | primaryType$1;
  domain: schema extends {
    EIP712Domain: infer domain;
  } ? domain : Prettify<TypedDataDomain>;
  message?: undefined;
};
//#endregion
//#region src/core/accounts/PrivateKey.d.ts
/**
 * Class for wrapping SigningKey that is used for signature creation and public key derivation.
 *
 * @category Crypto Utility Classes
 */
declare class PrivateKey {
  private wallet;
  private constructor();
  /**
   * Generate new private key with random mnemonic phrase
   * @returns { privateKey: PrivateKey, mnemonic: string }
   */
  static generate(): {
    privateKey: PrivateKey;
    mnemonic: string;
  };
  /**
   * Create a PrivateKey instance from a given mnemonic phrase and a HD derivation path.
   * If path is not given, default to Band's HD prefix 494 and all other indexes being zeroes.
   * @param {string} words the mnemonic phrase
   * @param {string|undefined} path the HD path that follows the BIP32 standard (optional)
   * @returns {PrivateKey} Initialized PrivateKey object
   */
  static fromMnemonic(words: string, path?: string): PrivateKey;
  /**
   * Create a PrivateKey instance from a given private key and a HD derivation path.
   * If path is not given, default to Band's HD prefix 494 and all other indexes being zeroes.
   * @param {string} privateKey  the private key
   * @returns {PrivateKey} Initialized PrivateKey object
   *
   * @deprecated - use fromHex instead
   */
  static fromPrivateKey(privateKey: string): PrivateKey;
  /**
   * Create a PrivateKey instance from a given private key and a HD derivation path.
   * If path is not given, default to Band's HD prefix 494 and all other indexes being zeroes.
   * @param {string} privateKey  the private key
   * @returns {PrivateKey} Initialized PrivateKey object
   */
  static fromHex(privateKey: string | Uint8Array): PrivateKey;
  /**
   * Return the private key in hex
   * @returns {string}
   **/
  toPrivateKeyHex(): string;
  /**
   * Return the PublicKey associated with this private key.
   * @returns {PublicKey} a Public key that can be used to verify the signatures made with this PrivateKey
   **/
  toPublicKey(): PublicKey;
  /**
   * Return the hex address associated with this private key.
   * @returns {string}
   */
  toHex(): string;
  /**
   * Return the Address associated with this private key.
   * @returns {Address}
   **/
  toAddress(): Address;
  /**
   * Return the Bech32 address associated with this private key.
   * @returns {string}
   **/
  toBech32(): string;
  /**
   * Sign the given message using the wallet's _signingKey function.
   * @param {string} messageBytes: the message that will be hashed and signed, a Buffer made of bytes
   * @returns {Uint8Array} a signature of this private key over the given message
   */
  sign(messageBytes: Uint8Array): Uint8Array;
  /**
   * Sign the given message using the edcsa sign_deterministic function.
   * @param {Buffer} messageBytes: the message that will be hashed and signed, a Buffer made of bytes
   * @returns {Uint8Array} a signature of this private key over the given message
   */
  signEcda(messageBytes: Uint8Array): Uint8Array;
  /**
   * Sign the given message using the wallet's _signingKey function.
   * @param {string} messageHashedBytes: the message that will be signed, a Buffer made of bytes
   * @returns {Uint8Array} a signature of this private key over the given message
   */
  signHashed(messageHashedBytes: Uint8Array): Uint8Array;
  /**
   * Sign the given message using the edcsa sign_deterministic function.
   * @param {Buffer} messageHashedBytes: the message that will be signed, a Buffer made of bytes
   * @returns {Uint8Array} a signature of this private key over the given message
   */
  signHashedEcda(messageHashedBytes: Uint8Array): Uint8Array;
  /**
   * Sign the given typed data using the edcsa sign_deterministic function.
   * @param {TypedDataDefinition | any} eip712Data: the typed data that will be hashed and signed
   * @returns {Uint8Array} a signature of this private key over the given message
   */
  signTypedData(eip712Data: TypedDataDefinition | any): Promise<Uint8Array>;
  /**
   * Sign the given typed data using the edcsa sign_deterministic function.
   * @param {Buffer} eip712Data: the typed data that will be signed, a Buffer made of bytes
   * @returns {Uint8Array} a signature of this private key over the given message
   */
  signHashedTypedData(eip712Data: Uint8Array): Uint8Array;
  /**
   * Verify signature using EIP712 typed data
   * and the publicKey
   *
   * (params are passed as an object)
   *
   * @param {string} signature: the signature to verify in hex
   * @param {any} eip712: the EIP712 typed data to verify against
   * @param {string} publicKey: the public key to verify against in hex
   * */
  static verifySignature({
    signature,
    eip712,
    publicKey
  }: {
    signature: string;
    eip712: any;
    publicKey: string;
  }): Promise<boolean>;
  /**
   * Verify signature using EIP712 typed data
   * and the publicKey
   *
   * (params are passed as an object)
   *
   * @param {string} signature: the signature to verify in hex
   * @param {any} eip712: the EIP712 typed data to verify against
   * @param {string} publicKey: the public key to verify against in hex
   * */
  verifyThisPkSignature({
    signature,
    eip712
  }: {
    signature: string;
    eip712: any;
  }): Promise<boolean>;
  /**
   * Verify cosmos signature EIP712 typed
   * data from the TxRaw and verify the signature
   * that's included in the TxRaw
   *
   * (params are passed as an object)
   *
   * @param {CosmosTxV1Beta1TxPb.TxRaw} txRaw: the signature to verify in hex
   * @param {object} signer: the public key and the account number to verify against
   **/
  static verifyCosmosSignature({
    txRaw,
    signer
  }: {
    txRaw: TxRaw;
    signer: {
      accountNumber: number | string;
      publicKey: string;
    };
  }): Promise<boolean>;
  /**
   * Verify signature using ADR-36 sign doc
   * and the publicKey
   *
   * (params are passed as an object)
   *
   * @param {string} signature: the signature to verify in hex
   * @param {any} signDoc: the signDoc to verify against
   * @param {string} publicKey:the public key to verify against in hex
   * */
  static verifyArbitrarySignature({
    signature,
    signDoc,
    publicKey
  }: {
    signature: string;
    signDoc: Uint8Array;
    publicKey: string;
  }): boolean;
}
//#endregion
//#region src/types/auth.d.ts
interface AccountDetails {
  address: string;
  pubKey: {
    type: string;
    key: string;
  };
  accountNumber: number;
  sequence: number;
}
//#endregion
//#region src/core/accounts/BaseAccount.d.ts
/**
 * @category Utility Classes
 */
declare class BaseAccount extends Address {
  accountNumber: number;
  sequence: number;
  pubKey: {
    type: string;
    key: string;
  };
  constructor({
    address,
    accountNumber,
    sequence,
    pubKey
  }: {
    address: string;
    accountNumber: number;
    sequence: number;
    pubKey: {
      type: string;
      key: string;
    };
  });
  static fromRestApi(accountResponse: AccountResponse): BaseAccount;
  static fromRestCosmosApi(accountResponse: BaseAccountRestResponse): BaseAccount;
  incrementSequence(): this;
  toAccountDetails(): AccountDetails;
}
//#endregion
//#region src/core/tx/broadcaster/MsgBroadcasterWithPk.d.ts
interface MsgBroadcasterTxOptions {
  msgs: Msgs | Msgs[];
  memo?: string;
  gas?: {
    gasPrice?: string;
    gas?: number; /** gas limit */
    feePayer?: string;
    granter?: string;
  };
}
interface MsgBroadcasterWithPkOptions {
  network?: Network;
  /**
   * Only used if we want to override the default
   * endpoints taken from the network param
   */
  endpoints?: {
    indexer: string;
    grpc: string;
    rest: string;
  };
  privateKey: string | PrivateKey;
  evmChainId?: EvmChainId;
  chainId?: ChainId;
  simulateTx?: boolean;
  loggingEnabled?: boolean;
  useRest?: boolean;
  txTimeout?: number;
  gasBufferCoefficient?: number;
  txTimeoutOnFeeDelegation?: boolean;
}
/**
 * This class is used to broadcast transactions
 * using a privateKey as a signer
 * for the transactions and broadcasting
 * the transactions directly to the node
 *
 * Mainly used for working in a Node Environment
 */
declare class MsgBroadcasterWithPk {
  endpoints: NetworkEndpoints;
  chainId: ChainId;
  evmChainId?: EvmChainId;
  privateKey: PrivateKey;
  simulateTx: boolean;
  txTimeoutOnFeeDelegation: boolean;
  useRest: boolean;
  gasBufferCoefficient: number;
  txTimeout: number;
  constructor(options: MsgBroadcasterWithPkOptions);
  /**
   * Broadcasting the transaction using the client
   *
   * @param tx
   * @returns {string} transaction hash
   */
  broadcast(transaction: MsgBroadcasterTxOptions, accountDetails?: AccountDetails): Promise<TxResponse>;
  /**
   * Broadcasting the transaction with fee delegation services
   *
   * @param tx
   * @returns {string} transaction hash
   */
  broadcastWithFeeDelegation(transaction: MsgBroadcasterTxOptions): Promise<TxResponse>;
  /**
   * Broadcasting the transaction using the client
   *
   * @param tx
   * @returns {string} transaction hash
   */
  simulate(transaction: MsgBroadcasterTxOptions, accountDetails?: AccountDetails): Promise<{
    result: {
      data: string | Uint8Array<ArrayBufferLike>;
      log: string;
      eventsList: Event$1[];
      events?: Event$1[] | undefined;
      msgResponses?: Any[] | undefined;
    };
    gasInfo: {
      gasWanted: number;
      gasUsed: number;
    };
  }>;
  /**
   * In case we don't want to simulate the transaction
   * we get the gas limit based on the message type.
   *
   * If we want to simulate the transaction we set the
   * gas limit based on the simulation and add a small multiplier
   * to be safe (factor of 1.1 (or user specified))
   */
  private getTxWithStdFee;
  /**
   * Create TxRaw and simulate it
   */
  private simulateTxRaw;
  private prepareTxForBroadcast;
  private getAccountDetails;
  private getTimeoutHeight;
  private broadcastTxRaw;
}
//#endregion
//#region src/core/modules/wasm/exec-args/ExecArgNeptuneDeposit.d.ts
declare namespace ExecArgNeptuneDeposit {
  interface Params {}
  interface Data {}
}
/**
 * @category Contract Exec Arguments
 */
declare class ExecArgNeptuneDeposit extends ExecArgBase<ExecArgNeptuneDeposit.Params, ExecArgNeptuneDeposit.Data> {
  static fromJSON(params: ExecArgNeptuneDeposit.Params): ExecArgNeptuneDeposit;
  toData(): ExecArgNeptuneDeposit.Data;
  toExecData(): ExecDataRepresentation<ExecArgNeptuneDeposit.Data>;
}
//#endregion
//#region src/core/modules/wasm/exec-args/ExecArgNeptuneWithdraw.d.ts
declare namespace ExecArgNeptuneWithdraw {
  interface Params {
    amount: string;
    contract: string;
  }
  interface Data {
    amount: string;
    contract: string;
    msg: string;
  }
}
/**
 * @category Contract Exec Arguments
 */
declare class ExecArgNeptuneWithdraw extends ExecArgBase<ExecArgNeptuneWithdraw.Params, ExecArgNeptuneWithdraw.Data> {
  static fromJSON(params: ExecArgNeptuneWithdraw.Params): ExecArgNeptuneWithdraw;
  toData(): ExecArgNeptuneWithdraw.Data;
  toExecData(): ExecDataRepresentation<ExecArgNeptuneWithdraw.Data>;
}
//#endregion
//#region src/core/modules/authz/utils.d.ts
declare const msgsOrMsgExecMsgs: (msgs: Msgs | Msgs[], grantee?: string) => Msgs[];
declare const getGenericAuthorizationFromMessageType: (messageTypeUrl: string) => Any;
//#endregion
//#region src/core/modules/authz/types.d.ts
declare const GrantAuthorizationType: {
  readonly GenericAuthorization: "GenericAuthorization";
  readonly ContractExecutionAuthorization: "ContractExecutionAuthorization";
};
type GrantAuthorizationType = (typeof GrantAuthorizationType)[keyof typeof GrantAuthorizationType];
//#endregion
//#region src/core/modules/authz/msgs/authorizations/GenericAuthorization.d.ts
declare namespace GenericAuthorization {
  interface Params {
    messageTypeUrl?: string;
    authorization?: Any;
  }
  type Any = Any;
  type Proto = GenericAuthorization$2;
  type Amino = Object;
}
/**
 * @category Contract Exec Arguments
 */
declare class GenericAuthorization extends BaseAuthorization<GenericAuthorization.Params, GenericAuthorization.Proto, GenericAuthorization.Amino> {
  static fromJSON(params: GenericAuthorization.Params): GenericAuthorization;
  toProto(): GenericAuthorization.Proto;
  toAmino(): GenericAuthorization.Amino;
  toWeb3(): GenericAuthorization.Amino;
  toAny(): Any;
}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/cosmwasm/wasm/v1/authz_pb.d.ts
/**
 * ContractExecutionAuthorization defines authorization for wasm execute.
 * Since: wasmd 0.30
 *
 * @generated from protobuf message cosmwasm.wasm.v1.ContractExecutionAuthorization
 */
interface ContractExecutionAuthorization$1 {
  /**
   * Grants for contract executions
   *
   * @generated from protobuf field: repeated cosmwasm.wasm.v1.ContractGrant grants = 1
   */
  grants: ContractGrant[];
}
/**
 * ContractGrant a granted permission for a single contract
 * Since: wasmd 0.30
 *
 * @generated from protobuf message cosmwasm.wasm.v1.ContractGrant
 */
interface ContractGrant {
  /**
   * Contract is the bech32 address of the smart contract
   *
   * @generated from protobuf field: string contract = 1
   */
  contract: string;
  /**
   * Limit defines execution limits that are enforced and updated when the grant
   * is applied. When the limit lapsed the grant is removed.
   *
   * @generated from protobuf field: google.protobuf.Any limit = 2
   */
  limit?: Any;
  /**
   * Filter define more fine-grained control on the message payload passed
   * to the contract in the operation. When no filter applies on execution, the
   * operation is prohibited.
   *
   * @generated from protobuf field: google.protobuf.Any filter = 3
   */
  filter?: Any;
}
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.ContractExecutionAuthorization
 */
declare const ContractExecutionAuthorization$1 = new ContractExecutionAuthorization$Type();
/**
 * @generated MessageType for protobuf message cosmwasm.wasm.v1.ContractGrant
 */
declare const ContractGrant = new ContractGrant$Type();
//#endregion
//#region src/core/modules/authz/msgs/authorizations/ContractExecutionAuthorization.d.ts
declare namespace ContractExecutionAuthorization {
  interface Params {
    contract: string;
    limit?: {
      maxCalls?: number;
      amounts?: Coin[];
    };
    filter?: {
      acceptedMessagesKeys: string[];
    };
  }
  type Any = Any;
  type Proto = ContractExecutionAuthorization$1;
  type Amino = Object;
}
/**
 * @category Contract Exec Arguments
 */
declare class ContractExecutionAuthorization extends BaseAuthorization<ContractExecutionAuthorization.Params, ContractExecutionAuthorization.Proto, ContractExecutionAuthorization.Amino> {
  static fromJSON(params: ContractExecutionAuthorization.Params): ContractExecutionAuthorization;
  toAny(): Any;
  toProto(): ContractExecutionAuthorization.Proto;
  toAmino(): ContractExecutionAuthorization.Amino;
  toWeb3(): ContractExecutionAuthorization.Amino;
}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/injective/wasmx/v1/authz_pb.d.ts
/**
 * ContractExecutionAuthorization defines authorization for wasm execute.
 * Since: wasmd 0.30
 *
 * @generated from protobuf message injective.wasmx.v1.ContractExecutionCompatAuthorization
 */
interface ContractExecutionCompatAuthorization$1 {
  /**
   * Grants for contract executions
   *
   * @generated from protobuf field: repeated cosmwasm.wasm.v1.ContractGrant grants = 1
   */
  grants: ContractGrant[];
}
/**
 * @generated MessageType for protobuf message injective.wasmx.v1.ContractExecutionCompatAuthorization
 */
declare const ContractExecutionCompatAuthorization$1 = new ContractExecutionCompatAuthorization$Type();
//#endregion
//#region src/core/modules/authz/msgs/authorizations/ContractExecutionCompatAuthorization.d.ts
declare namespace ContractExecutionCompatAuthorization {
  interface Params {
    contract: string;
    limit?: {
      maxCalls?: number;
      amounts?: Coin[];
    };
    filter?: {
      acceptedMessagesKeys: string[];
    };
  }
  type Any = Any;
  type Proto = ContractExecutionCompatAuthorization$1;
  type Amino = Object;
}
/**
 * @category Contract Exec Arguments
 */
declare class ContractExecutionCompatAuthorization extends BaseAuthorization<ContractExecutionCompatAuthorization.Params, ContractExecutionCompatAuthorization.Proto, ContractExecutionCompatAuthorization.Amino> {
  static fromJSON(params: ContractExecutionCompatAuthorization.Params): ContractExecutionCompatAuthorization;
  toAny(): Any;
  toProto(): ContractExecutionCompatAuthorization.Proto;
  toAmino(): ContractExecutionCompatAuthorization.Amino;
  toWeb3(): ContractExecutionCompatAuthorization.Amino;
}
//#endregion
//#region src/core/modules/exchange/msgs/MsgInstantBinaryOptionsMarketLaunch.d.ts
declare namespace MsgInstantBinaryOptionsMarketLaunch {
  interface Params {
    proposer: string;
    market: {
      ticker: string;
      admin: string;
      oracleSymbol: string;
      oracleProvider: string;
      oracleScaleFactor: number;
      oracleType: OracleType;
      quoteDenom: string;
      makerFeeRate: string;
      takerFeeRate: string;
      expirationTimestamp: number;
      settlementTimestamp: number;
      minPriceTickSize: string;
      minQuantityTickSize: string;
      minNotional: string;
    };
  }
  type Proto = MsgInstantBinaryOptionsMarketLaunch$1;
}
/**
 * @category Messages
 */
declare class MsgInstantBinaryOptionsMarketLaunch extends MsgBase<MsgInstantBinaryOptionsMarketLaunch.Params, MsgInstantBinaryOptionsMarketLaunch.Proto> {
  static fromJSON(params: MsgInstantBinaryOptionsMarketLaunch.Params): MsgInstantBinaryOptionsMarketLaunch;
  toProto(): MsgInstantBinaryOptionsMarketLaunch$1;
  toData(): {
    sender: string;
    ticker: string;
    oracleSymbol: string;
    oracleProvider: string;
    oracleType: OracleType;
    oracleScaleFactor: number;
    makerFeeRate: string;
    takerFeeRate: string;
    expirationTimestamp: bigint;
    settlementTimestamp: bigint;
    admin: string;
    quoteDenom: string;
    minPriceTickSize: string;
    minQuantityTickSize: string;
    minNotional: string;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      sender: string;
      ticker: string;
      oracle_symbol: string;
      oracle_provider: string;
      oracle_type: OracleType;
      oracle_scale_factor: number;
      maker_fee_rate: string;
      taker_fee_rate: string;
      expiration_timestamp: string;
      settlement_timestamp: string;
      admin: string;
      quote_denom: string;
      min_price_tick_size: string;
      min_quantity_tick_size: string;
      min_notional: string;
    };
  };
  toWeb3Gw(): {
    sender: string;
    ticker: string;
    oracle_symbol: string;
    oracle_provider: string;
    oracle_type: OracleType;
    oracle_scale_factor: number;
    maker_fee_rate: string;
    taker_fee_rate: string;
    expiration_timestamp: string;
    settlement_timestamp: string;
    admin: string;
    quote_denom: string;
    min_price_tick_size: string;
    min_quantity_tick_size: string;
    min_notional: string;
    '@type': string;
  };
  toEip712(): {
    type: string;
    value: {
      min_price_tick_size: any;
      min_quantity_tick_size: any;
      min_notional: any;
      taker_fee_rate: any;
      maker_fee_rate: any;
      sender: string;
      ticker: string;
      oracle_symbol: string;
      oracle_provider: string;
      oracle_type: OracleType;
      oracle_scale_factor: number;
      expiration_timestamp: string;
      settlement_timestamp: string;
      admin: string;
      quote_denom: string;
    };
  };
  toEip712V2(): {
    min_price_tick_size: string;
    min_quantity_tick_size: string;
    min_notional: string;
    taker_fee_rate: string;
    maker_fee_rate: string;
    oracle_type: string;
    sender: string;
    ticker: string;
    oracle_symbol: string;
    oracle_provider: string;
    oracle_scale_factor: number;
    expiration_timestamp: string;
    settlement_timestamp: string;
    admin: string;
    quote_denom: string;
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgInstantBinaryOptionsMarketLaunch$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/exchange/utils/classes/OrderHashManager.d.ts
interface OrderInfo {
  subaccountId: string;
  feeRecipient: string;
  price: string;
  quantity: string;
}
interface SpotOrder {
  marketId: string;
  orderInfo: OrderInfo;
  orderType: number;
  triggerPrice?: string;
}
interface DerivativeOrder extends SpotOrder {
  margin: string;
}
declare class OrderHashManager {
  subaccountIndex: number;
  address: string;
  network: Network;
  nonce: number;
  constructor({
    network,
    address,
    subaccountIndex
  }: {
    network: Network;
    address: string;
    subaccountIndex?: number;
  });
  incrementNonce(): void;
  setNonce(nonce: number): void;
  /**
   * Keep in mind that the order params have to be transformed
   * in proper format that's supported on the chain
   */
  getOrderHashes({
    spotOrders,
    derivativeOrders
  }: {
    spotOrders: SpotOrder[];
    derivativeOrders: DerivativeOrder[];
  }): Promise<{
    derivativeOrderHashes: string[];
    spotOrderHashes: string[];
  }>;
  /**
   * Keep in mind that the order params have to be transformed
   * in proper format that's supported on the chain
   */
  getDerivativeOrderHashes(orders: DerivativeOrder[]): Promise<string[]>;
  /**
   * Keep in mind that the order params have to be transformed
   * in proper format that's supported on the chain
   */
  getSpotOrderHashes(orders: SpotOrder[]): Promise<string[]>;
  getSpotOrderHashFromMsg(msg: MsgCreateSpotLimitOrder): Promise<string>;
  getDerivativeOrderHashFromMsg(msg: MsgCreateDerivativeLimitOrder): Promise<string>;
  private initSubaccountNonce;
  private hashTypedData;
  private incrementNonceAndReturn;
}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/injective/permissions/v1beta1/tx_pb.d.ts
/**
 * @generated from protobuf message injective.permissions.v1beta1.MsgUpdateParams
 */
interface MsgUpdateParams$1 {
  /**
   * authority is the address of the governance account.
   *
   * @generated from protobuf field: string authority = 1
   */
  authority: string;
  /**
   * params defines the permissions parameters to update.
   *
   * NOTE: All parameters must be supplied.
   *
   * @generated from protobuf field: injective.permissions.v1beta1.Params params = 2
   */
  params?: Params$3;
}
/**
 * @generated from protobuf message injective.permissions.v1beta1.MsgCreateNamespace
 */
interface MsgCreateNamespace$1 {
  /**
   * The sender's Injective address
   *
   * @generated from protobuf field: string sender = 1
   */
  sender: string;
  /**
   * The namespace information
   *
   * @generated from protobuf field: injective.permissions.v1beta1.Namespace namespace = 2
   */
  namespace?: Namespace;
}
/**
 * @generated from protobuf message injective.permissions.v1beta1.MsgUpdateNamespace
 */
interface MsgUpdateNamespace$1 {
  /**
   * The sender's Injective address
   *
   * @generated from protobuf field: string sender = 1
   */
  sender: string;
  /**
   * denom whose namespace updates are to be applied
   *
   * @generated from protobuf field: string denom = 2
   */
  denom: string;
  /**
   * address of smart contract to apply code-based restrictions
   *
   * @generated from protobuf field: injective.permissions.v1beta1.MsgUpdateNamespace.SetContractHook contract_hook = 3
   */
  contractHook?: MsgUpdateNamespace_SetContractHook;
  /**
   * role permissions to update
   *
   * @generated from protobuf field: repeated injective.permissions.v1beta1.Role role_permissions = 4
   */
  rolePermissions: Role[];
  /**
   * role managers to update
   *
   * @generated from protobuf field: repeated injective.permissions.v1beta1.RoleManager role_managers = 5
   */
  roleManagers: RoleManager[];
  /**
   * policy statuses to update
   *
   * @generated from protobuf field: repeated injective.permissions.v1beta1.PolicyStatus policy_statuses = 6
   */
  policyStatuses: PolicyStatus[];
  /**
   * policy manager capabilities to update
   *
   * @generated from protobuf field: repeated injective.permissions.v1beta1.PolicyManagerCapability policy_manager_capabilities = 7
   */
  policyManagerCapabilities: PolicyManagerCapability[];
}
/**
 * @generated from protobuf message injective.permissions.v1beta1.MsgUpdateNamespace.SetContractHook
 */
interface MsgUpdateNamespace_SetContractHook {
  /**
   * @generated from protobuf field: string new_value = 1
   */
  newValue: string;
}
/**
 * @generated from protobuf message injective.permissions.v1beta1.MsgUpdateActorRoles
 */
interface MsgUpdateActorRoles$1 {
  /**
   * The sender's Injective address
   *
   * @generated from protobuf field: string sender = 1
   */
  sender: string;
  /**
   * The namespace denom to which this updates are applied
   *
   * @generated from protobuf field: string denom = 2
   */
  denom: string;
  /**
   * The roles to add for given actors
   *
   * @generated from protobuf field: repeated injective.permissions.v1beta1.RoleActors role_actors_to_add = 3
   */
  roleActorsToAdd: RoleActors[];
  /**
   * The roles to revoke from given actors
   *
   * @generated from protobuf field: repeated injective.permissions.v1beta1.RoleActors role_actors_to_revoke = 5
   */
  roleActorsToRevoke: RoleActors[];
}
/**
 * @generated from protobuf message injective.permissions.v1beta1.MsgClaimVoucher
 */
interface MsgClaimVoucher$1 {
  /**
   * The sender's Injective address
   *
   * @generated from protobuf field: string sender = 1
   */
  sender: string;
  /**
   * The token denom of the voucher to claim
   *
   * @generated from protobuf field: string denom = 2
   */
  denom: string;
}
/**
 * @generated MessageType for protobuf message injective.permissions.v1beta1.MsgUpdateParams
 */
declare const MsgUpdateParams$1 = new MsgUpdateParams$Type();
/**
 * @generated MessageType for protobuf message injective.permissions.v1beta1.MsgCreateNamespace
 */
declare const MsgCreateNamespace$1 = new MsgCreateNamespace$Type();
/**
 * @generated MessageType for protobuf message injective.permissions.v1beta1.MsgUpdateNamespace
 */
declare const MsgUpdateNamespace$1 = new MsgUpdateNamespace$Type();
/**
 * @generated MessageType for protobuf message injective.permissions.v1beta1.MsgUpdateNamespace.SetContractHook
 */
declare const MsgUpdateNamespace_SetContractHook = new MsgUpdateNamespace_SetContractHook$Type();
/**
 * @generated MessageType for protobuf message injective.permissions.v1beta1.MsgUpdateActorRoles
 */
declare const MsgUpdateActorRoles$1 = new MsgUpdateActorRoles$Type();
/**
 * @generated MessageType for protobuf message injective.permissions.v1beta1.MsgClaimVoucher
 */
declare const MsgClaimVoucher$1 = new MsgClaimVoucher$Type();
//#endregion
//#region src/core/modules/permissions/msgs/MsgClaimVoucher.d.ts
declare namespace MsgClaimVoucher {
  interface Params {
    sender: string;
    denom: string;
  }
  type Proto = MsgClaimVoucher$1;
}
/**
 * @category Messages
 */
declare class MsgClaimVoucher extends MsgBase<MsgClaimVoucher.Params, MsgClaimVoucher.Proto> {
  static fromJSON(params: MsgClaimVoucher.Params): MsgClaimVoucher;
  toProto(): MsgClaimVoucher$1;
  toData(): {
    sender: string;
    denom: string;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      sender: string;
      denom: string;
    };
  };
  toWeb3Gw(): {
    sender: string;
    denom: string;
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgClaimVoucher$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/permissions/msgs/MsgUpdateParams.d.ts
declare namespace MsgUpdateParams {
  interface Params {
    authority: string;
    params: {
      wasmHookQueryMaxGas: string;
    };
  }
  type Proto = MsgUpdateParams$1;
}
/**
 * @category Messages
 */
declare class MsgUpdateParams extends MsgBase<MsgUpdateParams.Params, MsgUpdateParams.Proto> {
  static fromJSON(params: MsgUpdateParams.Params): MsgUpdateParams;
  toProto(): MsgUpdateParams$1;
  toData(): {
    authority: string;
    params?: Params$3;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      authority: string;
      params: {
        wasm_hook_query_max_gas: string;
      };
    };
  };
  toWeb3Gw(): {
    authority: string;
    params: {
      wasm_hook_query_max_gas: string;
    };
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgUpdateParams$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/permissions/msgs/MsgCreateNamespace.d.ts
declare namespace MsgCreateNamespace {
  interface Params {
    sender: string;
    namespace: {
      denom: string;
      contractHook: string;
      rolePermissions: PermissionRole[];
      actorRoles: PermissionActorRoles[];
      roleManagers: PermissionRoleManager[];
      policyStatuses: PermissionPolicyStatus[];
      policyManagerCapabilities: PermissionPolicyManagerCapability[];
    };
  }
  type Proto = MsgCreateNamespace$1;
}
/**
 * @category Messages
 */
declare class MsgCreateNamespace extends MsgBase<MsgCreateNamespace.Params, MsgCreateNamespace.Proto> {
  static fromJSON(params: MsgCreateNamespace.Params): MsgCreateNamespace;
  toProto(): MsgCreateNamespace$1;
  toData(): {
    sender: string;
    namespace?: Namespace;
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      sender: string;
      namespace: {
        denom: string | undefined;
        contract_hook: string | undefined;
        role_permissions: {
          name: string;
          role_id: number;
          permissions: number;
        }[];
        actor_roles: {
          actor: string;
          roles: string[];
        }[];
        role_managers: {
          manager: string;
          roles: string[];
        }[];
        policy_statuses: {
          action: Action;
          is_disabled: boolean;
          is_sealed: boolean;
        }[];
        policy_manager_capabilities: {
          manager: string;
          action: Action;
          can_disable: boolean;
          can_seal: boolean;
        }[];
      };
    };
  };
  toWeb3Gw(): {
    sender: string;
    namespace: {
      denom: string | undefined;
      contract_hook: string | undefined;
      role_permissions: {
        name: string;
        role_id: number;
        permissions: number;
      }[];
      actor_roles: {
        actor: string;
        roles: string[];
      }[];
      role_managers: {
        manager: string;
        roles: string[];
      }[];
      policy_statuses: {
        action: Action;
        is_disabled: boolean;
        is_sealed: boolean;
      }[];
      policy_manager_capabilities: {
        manager: string;
        action: Action;
        can_disable: boolean;
        can_seal: boolean;
      }[];
    };
    '@type': string;
  };
  toEip712(): never;
  toEip712V2(): {
    namespace: {
      denom: any;
      contract_hook: any;
      role_permissions: any;
      actor_roles: any;
      role_managers: any;
      policy_statuses: any;
      policy_manager_capabilities: any;
    };
    sender: string;
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgCreateNamespace$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/permissions/msgs/MsgUpdateNamespace.d.ts
declare namespace MsgUpdateNamespace {
  interface Params {
    sender: string;
    denom: string;
    contractHook?: string;
    rolePermissions: PermissionRole[];
    roleManagers: PermissionRoleManager[];
    policyStatuses: PermissionPolicyStatus[];
    policyManagerCapabilities: PermissionPolicyManagerCapability[];
  }
  type Proto = MsgUpdateNamespace$1;
}
/**
 * @category Messages
 */
declare class MsgUpdateNamespace extends MsgBase<MsgUpdateNamespace.Params, MsgUpdateNamespace.Proto> {
  static fromJSON(params: MsgUpdateNamespace.Params): MsgUpdateNamespace;
  toProto(): MsgUpdateNamespace$1;
  toData(): {
    sender: string;
    denom: string;
    contractHook?: MsgUpdateNamespace_SetContractHook;
    rolePermissions: Role[];
    roleManagers: RoleManager[];
    policyStatuses: PolicyStatus[];
    policyManagerCapabilities: PolicyManagerCapability[];
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      sender: string;
      denom: string;
      contract_hook: {
        new_value: string;
      } | undefined;
      role_permissions: {
        name: string;
        role_id: number;
        permissions: number;
      }[];
      role_managers: {
        manager: string;
        roles: string[];
      }[];
      policy_statuses: {
        action: Action;
        is_disabled: boolean;
        is_sealed: boolean;
      }[];
      policy_manager_capabilities: {
        manager: string;
        action: Action;
        can_disable: boolean;
        can_seal: boolean;
      }[];
    };
  };
  toWeb3Gw(): {
    sender: string;
    denom: string;
    contract_hook: {
      new_value: string;
    } | undefined;
    role_permissions: {
      name: string;
      role_id: number;
      permissions: number;
    }[];
    role_managers: {
      manager: string;
      roles: string[];
    }[];
    policy_statuses: {
      action: Action;
      is_disabled: boolean;
      is_sealed: boolean;
    }[];
    policy_manager_capabilities: {
      manager: string;
      action: Action;
      can_disable: boolean;
      can_seal: boolean;
    }[];
    '@type': string;
  };
  toEip712(): never;
  toEip712V2(): {
    policy_statuses: any[];
    policy_manager_capabilities: any[];
    sender: string;
    denom: string;
    contract_hook: {
      new_value: string;
    } | undefined;
    role_permissions: {
      name: string;
      role_id: number;
      permissions: number;
    }[];
    role_managers: {
      manager: string;
      roles: string[];
    }[];
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgUpdateNamespace$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/modules/permissions/msgs/MsgUpdateActorRoles.d.ts
declare namespace MsgUpdateActorRoles {
  interface Params {
    sender: string;
    denom: string;
    roleActorsToAdd: PermissionRoleActors[];
    roleActorsToRevoke: PermissionRoleActors[];
  }
  type Proto = MsgUpdateActorRoles$1;
}
/**
 * @category Messages
 */
declare class MsgUpdateActorRoles extends MsgBase<MsgUpdateActorRoles.Params, MsgUpdateActorRoles.Proto> {
  static fromJSON(params: MsgUpdateActorRoles.Params): MsgUpdateActorRoles;
  toProto(): MsgUpdateActorRoles$1;
  toData(): {
    sender: string;
    denom: string;
    roleActorsToAdd: RoleActors[];
    roleActorsToRevoke: RoleActors[];
    '@type': string;
  };
  toAmino(): {
    type: string;
    value: {
      sender: string;
      denom: string;
      role_actors_to_add: {
        role: string;
        actors: string[];
      }[];
      role_actors_to_revoke: {
        role: string;
        actors: string[];
      }[];
    };
  };
  toWeb3Gw(): {
    sender: string;
    denom: string;
    role_actors_to_add: {
      role: string;
      actors: string[];
    }[];
    role_actors_to_revoke: {
      role: string;
      actors: string[];
    }[];
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgUpdateActorRoles$1;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/utils/time.d.ts
/**
 * Returns a timeout timestamp in milliseconds so its compatible
 * with the way Cosmos handles transactions
 */
declare const makeTimeoutTimestamp: (timeoutInMs?: number) => number;
/**
 * Returns a timeout timestamp in nanoseconds so its compatible
 * with the way Cosmos handles transactions
 */
declare const makeTimeoutTimestampInNs: (timeoutInMs?: number) => number;
/**
 * Converts a protobuf Timestamp to a JavaScript Date
 * @param timestamp - Protobuf Timestamp object with seconds and nanos fields
 * @returns JavaScript Date or undefined if timestamp is null/undefined
 */
declare const protobufTimestampToDate: (timestamp: {
  seconds: bigint | number;
  nanos: number;
} | null | undefined) => Date | undefined;
/**
 * Converts a protobuf Timestamp to Unix timestamp in seconds
 * @param timestamp - Protobuf Timestamp object with seconds and nanos fields
 * @returns Unix timestamp in seconds or 0 if timestamp is null/undefined
 */
declare const protobufTimestampToUnixSeconds: (timestamp: {
  seconds: bigint | number;
  nanos: number;
} | null | undefined) => number;
/**
 * Converts a protobuf Timestamp to Unix timestamp in milliseconds
 * @param timestamp - Protobuf Timestamp object with seconds and nanos fields
 * @returns Unix timestamp in milliseconds or 0 if timestamp is null/undefined
 */
declare const protobufTimestampToUnixMs: (timestamp: {
  seconds: bigint | number;
  nanos: number;
} | null | undefined) => number;
//#endregion
//#region src/utils/msgs.d.ts
declare const getGasPriceBasedOnMessage: (msgs: Msgs[]) => number;
//#endregion
//#region src/utils/grpc.d.ts
/**
 * Creates a gRPC-Web transport using @protobuf-ts/grpcweb-transport.
 * This transport works in browser, Node.js, and React Native environments.
 *
 * @param baseUrl - The base URL of the gRPC-Web endpoint
 * @param options - Optional configuration for the transport
 * @returns A configured RpcTransport instance
 */
declare const getGrpcWebTransport: (baseUrl: string, options?: GrpcWebTransportAdditionalOptions) => RpcTransport;
//#endregion
//#region src/utils/ofac.d.ts
declare const ofacList: string[];
//#endregion
//#region src/utils/coins.d.ts
declare const parseCoins: (input: string) => {
  amount: string;
  denom: string;
}[];
//#endregion
//#region src/utils/crypto.d.ts
/**
 * Hash data to hex string using SHA256
 * @param data - Base64 encoded string to hash
 * @returns Uppercase hex string
 */
declare const hashToHex: (data: string) => string;
/**
 * Compute SHA256 hash of Uint8Array data
 * @param data - Data to hash
 * @returns SHA256 hash as Uint8Array
 */
declare const sha256: (data: Uint8Array) => Uint8Array;
/**
 * Compute RIPEMD160 hash of Uint8Array data
 * @param data - Data to hash
 * @returns RIPEMD160 hash as Uint8Array
 */
declare const ripemd160: (data: Uint8Array) => Uint8Array;
/**
 * Derive public key from private key
 * @param privateKey - Private key as Uint8Array
 * @returns Compressed public key (33 bytes)
 */
declare const privateKeyToPublicKey: (privateKey: Uint8Array) => Uint8Array;
/**
 * Derive public key from private key hash (hex string)
 * @param privateKeyHash - Private key as hex string (with or without 0x prefix)
 * @returns Compressed public key (33 bytes)
 */
declare const privateKeyHashToPublicKey: (privateKeyHash: string) => Uint8Array;
/**
 * Derive public key from private key and encode as base64
 * @param privateKey - Private key as Uint8Array
 * @returns Base64 encoded compressed public key
 */
declare const privateKeyToPublicKeyBase64: (privateKey: Uint8Array) => string;
/**
 * Derive public key from private key hash and encode as base64
 * @param privateKeyHash - Private key as hex string (with or without 0x prefix)
 * @returns Base64 encoded compressed public key
 */
declare const privateKeyHashToPublicKeyBase64: (privateKeyHash: string) => string;
/**
 * Hash only the domain portion of EIP-712 typed data
 * @param message - EIP-712 typed data definition
 * @returns Hash of the domain
 */
declare const domainHash: (message: TypedDataDefinition) => `0x${string}`;
/**
 * Hash only the message portion of EIP-712 typed data
 * @param message - EIP-712 typed data definition
 * @returns Hash of the message
 */
declare const messageHash: (message: TypedDataDefinition) => `0x${string}`;
/**
 * Decompress a compressed public key (starts with 02 or 03)
 * If the key is already 64 bytes, prepends '04' to make it uncompressed
 * @param startsWith02Or03 - Compressed public key hex string
 * @returns Decompressed public key hex string (without 04 prefix)
 */
declare function decompressPubKey(startsWith02Or03: string): string;
/**
 * Convert public key to Ethereum address using Keccak256
 * @param pubKey - Public key as Uint8Array (64 bytes uncompressed or 33 bytes compressed)
 * @param sanitize - If true, will decompress compressed keys before hashing
 * @returns Ethereum address (20 bytes)
 * @throws Error if pubKey length is not 64 after sanitization
 */
declare const publicKeyToAddress: (pubKey: Uint8Array, sanitize?: boolean) => Uint8Array;
/**
 * Sanitize typed data by converting BigInt values to strings
 * Recursively processes objects and arrays
 * @param data - Data to sanitize (can be object, array, or primitive)
 * @returns Sanitized data with BigInt values converted to strings
 */
declare const sanitizeTypedData: <T extends object | any[] | bigint | string | number | boolean | null | undefined>(data: T) => T;
interface BufferLike {
  toString(encoding?: string): string;
}
declare const TypedDataUtilsSanitizeData: <T extends object | any[] | bigint | string | number | boolean | null | undefined>(data: T) => T;
declare const TypedDataUtilsHashStruct: (primaryType: string, data: any, types: any, _version?: string) => BufferLike;
declare const SignTypedDataVersionV4: "V4";
type TypedMessageV4 = TypedDataDefinition;
//#endregion
//#region src/utils/helpers.d.ts
declare const isServerSide: () => boolean;
declare const isReactNative: () => boolean;
declare const isNode: () => boolean;
declare const isBrowser: () => boolean;
declare const objectToJson: (object: Record<string, any>, params?: {
  replacer?: (key: string, value: unknown) => unknown;
  indentation?: number;
} | undefined) => string;
declare const protoObjectToJson: (object: any, params?: {
  replacer?: (key: string, value: unknown) => unknown;
  indentation?: number;
} | undefined) => string;
declare const grpcCoinToUiCoin: (coin: Coin$1) => Coin;
declare const sortObjectByKeysWithReduce: <T>(obj: T) => T;
declare const sortObjectByKeys: <T>(obj: T) => T;
declare const getErrorMessage: (error: any, endpoint: string) => string;
/**
 * Converts value to it's number representation
 */
declare const hexToNumber: (value: string) => number;
declare function isJsonString<T>(str: T): boolean;
/**
 * BigInt-safe JSON replacer function.
 * Converts BigInt values to strings during JSON serialization.
 */
declare const bigIntReplacer: (_key: string, value: unknown) => unknown;
/**
 * Converts a potentially bigint value to a number.
 * Handles bigint, string, and other number-like types.
 * Returns 0 for null/undefined values.
 */
declare const bigIntToNumber: (value: unknown) => number;
/**
 * Converts a potentially bigint value to a string.
 * Handles bigint, string, and other types that can be converted to string.
 * Returns empty string for null/undefined values.
 */
declare const bigIntToString: (value: unknown) => string;
/**
 * Stringify an object to JSON with BigInt support.
 * Converts BigInt values to strings during serialization to prevent
 * "Do not know how to serialize a BigInt" errors.
 *
 * @param value - The value to serialize
 * @param replacer - Optional custom replacer function (BigInt handling is applied first)
 * @param space - Optional indentation for pretty printing
 * @returns JSON string
 */
declare const safeBigIntStringify: (value: unknown, replacer?: ((key: string, value: unknown) => unknown) | null, space?: string | number) => string;
//#endregion
//#region src/utils/numbers.d.ts
declare const isNumber: (number: string | number) => boolean;
declare const formatNumberToAllowableDecimals: (value: string | number, allowableDecimals: number, roundingMode?: BigNumber.RoundingMode) => string;
declare const formatNumberToAllowableTensMultiplier: (value: string | number, tensMultiplier: number, roundingMode?: BigNumber.RoundingMode) => string;
declare const formatAmountToAllowableAmount: (value: string | number, tensMultiplier: number) => string;
declare const formatPriceToAllowablePrice: (value: string | number, tensMultiplier: number) => string;
/**
 *
 * Legacy function - use formatNumberToAllowableDecimals
 *
 * @param value
 * @param allowableDecimals
 * @returns
 */
declare const formatAmountToAllowableDecimals: (value: string | number, allowableDecimals: number) => string;
/**
 *
 * Legacy function - use formatNumberToAllowableDecimals
 *
 * @param value
 * @param allowableDecimals
 * @returns
 */
declare const formatPriceToAllowableDecimals: (value: string | number, allowableDecimals: number) => string;
/**
 * On chain amounts queried from a sentry using the
 * gRPC API are returned with an extra decimal point
 * 18 places from the beginning, so we need to remove it
 * to get a workable amount
 */
declare const denomAmountFromGrpcChainDenomAmount: (value: string | number | BigNumber) => BigNumber;
/**
 * @deprecated use toChainFormat from injectivelabs/utils instead
 *
 * On chain amounts broadcasted to a sentry directly using the
 * gRPC API should be passed with an extra decimal point
 * 18 places from the beginning, so we need to add it
 * to get a workable amount
 */
declare const denomAmountToGrpcChainDenomAmount: (value: string | number | BigNumber) => BigNumber;
/**
 * @deprecated use toChainFormat from injectivelabs/utils instead
 *
 * On chain amounts (based on the cosmosSdk.Dec type)
 * broadcasted to a sentry directly using the
 * gRPC API should be passed with an extra decimal point
 * 18 places from the beginning (i.e multiplied by 1e18), so we need to add it
 * to get a workable amount
 */
declare const amountToCosmosSdkDecAmount: (value: string | number | BigNumber) => BigNumber;
/**
 * * @deprecated use toChainFormat from injectivelabs/utils instead
 *
 * Amount that the chain requires is in the x * 10^(quoteDecimals) format
 * where x is a human readable number
 */
declare const denomAmountToChainDenomAmount: ({
  value,
  decimals
}: {
  value: number | string | BigNumber;
  decimals?: number | string;
}) => BigNumber;
/**
 * Amount that the chain returns is in the x * 10^(quoteDecimals) format
 * where x is a human readable number
 */
declare const denomAmountToChainDenomAmountToFixed: ({
  value,
  decimals,
  tensMultiplier,
  decimalPlaces,
  roundingMode
}: {
  value: number | string | BigNumber;
  decimals?: number | string;
  tensMultiplier?: number;
  decimalPlaces?: number;
  roundingMode?: BigNumber.RoundingMode;
}) => string;
/**
 * @deprecated use toHumanReadable from injectivelabs/utils instead
 *
 * Amount that the chain returns is in the x * 10^(quoteDecimals) format
 * where x is a human readable number
 */
declare const denomAmountFromChainDenomAmount: ({
  value,
  decimals
}: {
  value: number | string | BigNumber;
  decimals?: number | string;
}) => BigNumber;
/**
 *
 * Amount that the chain returns is in the x * 10^(quoteDecimals) format
 * where x is a human readable number stringified
 */
declare const denomAmountFromChainDenomAmountToFixed: ({
  value,
  decimals,
  decimalPlaces,
  roundingMode
}: {
  value: number | string | BigNumber;
  decimals?: number;
  decimalPlaces?: number;
  roundingMode?: BigNumber.RoundingMode;
}) => any;
/**
 * @deprecated use toChainFormat from injectivelabs/utils instead
 *
 * Amount that the chain requires is in the x * 10^(quoteDecimals) format
 * where x is a human readable number
 */
declare const derivativeMarginToChainMargin: ({
  value,
  quoteDecimals
}: {
  value: number | string | BigNumber;
  quoteDecimals?: number | string;
}) => BigNumber;
/**
 * Amount that the chain requires is in the x * 10^(quoteDecimals) format
 * where x is a human readable number stringified
 */
declare const derivativeMarginToChainMarginToFixed: ({
  value,
  quoteDecimals,
  tensMultiplier,
  decimalPlaces,
  roundingMode
}: {
  decimalPlaces?: number;
  tensMultiplier?: number;
  roundingMode?: BigNumber.RoundingMode;
  value: number | string | BigNumber;
  quoteDecimals?: number | string;
}) => string;
/**
 * @deprecated use toHumanReadable from injectivelabs/utils instead
 *
 * Amount that the chain returns is in the x * 10^(quoteDecimals) format
 * where x is a human readable number
 */
declare const derivativeMarginFromChainMargin: ({
  value,
  quoteDecimals
}: {
  value: number | string | BigNumber;
  quoteDecimals?: number | string;
}) => BigNumber;
/**
 * Amount that the chain returns is in the x * 10^(quoteDecimals) format
 * where x is a human readable number
 */
declare const derivativeMarginFromChainMarginToFixed: ({
  value,
  quoteDecimals,
  decimalPlaces,
  roundingMode
}: {
  value: number | string | BigNumber;
  quoteDecimals?: number;
  decimalPlaces?: number;
  roundingMode?: BigNumber.RoundingMode;
}) => any;
/**
 * @deprecated use toChainFormat from injectivelabs/utils instead
 * Amount that the chain requires is in the x * 10^(quoteDecimals) format
 * where x is a human readable number
 */
declare const derivativePriceToChainPrice: ({
  value,
  quoteDecimals
}: {
  value: number | string | BigNumber;
  quoteDecimals?: number | string;
}) => BigNumber;
/**
 * Amount that the chain requires is in the x * 10^(quoteDecimals) format
 * where x is a human readable number stringified
 */
declare const derivativePriceToChainPriceToFixed: ({
  value,
  tensMultiplier,
  quoteDecimals,
  decimalPlaces,
  roundingMode
}: {
  value: number | string | BigNumber;
  tensMultiplier?: number;
  quoteDecimals?: number;
  decimalPlaces?: number;
  roundingMode?: BigNumber.RoundingMode;
}) => any;
/**
 * @deprecated use toHumanReadable from injectivelabs/utils instead
 *
 * Amount that the chain returns is in the x * 10^(quoteDecimals) format
 * where x is a human readable number
 */
declare const derivativePriceFromChainPrice: ({
  value,
  quoteDecimals
}: {
  value: number | string | BigNumber;
  quoteDecimals?: number | string;
}) => BigNumber;
/**
 * Amount that the chain returns is in the x * 10^(quoteDecimals) format
 * where x is a human readable number stringified
 */
declare const derivativePriceFromChainPriceToFixed: ({
  value,
  quoteDecimals,
  decimalPlaces,
  roundingMode
}: {
  value: number | string | BigNumber;
  quoteDecimals?: number;
  decimalPlaces?: number;
  roundingMode?: BigNumber.RoundingMode;
}) => any;
/**
 * @deprecated use toBigNumber from injectivelabs/utils instead
 * Amount that the chain requires is in the x format
 * where x is a human readable number
 */
declare const derivativeQuantityToChainQuantity: ({
  value
}: {
  value: number | string | BigNumber;
}) => BigNumber;
/**
 * Amount that the chain requires is in the x format
 * where x is a human readable number stringified
 */
declare const derivativeQuantityToChainQuantityToFixed: ({
  value,
  decimalPlaces,
  tensMultiplier,
  roundingMode
}: {
  value: number | string | BigNumber;
  decimalPlaces?: number;
  tensMultiplier?: number;
  roundingMode?: BigNumber.RoundingMode;
}) => string;
/**
 * @deprecated
 * Amount that the chain requires is in the x format
 * where x is a human readable number
 */
declare const derivativeQuantityFromChainQuantity: ({
  value
}: {
  value: number | string | BigNumber;
}) => BigNumber;
/**
 * Amount that the chain requires is in the x format
 * where x is a human readable number stringified
 */
declare const derivativeQuantityFromChainQuantityToFixed: ({
  value,
  decimalPlaces,
  roundingMode
}: {
  value: number | string | BigNumber;
  decimalPlaces?: number;
  roundingMode?: BigNumber.RoundingMode;
}) => string;
/**
 * @deprecated use toChainFormat from injectivelabs/utils instead
 * Amount that the chain requires is in the x / 10^(quoteDecimals - baseDecimals) format
 * where x is a human readable number
 */
declare const spotPriceToChainPrice: ({
  value,
  baseDecimals,
  quoteDecimals
}: {
  value: number | string | BigNumber;
  quoteDecimals?: number | string;
  baseDecimals?: number | string;
}) => BigNumber;
/**
 * Amount that the chain requires is in the x / 10^(quoteDecimals - baseDecimals) format
 * where x is a human readable number stringified
 */
declare const spotPriceToChainPriceToFixed: ({
  value,
  baseDecimals,
  quoteDecimals,
  tensMultiplier,
  decimalPlaces,
  roundingMode
}: {
  value: number | string | BigNumber;
  quoteDecimals?: number | string;
  baseDecimals?: number | string;
  decimalPlaces?: number;
  tensMultiplier?: number;
  roundingMode?: BigNumber.RoundingMode;
}) => any;
/**
 * @deprecated use toHumanReadable from injectivelabs/utils instead
 *
 * Amount that the chain returns is in the x / 10^(quoteDecimals - baseDecimals) format
 * where x is a human readable number
 */
declare const spotPriceFromChainPrice: ({
  value,
  baseDecimals,
  quoteDecimals
}: {
  value: number | string | BigNumber;
  quoteDecimals?: number | string;
  baseDecimals?: number | string;
}) => BigNumber;
/**
 * Amount that the chain returns is in the x / 10^(quoteDecimals - baseDecimals) format
 * where x is a human readable number stringified
 */
declare const spotPriceFromChainPriceToFixed: ({
  value,
  baseDecimals,
  quoteDecimals,
  decimalPlaces,
  roundingMode
}: {
  value: number | string | BigNumber;
  quoteDecimals?: number;
  baseDecimals?: number;
  decimalPlaces?: number;
  roundingMode?: BigNumber.RoundingMode;
}) => any;
/**
 * @deprecated use toChainFormat from injectivelabs/utils instead
 *
 * Amount that the chain requires is in the x * 10^(baseDecimals) format
 * where x is a human readable number
 */
declare const spotQuantityToChainQuantity: ({
  value,
  baseDecimals
}: {
  value: number | string | BigNumber;
  baseDecimals?: number | string;
}) => BigNumber;
/**
 * Amount that the chain requires is in the x * 10^(baseDecimals) format
 * where x is a human readable number
 */
declare const spotQuantityToChainQuantityToFixed: ({
  value,
  baseDecimals,
  tensMultiplier,
  decimalPlaces,
  roundingMode
}: {
  value: number | string | BigNumber;
  tensMultiplier?: number;
  baseDecimals?: number;
  decimalPlaces?: number;
  roundingMode?: BigNumber.RoundingMode;
}) => any;
/**
 * @deprecated use toHumanReadable from injectivelabs/utils instead
 *
 * Amount that the chain returns is in the x * 10^(baseDecimals) format
 * where x is a human readable number
 */
declare const spotQuantityFromChainQuantity: ({
  value,
  baseDecimals
}: {
  value: number | string | BigNumber;
  baseDecimals?: number | string;
}) => BigNumber;
/**
 * Amount that the chain returns is in the x * 10^(baseDecimals) format
 * where x is a human readable number
 */
declare const spotQuantityFromChainQuantityToFixed: ({
  value,
  baseDecimals,
  decimalPlaces,
  roundingMode
}: {
  value: number | string | BigNumber;
  baseDecimals?: number;
  decimalPlaces?: number;
  roundingMode?: BigNumber.RoundingMode;
}) => any;
/**
 * @deprecated use toHumanReadable from injectivelabs/utils instead
 */
declare const cosmosSdkDecToBigNumber: (number: string | number | BigNumber) => BigNumber;
declare const numberToCosmosSdkDecString: (value: string | number | BigNumber) => string;
/**
 * This function returns a multiplier of 10
 * based on the input. There are two cases:
 *
 * 1. If the number is less than 1, it returns a NEGATIVE
 * number which is the number of decimals the number has
 *
 * 2. If the number is higher than 1, it returns a POSITIVE
 * number which is the number of 10 multiplier the number has
 *
 * @param number
 * @returns {number}
 */
declare const getTensMultiplier: (number: number | string) => number;
//#endregion
//#region src/utils/markets.d.ts
declare const getDerivativeMarketTensMultiplier: ({
  quoteDecimals,
  minPriceTickSize,
  minQuantityTickSize
}: {
  minPriceTickSize: number | string;
  minQuantityTickSize: number | string;
  quoteDecimals: number;
}) => {
  quantityTensMultiplier: number;
  priceTensMultiplier: number;
};
declare const getSpotMarketTensMultiplier: ({
  baseDecimals,
  quoteDecimals,
  minPriceTickSize,
  minQuantityTickSize
}: {
  minPriceTickSize: number | string;
  minQuantityTickSize: number | string;
  baseDecimals: number;
  quoteDecimals: number;
}) => {
  priceTensMultiplier: number;
  quantityTensMultiplier: number;
};
declare const getDerivativeMarketDecimals: ({
  minPriceTickSize,
  minQuantityTickSize,
  quoteDecimals
}: {
  minPriceTickSize: number | string;
  minQuantityTickSize: number | string;
  quoteDecimals: number;
}) => {
  quantityDecimals: number;
  priceDecimals: number;
};
declare const getSpotMarketDecimals: ({
  minPriceTickSize,
  minQuantityTickSize,
  baseDecimals,
  quoteDecimals
}: {
  minPriceTickSize: number | string;
  minQuantityTickSize: number | string;
  baseDecimals: number;
  quoteDecimals: number;
}) => {
  priceDecimals: number;
  quantityDecimals: number;
};
//#endregion
//#region src/utils/address.d.ts
/**
 * Get injective address from Ethereum hex address
 *
 * @param ethAddress string
 * @returns string
 */
declare const getInjectiveAddress: (ethAddress: string) => string;
/**
 * Get ethereum address from injective bech32 address
 *
 * @param injectiveAddress string
 * @returns string
 */
declare const getEthereumAddress: (injectiveAddress: string) => string;
/**
 * Get ethereum address from injective bech32 address
 *
 * @param injectiveAddress string
 * @returns string
 */
declare const getInjectiveAddressFromSubaccountId: (subaccountId: string) => string;
/**
 * Get default subaccount id from injective bech32 address
 *
 * @param injectiveAddress string
 * @returns string
 */
declare const getDefaultSubaccountId: (injectiveAddress: string) => string;
/**
 * Get subaccount id from injective bech32 address and an index (defaults to 0)
 * @param injectiveAddress string
 * @param nonce number
 * @returns string
 */
declare const getSubaccountId: (injectiveAddress: string, nonce?: number) => string;
/** @deprecated - use getEthereumAddress */
declare const getAddressFromInjectiveAddress: (address: string) => string;
/**
 * Convert Ethereum address to checksummed format (EIP-55)
 * @param ethAddress - Ethereum address (with or without 0x prefix)
 * @returns Checksummed Ethereum address
 */
declare const getChecksumAddress: (ethAddress: string) => string;
/**
 * Check if address is a CW20 contract address
 * @param address - Address to check
 * @returns True if address is a CW20 contract address
 */
declare const isCw20ContractAddress: (address: string) => boolean;
/**
 * Add 0x prefix to hex string if not present
 * @param hex - Hex string
 * @returns Hex string with 0x prefix
 */
declare const addHexPrefix: (hex: string) => string;
/**
 * Remove 0x prefix from hex string if present
 * @param hex - Hex string
 * @returns Hex string without 0x prefix
 */
declare const removeHexPrefix: (hex: string) => string;
//#endregion
//#region src/utils/encoding.d.ts
/**
 * Encoding/decoding utilities using industry-standard libraries
 *
 * Uses viem for hex encoding and @scure/base for base64 encoding
 * to ensure compatibility, better performance, and reduce bundle size.
 *
 * These libraries are already dependencies in the project and are
 * battle-tested by millions of developers.
 */
/**
 * Convert a hex string to Uint8Array
 * @param hex - Hex string (with or without 0x prefix)
 * @returns Uint8Array
 * @throws Error if hex string is invalid
 */
declare function hexToUint8Array(hex: string): Uint8Array;
/**
 * Convert a Uint8Array to hex string
 * @param arr - Uint8Array to convert
 * @returns Hex string (without 0x prefix)
 */
declare function uint8ArrayToHex(arr: Uint8Array): string;
/**
 * Convert a base64 string to Uint8Array
 * @param base64String - Base64 encoded string
 * @returns Uint8Array
 * @throws Error if base64 string is invalid
 */
declare function base64ToUint8Array(base64String: string): Uint8Array;
/**
 * Convert a Uint8Array to base64 string
 * @param arr - Uint8Array to convert
 * @returns Base64 encoded string
 */
declare function uint8ArrayToBase64(arr: Uint8Array): string;
/**
 * Convert a string to Uint8Array using UTF-8 encoding
 * @param str - String to encode
 * @returns Uint8Array
 */
declare function stringToUint8Array(str: string): Uint8Array;
/**
 * Convert a hex string to Uint8Array (buffer-like)
 * Handles hex strings with or without 0x prefix
 * @param hex - Hex string (with or without 0x prefix)
 * @returns Uint8Array
 */
declare function hexToBuff(hex: string): Uint8Array;
/**
 * Convert a hex string to base64 string
 * Handles hex strings with or without 0x prefix
 * @param hex - Hex string (with or without 0x prefix)
 * @returns Base64 encoded string
 */
declare function hexToBase64(hex: string): string;
/**
 * Convert a base64 string to UTF-8 string
 * @param base64String - Base64 encoded string
 * @returns Decoded UTF-8 string
 * @throws Error if base64 string is invalid
 */
declare function base64ToUtf8(base64String: string): string;
/**
 * Convert a string or Uint8Array to Uint8Array using UTF-8 encoding
 * If input is already Uint8Array, returns it as-is
 * @param str - String or Uint8Array to encode
 * @returns Uint8Array
 */
declare function fromUtf8(str: Uint8Array | string): Uint8Array;
/**
 * Convert a Uint8Array or string to string using UTF-8 decoding
 * If input is already a string, returns it as-is
 * @param data - Uint8Array or string to decode
 * @returns Decoded string
 */
declare function toUtf8(data: Uint8Array | string): string;
/**
 * Convert a Uint8Array, string, null, or undefined to string using UTF-8 decoding
 * More robust version that handles null/undefined gracefully
 * @param string - Uint8Array, string, null, or undefined to decode
 * @returns Decoded string (empty string if input is null/undefined)
 */
declare function uint8ArrayToString(string: string | Uint8Array | null | undefined): string;
/**
 * Convert binary data (string or Uint8Array) to base64 string
 * If input is already a string, returns it as-is
 * @param data - String or Uint8Array to encode
 * @returns Base64 encoded string
 */
declare function binaryToBase64(data: string | Uint8Array): string;
/**
 * Convert a JSON object to base64 string
 * @param data - JSON object to encode
 * @returns Base64 encoded string
 */
declare function toBase64(data: Record<string, any>): string;
/**
 * Convert a base64 string to JSON object
 * @param payload - Base64 encoded string
 * @returns Decoded JSON object
 * @throws Error if base64 string is invalid or contains invalid JSON
 */
declare function fromBase64(payload: string): Record<string, any>;
/**
 * Concatenate multiple Uint8Arrays into a single Uint8Array
 * Replacement for Buffer.concat()
 * @param arrays - Array of Uint8Arrays to concatenate
 * @returns Concatenated Uint8Array
 */
declare function concatUint8Arrays(arrays: Uint8Array[]): Uint8Array;
//#endregion
//#region src/utils/constants.d.ts
declare const BECH32_PUBKEY_ACC_PREFIX = "injpub";
declare const BECH32_PUBKEY_VAL_PREFIX = "injvaloperpub";
declare const BECH32_PUBKEY_CONS_PREFIX = "injvalconspub";
declare const BECH32_ADDR_ACC_PREFIX = "inj";
declare const BECH32_ADDR_VAL_PREFIX = "injvaloper";
declare const BECH32_ADDR_CONS_PREFIX = "injvalcons";
declare const DEFAULT_DERIVATION_PATH = "m/44'/60'/0'/0/0";
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+indexer-proto-ts-v2@1.17.6/node_modules/@injectivelabs/indexer-proto-ts-v2/esm/generated/injective_accounts_rpc_pb.d.ts
/**
 * @generated from protobuf message injective_accounts_rpc.PortfolioResponse
 */
interface PortfolioResponse$1 {
  /**
   * The portfolio of this account
   *
   * @generated from protobuf field: injective_accounts_rpc.AccountPortfolio portfolio = 1
   */
  portfolio?: AccountPortfolio$1;
}
/**
 * @generated from protobuf message injective_accounts_rpc.AccountPortfolio
 */
interface AccountPortfolio$1 {
  /**
   * The account's portfolio value in USD.
   *
   * @generated from protobuf field: string portfolio_value = 1
   */
  portfolioValue: string;
  /**
   * The account's available balance value in USD.
   *
   * @generated from protobuf field: string available_balance = 2
   */
  availableBalance: string;
  /**
   * The account's locked balance value in USD.
   *
   * @generated from protobuf field: string locked_balance = 3
   */
  lockedBalance: string;
  /**
   * The account's total unrealized PnL value in USD.
   *
   * @generated from protobuf field: string unrealized_pnl = 4
   */
  unrealizedPnl: string;
  /**
   * List of all subaccounts' portfolio
   *
   * @generated from protobuf field: repeated injective_accounts_rpc.SubaccountPortfolio subaccounts = 5
   */
  subaccounts: SubaccountPortfolio$1[];
}
/**
 * @generated from protobuf message injective_accounts_rpc.SubaccountPortfolio
 */
interface SubaccountPortfolio$1 {
  /**
   * The ID of this subaccount
   *
   * @generated from protobuf field: string subaccount_id = 1
   */
  subaccountId: string;
  /**
   * The subaccount's available balance value in USD.
   *
   * @generated from protobuf field: string available_balance = 2
   */
  availableBalance: string;
  /**
   * The subaccount's locked balance value in USD.
   *
   * @generated from protobuf field: string locked_balance = 3
   */
  lockedBalance: string;
  /**
   * The subaccount's total unrealized PnL value in USD.
   *
   * @generated from protobuf field: string unrealized_pnl = 4
   */
  unrealizedPnl: string;
}
/**
 * @generated from protobuf message injective_accounts_rpc.OrderStatesResponse
 */
interface OrderStatesResponse {
  /**
   * List of the spot order state records
   *
   * @generated from protobuf field: repeated injective_accounts_rpc.OrderStateRecord spot_order_states = 1
   */
  spotOrderStates: OrderStateRecord[];
  /**
   * List of the derivative order state records
   *
   * @generated from protobuf field: repeated injective_accounts_rpc.OrderStateRecord derivative_order_states = 2
   */
  derivativeOrderStates: OrderStateRecord[];
}
/**
 * @generated from protobuf message injective_accounts_rpc.OrderStateRecord
 */
interface OrderStateRecord {
  /**
   * Hash of the order
   *
   * @generated from protobuf field: string order_hash = 1
   */
  orderHash: string;
  /**
   * The subaccountId that this order belongs to
   *
   * @generated from protobuf field: string subaccount_id = 2
   */
  subaccountId: string;
  /**
   * The Market ID of the order
   *
   * @generated from protobuf field: string market_id = 3
   */
  marketId: string;
  /**
   * The type of the order
   *
   * @generated from protobuf field: string order_type = 4
   */
  orderType: string;
  /**
   * The side of the order
   *
   * @generated from protobuf field: string order_side = 5
   */
  orderSide: string;
  /**
   * The state (status) of the order
   *
   * @generated from protobuf field: string state = 6
   */
  state: string;
  /**
   * The filled quantity of the order
   *
   * @generated from protobuf field: string quantity_filled = 7
   */
  quantityFilled: string;
  /**
   * The filled quantity of the order
   *
   * @generated from protobuf field: string quantity_remaining = 8
   */
  quantityRemaining: string;
  /**
   * Order committed timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 created_at = 9
   */
  createdAt: bigint;
  /**
   * Order updated timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 updated_at = 10
   */
  updatedAt: bigint;
  /**
   * Order prices
   *
   * @generated from protobuf field: string price = 11
   */
  price: string;
  /**
   * Margin for derivative order
   *
   * @generated from protobuf field: string margin = 12
   */
  margin: string;
}
/**
 * @generated from protobuf message injective_accounts_rpc.SubaccountBalancesListResponse
 */
interface SubaccountBalancesListResponse {
  /**
   * List of subaccount balances
   *
   * @generated from protobuf field: repeated injective_accounts_rpc.SubaccountBalance balances = 1
   */
  balances: SubaccountBalance$2[];
}
/**
 * @generated from protobuf message injective_accounts_rpc.SubaccountBalance
 */
interface SubaccountBalance$2 {
  /**
   * Related subaccount ID
   *
   * @generated from protobuf field: string subaccount_id = 1
   */
  subaccountId: string;
  /**
   * Account address, owner of this subaccount
   *
   * @generated from protobuf field: string account_address = 2
   */
  accountAddress: string;
  /**
   * Coin denom on the chain.
   *
   * @generated from protobuf field: string denom = 3
   */
  denom: string;
  /**
   * @generated from protobuf field: injective_accounts_rpc.SubaccountDeposit deposit = 4
   */
  deposit?: SubaccountDeposit$2;
}
/**
 * @generated from protobuf message injective_accounts_rpc.SubaccountDeposit
 */
interface SubaccountDeposit$2 {
  /**
   * @generated from protobuf field: string total_balance = 1
   */
  totalBalance: string;
  /**
   * @generated from protobuf field: string available_balance = 2
   */
  availableBalance: string;
  /**
   * @generated from protobuf field: string total_balance_usd = 3
   */
  totalBalanceUsd: string;
  /**
   * @generated from protobuf field: string available_balance_usd = 4
   */
  availableBalanceUsd: string;
}
/**
 * @generated from protobuf message injective_accounts_rpc.SubaccountBalanceEndpointResponse
 */
interface SubaccountBalanceEndpointResponse {
  /**
   * Subaccount balance
   *
   * @generated from protobuf field: injective_accounts_rpc.SubaccountBalance balance = 1
   */
  balance?: SubaccountBalance$2;
}
/**
 * @generated from protobuf message injective_accounts_rpc.StreamSubaccountBalanceResponse
 */
interface StreamSubaccountBalanceResponse {
  /**
   * Subaccount balance
   *
   * @generated from protobuf field: injective_accounts_rpc.SubaccountBalance balance = 1
   */
  balance?: SubaccountBalance$2;
  /**
   * Operation timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 timestamp = 2
   */
  timestamp: bigint;
}
/**
 * @generated from protobuf message injective_accounts_rpc.SubaccountHistoryResponse
 */
interface SubaccountHistoryResponse {
  /**
   * List of subaccount transfers
   *
   * @generated from protobuf field: repeated injective_accounts_rpc.SubaccountBalanceTransfer transfers = 1
   */
  transfers: SubaccountBalanceTransfer[];
  /**
   * @generated from protobuf field: injective_accounts_rpc.Paging paging = 2
   */
  paging?: Paging$6;
}
/**
 * @generated from protobuf message injective_accounts_rpc.SubaccountBalanceTransfer
 */
interface SubaccountBalanceTransfer {
  /**
   * Type of the subaccount balance transfer
   *
   * @generated from protobuf field: string transfer_type = 1
   */
  transferType: string;
  /**
   * Subaccount ID of the sending side
   *
   * @generated from protobuf field: string src_subaccount_id = 2
   */
  srcSubaccountId: string;
  /**
   * Account address of the sending side
   *
   * @generated from protobuf field: string src_account_address = 3
   */
  srcAccountAddress: string;
  /**
   * Subaccount ID of the receiving side
   *
   * @generated from protobuf field: string dst_subaccount_id = 4
   */
  dstSubaccountId: string;
  /**
   * Account address of the receiving side
   *
   * @generated from protobuf field: string dst_account_address = 5
   */
  dstAccountAddress: string;
  /**
   * Coin amount of the transfer
   *
   * @generated from protobuf field: injective_accounts_rpc.CosmosCoin amount = 6
   */
  amount?: CosmosCoin$1;
  /**
   * Timestamp of the transfer in UNIX millis
   *
   * @generated from protobuf field: sint64 executed_at = 7
   */
  executedAt: bigint;
}
/**
 * @generated from protobuf message injective_accounts_rpc.CosmosCoin
 */
interface CosmosCoin$1 {
  /**
   * Coin denominator
   *
   * @generated from protobuf field: string denom = 1
   */
  denom: string;
  /**
   * Coin amount (big int)
   *
   * @generated from protobuf field: string amount = 2
   */
  amount: string;
}
/**
 * Paging defines the structure for required params for handling pagination
 *
 * @generated from protobuf message injective_accounts_rpc.Paging
 */
interface Paging$6 {
  /**
   * total number of txs saved in database
   *
   * @generated from protobuf field: sint64 total = 1
   */
  total: bigint;
  /**
   * can be either block height or index num
   *
   * @generated from protobuf field: sint32 from = 2
   */
  from: number;
  /**
   * can be either block height or index num
   *
   * @generated from protobuf field: sint32 to = 3
   */
  to: number;
  /**
   * count entries by subaccount, serving some places on helix
   *
   * @generated from protobuf field: sint64 count_by_subaccount = 4
   */
  countBySubaccount: bigint;
  /**
   * array of tokens to navigate to the next pages
   *
   * @generated from protobuf field: repeated string next = 5
   */
  next: string[];
}
/**
 * @generated from protobuf message injective_accounts_rpc.SubaccountOrderSummaryResponse
 */
interface SubaccountOrderSummaryResponse {
  /**
   * Total count of subaccount's spot orders in given market and direction
   *
   * @generated from protobuf field: sint64 spot_orders_total = 1
   */
  spotOrdersTotal: bigint;
  /**
   * Total count of subaccount's derivative orders in given market and direction
   *
   * @generated from protobuf field: sint64 derivative_orders_total = 2
   */
  derivativeOrdersTotal: bigint;
}
/**
 * @generated from protobuf message injective_accounts_rpc.RewardsResponse
 */
interface RewardsResponse {
  /**
   * The trading rewards distributed
   *
   * @generated from protobuf field: repeated injective_accounts_rpc.Reward rewards = 1
   */
  rewards: Reward[];
}
/**
 * @generated from protobuf message injective_accounts_rpc.Reward
 */
interface Reward {
  /**
   * Account address
   *
   * @generated from protobuf field: string account_address = 1
   */
  accountAddress: string;
  /**
   * Reward coins distributed
   *
   * @generated from protobuf field: repeated injective_accounts_rpc.Coin rewards = 2
   */
  rewards: Coin$7[];
  /**
   * Rewards distribution timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 distributed_at = 3
   */
  distributedAt: bigint;
}
/**
 * @generated from protobuf message injective_accounts_rpc.Coin
 */
interface Coin$7 {
  /**
   * Denom of the coin
   *
   * @generated from protobuf field: string denom = 1
   */
  denom: string;
  /**
   * @generated from protobuf field: string amount = 2
   */
  amount: string;
  /**
   * @generated from protobuf field: string usd_value = 3
   */
  usdValue: string;
}
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.PortfolioResponse
 */
declare const PortfolioResponse$1 = new PortfolioResponse$Type();
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.AccountPortfolio
 */
declare const AccountPortfolio$1 = new AccountPortfolio$Type();
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.SubaccountPortfolio
 */
declare const SubaccountPortfolio$1 = new SubaccountPortfolio$Type();
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.OrderStatesResponse
 */
declare const OrderStatesResponse = new OrderStatesResponse$Type();
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.OrderStateRecord
 */
declare const OrderStateRecord = new OrderStateRecord$Type();
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.SubaccountBalancesListResponse
 */
declare const SubaccountBalancesListResponse = new SubaccountBalancesListResponse$Type();
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.SubaccountBalance
 */
declare const SubaccountBalance$2 = new SubaccountBalance$Type();
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.SubaccountDeposit
 */
declare const SubaccountDeposit$2 = new SubaccountDeposit$Type();
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.SubaccountBalanceEndpointResponse
 */
declare const SubaccountBalanceEndpointResponse = new SubaccountBalanceEndpointResponse$Type();
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.StreamSubaccountBalanceResponse
 */
declare const StreamSubaccountBalanceResponse = new StreamSubaccountBalanceResponse$Type();
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.SubaccountHistoryResponse
 */
declare const SubaccountHistoryResponse = new SubaccountHistoryResponse$Type();
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.SubaccountBalanceTransfer
 */
declare const SubaccountBalanceTransfer = new SubaccountBalanceTransfer$Type();
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.CosmosCoin
 */
declare const CosmosCoin$1 = new CosmosCoin$Type();
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.Paging
 */
declare const Paging$6 = new Paging$Type();
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.SubaccountOrderSummaryResponse
 */
declare const SubaccountOrderSummaryResponse = new SubaccountOrderSummaryResponse$Type();
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.RewardsResponse
 */
declare const RewardsResponse = new RewardsResponse$Type();
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.Reward
 */
declare const Reward = new Reward$Type();
/**
 * @generated MessageType for protobuf message injective_accounts_rpc.Coin
 */
declare const Coin$7 = new Coin$Type();
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+indexer-proto-ts-v2@1.17.6/node_modules/@injectivelabs/indexer-proto-ts-v2/esm/generated/injective_explorer_rpc_pb.d.ts
/**
 * @generated from protobuf message injective_explorer_rpc.GetAccountTxsResponse
 */
interface GetAccountTxsResponse {
  /**
   * @generated from protobuf field: injective_explorer_rpc.Paging paging = 1
   */
  paging?: Paging$5;
  /**
   * @generated from protobuf field: repeated injective_explorer_rpc.TxDetailData data = 2
   */
  data: TxDetailData[];
}
/**
 * Paging defines the structure for required params for handling pagination
 *
 * @generated from protobuf message injective_explorer_rpc.Paging
 */
interface Paging$5 {
  /**
   * total number of txs saved in database
   *
   * @generated from protobuf field: sint64 total = 1
   */
  total: bigint;
  /**
   * can be either block height or index num
   *
   * @generated from protobuf field: sint32 from = 2
   */
  from: number;
  /**
   * can be either block height or index num
   *
   * @generated from protobuf field: sint32 to = 3
   */
  to: number;
  /**
   * count entries by subaccount, serving some places on helix
   *
   * @generated from protobuf field: sint64 count_by_subaccount = 4
   */
  countBySubaccount: bigint;
  /**
   * array of tokens to navigate to the next pages
   *
   * @generated from protobuf field: repeated string next = 5
   */
  next: string[];
}
/**
 * TxDetailData wraps tx data includes details information
 *
 * @generated from protobuf message injective_explorer_rpc.TxDetailData
 */
interface TxDetailData {
  /**
   * @generated from protobuf field: string id = 1
   */
  id: string;
  /**
   * @generated from protobuf field: uint64 block_number = 2
   */
  blockNumber: bigint;
  /**
   * @generated from protobuf field: string block_timestamp = 3
   */
  blockTimestamp: string;
  /**
   * @generated from protobuf field: string hash = 4
   */
  hash: string;
  /**
   * @generated from protobuf field: uint32 code = 5
   */
  code: number;
  /**
   * @generated from protobuf field: bytes data = 6
   */
  data: Uint8Array;
  /**
   * @generated from protobuf field: string info = 8
   */
  info: string;
  /**
   * @generated from protobuf field: sint64 gas_wanted = 9
   */
  gasWanted: bigint;
  /**
   * @generated from protobuf field: sint64 gas_used = 10
   */
  gasUsed: bigint;
  /**
   * @generated from protobuf field: injective_explorer_rpc.GasFee gas_fee = 11
   */
  gasFee?: GasFee$1;
  /**
   * @generated from protobuf field: string codespace = 12
   */
  codespace: string;
  /**
   * @generated from protobuf field: repeated injective_explorer_rpc.Event events = 13
   */
  events: Event[];
  /**
   * @generated from protobuf field: string tx_type = 14
   */
  txType: string;
  /**
   * @generated from protobuf field: bytes messages = 15
   */
  messages: Uint8Array;
  /**
   * @generated from protobuf field: repeated injective_explorer_rpc.Signature signatures = 16
   */
  signatures: Signature$1[];
  /**
   * @generated from protobuf field: string memo = 17
   */
  memo: string;
  /**
   * @generated from protobuf field: uint64 tx_number = 18
   */
  txNumber: bigint;
  /**
   * Block timestamp in unix milli
   *
   * @generated from protobuf field: uint64 block_unix_timestamp = 19
   */
  blockUnixTimestamp: bigint;
  /**
   * Transaction log indicating errors
   *
   * @generated from protobuf field: string error_log = 20
   */
  errorLog: string;
  /**
   * transaction event logs
   *
   * @generated from protobuf field: bytes logs = 21
   */
  logs: Uint8Array;
  /**
   * peggy bridge claim id, non-zero if tx contains MsgDepositClaim
   *
   * @generated from protobuf field: repeated sint64 claim_ids = 22
   */
  claimIds: bigint[];
}
/**
 * @generated from protobuf message injective_explorer_rpc.GasFee
 */
interface GasFee$1 {
  /**
   * @generated from protobuf field: repeated injective_explorer_rpc.CosmosCoin amount = 1
   */
  amount: CosmosCoin[];
  /**
   * @generated from protobuf field: uint64 gas_limit = 2
   */
  gasLimit: bigint;
  /**
   * @generated from protobuf field: string payer = 3
   */
  payer: string;
  /**
   * @generated from protobuf field: string granter = 4
   */
  granter: string;
}
/**
 * @generated from protobuf message injective_explorer_rpc.CosmosCoin
 */
interface CosmosCoin {
  /**
   * Coin denominator
   *
   * @generated from protobuf field: string denom = 1
   */
  denom: string;
  /**
   * Coin amount (big int)
   *
   * @generated from protobuf field: string amount = 2
   */
  amount: string;
}
/**
 * @generated from protobuf message injective_explorer_rpc.Event
 */
interface Event {
  /**
   * @generated from protobuf field: string type = 1
   */
  type: string;
  /**
   * @generated from protobuf field: map<string, string> attributes = 2
   */
  attributes: {
    [key: string]: string;
  };
}
/**
 * Signature wraps tx signature
 *
 * @generated from protobuf message injective_explorer_rpc.Signature
 */
interface Signature$1 {
  /**
   * @generated from protobuf field: string pubkey = 1
   */
  pubkey: string;
  /**
   * @generated from protobuf field: string address = 2
   */
  address: string;
  /**
   * @generated from protobuf field: uint64 sequence = 3
   */
  sequence: bigint;
  /**
   * @generated from protobuf field: string signature = 4
   */
  signature: string;
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetAccountTxsV2Response
 */
interface GetAccountTxsV2Response {
  /**
   * @generated from protobuf field: injective_explorer_rpc.Cursor paging = 1
   */
  paging?: Cursor;
  /**
   * @generated from protobuf field: repeated injective_explorer_rpc.TxDetailData data = 2
   */
  data: TxDetailData[];
}
/**
 * Cursor Pagination defines the structure for required params for handling
 * pagination
 *
 * @generated from protobuf message injective_explorer_rpc.Cursor
 */
interface Cursor {
  /**
   * array of tokens to navigate to the next pages
   *
   * @generated from protobuf field: repeated string next = 1
   */
  next: string[];
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetContractTxsV2Response
 */
interface GetContractTxsV2Response {
  /**
   * @generated from protobuf field: injective_explorer_rpc.Cursor paging = 1
   */
  paging?: Cursor;
  /**
   * @generated from protobuf field: repeated injective_explorer_rpc.TxDetailData data = 2
   */
  data: TxDetailData[];
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetBlocksResponse
 */
interface GetBlocksResponse {
  /**
   * @generated from protobuf field: injective_explorer_rpc.Paging paging = 1
   */
  paging?: Paging$5;
  /**
   * @generated from protobuf field: repeated injective_explorer_rpc.BlockInfo data = 2
   */
  data: BlockInfo[];
}
/**
 * @generated from protobuf message injective_explorer_rpc.BlockInfo
 */
interface BlockInfo {
  /**
   * @generated from protobuf field: uint64 height = 1
   */
  height: bigint;
  /**
   * @generated from protobuf field: string proposer = 2
   */
  proposer: string;
  /**
   * @generated from protobuf field: string moniker = 3
   */
  moniker: string;
  /**
   * @generated from protobuf field: string block_hash = 4
   */
  blockHash: string;
  /**
   * @generated from protobuf field: string parent_hash = 5
   */
  parentHash: string;
  /**
   * @generated from protobuf field: sint64 num_pre_commits = 6
   */
  numPreCommits: bigint;
  /**
   * @generated from protobuf field: sint64 num_txs = 7
   */
  numTxs: bigint;
  /**
   * @generated from protobuf field: repeated injective_explorer_rpc.TxDataRPC txs = 8
   */
  txs: TxDataRPC[];
  /**
   * @generated from protobuf field: string timestamp = 9
   */
  timestamp: string;
  /**
   * Block timestamp in unix milli
   *
   * @generated from protobuf field: uint64 block_unix_timestamp = 10
   */
  blockUnixTimestamp: bigint;
}
/**
 * TxData wraps tx data
 *
 * @generated from protobuf message injective_explorer_rpc.TxDataRPC
 */
interface TxDataRPC {
  /**
   * @generated from protobuf field: string id = 1
   */
  id: string;
  /**
   * @generated from protobuf field: uint64 block_number = 2
   */
  blockNumber: bigint;
  /**
   * @generated from protobuf field: string block_timestamp = 3
   */
  blockTimestamp: string;
  /**
   * @generated from protobuf field: string hash = 4
   */
  hash: string;
  /**
   * @generated from protobuf field: string codespace = 5
   */
  codespace: string;
  /**
   * @generated from protobuf field: string messages = 6
   */
  messages: string;
  /**
   * @generated from protobuf field: uint64 tx_number = 7
   */
  txNumber: bigint;
  /**
   * Transaction log indicating errors
   *
   * @generated from protobuf field: string error_log = 8
   */
  errorLog: string;
  /**
   * @generated from protobuf field: uint32 code = 9
   */
  code: number;
  /**
   * peggy bridge claim id, non-zero if tx contains MsgDepositClaim
   *
   * @generated from protobuf field: repeated sint64 claim_ids = 10
   */
  claimIds: bigint[];
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetBlocksV2Response
 */
interface GetBlocksV2Response {
  /**
   * @generated from protobuf field: injective_explorer_rpc.Cursor paging = 1
   */
  paging?: Cursor;
  /**
   * @generated from protobuf field: repeated injective_explorer_rpc.BlockInfo data = 2
   */
  data: BlockInfo[];
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetBlockResponse
 */
interface GetBlockResponse {
  /**
   * Status of the response.
   *
   * @generated from protobuf field: string s = 1
   */
  s: string;
  /**
   * Error message.
   *
   * @generated from protobuf field: string errmsg = 2
   */
  errmsg: string;
  /**
   * @generated from protobuf field: injective_explorer_rpc.BlockDetailInfo data = 3
   */
  data?: BlockDetailInfo;
}
/**
 * @generated from protobuf message injective_explorer_rpc.BlockDetailInfo
 */
interface BlockDetailInfo {
  /**
   * @generated from protobuf field: uint64 height = 1
   */
  height: bigint;
  /**
   * @generated from protobuf field: string proposer = 2
   */
  proposer: string;
  /**
   * @generated from protobuf field: string moniker = 3
   */
  moniker: string;
  /**
   * @generated from protobuf field: string block_hash = 4
   */
  blockHash: string;
  /**
   * @generated from protobuf field: string parent_hash = 5
   */
  parentHash: string;
  /**
   * @generated from protobuf field: sint64 num_pre_commits = 6
   */
  numPreCommits: bigint;
  /**
   * @generated from protobuf field: sint64 num_txs = 7
   */
  numTxs: bigint;
  /**
   * @generated from protobuf field: sint64 total_txs = 8
   */
  totalTxs: bigint;
  /**
   * @generated from protobuf field: repeated injective_explorer_rpc.TxData txs = 9
   */
  txs: TxData[];
  /**
   * @generated from protobuf field: string timestamp = 10
   */
  timestamp: string;
  /**
   * Block timestamp in unix milli
   *
   * @generated from protobuf field: uint64 block_unix_timestamp = 11
   */
  blockUnixTimestamp: bigint;
}
/**
 * TxData wraps tx data
 *
 * @generated from protobuf message injective_explorer_rpc.TxData
 */
interface TxData {
  /**
   * @generated from protobuf field: string id = 1
   */
  id: string;
  /**
   * @generated from protobuf field: uint64 block_number = 2
   */
  blockNumber: bigint;
  /**
   * @generated from protobuf field: string block_timestamp = 3
   */
  blockTimestamp: string;
  /**
   * @generated from protobuf field: string hash = 4
   */
  hash: string;
  /**
   * @generated from protobuf field: string codespace = 5
   */
  codespace: string;
  /**
   * @generated from protobuf field: bytes messages = 6
   */
  messages: Uint8Array;
  /**
   * @generated from protobuf field: uint64 tx_number = 7
   */
  txNumber: bigint;
  /**
   * Transaction log indicating errors
   *
   * @generated from protobuf field: string error_log = 8
   */
  errorLog: string;
  /**
   * @generated from protobuf field: uint32 code = 9
   */
  code: number;
  /**
   * @generated from protobuf field: bytes tx_msg_types = 10
   */
  txMsgTypes: Uint8Array;
  /**
   * transaction event logs
   *
   * @generated from protobuf field: bytes logs = 11
   */
  logs: Uint8Array;
  /**
   * peggy bridge claim id, non-zero if tx contains MsgDepositClaim
   *
   * @generated from protobuf field: repeated sint64 claim_ids = 12
   */
  claimIds: bigint[];
  /**
   * @generated from protobuf field: repeated injective_explorer_rpc.Signature signatures = 13
   */
  signatures: Signature$1[];
  /**
   * Block timestamp in unix milli
   *
   * @generated from protobuf field: uint64 block_unix_timestamp = 14
   */
  blockUnixTimestamp: bigint;
  /**
   * @generated from protobuf field: string ethereum_tx_hash_hex = 15
   */
  ethereumTxHashHex: string;
}
/**
 * Validator defines the structure for validator information.
 *
 * @generated from protobuf message injective_explorer_rpc.Validator
 */
interface Validator$2 {
  /**
   * @generated from protobuf field: string id = 1
   */
  id: string;
  /**
   * @generated from protobuf field: string moniker = 2
   */
  moniker: string;
  /**
   * @generated from protobuf field: string operator_address = 3
   */
  operatorAddress: string;
  /**
   * @generated from protobuf field: string consensus_address = 4
   */
  consensusAddress: string;
  /**
   * @generated from protobuf field: bool jailed = 5
   */
  jailed: boolean;
  /**
   * @generated from protobuf field: sint32 status = 6
   */
  status: number;
  /**
   * @generated from protobuf field: string tokens = 7
   */
  tokens: string;
  /**
   * @generated from protobuf field: string delegator_shares = 8
   */
  delegatorShares: string;
  /**
   * @generated from protobuf field: injective_explorer_rpc.ValidatorDescription description = 9
   */
  description?: ValidatorDescription$1;
  /**
   * @generated from protobuf field: sint64 unbonding_height = 10
   */
  unbondingHeight: bigint;
  /**
   * @generated from protobuf field: string unbonding_time = 11
   */
  unbondingTime: string;
  /**
   * @generated from protobuf field: string commission_rate = 12
   */
  commissionRate: string;
  /**
   * @generated from protobuf field: string commission_max_rate = 13
   */
  commissionMaxRate: string;
  /**
   * @generated from protobuf field: string commission_max_change_rate = 14
   */
  commissionMaxChangeRate: string;
  /**
   * @generated from protobuf field: string commission_update_time = 15
   */
  commissionUpdateTime: string;
  /**
   * @generated from protobuf field: uint64 proposed = 16
   */
  proposed: bigint;
  /**
   * @generated from protobuf field: uint64 signed = 17
   */
  signed: bigint;
  /**
   * @generated from protobuf field: uint64 missed = 18
   */
  missed: bigint;
  /**
   * @generated from protobuf field: string timestamp = 19
   */
  timestamp: string;
  /**
   * @generated from protobuf field: repeated injective_explorer_rpc.ValidatorUptime uptimes = 20
   */
  uptimes: ValidatorUptime$1[];
  /**
   * @generated from protobuf field: repeated injective_explorer_rpc.SlashingEvent slashing_events = 21
   */
  slashingEvents: SlashingEvent[];
  /**
   * uptime percentage base on latest 10k block
   *
   * @generated from protobuf field: double uptime_percentage = 22
   */
  uptimePercentage: number;
  /**
   * URL of the validator logo
   *
   * @generated from protobuf field: string image_url = 23
   */
  imageUrl: string;
}
/**
 * @generated from protobuf message injective_explorer_rpc.ValidatorDescription
 */
interface ValidatorDescription$1 {
  /**
   * @generated from protobuf field: string moniker = 1
   */
  moniker: string;
  /**
   * @generated from protobuf field: string identity = 2
   */
  identity: string;
  /**
   * @generated from protobuf field: string website = 3
   */
  website: string;
  /**
   * @generated from protobuf field: string security_contact = 4
   */
  securityContact: string;
  /**
   * @generated from protobuf field: string details = 5
   */
  details: string;
  /**
   * @generated from protobuf field: string image_url = 6
   */
  imageUrl: string;
}
/**
 * @generated from protobuf message injective_explorer_rpc.ValidatorUptime
 */
interface ValidatorUptime$1 {
  /**
   * @generated from protobuf field: uint64 block_number = 1
   */
  blockNumber: bigint;
  /**
   * @generated from protobuf field: string status = 2
   */
  status: string;
}
/**
 * @generated from protobuf message injective_explorer_rpc.SlashingEvent
 */
interface SlashingEvent {
  /**
   * @generated from protobuf field: uint64 block_number = 1
   */
  blockNumber: bigint;
  /**
   * @generated from protobuf field: string block_timestamp = 2
   */
  blockTimestamp: string;
  /**
   * @generated from protobuf field: string address = 3
   */
  address: string;
  /**
   * @generated from protobuf field: uint64 power = 4
   */
  power: bigint;
  /**
   * @generated from protobuf field: string reason = 5
   */
  reason: string;
  /**
   * @generated from protobuf field: string jailed = 6
   */
  jailed: string;
  /**
   * @generated from protobuf field: uint64 missed_blocks = 7
   */
  missedBlocks: bigint;
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetValidatorResponse
 */
interface GetValidatorResponse {
  /**
   * Status of the response.
   *
   * @generated from protobuf field: string s = 1
   */
  s: string;
  /**
   * Error message.
   *
   * @generated from protobuf field: string errmsg = 2
   */
  errmsg: string;
  /**
   * @generated from protobuf field: injective_explorer_rpc.Validator data = 3
   */
  data?: Validator$2;
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetValidatorUptimeResponse
 */
interface GetValidatorUptimeResponse {
  /**
   * Status of the response.
   *
   * @generated from protobuf field: string s = 1
   */
  s: string;
  /**
   * Error message.
   *
   * @generated from protobuf field: string errmsg = 2
   */
  errmsg: string;
  /**
   * @generated from protobuf field: repeated injective_explorer_rpc.ValidatorUptime data = 3
   */
  data: ValidatorUptime$1[];
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetTxsResponse
 */
interface GetTxsResponse {
  /**
   * @generated from protobuf field: injective_explorer_rpc.Paging paging = 1
   */
  paging?: Paging$5;
  /**
   * @generated from protobuf field: repeated injective_explorer_rpc.TxData data = 2
   */
  data: TxData[];
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetTxsV2Response
 */
interface GetTxsV2Response {
  /**
   * @generated from protobuf field: injective_explorer_rpc.Cursor paging = 1
   */
  paging?: Cursor;
  /**
   * @generated from protobuf field: repeated injective_explorer_rpc.TxData data = 2
   */
  data: TxData[];
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetTxByTxHashResponse
 */
interface GetTxByTxHashResponse {
  /**
   * Status of the response.
   *
   * @generated from protobuf field: string s = 1
   */
  s: string;
  /**
   * Error message.
   *
   * @generated from protobuf field: string errmsg = 2
   */
  errmsg: string;
  /**
   * @generated from protobuf field: injective_explorer_rpc.TxDetailData data = 3
   */
  data?: TxDetailData;
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetPeggyDepositTxsResponse
 */
interface GetPeggyDepositTxsResponse {
  /**
   * @generated from protobuf field: repeated injective_explorer_rpc.PeggyDepositTx field = 1
   */
  field: PeggyDepositTx$1[];
}
/**
 * PeggyDepositTx wraps tx data includes peggy deposit tx details information
 *
 * @generated from protobuf message injective_explorer_rpc.PeggyDepositTx
 */
interface PeggyDepositTx$1 {
  /**
   * Sender address of deposit request
   *
   * @generated from protobuf field: string sender = 1
   */
  sender: string;
  /**
   * Address of receiveer upon deposit
   *
   * @generated from protobuf field: string receiver = 2
   */
  receiver: string;
  /**
   * The event nonce of WithdrawalClaim event emitted by Ethereum chain upon
   * deposit
   *
   * @generated from protobuf field: uint64 event_nonce = 3
   */
  eventNonce: bigint;
  /**
   * The block height of WithdrawalClaim event emitted by Ethereum chain upon
   * deposit
   *
   * @generated from protobuf field: uint64 event_height = 4
   */
  eventHeight: bigint;
  /**
   * Amount of tokens being deposited
   *
   * @generated from protobuf field: string amount = 5
   */
  amount: string;
  /**
   * Denom of tokens being deposited
   *
   * @generated from protobuf field: string denom = 6
   */
  denom: string;
  /**
   * orchestratorAddress who created batch request
   *
   * @generated from protobuf field: string orchestrator_address = 7
   */
  orchestratorAddress: string;
  /**
   * @generated from protobuf field: string state = 8
   */
  state: string;
  /**
   * The claimType will be DepoistClaim for Deposits
   *
   * @generated from protobuf field: sint32 claim_type = 9
   */
  claimType: number;
  /**
   * @generated from protobuf field: repeated string tx_hashes = 10
   */
  txHashes: string[];
  /**
   * @generated from protobuf field: string created_at = 11
   */
  createdAt: string;
  /**
   * @generated from protobuf field: string updated_at = 12
   */
  updatedAt: string;
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetPeggyWithdrawalTxsResponse
 */
interface GetPeggyWithdrawalTxsResponse {
  /**
   * @generated from protobuf field: repeated injective_explorer_rpc.PeggyWithdrawalTx field = 1
   */
  field: PeggyWithdrawalTx$1[];
}
/**
 * PeggyWithdrawalTx wraps tx data includes peggy withdrawal tx details
 * information
 *
 * @generated from protobuf message injective_explorer_rpc.PeggyWithdrawalTx
 */
interface PeggyWithdrawalTx$1 {
  /**
   * Sender address of withdrawal request
   *
   * @generated from protobuf field: string sender = 1
   */
  sender: string;
  /**
   * Address of receiveer upon withdrawal
   *
   * @generated from protobuf field: string receiver = 2
   */
  receiver: string;
  /**
   * Amount of tokens being withdrawan
   *
   * @generated from protobuf field: string amount = 3
   */
  amount: string;
  /**
   * Denom of tokens being withdrawan
   *
   * @generated from protobuf field: string denom = 4
   */
  denom: string;
  /**
   * The bridge fee paid by sender for withdrawal
   *
   * @generated from protobuf field: string bridge_fee = 5
   */
  bridgeFee: string;
  /**
   * A auto incremented unique ID representing the withdrawal request
   *
   * @generated from protobuf field: uint64 outgoing_tx_id = 6
   */
  outgoingTxId: bigint;
  /**
   * The timestamp after which Batch request will be discarded if not processed
   * already
   *
   * @generated from protobuf field: uint64 batch_timeout = 7
   */
  batchTimeout: bigint;
  /**
   * A auto incremented unique ID representing the Withdrawal Batches
   *
   * @generated from protobuf field: uint64 batch_nonce = 8
   */
  batchNonce: bigint;
  /**
   * orchestratorAddress who created batch request
   *
   * @generated from protobuf field: string orchestrator_address = 9
   */
  orchestratorAddress: string;
  /**
   * The event nonce of WithdrawalClaim event emitted by Ethereum chain upon
   * batch withdrawal
   *
   * @generated from protobuf field: uint64 event_nonce = 10
   */
  eventNonce: bigint;
  /**
   * The block height of WithdrawalClaim event emitted by Ethereum chain upon
   * batch withdrawal
   *
   * @generated from protobuf field: uint64 event_height = 11
   */
  eventHeight: bigint;
  /**
   * @generated from protobuf field: string state = 12
   */
  state: string;
  /**
   * The claimType will be WithdrawalClaim for Batch Withdrawals
   *
   * @generated from protobuf field: sint32 claim_type = 13
   */
  claimType: number;
  /**
   * @generated from protobuf field: repeated string tx_hashes = 14
   */
  txHashes: string[];
  /**
   * @generated from protobuf field: string created_at = 15
   */
  createdAt: string;
  /**
   * @generated from protobuf field: string updated_at = 16
   */
  updatedAt: string;
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetIBCTransferTxsResponse
 */
interface GetIBCTransferTxsResponse {
  /**
   * @generated from protobuf field: repeated injective_explorer_rpc.IBCTransferTx field = 1
   */
  field: IBCTransferTx$1[];
}
/**
 * IBCTransferTx wraps tx data includes ibc transfer tx details information
 *
 * @generated from protobuf message injective_explorer_rpc.IBCTransferTx
 */
interface IBCTransferTx$1 {
  /**
   * the sender address
   *
   * @generated from protobuf field: string sender = 1
   */
  sender: string;
  /**
   * the recipient address on the destination chain
   *
   * @generated from protobuf field: string receiver = 2
   */
  receiver: string;
  /**
   * the port on which the packet will be sent
   *
   * @generated from protobuf field: string source_port = 3
   */
  sourcePort: string;
  /**
   * the channel by which the packet will be sent
   *
   * @generated from protobuf field: string source_channel = 4
   */
  sourceChannel: string;
  /**
   * identifies the port on the receiving chain
   *
   * @generated from protobuf field: string destination_port = 5
   */
  destinationPort: string;
  /**
   * identifies the channel end on the receiving chain
   *
   * @generated from protobuf field: string destination_channel = 6
   */
  destinationChannel: string;
  /**
   * transfer amount
   *
   * @generated from protobuf field: string amount = 7
   */
  amount: string;
  /**
   * transafer denom
   *
   * @generated from protobuf field: string denom = 8
   */
  denom: string;
  /**
   * Timeout height relative to the current block height. The timeout is disabled
   * when set to 0
   *
   * @generated from protobuf field: string timeout_height = 9
   */
  timeoutHeight: string;
  /**
   * Timeout timestamp (in nanoseconds) relative to the current block timestamp
   *
   * @generated from protobuf field: uint64 timeout_timestamp = 10
   */
  timeoutTimestamp: bigint;
  /**
   * number corresponds to the order of sends and receives, where a Packet with
   * an earlier sequence number must be sent and received before a Packet with a
   * later sequence number
   *
   * @generated from protobuf field: uint64 packet_sequence = 11
   */
  packetSequence: bigint;
  /**
   * @generated from protobuf field: bytes data_hex = 12
   */
  dataHex: Uint8Array;
  /**
   * @generated from protobuf field: string state = 13
   */
  state: string;
  /**
   * it's injective chain tx hash array
   *
   * @generated from protobuf field: repeated string tx_hashes = 14
   */
  txHashes: string[];
  /**
   * @generated from protobuf field: string created_at = 15
   */
  createdAt: string;
  /**
   * @generated from protobuf field: string updated_at = 16
   */
  updatedAt: string;
}
/**
 * @generated from protobuf message injective_explorer_rpc.StreamTxsResponse
 */
interface StreamTxsResponse {
  /**
   * @generated from protobuf field: string id = 1
   */
  id: string;
  /**
   * @generated from protobuf field: uint64 block_number = 2
   */
  blockNumber: bigint;
  /**
   * @generated from protobuf field: string block_timestamp = 3
   */
  blockTimestamp: string;
  /**
   * @generated from protobuf field: string hash = 4
   */
  hash: string;
  /**
   * @generated from protobuf field: string codespace = 5
   */
  codespace: string;
  /**
   * @generated from protobuf field: string messages = 6
   */
  messages: string;
  /**
   * @generated from protobuf field: uint64 tx_number = 7
   */
  txNumber: bigint;
  /**
   * Transaction log indicating errors
   *
   * @generated from protobuf field: string error_log = 8
   */
  errorLog: string;
  /**
   * @generated from protobuf field: uint32 code = 9
   */
  code: number;
  /**
   * peggy bridge claim id, non-zero if tx contains MsgDepositClaim
   *
   * @generated from protobuf field: repeated sint64 claim_ids = 10
   */
  claimIds: bigint[];
}
/**
 * @generated from protobuf message injective_explorer_rpc.StreamBlocksResponse
 */
interface StreamBlocksResponse {
  /**
   * @generated from protobuf field: uint64 height = 1
   */
  height: bigint;
  /**
   * @generated from protobuf field: string proposer = 2
   */
  proposer: string;
  /**
   * @generated from protobuf field: string moniker = 3
   */
  moniker: string;
  /**
   * @generated from protobuf field: string block_hash = 4
   */
  blockHash: string;
  /**
   * @generated from protobuf field: string parent_hash = 5
   */
  parentHash: string;
  /**
   * @generated from protobuf field: sint64 num_pre_commits = 6
   */
  numPreCommits: bigint;
  /**
   * @generated from protobuf field: sint64 num_txs = 7
   */
  numTxs: bigint;
  /**
   * @generated from protobuf field: repeated injective_explorer_rpc.TxDataRPC txs = 8
   */
  txs: TxDataRPC[];
  /**
   * @generated from protobuf field: string timestamp = 9
   */
  timestamp: string;
  /**
   * Block timestamp in unix milli
   *
   * @generated from protobuf field: uint64 block_unix_timestamp = 10
   */
  blockUnixTimestamp: bigint;
}
/**
 * @generated from protobuf message injective_explorer_rpc.GetStatsResponse
 */
interface GetStatsResponse {
  /**
   * Total of unique addresses
   *
   * @generated from protobuf field: uint64 addresses = 1
   */
  addresses: bigint;
  /**
   * Total number of assets
   *
   * @generated from protobuf field: uint64 assets = 2
   */
  assets: bigint;
  /**
   * Total circulating supply of INJ
   *
   * @generated from protobuf field: uint64 inj_supply = 3
   */
  injSupply: bigint;
  /**
   * Avg of TX per second in the past 24hs
   *
   * @generated from protobuf field: uint64 txs_ps24_h = 4
   */
  txsPs24H: bigint;
  /**
   * Avg of TX per second in the 100 blocks
   *
   * @generated from protobuf field: uint64 txs_ps100_b = 5
   */
  txsPs100B: bigint;
  /**
   * Total number of TXs
   *
   * @generated from protobuf field: uint64 txs_total = 6
   */
  txsTotal: bigint;
  /**
   * Total number of TXs in the past 24hs
   *
   * @generated from protobuf field: uint64 txs24_h = 7
   */
  txs24H: bigint;
  /**
   * Total number of TXs in the past 30 days
   *
   * @generated from protobuf field: uint64 txs30_d = 8
   */
  txs30D: bigint;
  /**
   * Number of blocks produced in the past 24hs
   *
   * @generated from protobuf field: uint64 block_count24_h = 9
   */
  blockCount24H: bigint;
}
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetAccountTxsResponse
 */
declare const GetAccountTxsResponse = new GetAccountTxsResponse$Type();
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.Paging
 */
declare const Paging$5 = new Paging$Type();
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.TxDetailData
 */
declare const TxDetailData = new TxDetailData$Type();
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GasFee
 */
declare const GasFee$1 = new GasFee$Type();
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.CosmosCoin
 */
declare const CosmosCoin = new CosmosCoin$Type();
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.Event
 */
declare const Event = new Event$Type();
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.Signature
 */
declare const Signature$1 = new Signature$Type();
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetAccountTxsV2Response
 */
declare const GetAccountTxsV2Response = new GetAccountTxsV2Response$Type();
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.Cursor
 */
declare const Cursor = new Cursor$Type();
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetContractTxsV2Response
 */
declare const GetContractTxsV2Response = new GetContractTxsV2Response$Type();
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetBlocksResponse
 */
declare const GetBlocksResponse = new GetBlocksResponse$Type();
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.BlockInfo
 */
declare const BlockInfo = new BlockInfo$Type();
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.TxDataRPC
 */
declare const TxDataRPC = new TxDataRPC$Type();
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetBlocksV2Response
 */
declare const GetBlocksV2Response = new GetBlocksV2Response$Type();
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetBlockResponse
 */
declare const GetBlockResponse = new GetBlockResponse$Type();
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.BlockDetailInfo
 */
declare const BlockDetailInfo = new BlockDetailInfo$Type();
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.TxData
 */
declare const TxData = new TxData$Type();
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.Validator
 */
declare const Validator$2 = new Validator$Type();
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.ValidatorDescription
 */
declare const ValidatorDescription$1 = new ValidatorDescription$Type();
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.ValidatorUptime
 */
declare const ValidatorUptime$1 = new ValidatorUptime$Type();
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.SlashingEvent
 */
declare const SlashingEvent = new SlashingEvent$Type();
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetValidatorResponse
 */
declare const GetValidatorResponse = new GetValidatorResponse$Type();
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetValidatorUptimeResponse
 */
declare const GetValidatorUptimeResponse = new GetValidatorUptimeResponse$Type();
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetTxsResponse
 */
declare const GetTxsResponse = new GetTxsResponse$Type();
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetTxsV2Response
 */
declare const GetTxsV2Response = new GetTxsV2Response$Type();
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetTxByTxHashResponse
 */
declare const GetTxByTxHashResponse = new GetTxByTxHashResponse$Type();
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetPeggyDepositTxsResponse
 */
declare const GetPeggyDepositTxsResponse = new GetPeggyDepositTxsResponse$Type();
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.PeggyDepositTx
 */
declare const PeggyDepositTx$1 = new PeggyDepositTx$Type();
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetPeggyWithdrawalTxsResponse
 */
declare const GetPeggyWithdrawalTxsResponse = new GetPeggyWithdrawalTxsResponse$Type();
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.PeggyWithdrawalTx
 */
declare const PeggyWithdrawalTx$1 = new PeggyWithdrawalTx$Type();
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetIBCTransferTxsResponse
 */
declare const GetIBCTransferTxsResponse = new GetIBCTransferTxsResponse$Type();
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.IBCTransferTx
 */
declare const IBCTransferTx$1 = new IBCTransferTx$Type();
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.StreamTxsResponse
 */
declare const StreamTxsResponse = new StreamTxsResponse$Type();
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.StreamBlocksResponse
 */
declare const StreamBlocksResponse = new StreamBlocksResponse$Type();
/**
 * @generated MessageType for protobuf message injective_explorer_rpc.GetStatsResponse
 */
declare const GetStatsResponse = new GetStatsResponse$Type();
//#endregion
//#region src/utils/pagination.d.ts
/**
 * @deprecated Use ChainGrpcCommonTransformer.pageRequestToGrpcPageRequest instead
 */
declare const paginationRequestFromPagination: (pagination?: PaginationOption) => PageRequest | undefined;
declare const pageRequestToGrpcPageRequestV2: (pagination?: PaginationOption) => PageRequest | undefined;
/**
 * @deprecated Use ChainGrpcCommonTransformer.paginationUint8ArrayToString instead
 */
declare const paginationUint8ArrayToString: (key: any) => string;
/**
 * @deprecated Use ChainGrpcCommonTransformer.grpcPaginationToPagination instead
 */
declare const grpcPaginationToPagination: (pagination: PageResponse | undefined) => Pagination;
/**
 * @deprecated Use grpcPagingToPagingV2 instead (V1 proto package)
 */
declare const grpcPagingToPaging: (pagination: Paging$5 | undefined) => ExchangePagination;
/**
 * Converts gRPC Paging to ExchangePagination for V2 proto packages.
 * Handles both InjectiveAccountsRpcPb.Paging and InjectiveExplorerRpcPb.Paging types.
 * Supports bigint and string types for the total and countBySubaccount fields.
 */
declare const grpcPagingToPagingV2: (pagination: Paging$6 | Paging$5 | undefined) => ExchangePagination;
declare const fetchAllWithPagination: <T extends {
  pagination: PaginationOption | undefined;
} | PaginationOption | undefined, Q extends {
  pagination: Pagination;
}>(args: T, method: (args: T) => Promise<Q>, result?: Array<unknown>) => Promise<Q>;
//#endregion
//#region src/utils/transaction.d.ts
declare const recoverTypedSignaturePubKey: (data: TypedDataDefinition, signature: string) => Promise<string>;
//#endregion
//#region src/client/indexer/grpc/IndexerGrpcMitoApi.d.ts
/**
 * @category Indexer Grpc API
 */
declare class IndexerGrpcMitoApi extends BaseIndexerGrpcConsumer {
  protected module: string;
  private get client();
  fetchVault({
    contractAddress,
    slug
  }: {
    contractAddress?: string;
    slug?: string;
  }): Promise<MitoVault>;
  fetchVaults({
    limit,
    codeId,
    pageIndex
  }: {
    limit?: number;
    codeId?: string;
    pageIndex?: number;
  }): Promise<{
    vaults: MitoVault[];
    pagination?: MitoPagination;
  }>;
  fetchLpTokenPriceChart({
    to,
    from,
    vaultAddress
  }: {
    to?: string;
    from?: string;
    vaultAddress: string;
  }): Promise<MitoPriceSnapshot[]>;
  fetchTVLChartRequest({
    to,
    from,
    vaultAddress
  }: {
    to?: string;
    from?: string;
    vaultAddress: string;
  }): Promise<MitoPriceSnapshot[]>;
  fetchVaultsByHolderAddress({
    skip,
    limit,
    holderAddress,
    vaultAddress
  }: {
    skip?: number;
    limit?: number;
    holderAddress: string;
    vaultAddress?: string;
  }): Promise<{
    subscriptions: MitoSubscription[];
    pagination: MitoPagination | undefined;
  }>;
  fetchLPHolders({
    skip,
    limit,
    vaultAddress,
    stakingContractAddress
  }: {
    skip?: number;
    limit?: number;
    vaultAddress: string;
    stakingContractAddress: string;
  }): Promise<{
    holders: MitoHolders[];
    pagination: MitoPagination | undefined;
  }>;
  fetchHolderPortfolio({
    holderAddress,
    stakingContractAddress
  }: {
    holderAddress: string;
    stakingContractAddress: string;
  }): Promise<MitoPortfolio>;
  fetchLeaderboard(epochId?: number): Promise<MitoLeaderboard>;
  fetchTransferHistory({
    vault,
    account,
    limit,
    toNumber,
    fromNumber
  }: {
    vault?: string;
    account?: string;
    limit?: number;
    toNumber?: number;
    fromNumber?: number;
  }): Promise<{
    transfers: MitoTransfer[];
    pagination: MitoPagination | undefined;
  }>;
  fetchLeaderboardEpochs({
    limit,
    toEpochId,
    fromEpochId
  }: {
    limit?: number;
    toEpochId?: number;
    fromEpochId?: number;
  }): Promise<{
    epochs: MitoLeaderboardEpoch[];
    pagination: MitoPagination | undefined;
  }>;
  fetchStakingPools({
    staker,
    stakingContractAddress
  }: {
    staker?: string;
    stakingContractAddress: string;
  }): Promise<{
    pools: MitoStakingPool[];
    pagination: MitoPagination | undefined;
  }>;
  fetchStakingHistory({
    staker,
    toNumber,
    limit,
    fromNumber
  }?: {
    staker?: string;
    limit?: number;
    toNumber?: number;
    fromNumber?: number;
  }): Promise<{
    activities: {
      action: string;
      txHash: string;
      staker: string;
      vaultAddress: string;
      numberByAccount: number;
      timestamp: number;
      rewardedTokens: Coin$8[];
      stakeAmount: Coin$8 | undefined;
    }[];
    pagination: MitoPagination | undefined;
  }>;
  fetchStakingRewardsByAccount({
    staker,
    stakingContractAddress
  }: {
    staker: string;
    stakingContractAddress: string;
  }): Promise<{
    rewards: {
      apr: number;
      vaultName: string;
      vaultAddress: string;
      lockTimestamp: number;
      claimableRewards: Coin$8[];
      stakedAmount: Coin$8 | undefined;
      lockedAmount: Coin$8 | undefined;
    }[];
    pagination: MitoPagination | undefined;
  }>;
  fetchMissions({
    accountAddress
  }: {
    accountAddress: string;
  }): Promise<MitoMission[]>;
  fetchMissionLeaderboard(userAddress?: string): Promise<MitoMissionLeaderboard>;
  fetchIDO({
    contractAddress,
    accountAddress
  }: {
    contractAddress: string;
    accountAddress?: string;
  }): Promise<{
    ido: MitoIDO | undefined;
  }>;
  fetchIDOs({
    status,
    limit,
    toNumber,
    accountAddress,
    ownerAddress
  }?: {
    status?: string;
    limit?: number;
    toNumber?: number;
    accountAddress?: string;
    ownerAddress?: string;
  }): Promise<{
    idos: MitoIDO[];
    pagination: MitoPagination | undefined;
  }>;
  fetchIDOSubscribers({
    skip,
    limit,
    sortBy,
    contractAddress
  }: {
    skip?: number;
    limit?: number;
    sortBy?: string;
    contractAddress: string;
  }): Promise<{
    marketId: string;
    quoteDenom: string;
    subscribers: MitoIDOSubscriber[];
    pagination: MitoPagination | undefined;
    tokenInfo: MitoTokenInfo | undefined;
  }>;
  fetchIDOSubscription({
    contractAddress,
    accountAddress
  }: {
    contractAddress: string;
    accountAddress: string;
  }): Promise<{
    subscription: MitoIDOSubscription | undefined;
  }>;
  fetchIDOActivities({
    contractAddress,
    accountAddress,
    limit,
    toNumber
  }?: {
    contractAddress?: string;
    accountAddress?: string;
    limit?: number;
    toNumber?: string;
  }): Promise<{
    activities: MitoIDOSubscriptionActivity[];
    pagination: MitoPagination | undefined;
  }>;
  fetchIDOWhitelist({
    skip,
    limit,
    idoAddress
  }: {
    skip?: number;
    limit?: number;
    idoAddress: string;
  }): Promise<{
    idoAddress: string | undefined;
    accounts: MitoWhitelistAccount[];
    pagination: MitoPagination | undefined;
  }>;
  fetchClaimReferences({
    skip,
    limit,
    idoAddress,
    accountAddress
  }: {
    skip?: number;
    limit?: number;
    idoAddress: string;
    accountAddress: string;
  }): Promise<{
    claimReferences: MitoClaimReference[];
    pagination?: MitoPagination;
  }>;
}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+indexer-proto-ts-v2@1.17.6/node_modules/@injectivelabs/indexer-proto-ts-v2/esm/generated/injective_meta_rpc_pb.d.ts
/**
 * @generated from protobuf message injective_meta_rpc.PingResponse
 */
interface PingResponse {}
/**
 * @generated from protobuf message injective_meta_rpc.VersionResponse
 */
interface VersionResponse {
  /**
   * injective-exchange code version.
   *
   * @generated from protobuf field: string version = 1
   */
  version: string;
  /**
   * Additional build meta info.
   *
   * @generated from protobuf field: map<string, string> build = 2
   */
  build: {
    [key: string]: string;
  };
}
/**
 * @generated from protobuf message injective_meta_rpc.InfoResponse
 */
interface InfoResponse {
  /**
   * The original timestamp value in millis.
   *
   * @generated from protobuf field: sint64 timestamp = 1
   */
  timestamp: bigint;
  /**
   * UNIX time on the server in millis.
   *
   * @generated from protobuf field: sint64 server_time = 2
   */
  serverTime: bigint;
  /**
   * injective-exchange code version.
   *
   * @generated from protobuf field: string version = 3
   */
  version: string;
  /**
   * Additional build meta info.
   *
   * @generated from protobuf field: map<string, string> build = 4
   */
  build: {
    [key: string]: string;
  };
  /**
   * Server's location region
   *
   * @generated from protobuf field: string region = 5
   */
  region: string;
}
/**
 * @generated MessageType for protobuf message injective_meta_rpc.PingResponse
 */
declare const PingResponse = new PingResponse$Type();
/**
 * @generated MessageType for protobuf message injective_meta_rpc.VersionResponse
 */
declare const VersionResponse = new VersionResponse$Type();
/**
 * @generated MessageType for protobuf message injective_meta_rpc.InfoResponse
 */
declare const InfoResponse = new InfoResponse$Type();
//#endregion
//#region src/client/indexer/grpc/IndexerGrpcMetaApi.d.ts
/**
 * @category Indexer Grpc API
 */
declare class IndexerGrpcMetaApi extends BaseIndexerGrpcConsumer {
  protected module: string;
  private get client();
  fetchPing(): Promise<PingResponse>;
  fetchVersion(): Promise<VersionResponse>;
  fetchInfo(): Promise<InfoResponse>;
}
//#endregion
//#region src/client/indexer/grpc/IndexerGrpcSpotApi.d.ts
/**
 * @category Indexer Grpc API
 */
declare class IndexerGrpcSpotApi extends BaseIndexerGrpcConsumer {
  protected module: string;
  private get client();
  fetchMarkets(params?: {
    baseDenom?: string;
    marketStatus?: string;
    quoteDenom?: string;
    marketStatuses?: string[];
  }): Promise<SpotMarket[]>;
  fetchMarket(marketId: string): Promise<SpotMarket>;
  /** @deprecated - use fetchOrderbookV2 */
  fetchOrderbook(_marketId: string): Promise<void>;
  fetchOrders(params?: {
    marketId?: string;
    marketIds?: string[];
    subaccountId?: string;
    orderSide?: OrderSide;
    isConditional?: boolean;
    pagination?: PaginationOption;
    cid?: string;
    tradeId?: string;
  }): Promise<{
    orders: SpotLimitOrder[];
    pagination: ExchangePagination;
  }>;
  fetchOrderHistory(params?: {
    cid?: string;
    state?: OrderState;
    tradeId?: string;
    marketId?: string;
    marketIds?: string[];
    direction?: TradeDirection;
    orderTypes?: OrderSide[];
    pagination?: PaginationOption;
    isConditional?: boolean;
    executionTypes?: TradeExecutionType[];
    subaccountId?: string;
  }): Promise<{
    orderHistory: SpotOrderHistory[];
    pagination: ExchangePagination;
  }>;
  fetchTrades(params?: {
    endTime?: number;
    tradeId?: string;
    marketId?: string;
    startTime?: number;
    marketIds?: string[];
    subaccountId?: string;
    accountAddress?: string;
    direction?: TradeDirection;
    pagination?: PaginationOption;
    executionSide?: TradeExecutionSide;
    executionTypes?: TradeExecutionType[];
    cid?: string;
  }): Promise<{
    trades: SpotTrade[];
    pagination: ExchangePagination;
  }>;
  fetchSubaccountOrdersList(params?: {
    subaccountId?: string;
    marketId?: string;
    pagination?: PaginationOption;
  }): Promise<{
    orders: SpotLimitOrder[];
    pagination: ExchangePagination;
  }>;
  fetchSubaccountTradesList(params?: {
    subaccountId?: string;
    marketId?: string;
    direction?: TradeDirection;
    executionType?: TradeExecutionType;
    pagination?: PaginationOption;
  }): Promise<SpotTrade[]>;
  /** @deprecated - use fetchOrderbooksV2 */
  fetchOrderbooks(_marketIds: string[]): Promise<void>;
  fetchOrderbooksV2(marketIds: string[]): Promise<{
    marketId: string;
    orderbook: OrderbookWithSequence;
  }[]>;
  fetchOrderbookV2(marketId: string): Promise<OrderbookWithSequence>;
  fetchAtomicSwapHistory(params: {
    address: string;
    contractAddress: string;
    pagination?: PaginationOption;
  }): Promise<{
    swapHistory: AtomicSwap[];
    pagination: ExchangePagination;
  }>;
}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+indexer-proto-ts-v2@1.17.6/node_modules/@injectivelabs/indexer-proto-ts-v2/esm/generated/injective_oracle_rpc_pb.d.ts
/**
 * @generated from protobuf message injective_oracle_rpc.OracleListResponse
 */
interface OracleListResponse {
  /**
   * @generated from protobuf field: repeated injective_oracle_rpc.Oracle oracles = 1
   */
  oracles: Oracle$1[];
}
/**
 * @generated from protobuf message injective_oracle_rpc.Oracle
 */
interface Oracle$1 {
  /**
   * The symbol of the oracle asset.
   *
   * @generated from protobuf field: string symbol = 1
   */
  symbol: string;
  /**
   * Oracle base currency
   *
   * @generated from protobuf field: string base_symbol = 2
   */
  baseSymbol: string;
  /**
   * Oracle quote currency
   *
   * @generated from protobuf field: string quote_symbol = 3
   */
  quoteSymbol: string;
  /**
   * Oracle Type
   *
   * @generated from protobuf field: string oracle_type = 4
   */
  oracleType: string;
  /**
   * The price of the oracle asset
   *
   * @generated from protobuf field: string price = 5
   */
  price: string;
}
/**
 * @generated from protobuf message injective_oracle_rpc.PriceResponse
 */
interface PriceResponse {
  /**
   * The price of the oracle asset
   *
   * @generated from protobuf field: string price = 1
   */
  price: string;
}
/**
 * @generated from protobuf message injective_oracle_rpc.StreamPricesResponse
 */
interface StreamPricesResponse {
  /**
   * The price of the oracle asset
   *
   * @generated from protobuf field: string price = 1
   */
  price: string;
  /**
   * Operation timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 timestamp = 2
   */
  timestamp: bigint;
}
/**
 * @generated from protobuf message injective_oracle_rpc.StreamPricesByMarketsResponse
 */
interface StreamPricesByMarketsResponse {
  /**
   * The price of the oracle asset
   *
   * @generated from protobuf field: string price = 1
   */
  price: string;
  /**
   * Operation timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 timestamp = 2
   */
  timestamp: bigint;
  /**
   * marketID that the price has been updated
   *
   * @generated from protobuf field: string market_id = 3
   */
  marketId: string;
}
/**
 * @generated MessageType for protobuf message injective_oracle_rpc.OracleListResponse
 */
declare const OracleListResponse = new OracleListResponse$Type();
/**
 * @generated MessageType for protobuf message injective_oracle_rpc.Oracle
 */
declare const Oracle$1 = new Oracle$Type();
/**
 * @generated MessageType for protobuf message injective_oracle_rpc.PriceResponse
 */
declare const PriceResponse = new PriceResponse$Type();
/**
 * @generated MessageType for protobuf message injective_oracle_rpc.StreamPricesResponse
 */
declare const StreamPricesResponse = new StreamPricesResponse$Type();
/**
 * @generated MessageType for protobuf message injective_oracle_rpc.StreamPricesByMarketsResponse
 */
declare const StreamPricesByMarketsResponse = new StreamPricesByMarketsResponse$Type();
//#endregion
//#region src/client/indexer/grpc/IndexerGrpcOracleApi.d.ts
/**
 * @category Indexer Grpc API
 */
declare class IndexerGrpcOracleApi extends BaseIndexerGrpcConsumer {
  protected module: string;
  private get client();
  fetchOracleList(): Promise<Oracle[]>;
  fetchOraclePrice({
    baseSymbol,
    quoteSymbol,
    oracleScaleFactor,
    oracleType
  }: {
    baseSymbol: string;
    quoteSymbol: string;
    oracleType: string;
    oracleScaleFactor?: number;
  }): Promise<PriceResponse>;
  fetchOraclePriceNoThrow({
    baseSymbol,
    quoteSymbol,
    oracleScaleFactor,
    oracleType
  }: {
    baseSymbol: string;
    quoteSymbol: string;
    oracleType: string;
    oracleScaleFactor?: number;
  }): Promise<PriceResponse>;
}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+indexer-proto-ts-v2@1.17.6/node_modules/@injectivelabs/indexer-proto-ts-v2/esm/generated/injective_exchange_rpc_pb.d.ts
/**
 * @generated from protobuf message injective_exchange_rpc.PrepareTxResponse
 */
interface PrepareTxResponse {
  /**
   * EIP712-compatible message suitable for signing with eth_signTypedData_v4
   *
   * @generated from protobuf field: string data = 1
   */
  data: string;
  /**
   * Account tx sequence (nonce)
   *
   * @generated from protobuf field: uint64 sequence = 2
   */
  sequence: bigint;
  /**
   * Sign mode for the resulting tx
   *
   * @generated from protobuf field: string sign_mode = 3
   */
  signMode: string;
  /**
   * Specify proto-URL of a public key, which defines the signature format
   *
   * @generated from protobuf field: string pub_key_type = 4
   */
  pubKeyType: string;
  /**
   * Fee payer address provided by service
   *
   * @generated from protobuf field: string fee_payer = 5
   */
  feePayer: string;
  /**
   * Hex-encoded ethsecp256k1 signature bytes from fee payer
   *
   * @generated from protobuf field: string fee_payer_sig = 6
   */
  feePayerSig: string;
}
/**
 * @generated from protobuf message injective_exchange_rpc.PrepareEip712Response
 */
interface PrepareEip712Response {
  /**
   * EIP712-compatible message suitable for signing with eth_signTypedData_v4
   *
   * @generated from protobuf field: string data = 1
   */
  data: string;
}
/**
 * @generated from protobuf message injective_exchange_rpc.CosmosPubKey
 */
interface CosmosPubKey {
  /**
   * Pubkey type URL
   *
   * @generated from protobuf field: string type = 1
   */
  type: string;
  /**
   * Hex-encoded string of the public key
   *
   * @generated from protobuf field: string key = 2
   */
  key: string;
}
/**
 * @generated from protobuf message injective_exchange_rpc.BroadcastTxResponse
 */
interface BroadcastTxResponse {
  /**
   * Hex-encoded Tendermint transaction hash
   *
   * @generated from protobuf field: string tx_hash = 1
   */
  txHash: string;
  /**
   * The block height
   *
   * @generated from protobuf field: sint64 height = 2
   */
  height: bigint;
  /**
   * Tx index in the block
   *
   * @generated from protobuf field: uint32 index = 3
   */
  index: number;
  /**
   * Namespace for the resp code
   *
   * @generated from protobuf field: string codespace = 4
   */
  codespace: string;
  /**
   * Response code
   *
   * @generated from protobuf field: uint32 code = 5
   */
  code: number;
  /**
   * Result bytes, if any
   *
   * @generated from protobuf field: bytes data = 6
   */
  data: Uint8Array;
  /**
   * The output of the application's logger (raw string). May be
   * non-deterministic.
   *
   * @generated from protobuf field: string raw_log = 7
   */
  rawLog: string;
  /**
   * Time of the previous block.
   *
   * @generated from protobuf field: string timestamp = 8
   */
  timestamp: string;
}
/**
 * @generated from protobuf message injective_exchange_rpc.PrepareCosmosTxResponse
 */
interface PrepareCosmosTxResponse {
  /**
   * proto encoded tx
   *
   * @generated from protobuf field: bytes tx = 1
   */
  tx: Uint8Array;
  /**
   * Sign mode for the resulting tx
   *
   * @generated from protobuf field: string sign_mode = 2
   */
  signMode: string;
  /**
   * Specify proto-URL of a public key, which defines the signature format
   *
   * @generated from protobuf field: string pub_key_type = 3
   */
  pubKeyType: string;
  /**
   * Fee payer address provided by service
   *
   * @generated from protobuf field: string fee_payer = 4
   */
  feePayer: string;
  /**
   * Hex-encoded ethsecp256k1 signature bytes from fee payer
   *
   * @generated from protobuf field: string fee_payer_sig = 5
   */
  feePayerSig: string;
  /**
   * ethsecp256k1 feePayer pubkey
   *
   * @generated from protobuf field: injective_exchange_rpc.CosmosPubKey fee_payer_pub_key = 6
   */
  feePayerPubKey?: CosmosPubKey;
}
/**
 * @generated from protobuf message injective_exchange_rpc.BroadcastCosmosTxResponse
 */
interface BroadcastCosmosTxResponse {
  /**
   * Hex-encoded Tendermint transaction hash
   *
   * @generated from protobuf field: string tx_hash = 1
   */
  txHash: string;
  /**
   * The block height
   *
   * @generated from protobuf field: sint64 height = 2
   */
  height: bigint;
  /**
   * Tx index in the block
   *
   * @generated from protobuf field: uint32 index = 3
   */
  index: number;
  /**
   * Namespace for the resp code
   *
   * @generated from protobuf field: string codespace = 4
   */
  codespace: string;
  /**
   * Response code
   *
   * @generated from protobuf field: uint32 code = 5
   */
  code: number;
  /**
   * Result bytes, if any
   *
   * @generated from protobuf field: bytes data = 6
   */
  data: Uint8Array;
  /**
   * The output of the application's logger (raw string). May be
   * non-deterministic.
   *
   * @generated from protobuf field: string raw_log = 7
   */
  rawLog: string;
  /**
   * Time of the previous block.
   *
   * @generated from protobuf field: string timestamp = 8
   */
  timestamp: string;
}
/**
 * @generated from protobuf message injective_exchange_rpc.GetFeePayerResponse
 */
interface GetFeePayerResponse {
  /**
   * Fee payer address provided by service
   *
   * @generated from protobuf field: string fee_payer = 1
   */
  feePayer: string;
  /**
   * ethsecp256k1 feePayer pubkey
   *
   * @generated from protobuf field: injective_exchange_rpc.CosmosPubKey fee_payer_pub_key = 2
   */
  feePayerPubKey?: CosmosPubKey;
}
/**
 * @generated MessageType for protobuf message injective_exchange_rpc.PrepareTxResponse
 */
declare const PrepareTxResponse = new PrepareTxResponse$Type();
/**
 * @generated MessageType for protobuf message injective_exchange_rpc.PrepareEip712Response
 */
declare const PrepareEip712Response = new PrepareEip712Response$Type();
/**
 * @generated MessageType for protobuf message injective_exchange_rpc.CosmosPubKey
 */
declare const CosmosPubKey = new CosmosPubKey$Type();
/**
 * @generated MessageType for protobuf message injective_exchange_rpc.BroadcastTxResponse
 */
declare const BroadcastTxResponse = new BroadcastTxResponse$Type();
/**
 * @generated MessageType for protobuf message injective_exchange_rpc.PrepareCosmosTxResponse
 */
declare const PrepareCosmosTxResponse = new PrepareCosmosTxResponse$Type();
/**
 * @generated MessageType for protobuf message injective_exchange_rpc.BroadcastCosmosTxResponse
 */
declare const BroadcastCosmosTxResponse = new BroadcastCosmosTxResponse$Type();
/**
 * @generated MessageType for protobuf message injective_exchange_rpc.GetFeePayerResponse
 */
declare const GetFeePayerResponse = new GetFeePayerResponse$Type();
//#endregion
//#region src/client/indexer/grpc/IndexerGrpcTransactionApi.d.ts
interface PrepareTxArgs {
  address: AccountAddress;
  chainId: EvmChainId;
  message: any;
  estimateGas?: boolean;
  gasLimit?: number;
  memo?: string | number;
  timeoutHeight?: number;
  feeDenom?: string;
  feePrice?: string;
}
/**
 * @category Indexer Grpc API
 * @deprecated use IndexerGrpcWeb3GwApi
 */
declare class IndexerGrpcTransactionApi extends BaseIndexerGrpcConsumer {
  protected module: string;
  private get client();
  prepareTxRequest(args: PrepareTxArgs): Promise<PrepareTxResponse>;
  prepareExchangeTxRequest(args: PrepareTxArgs): Promise<PrepareTxResponse>;
  prepareCosmosTxRequest({
    memo,
    address,
    message,
    estimateGas,
    gasLimit,
    feeDenom,
    feePrice,
    timeoutHeight
  }: {
    address: string;
    message: any;
    estimateGas?: boolean;
    gasLimit?: number;
    memo?: string | number;
    timeoutHeight?: number;
    feeDenom?: string;
    feePrice?: string;
  }): Promise<PrepareCosmosTxResponse>;
  /**
   * Keep in mind that the transaction is just added
   * to the mempool, we need to query the transaction hash
   * if we want to ensure that the transaction is included
   * in the block
   */
  broadcastTxRequest({
    signature,
    chainId,
    message,
    txResponse
  }: {
    signature: string;
    chainId: EvmChainId;
    useCorrectEIP712Hash?: boolean;
    txResponse: PrepareTxResponse;
    message: Record<string, any>;
  }): Promise<BroadcastTxResponse>;
  /**
   * Keep in mind that the transaction is just added
   * to the mempool, we need to query the transaction hash
   * if we want to ensure that the transaction is included
   * in the block
   */
  broadcastCosmosTxRequest({
    address,
    signature,
    txRaw,
    pubKey
  }: {
    address: string;
    signature: string;
    txRaw: TxRaw;
    pubKey: {
      type: string;
      value: string;
    };
  }): Promise<BroadcastCosmosTxResponse>;
  fetchFeePayer(): Promise<GetFeePayerResponse>;
}
//#endregion
//#region src/client/indexer/grpc/IndexerGrpcWeb3GwApi.d.ts
/**
 * @category Indexer Grpc API
 */
declare class IndexerGrpcWeb3GwApi extends IndexerGrpcTransactionApi {
  protected module: string;
  prepareEip712Request({
    address,
    chainId,
    message,
    memo,
    sequence,
    accountNumber,
    estimateGas,
    gasLimit,
    feeDenom,
    feePrice,
    timeoutHeight,
    eip712Version
  }: {
    address: AccountAddress;
    chainId: EvmChainId;
    message: any;
    estimateGas?: boolean;
    gasLimit?: number;
    memo?: string | number;
    timeoutHeight?: number;
    feeDenom?: string;
    feePrice?: string;
    sequence?: number;
    accountNumber?: number;
    eip712Version?: string;
  }): Promise<PrepareEip712Response>;
}
//#endregion
//#region src/client/indexer/grpc/IndexerGrpcAccountApi.d.ts
/**
 * @category Indexer Grpc API
 */
declare class IndexerGrpcAccountApi extends BaseIndexerGrpcConsumer {
  protected module: string;
  private get client();
  /**
   * @deprecated - use IndexerGrpcAccountPortfolioApi.fetchPortfolio instead
   */
  fetchPortfolio(_address: string): Promise<void>;
  fetchRewards({
    address,
    epoch
  }: {
    address: string;
    epoch: number;
  }): Promise<TradingReward[]>;
  fetchSubaccountsList(address: string): Promise<string[]>;
  fetchSubaccountBalance(subaccountId: string, denom: string): Promise<SubaccountBalance>;
  fetchSubaccountBalancesList(subaccountId: string): Promise<SubaccountBalance[]>;
  fetchSubaccountHistory({
    subaccountId,
    denom,
    transferTypes,
    pagination
  }: {
    subaccountId: string;
    denom?: string;
    transferTypes?: string[];
    pagination?: PaginationOption;
  }): Promise<{
    transfers: SubaccountTransfer[];
    pagination: ExchangePagination;
  }>;
  fetchSubaccountOrderSummary({
    subaccountId,
    marketId,
    orderDirection
  }: {
    subaccountId: string;
    marketId?: string;
    orderDirection?: string;
  }): Promise<SubaccountOrderSummaryResponse>;
  fetchOrderStates(params?: {
    spotOrderHashes?: string[];
    derivativeOrderHashes?: string[];
  }): Promise<OrderStatesResponse>;
}
//#endregion
//#region src/client/indexer/grpc/IndexerGrpcAuctionApi.d.ts
/**
 * @category Indexer Grpc API
 */
declare class IndexerGrpcAuctionApi extends BaseIndexerGrpcConsumer {
  protected module: string;
  private get client();
  fetchAuction(round?: number): Promise<{
    auction: Auction;
    bids: IndexerAuctionBid[];
  }>;
  fetchAuctions(): Promise<Auction[]>;
  fetchInjBurnt(): Promise<number>;
  fetchAuctionsHistoryV2({
    token,
    endTime,
    perPage
  }: {
    token?: string;
    endTime?: string;
    perPage?: number;
  }): Promise<{
    auctions: AuctionV2[];
    next: string[];
  }>;
  fetchAuctionV2(round?: number | string): Promise<AuctionV2>;
  fetchAccountAuctionsV2({
    token,
    address,
    perPage
  }: {
    token?: string;
    address: string;
    perPage?: number;
  }): Promise<{
    auctions: AccountAuctionV2[];
    next: string[];
    total: bigint;
  }>;
  fetchAuctionStats(): Promise<AuctionsStats>;
  fetchAccountAuctionStatus({
    address,
    round
  }: {
    address: string;
    round?: string | number;
  }): Promise<AccountAuctionStatus>;
}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+indexer-proto-ts-v2@1.17.6/node_modules/@injectivelabs/indexer-proto-ts-v2/esm/generated/injective_trading_rpc_pb.d.ts
/**
 * @generated from protobuf message injective_trading_rpc.ListTradingStrategiesResponse
 */
interface ListTradingStrategiesResponse$1 {
  /**
   * The trading strategies
   *
   * @generated from protobuf field: repeated injective_trading_rpc.TradingStrategy strategies = 1
   */
  strategies: TradingStrategy$1[];
  /**
   * @generated from protobuf field: injective_trading_rpc.Paging paging = 2
   */
  paging?: Paging$4;
}
/**
 * @generated from protobuf message injective_trading_rpc.TradingStrategy
 */
interface TradingStrategy$1 {
  /**
   * @generated from protobuf field: string state = 1
   */
  state: string;
  /**
   * MarketId of the trading strategy
   *
   * @generated from protobuf field: string market_id = 2
   */
  marketId: string;
  /**
   * subaccount ID of the trading strategy
   *
   * @generated from protobuf field: string subaccount_id = 3
   */
  subaccountId: string;
  /**
   * Account address
   *
   * @generated from protobuf field: string account_address = 4
   */
  accountAddress: string;
  /**
   * Contract address
   *
   * @generated from protobuf field: string contract_address = 5
   */
  contractAddress: string;
  /**
   * Execution price of the trading strategy
   *
   * @generated from protobuf field: string execution_price = 6
   */
  executionPrice: string;
  /**
   * Base quantity of the trading strategy
   *
   * @generated from protobuf field: string base_quantity = 7
   */
  baseQuantity: string;
  /**
   * Quote quantity of the trading strategy
   *
   * @generated from protobuf field: string quote_quantity = 20
   */
  quoteQuantity: string;
  /**
   * Lower bound of the trading strategy
   *
   * @generated from protobuf field: string lower_bound = 8
   */
  lowerBound: string;
  /**
   * Upper bound of the trading strategy
   *
   * @generated from protobuf field: string upper_bound = 9
   */
  upperBound: string;
  /**
   * Stop loss limit of the trading strategy
   *
   * @generated from protobuf field: string stop_loss = 10
   */
  stopLoss: string;
  /**
   * Take profit limit of the trading strategy
   *
   * @generated from protobuf field: string take_profit = 11
   */
  takeProfit: string;
  /**
   * Swap fee of the trading strategy
   *
   * @generated from protobuf field: string swap_fee = 12
   */
  swapFee: string;
  /**
   * Base deposit at the time of closing the trading strategy
   *
   * @generated from protobuf field: string base_deposit = 17
   */
  baseDeposit: string;
  /**
   * Quote deposit at the time of closing the trading strategy
   *
   * @generated from protobuf field: string quote_deposit = 18
   */
  quoteDeposit: string;
  /**
   * Market mid price at the time of closing the trading strategy
   *
   * @generated from protobuf field: string market_mid_price = 19
   */
  marketMidPrice: string;
  /**
   * Subscription quote quantity of the trading strategy
   *
   * @generated from protobuf field: string subscription_quote_quantity = 21
   */
  subscriptionQuoteQuantity: string;
  /**
   * Subscription base quantity of the trading strategy
   *
   * @generated from protobuf field: string subscription_base_quantity = 22
   */
  subscriptionBaseQuantity: string;
  /**
   * Number of grid levels of the trading strategy
   *
   * @generated from protobuf field: string number_of_grid_levels = 23
   */
  numberOfGridLevels: string;
  /**
   * Indicates whether the trading strategy should exit with quote only
   *
   * @generated from protobuf field: bool should_exit_with_quote_only = 24
   */
  shouldExitWithQuoteOnly: boolean;
  /**
   * Indicates the reason for stopping the trading strategy
   *
   * @generated from protobuf field: string stop_reason = 25
   */
  stopReason: string;
  /**
   * Indicates whether the trading strategy is pending execution
   *
   * @generated from protobuf field: bool pending_execution = 26
   */
  pendingExecution: boolean;
  /**
   * Block height when the strategy was created.
   *
   * @generated from protobuf field: sint64 created_height = 13
   */
  createdHeight: bigint;
  /**
   * Block height when the strategy was removed.
   *
   * @generated from protobuf field: sint64 removed_height = 14
   */
  removedHeight: bigint;
  /**
   * UpdatedAt timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 created_at = 15
   */
  createdAt: bigint;
  /**
   * UpdatedAt timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 updated_at = 16
   */
  updatedAt: bigint;
  /**
   * Indicate how bot will convert funds (into base or quote or keep as is) after
   * strategy ended
   *
   * @generated from protobuf field: string exit_type = 27
   */
  exitType: string;
  /**
   * Exit config for stop loss
   *
   * @generated from protobuf field: injective_trading_rpc.ExitConfig stop_loss_config = 28
   */
  stopLossConfig?: ExitConfig;
  /**
   * Exit config for take profit
   *
   * @generated from protobuf field: injective_trading_rpc.ExitConfig take_profit_config = 29
   */
  takeProfitConfig?: ExitConfig;
  /**
   * Strategy type: arithmetic, geometric...
   *
   * @generated from protobuf field: string strategy_type = 30
   */
  strategyType: string;
  /**
   * Version of the contract
   *
   * @generated from protobuf field: string contract_version = 31
   */
  contractVersion: string;
  /**
   * Name of the contract
   *
   * @generated from protobuf field: string contract_name = 32
   */
  contractName: string;
  /**
   * Type of the market
   *
   * @generated from protobuf field: string market_type = 33
   */
  marketType: string;
  /**
   * lastExecutedAt timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 last_executed_at = 34
   */
  lastExecutedAt: bigint;
  /**
   * trailing up price
   *
   * @generated from protobuf field: string trail_up_price = 35
   */
  trailUpPrice: string;
  /**
   * trailing down price
   *
   * @generated from protobuf field: string trail_down_price = 36
   */
  trailDownPrice: string;
  /**
   * trailing up counter
   *
   * @generated from protobuf field: sint64 trail_up_counter = 37
   */
  trailUpCounter: bigint;
  /**
   * trailing down counter
   *
   * @generated from protobuf field: sint64 trail_down_counter = 38
   */
  trailDownCounter: bigint;
  /**
   * TVL of the trading strategy
   *
   * @generated from protobuf field: string tvl = 39
   */
  tvl: string;
  /**
   * PnL of the trading strategy
   *
   * @generated from protobuf field: string pnl = 40
   */
  pnl: string;
  /**
   * PnL percentage of the trading strategy
   *
   * @generated from protobuf field: string pnl_perc = 41
   */
  pnlPerc: string;
  /**
   * pnlUpdatedAt timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 pnl_updated_at = 42
   */
  pnlUpdatedAt: bigint;
  /**
   * Indicates the performance of the trading strategy
   *
   * @generated from protobuf field: string performance = 43
   */
  performance: string;
  /**
   * Return on investment of the trading strategy
   *
   * @generated from protobuf field: string roi = 44
   */
  roi: string;
  /**
   * Initial base price of the trading strategy from asset price service
   * Use strategyFinalData if available to have more accurate data
   *
   * @generated from protobuf field: string initial_base_price = 45
   */
  initialBasePrice: string;
  /**
   * Initial quote price of the trading strategy from asset price service
   * Use strategyFinalData if available to have more accurate data
   *
   * @generated from protobuf field: string initial_quote_price = 46
   */
  initialQuotePrice: string;
  /**
   * Current base price of the trading strategy from asset price service
   * Use strategyFinalData if available to have more accurate data
   *
   * @generated from protobuf field: string current_base_price = 47
   */
  currentBasePrice: string;
  /**
   * Current quote price of the trading strategy from asset price service
   * Use strategyFinalData if available to have more accurate data
   *
   * @generated from protobuf field: string current_quote_price = 48
   */
  currentQuotePrice: string;
  /**
   * Final base price of the trading strategy from asset price service
   * Use strategyFinalData if available to have more accurate data
   *
   * @generated from protobuf field: string final_base_price = 49
   */
  finalBasePrice: string;
  /**
   * Final quote price of the trading strategy from asset price service
   * Use strategyFinalData if available to have more accurate data
   *
   * @generated from protobuf field: string final_quote_price = 50
   */
  finalQuotePrice: string;
  /**
   * Final data of the trading strategy. This is present from contract v0.8.4.
   *
   * @generated from protobuf field: injective_trading_rpc.StrategyFinalData final_data = 51
   */
  finalData?: StrategyFinalData;
  /**
   * Margin ratio of the trading strategy
   *
   * @generated from protobuf field: string margin_ratio = 52
   */
  marginRatio: string;
  /**
   * Lower trailing bound of the trading strategy
   *
   * @generated from protobuf field: string lower_trailing_bound = 53
   */
  lowerTrailingBound: string;
  /**
   * Upper trailing bound of the trading strategy
   *
   * @generated from protobuf field: string upper_trailing_bound = 54
   */
  upperTrailingBound: string;
  /**
   * New upper bound of the trading strategy
   *
   * @generated from protobuf field: string new_upper_bound = 55
   */
  newUpperBound: string;
  /**
   * New lower bound of the trading strategy
   *
   * @generated from protobuf field: string new_lower_bound = 56
   */
  newLowerBound: string;
}
/**
 * @generated from protobuf message injective_trading_rpc.ExitConfig
 */
interface ExitConfig {
  /**
   * strategy exit type (stopLoss/takeProfit)
   *
   * @generated from protobuf field: string exit_type = 1
   */
  exitType: string;
  /**
   * strategy stopLoss/takeProfit price
   *
   * @generated from protobuf field: string exit_price = 2
   */
  exitPrice: string;
}
/**
 * @generated from protobuf message injective_trading_rpc.StrategyFinalData
 */
interface StrategyFinalData {
  /**
   * Initial base amount
   *
   * @generated from protobuf field: string initial_base_amount = 1
   */
  initialBaseAmount: string;
  /**
   * Initial quote amount
   *
   * @generated from protobuf field: string initial_quote_amount = 2
   */
  initialQuoteAmount: string;
  /**
   * Final base amount
   *
   * @generated from protobuf field: string final_base_amount = 3
   */
  finalBaseAmount: string;
  /**
   * Final quote amount
   *
   * @generated from protobuf field: string final_quote_amount = 4
   */
  finalQuoteAmount: string;
  /**
   * Initial base price
   *
   * @generated from protobuf field: string initial_base_price = 5
   */
  initialBasePrice: string;
  /**
   * Initial quote price
   *
   * @generated from protobuf field: string initial_quote_price = 6
   */
  initialQuotePrice: string;
  /**
   * Final base price
   *
   * @generated from protobuf field: string final_base_price = 7
   */
  finalBasePrice: string;
  /**
   * Final quote price
   *
   * @generated from protobuf field: string final_quote_price = 8
   */
  finalQuotePrice: string;
}
/**
 * Paging defines the structure for required params for handling pagination
 *
 * @generated from protobuf message injective_trading_rpc.Paging
 */
interface Paging$4 {
  /**
   * total number of txs saved in database
   *
   * @generated from protobuf field: sint64 total = 1
   */
  total: bigint;
  /**
   * can be either block height or index num
   *
   * @generated from protobuf field: sint32 from = 2
   */
  from: number;
  /**
   * can be either block height or index num
   *
   * @generated from protobuf field: sint32 to = 3
   */
  to: number;
  /**
   * count entries by subaccount, serving some places on helix
   *
   * @generated from protobuf field: sint64 count_by_subaccount = 4
   */
  countBySubaccount: bigint;
  /**
   * array of tokens to navigate to the next pages
   *
   * @generated from protobuf field: repeated string next = 5
   */
  next: string[];
}
/**
 * @generated from protobuf message injective_trading_rpc.GetTradingStatsResponse
 */
interface GetTradingStatsResponse {
  /**
   * Total of unique active trading strategies
   *
   * @generated from protobuf field: uint64 active_trading_strategies = 1
   */
  activeTradingStrategies: bigint;
  /**
   * Total number of created trading strategies
   *
   * @generated from protobuf field: uint64 total_trading_strategies_created = 2
   */
  totalTradingStrategiesCreated: bigint;
  /**
   * Total TVL of all active trading strategies
   *
   * @generated from protobuf field: string total_tvl = 3
   */
  totalTvl: string;
  /**
   * Market stats
   *
   * @generated from protobuf field: repeated injective_trading_rpc.Market markets = 4
   */
  markets: Market[];
}
/**
 * @generated from protobuf message injective_trading_rpc.Market
 */
interface Market {
  /**
   * MarketId of the trading strategy
   *
   * @generated from protobuf field: string market_id = 1
   */
  marketId: string;
  /**
   * Total of unique active trading strategies
   *
   * @generated from protobuf field: uint64 active_trading_strategies = 2
   */
  activeTradingStrategies: bigint;
}
/**
 * @generated from protobuf message injective_trading_rpc.StreamStrategyResponse
 */
interface StreamStrategyResponse {
  /**
   * The trading strategy
   *
   * @generated from protobuf field: injective_trading_rpc.TradingStrategy trading_strategy = 1
   */
  tradingStrategy?: TradingStrategy$1;
  /**
   * Timestamp in UNIX millis
   *
   * @generated from protobuf field: sint64 timestamp = 2
   */
  timestamp: bigint;
}
/**
 * @generated MessageType for protobuf message injective_trading_rpc.ListTradingStrategiesResponse
 */
declare const ListTradingStrategiesResponse$1 = new ListTradingStrategiesResponse$Type();
/**
 * @generated MessageType for protobuf message injective_trading_rpc.TradingStrategy
 */
declare const TradingStrategy$1 = new TradingStrategy$Type();
/**
 * @generated MessageType for protobuf message injective_trading_rpc.ExitConfig
 */
declare const ExitConfig = new ExitConfig$Type();
/**
 * @generated MessageType for protobuf message injective_trading_rpc.StrategyFinalData
 */
declare const StrategyFinalData = new StrategyFinalData$Type();
/**
 * @generated MessageType for protobuf message injective_trading_rpc.Paging
 */
declare const Paging$4 = new Paging$Type();
/**
 * @generated MessageType for protobuf message injective_trading_rpc.GetTradingStatsResponse
 */
declare const GetTradingStatsResponse = new GetTradingStatsResponse$Type();
/**
 * @generated MessageType for protobuf message injective_trading_rpc.Market
 */
declare const Market = new Market$Type();
/**
 * @generated MessageType for protobuf message injective_trading_rpc.StreamStrategyResponse
 */
declare const StreamStrategyResponse = new StreamStrategyResponse$Type();
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+mito-proto-ts-v2@1.17.3/node_modules/@injectivelabs/mito-proto-ts-v2/esm/generated/goadesign_goagen_mito_api_pb.d.ts
/**
 * @generated from protobuf message mito_api.GetVaultsResponse
 */
interface GetVaultsResponse {
  /**
   * Vaults data response
   *
   * @generated from protobuf field: repeated mito_api.Vault vaults = 1
   */
  vaults: Vault$1[];
  /**
   * @generated from protobuf field: mito_api.Pagination pagination = 2
   */
  pagination?: Pagination$1;
}
/**
 * @generated from protobuf message mito_api.Vault
 */
interface Vault$1 {
  /**
   * @generated from protobuf field: string contract_address = 1
   */
  contractAddress: string;
  /**
   * @generated from protobuf field: uint64 code_id = 2
   */
  codeId: bigint;
  /**
   * @generated from protobuf field: string vault_name = 3
   */
  vaultName: string;
  /**
   * @generated from protobuf field: string market_id = 4
   */
  marketId: string;
  /**
   * @generated from protobuf field: double current_tvl = 5
   */
  currentTvl: number;
  /**
   * @generated from protobuf field: mito_api.Changes profits = 6
   */
  profits?: Changes;
  /**
   * @generated from protobuf field: uint64 updated_at = 7
   */
  updatedAt: bigint;
  /**
   * @generated from protobuf field: string vault_type = 8
   */
  vaultType: string;
  /**
   * @generated from protobuf field: double lp_token_price = 9
   */
  lpTokenPrice: number;
  /**
   * @generated from protobuf field: mito_api.SubaccountBalance subaccount_info = 10
   */
  subaccountInfo?: SubaccountBalance$1;
  /**
   * @generated from protobuf field: string master_contract_address = 11
   */
  masterContractAddress: string;
  /**
   * @generated from protobuf field: string total_lp_amount = 12
   */
  totalLpAmount: string;
  /**
   * @generated from protobuf field: string slug = 13
   */
  slug: string;
  /**
   * @generated from protobuf field: sint64 created_at = 14
   */
  createdAt: bigint;
  /**
   * @generated from protobuf field: string notional_value_cap = 15
   */
  notionalValueCap: string;
  /**
   * @generated from protobuf field: mito_api.Changes tvl_changes = 16
   */
  tvlChanges?: Changes;
  /**
   * @generated from protobuf field: double apy = 17
   */
  apy: number;
  /**
   * @generated from protobuf field: double apy7_d = 18
   */
  apy7D: number;
  /**
   * @generated from protobuf field: double apy7_d_fq = 19
   */
  apy7DFq: number;
  /**
   * @generated from protobuf field: double apyue = 20
   */
  apyue: number;
  /**
   * @generated from protobuf field: double apy_v3 = 21
   */
  apyV3: number;
  /**
   * @generated from protobuf field: string registration_mode = 22
   */
  registrationMode: string;
}
/**
 * @generated from protobuf message mito_api.Changes
 */
interface Changes {
  /**
   * @generated from protobuf field: double all_time_change = 1
   */
  allTimeChange: number;
  /**
   * @generated from protobuf field: optional double three_months_change = 2
   */
  threeMonthsChange?: number;
  /**
   * @generated from protobuf field: optional double one_month_change = 3
   */
  oneMonthChange?: number;
  /**
   * @generated from protobuf field: optional double one_day_change = 4
   */
  oneDayChange?: number;
  /**
   * @generated from protobuf field: optional double one_week_change = 5
   */
  oneWeekChange?: number;
  /**
   * @generated from protobuf field: optional double one_year_change = 6
   */
  oneYearChange?: number;
  /**
   * @generated from protobuf field: optional double three_years_change = 7
   */
  threeYearsChange?: number;
  /**
   * @generated from protobuf field: optional double six_months_change = 8
   */
  sixMonthsChange?: number;
}
/**
 * @generated from protobuf message mito_api.SubaccountBalance
 */
interface SubaccountBalance$1 {
  /**
   * @generated from protobuf field: string subaccount_id = 1
   */
  subaccountId: string;
  /**
   * @generated from protobuf field: repeated mito_api.DenomBalance balances = 2
   */
  balances: DenomBalance$1[];
}
/**
 * @generated from protobuf message mito_api.DenomBalance
 */
interface DenomBalance$1 {
  /**
   * @generated from protobuf field: string denom = 1
   */
  denom: string;
  /**
   * @generated from protobuf field: string total_balance = 2
   */
  totalBalance: string;
  /**
   * @generated from protobuf field: optional string price = 3
   */
  price?: string;
  /**
   * @generated from protobuf field: optional sint64 updated_at = 4
   */
  updatedAt?: bigint;
  /**
   * @generated from protobuf field: optional string source = 5
   */
  source?: string;
}
/**
 * @generated from protobuf message mito_api.Pagination
 */
interface Pagination$1 {
  /**
   * @generated from protobuf field: uint32 total = 1
   */
  total: number;
}
/**
 * @generated from protobuf message mito_api.GetVaultResponse
 */
interface GetVaultResponse$1 {
  /**
   * Vault data response, if query by slug, there can be multiple vaults matching
   * the condition
   *
   * @generated from protobuf field: repeated mito_api.Vault vault = 1
   */
  vault: Vault$1[];
}
/**
 * @generated from protobuf message mito_api.LPTokenPriceChartResponse
 */
interface LPTokenPriceChartResponse {
  /**
   * @generated from protobuf field: repeated mito_api.PriceSnapshot prices = 1
   */
  prices: PriceSnapshot[];
}
/**
 * @generated from protobuf message mito_api.PriceSnapshot
 */
interface PriceSnapshot {
  /**
   * @generated from protobuf field: double price = 1
   */
  price: number;
  /**
   * @generated from protobuf field: uint64 updated_at = 2
   */
  updatedAt: bigint;
}
/**
 * @generated from protobuf message mito_api.VaultsByHolderAddressResponse
 */
interface VaultsByHolderAddressResponse {
  /**
   * @generated from protobuf field: repeated mito_api.Subscription subscriptions = 1
   */
  subscriptions: Subscription$2[];
  /**
   * @generated from protobuf field: mito_api.Pagination pagination = 2
   */
  pagination?: Pagination$1;
}
/**
 * @generated from protobuf message mito_api.Subscription
 */
interface Subscription$2 {
  /**
   * @generated from protobuf field: mito_api.Vault vault_info = 1
   */
  vaultInfo?: Vault$1;
  /**
   * @generated from protobuf field: string lp_amount = 2
   */
  lpAmount: string;
  /**
   * @generated from protobuf field: string holder_address = 3
   */
  holderAddress: string;
  /**
   * @generated from protobuf field: double lp_amount_percentage = 4
   */
  lpAmountPercentage: number;
}
/**
 * @generated from protobuf message mito_api.LPHoldersResponse
 */
interface LPHoldersResponse {
  /**
   * @generated from protobuf field: repeated mito_api.Holders holders = 1
   */
  holders: Holders[];
  /**
   * @generated from protobuf field: mito_api.Pagination pagination = 2
   */
  pagination?: Pagination$1;
}
/**
 * @generated from protobuf message mito_api.Holders
 */
interface Holders {
  /**
   * @generated from protobuf field: string holder_address = 1
   */
  holderAddress: string;
  /**
   * @generated from protobuf field: string vault_address = 2
   */
  vaultAddress: string;
  /**
   * @generated from protobuf field: string amount = 3
   */
  amount: string;
  /**
   * @generated from protobuf field: sint64 updated_at = 4
   */
  updatedAt: bigint;
  /**
   * @generated from protobuf field: double lp_amount_percentage = 5
   */
  lpAmountPercentage: number;
  /**
   * @generated from protobuf field: sint64 redemption_lock_time = 6
   */
  redemptionLockTime: bigint;
  /**
   * @generated from protobuf field: string staked_amount = 7
   */
  stakedAmount: string;
}
/**
 * @generated from protobuf message mito_api.PortfolioResponse
 */
interface PortfolioResponse {
  /**
   * @generated from protobuf field: double total_value = 1
   */
  totalValue: number;
  /**
   * @generated from protobuf field: double pnl = 2
   */
  pnl: number;
  /**
   * @generated from protobuf field: repeated mito_api.PriceSnapshot total_value_chart = 3
   */
  totalValueChart: PriceSnapshot[];
  /**
   * @generated from protobuf field: repeated mito_api.PriceSnapshot pnl_chart = 4
   */
  pnlChart: PriceSnapshot[];
  /**
   * @generated from protobuf field: sint64 pnl_updated_at = 5
   */
  pnlUpdatedAt: bigint;
}
/**
 * @generated from protobuf message mito_api.LeaderboardResponse
 */
interface LeaderboardResponse {
  /**
   * @generated from protobuf field: repeated mito_api.LeaderboardEntry entries = 1
   */
  entries: LeaderboardEntry[];
  /**
   * @generated from protobuf field: sint64 snapshot_block = 2
   */
  snapshotBlock: bigint;
  /**
   * @generated from protobuf field: sint64 updated_at = 3
   */
  updatedAt: bigint;
  /**
   * @generated from protobuf field: uint32 epoch_id = 4
   */
  epochId: number;
}
/**
 * @generated from protobuf message mito_api.LeaderboardEntry
 */
interface LeaderboardEntry {
  /**
   * @generated from protobuf field: string address = 1
   */
  address: string;
  /**
   * @generated from protobuf field: double pnl = 2
   */
  pnl: number;
}
/**
 * @generated from protobuf message mito_api.LeaderboardEpochsResponse
 */
interface LeaderboardEpochsResponse {
  /**
   * @generated from protobuf field: repeated mito_api.LeaderboardEpoch epochs = 1
   */
  epochs: LeaderboardEpoch[];
  /**
   * @generated from protobuf field: mito_api.Pagination pagination = 2
   */
  pagination?: Pagination$1;
}
/**
 * @generated from protobuf message mito_api.LeaderboardEpoch
 */
interface LeaderboardEpoch {
  /**
   * @generated from protobuf field: uint32 epoch_id = 1
   */
  epochId: number;
  /**
   * @generated from protobuf field: sint64 start_at = 2
   */
  startAt: bigint;
  /**
   * @generated from protobuf field: sint64 end_at = 3
   */
  endAt: bigint;
  /**
   * @generated from protobuf field: bool is_live = 4
   */
  isLive: boolean;
}
/**
 * @generated from protobuf message mito_api.TransfersHistoryResponse
 */
interface TransfersHistoryResponse {
  /**
   * @generated from protobuf field: repeated mito_api.Transfer transfers = 1
   */
  transfers: Transfer[];
  /**
   * @generated from protobuf field: mito_api.Pagination pagination = 2
   */
  pagination?: Pagination$1;
}
/**
 * @generated from protobuf message mito_api.Transfer
 */
interface Transfer {
  /**
   * @generated from protobuf field: string lp_amount = 1
   */
  lpAmount: string;
  /**
   * @generated from protobuf field: repeated mito_api.Coin coins = 2
   */
  coins: Coin$6[];
  /**
   * @generated from protobuf field: string usd_value = 3
   */
  usdValue: string;
  /**
   * @generated from protobuf field: bool is_deposit = 4
   */
  isDeposit: boolean;
  /**
   * time in unix milli
   *
   * @generated from protobuf field: sint64 executed_at = 5
   */
  executedAt: bigint;
  /**
   * @generated from protobuf field: string account = 6
   */
  account: string;
  /**
   * @generated from protobuf field: string vault = 7
   */
  vault: string;
  /**
   * @generated from protobuf field: string tx_hash = 8
   */
  txHash: string;
  /**
   * @generated from protobuf field: uint32 tid_by_vault = 9
   */
  tidByVault: number;
  /**
   * @generated from protobuf field: uint32 tid_by_account = 10
   */
  tidByAccount: number;
}
/**
 * @generated from protobuf message mito_api.Coin
 */
interface Coin$6 {
  /**
   * @generated from protobuf field: string amount = 1
   */
  amount: string;
  /**
   * @generated from protobuf field: string denom = 2
   */
  denom: string;
}
/**
 * @generated from protobuf message mito_api.GetStakingPoolsResponse
 */
interface GetStakingPoolsResponse {
  /**
   * @generated from protobuf field: repeated mito_api.StakingPool pools = 1
   */
  pools: StakingPool[];
  /**
   * @generated from protobuf field: mito_api.Pagination pagination = 2
   */
  pagination?: Pagination$1;
}
/**
 * @generated from protobuf message mito_api.StakingPool
 */
interface StakingPool {
  /**
   * @generated from protobuf field: string vault_name = 1
   */
  vaultName: string;
  /**
   * @generated from protobuf field: string vault_address = 2
   */
  vaultAddress: string;
  /**
   * @generated from protobuf field: string stake_denom = 3
   */
  stakeDenom: string;
  /**
   * @generated from protobuf field: repeated mito_api.Gauge gauges = 4
   */
  gauges: Gauge[];
  /**
   * @generated from protobuf field: double apr = 5
   */
  apr: number;
  /**
   * @generated from protobuf field: double total_liquidity = 6
   */
  totalLiquidity: number;
  /**
   * @generated from protobuf field: string staking_address = 7
   */
  stakingAddress: string;
  /**
   * denom => APR%, breakdown of staking APR
   *
   * @generated from protobuf field: map<string, double> apr_breakdown = 8
   */
  aprBreakdown: {
    [key: string]: number;
  };
}
/**
 * @generated from protobuf message mito_api.Gauge
 */
interface Gauge {
  /**
   * @generated from protobuf field: string id = 1
   */
  id: string;
  /**
   * @generated from protobuf field: string owner = 2
   */
  owner: string;
  /**
   * @generated from protobuf field: sint64 start_timestamp = 3
   */
  startTimestamp: bigint;
  /**
   * @generated from protobuf field: sint64 end_timestamp = 4
   */
  endTimestamp: bigint;
  /**
   * @generated from protobuf field: repeated mito_api.Coin reward_tokens = 5
   */
  rewardTokens: Coin$6[];
  /**
   * @generated from protobuf field: uint32 last_distribution = 6
   */
  lastDistribution: number;
  /**
   * @generated from protobuf field: string status = 7
   */
  status: string;
}
/**
 * @generated from protobuf message mito_api.StakingRewardByAccountResponse
 */
interface StakingRewardByAccountResponse {
  /**
   * @generated from protobuf field: repeated mito_api.StakingReward rewards = 1
   */
  rewards: StakingReward[];
  /**
   * @generated from protobuf field: mito_api.Pagination pagination = 2
   */
  pagination?: Pagination$1;
}
/**
 * @generated from protobuf message mito_api.StakingReward
 */
interface StakingReward {
  /**
   * @generated from protobuf field: string vault_name = 1
   */
  vaultName: string;
  /**
   * @generated from protobuf field: string vault_address = 2
   */
  vaultAddress: string;
  /**
   * @generated from protobuf field: mito_api.Coin staked_amount = 3
   */
  stakedAmount?: Coin$6;
  /**
   * @generated from protobuf field: double apr = 4
   */
  apr: number;
  /**
   * @generated from protobuf field: repeated mito_api.Coin claimable_rewards = 5
   */
  claimableRewards: Coin$6[];
  /**
   * @generated from protobuf field: sint64 lock_timestamp = 6
   */
  lockTimestamp: bigint;
  /**
   * @generated from protobuf field: mito_api.Coin locked_amount = 7
   */
  lockedAmount?: Coin$6;
}
/**
 * @generated from protobuf message mito_api.StakingHistoryResponse
 */
interface StakingHistoryResponse {
  /**
   * @generated from protobuf field: repeated mito_api.StakingActivity activities = 1
   */
  activities: StakingActivity[];
  /**
   * @generated from protobuf field: mito_api.Pagination pagination = 2
   */
  pagination?: Pagination$1;
}
/**
 * @generated from protobuf message mito_api.StakingActivity
 */
interface StakingActivity {
  /**
   * @generated from protobuf field: mito_api.Coin stake_amount = 1
   */
  stakeAmount?: Coin$6;
  /**
   * @generated from protobuf field: string vault_address = 2
   */
  vaultAddress: string;
  /**
   * @generated from protobuf field: string action = 3
   */
  action: string;
  /**
   * @generated from protobuf field: string tx_hash = 4
   */
  txHash: string;
  /**
   * @generated from protobuf field: repeated mito_api.Coin rewarded_tokens = 5
   */
  rewardedTokens: Coin$6[];
  /**
   * @generated from protobuf field: sint64 timestamp = 6
   */
  timestamp: bigint;
  /**
   * @generated from protobuf field: string staker = 7
   */
  staker: string;
  /**
   * @generated from protobuf field: uint32 number_by_account = 8
   */
  numberByAccount: number;
}
/**
 * @generated from protobuf message mito_api.StreamTransfersResponse
 */
interface StreamTransfersResponse {
  /**
   * @generated from protobuf field: mito_api.Transfer data = 1
   */
  data?: Transfer;
  /**
   * Update type
   *
   * @generated from protobuf field: optional string op_type = 2
   */
  opType?: string;
}
/**
 * @generated from protobuf message mito_api.StreamVaultResponse
 */
interface StreamVaultResponse {
  /**
   * @generated from protobuf field: mito_api.Vault data = 1
   */
  data?: Vault$1;
  /**
   * Update type
   *
   * @generated from protobuf field: optional string op_type = 2
   */
  opType?: string;
}
/**
 * @generated from protobuf message mito_api.StreamHolderSubscriptionResponse
 */
interface StreamHolderSubscriptionResponse {
  /**
   * @generated from protobuf field: mito_api.Subscription data = 1
   */
  data?: Subscription$2;
  /**
   * Update type
   *
   * @generated from protobuf field: optional string op_type = 2
   */
  opType?: string;
}
/**
 * @generated from protobuf message mito_api.StreamStakingRewardByAccountResponse
 */
interface StreamStakingRewardByAccountResponse {
  /**
   * @generated from protobuf field: mito_api.StakingReward data = 1
   */
  data?: StakingReward;
  /**
   * Update type
   *
   * @generated from protobuf field: optional string op_type = 2
   */
  opType?: string;
}
/**
 * @generated from protobuf message mito_api.StreamHistoricalStakingResponse
 */
interface StreamHistoricalStakingResponse {
  /**
   * @generated from protobuf field: mito_api.StakingActivity data = 1
   */
  data?: StakingActivity;
  /**
   * Update type
   *
   * @generated from protobuf field: optional string op_type = 2
   */
  opType?: string;
}
/**
 * @generated from protobuf message mito_api.MissionsResponse
 */
interface MissionsResponse {
  /**
   * @generated from protobuf field: repeated mito_api.Mission data = 1
   */
  data: Mission[];
  /**
   * @generated from protobuf field: optional sint64 rank = 2
   */
  rank?: bigint;
}
/**
 * @generated from protobuf message mito_api.Mission
 */
interface Mission {
  /**
   * @generated from protobuf field: string id = 1
   */
  id: string;
  /**
   * @generated from protobuf field: sint64 points = 2
   */
  points: bigint;
  /**
   * @generated from protobuf field: bool completed = 3
   */
  completed: boolean;
  /**
   * @generated from protobuf field: sint64 accrued_points = 4
   */
  accruedPoints: bigint;
  /**
   * @generated from protobuf field: sint64 updated_at = 5
   */
  updatedAt: bigint;
  /**
   * @generated from protobuf field: double progress = 6
   */
  progress: number;
  /**
   * @generated from protobuf field: double expected = 7
   */
  expected: number;
}
/**
 * @generated from protobuf message mito_api.MissionLeaderboardResponse
 */
interface MissionLeaderboardResponse {
  /**
   * @generated from protobuf field: repeated mito_api.MissionLeaderboardEntry data = 1
   */
  data: MissionLeaderboardEntry[];
  /**
   * @generated from protobuf field: sint64 updated_at = 2
   */
  updatedAt: bigint;
  /**
   * @generated from protobuf field: optional sint64 user_rank = 3
   */
  userRank?: bigint;
}
/**
 * @generated from protobuf message mito_api.MissionLeaderboardEntry
 */
interface MissionLeaderboardEntry {
  /**
   * @generated from protobuf field: string address = 1
   */
  address: string;
  /**
   * @generated from protobuf field: sint64 accrued_points = 2
   */
  accruedPoints: bigint;
}
/**
 * @generated from protobuf message mito_api.ListIDOsResponse
 */
interface ListIDOsResponse {
  /**
   * @generated from protobuf field: repeated mito_api.IDO idos = 1
   */
  idos: IDO[];
  /**
   * @generated from protobuf field: mito_api.Pagination pagination = 2
   */
  pagination?: Pagination$1;
}
/**
 * @generated from protobuf message mito_api.IDO
 */
interface IDO {
  /**
   * @generated from protobuf field: sint64 start_time = 1
   */
  startTime: bigint;
  /**
   * @generated from protobuf field: sint64 end_time = 2
   */
  endTime: bigint;
  /**
   * @generated from protobuf field: string owner = 3
   */
  owner: string;
  /**
   * @generated from protobuf field: string status = 4
   */
  status: string;
  /**
   * @generated from protobuf field: mito_api.TokenInfo token_info = 5
   */
  tokenInfo?: TokenInfo;
  /**
   * @generated from protobuf field: string project_token_amount = 6
   */
  projectTokenAmount: string;
  /**
   * @generated from protobuf field: string quote_denom = 7
   */
  quoteDenom: string;
  /**
   * @generated from protobuf field: string target_amount_in_quote_denom = 8
   */
  targetAmountInQuoteDenom: string;
  /**
   * @generated from protobuf field: string target_amount_in_usd = 9
   */
  targetAmountInUsd: string;
  /**
   * @generated from protobuf field: string cap_per_address = 10
   */
  capPerAddress: string;
  /**
   * @generated from protobuf field: string contract_address = 11
   */
  contractAddress: string;
  /**
   * @generated from protobuf field: string subscribed_amount = 12
   */
  subscribedAmount: string;
  /**
   * @generated from protobuf field: double token_price = 13
   */
  tokenPrice: number;
  /**
   * @generated from protobuf field: bool is_account_white_listed = 14
   */
  isAccountWhiteListed: boolean;
  /**
   * @generated from protobuf field: string name = 15
   */
  name: string;
  /**
   * @generated from protobuf field: repeated mito_api.IDOProgress progress = 16
   */
  progress: IDOProgress[];
  /**
   * @generated from protobuf field: repeated mito_api.ArrayOfString stake_to_subscription = 17
   */
  stakeToSubscription: ArrayOfString[];
  /**
   * @generated from protobuf field: sint64 second_before_start_to_set_quote_price = 18
   */
  secondBeforeStartToSetQuotePrice: bigint;
  /**
   * @generated from protobuf field: bool use_whitelist = 19
   */
  useWhitelist: boolean;
  /**
   * @generated from protobuf field: string market_id = 20
   */
  marketId: string;
  /**
   * @generated from protobuf field: string vault_address = 21
   */
  vaultAddress: string;
  /**
   * @generated from protobuf field: bool is_launch_with_vault = 22
   */
  isLaunchWithVault: boolean;
  /**
   * @generated from protobuf field: bool is_vesting_schedule_enabled = 23
   */
  isVestingScheduleEnabled: boolean;
  /**
   * @generated from protobuf field: mito_api.InitParams init_params = 24
   */
  initParams?: InitParams;
  /**
   * @generated from protobuf field: string project_description = 25
   */
  projectDescription: string;
  /**
   * @generated from protobuf field: bool is_permissionless = 26
   */
  isPermissionless: boolean;
}
/**
 * @generated from protobuf message mito_api.TokenInfo
 */
interface TokenInfo {
  /**
   * @generated from protobuf field: string denom = 1
   */
  denom: string;
  /**
   * @generated from protobuf field: string supply = 2
   */
  supply: string;
  /**
   * @generated from protobuf field: string symbol = 3
   */
  symbol: string;
  /**
   * @generated from protobuf field: sint32 decimal = 4
   */
  decimal: number;
  /**
   * @generated from protobuf field: string logo_url = 5
   */
  logoUrl: string;
}
/**
 * @generated from protobuf message mito_api.IDOProgress
 */
interface IDOProgress {
  /**
   * @generated from protobuf field: string status = 1
   */
  status: string;
  /**
   * @generated from protobuf field: sint64 timestamp = 2
   */
  timestamp: bigint;
}
/**
 * @generated from protobuf message mito_api.ArrayOfString
 */
interface ArrayOfString {
  /**
   * @generated from protobuf field: repeated string field = 1
   */
  field: string[];
}
/**
 * @generated from protobuf message mito_api.InitParams
 */
interface InitParams {
  /**
   * @generated from protobuf field: mito_api.VestingConfigMap vesting_config = 1
   */
  vestingConfig?: VestingConfigMap;
}
/**
 * @generated from protobuf message mito_api.VestingConfigMap
 */
interface VestingConfigMap {
  /**
   * @generated from protobuf field: mito_api.VestingConfig project_owner_quote = 1
   */
  projectOwnerQuote?: VestingConfig;
  /**
   * @generated from protobuf field: mito_api.VestingConfig project_owner_lp_tokens = 2
   */
  projectOwnerLpTokens?: VestingConfig;
  /**
   * @generated from protobuf field: mito_api.VestingConfig users_project_token = 3
   */
  usersProjectToken?: VestingConfig;
}
/**
 * @generated from protobuf message mito_api.VestingConfig
 */
interface VestingConfig {
  /**
   * @generated from protobuf field: optional sint64 vesting_duration_seconds = 1
   */
  vestingDurationSeconds?: bigint;
  /**
   * @generated from protobuf field: optional sint64 vesting_start_delay_seconds = 2
   */
  vestingStartDelaySeconds?: bigint;
  /**
   * @generated from protobuf field: optional string schedule = 3
   */
  schedule?: string;
}
/**
 * @generated from protobuf message mito_api.GetIDOResponse
 */
interface GetIDOResponse {
  /**
   * @generated from protobuf field: mito_api.IDO ido = 1
   */
  ido?: IDO;
}
/**
 * @generated from protobuf message mito_api.GetIDOSubscribersResponse
 */
interface GetIDOSubscribersResponse {
  /**
   * @generated from protobuf field: repeated mito_api.IDOSubscriber subscribers = 1
   */
  subscribers: IDOSubscriber[];
  /**
   * @generated from protobuf field: mito_api.Pagination pagination = 2
   */
  pagination?: Pagination$1;
  /**
   * @generated from protobuf field: mito_api.TokenInfo token_info = 3
   */
  tokenInfo?: TokenInfo;
  /**
   * @generated from protobuf field: string quote_denom = 4
   */
  quoteDenom: string;
  /**
   * @generated from protobuf field: string market_id = 5
   */
  marketId: string;
}
/**
 * @generated from protobuf message mito_api.IDOSubscriber
 */
interface IDOSubscriber {
  /**
   * @generated from protobuf field: string address = 1
   */
  address: string;
  /**
   * @generated from protobuf field: mito_api.Coin subscribed_coin = 2
   */
  subscribedCoin?: Coin$6;
  /**
   * @generated from protobuf field: sint64 last_subscribe_time = 3
   */
  lastSubscribeTime: bigint;
  /**
   * @generated from protobuf field: mito_api.Coin estimate_token_received = 4
   */
  estimateTokenReceived?: Coin$6;
  /**
   * @generated from protobuf field: mito_api.Coin estimate_lp_amount = 5
   */
  estimateLpAmount?: Coin$6;
  /**
   * @generated from protobuf field: mito_api.Coin estimate_refund_amount = 6
   */
  estimateRefundAmount?: Coin$6;
  /**
   * @generated from protobuf field: sint64 created_at = 7
   */
  createdAt: bigint;
}
/**
 * @generated from protobuf message mito_api.GetIDOSubscriptionResponse
 */
interface GetIDOSubscriptionResponse {
  /**
   * @generated from protobuf field: mito_api.IDOSubscription subscription = 1
   */
  subscription?: IDOSubscription;
}
/**
 * @generated from protobuf message mito_api.IDOSubscription
 */
interface IDOSubscription {
  /**
   * @generated from protobuf field: mito_api.Coin max_subscription_coin = 1
   */
  maxSubscriptionCoin?: Coin$6;
  /**
   * @generated from protobuf field: string committed_amount = 2
   */
  committedAmount: string;
  /**
   * @generated from protobuf field: double price = 3
   */
  price: number;
  /**
   * @generated from protobuf field: repeated mito_api.Coin claimable_coins = 4
   */
  claimableCoins: Coin$6[];
  /**
   * @generated from protobuf field: sint64 updated_at = 5
   */
  updatedAt: bigint;
  /**
   * @generated from protobuf field: bool reward_claimed = 6
   */
  rewardClaimed: boolean;
  /**
   * @generated from protobuf field: mito_api.TokenInfo token_info = 7
   */
  tokenInfo?: TokenInfo;
  /**
   * @generated from protobuf field: string quote_denom = 8
   */
  quoteDenom: string;
  /**
   * @generated from protobuf field: string staked_amount = 9
   */
  stakedAmount: string;
  /**
   * @generated from protobuf field: optional string claim_tx_hash = 10
   */
  claimTxHash?: string;
  /**
   * @generated from protobuf field: repeated mito_api.Coin owner_claimable_coins = 11
   */
  ownerClaimableCoins: Coin$6[];
  /**
   * @generated from protobuf field: string market_id = 12
   */
  marketId: string;
  /**
   * @generated from protobuf field: string weight = 13
   */
  weight: string;
  /**
   * @generated from protobuf field: mito_api.IDOClaimedCoins claimed_coins = 14
   */
  claimedCoins?: IDOClaimedCoins;
}
/**
 * @generated from protobuf message mito_api.IDOClaimedCoins
 */
interface IDOClaimedCoins {
  /**
   * @generated from protobuf field: repeated mito_api.Coin claimed_coins = 1
   */
  claimedCoins: Coin$6[];
  /**
   * @generated from protobuf field: sint64 updated_at = 2
   */
  updatedAt: bigint;
}
/**
 * @generated from protobuf message mito_api.GetIDOActivitiesResponse
 */
interface GetIDOActivitiesResponse {
  /**
   * @generated from protobuf field: repeated mito_api.IDOSubscriptionActivity activities = 1
   */
  activities: IDOSubscriptionActivity[];
  /**
   * @generated from protobuf field: mito_api.Pagination pagination = 2
   */
  pagination?: Pagination$1;
}
/**
 * @generated from protobuf message mito_api.IDOSubscriptionActivity
 */
interface IDOSubscriptionActivity {
  /**
   * @generated from protobuf field: string address = 1
   */
  address: string;
  /**
   * @generated from protobuf field: mito_api.Coin subscribed_coin = 2
   */
  subscribedCoin?: Coin$6;
  /**
   * @generated from protobuf field: double usd_value = 3
   */
  usdValue: number;
  /**
   * @generated from protobuf field: sint64 timestamp = 4
   */
  timestamp: bigint;
  /**
   * @generated from protobuf field: string tx_hash = 5
   */
  txHash: string;
}
/**
 * @generated from protobuf message mito_api.GetWhitelistResponse
 */
interface GetWhitelistResponse {
  /**
   * @generated from protobuf field: optional string ido_address = 1
   */
  idoAddress?: string;
  /**
   * @generated from protobuf field: repeated mito_api.WhitelistAccount accounts = 2
   */
  accounts: WhitelistAccount[];
  /**
   * @generated from protobuf field: mito_api.Pagination pagination = 3
   */
  pagination?: Pagination$1;
}
/**
 * @generated from protobuf message mito_api.WhitelistAccount
 */
interface WhitelistAccount {
  /**
   * @generated from protobuf field: string account_address = 1
   */
  accountAddress: string;
  /**
   * @generated from protobuf field: sint64 updated_at = 2
   */
  updatedAt: bigint;
  /**
   * @generated from protobuf field: string weight = 3
   */
  weight: string;
}
/**
 * @generated from protobuf message mito_api.GetClaimReferencesResponse
 */
interface GetClaimReferencesResponse {
  /**
   * @generated from protobuf field: repeated mito_api.ClaimReference claim_references = 1
   */
  claimReferences: ClaimReference[];
  /**
   * @generated from protobuf field: mito_api.Pagination pagination = 2
   */
  pagination?: Pagination$1;
}
/**
 * @generated from protobuf message mito_api.ClaimReference
 */
interface ClaimReference {
  /**
   * @generated from protobuf field: string account_address = 1
   */
  accountAddress: string;
  /**
   * @generated from protobuf field: string cw_contract_address = 2
   */
  cwContractAddress: string;
  /**
   * @generated from protobuf field: string ido_contract_address = 3
   */
  idoContractAddress: string;
  /**
   * @generated from protobuf field: string start_vesting_time = 4
   */
  startVestingTime: string;
  /**
   * @generated from protobuf field: sint64 vesting_duration_seconds = 5
   */
  vestingDurationSeconds: bigint;
  /**
   * @generated from protobuf field: sint64 updated_at = 6
   */
  updatedAt: bigint;
  /**
   * @generated from protobuf field: string claimed_amount = 7
   */
  claimedAmount: string;
  /**
   * @generated from protobuf field: string claimable_amount = 8
   */
  claimableAmount: string;
  /**
   * @generated from protobuf field: string denom = 9
   */
  denom: string;
}
/**
 * @generated MessageType for protobuf message mito_api.GetVaultsResponse
 */
declare const GetVaultsResponse = new GetVaultsResponse$Type();
/**
 * @generated MessageType for protobuf message mito_api.Vault
 */
declare const Vault$1 = new Vault$Type();
/**
 * @generated MessageType for protobuf message mito_api.Changes
 */
declare const Changes = new Changes$Type();
/**
 * @generated MessageType for protobuf message mito_api.SubaccountBalance
 */
declare const SubaccountBalance$1 = new SubaccountBalance$Type();
/**
 * @generated MessageType for protobuf message mito_api.DenomBalance
 */
declare const DenomBalance$1 = new DenomBalance$Type();
/**
 * @generated MessageType for protobuf message mito_api.Pagination
 */
declare const Pagination$1 = new Pagination$Type();
/**
 * @generated MessageType for protobuf message mito_api.GetVaultResponse
 */
declare const GetVaultResponse$1 = new GetVaultResponse$Type();
/**
 * @generated MessageType for protobuf message mito_api.LPTokenPriceChartResponse
 */
declare const LPTokenPriceChartResponse = new LPTokenPriceChartResponse$Type();
/**
 * @generated MessageType for protobuf message mito_api.PriceSnapshot
 */
declare const PriceSnapshot = new PriceSnapshot$Type();
/**
 * @generated MessageType for protobuf message mito_api.VaultsByHolderAddressResponse
 */
declare const VaultsByHolderAddressResponse = new VaultsByHolderAddressResponse$Type();
/**
 * @generated MessageType for protobuf message mito_api.Subscription
 */
declare const Subscription$2 = new Subscription$Type();
/**
 * @generated MessageType for protobuf message mito_api.LPHoldersResponse
 */
declare const LPHoldersResponse = new LPHoldersResponse$Type();
/**
 * @generated MessageType for protobuf message mito_api.Holders
 */
declare const Holders = new Holders$Type();
/**
 * @generated MessageType for protobuf message mito_api.PortfolioResponse
 */
declare const PortfolioResponse = new PortfolioResponse$Type();
/**
 * @generated MessageType for protobuf message mito_api.LeaderboardResponse
 */
declare const LeaderboardResponse = new LeaderboardResponse$Type();
/**
 * @generated MessageType for protobuf message mito_api.LeaderboardEntry
 */
declare const LeaderboardEntry = new LeaderboardEntry$Type();
/**
 * @generated MessageType for protobuf message mito_api.LeaderboardEpochsResponse
 */
declare const LeaderboardEpochsResponse = new LeaderboardEpochsResponse$Type();
/**
 * @generated MessageType for protobuf message mito_api.LeaderboardEpoch
 */
declare const LeaderboardEpoch = new LeaderboardEpoch$Type();
/**
 * @generated MessageType for protobuf message mito_api.TransfersHistoryResponse
 */
declare const TransfersHistoryResponse = new TransfersHistoryResponse$Type();
/**
 * @generated MessageType for protobuf message mito_api.Transfer
 */
declare const Transfer = new Transfer$Type();
/**
 * @generated MessageType for protobuf message mito_api.Coin
 */
declare const Coin$6 = new Coin$Type();
/**
 * @generated MessageType for protobuf message mito_api.GetStakingPoolsResponse
 */
declare const GetStakingPoolsResponse = new GetStakingPoolsResponse$Type();
/**
 * @generated MessageType for protobuf message mito_api.StakingPool
 */
declare const StakingPool = new StakingPool$Type();
/**
 * @generated MessageType for protobuf message mito_api.Gauge
 */
declare const Gauge = new Gauge$Type();
/**
 * @generated MessageType for protobuf message mito_api.StakingRewardByAccountResponse
 */
declare const StakingRewardByAccountResponse = new StakingRewardByAccountResponse$Type();
/**
 * @generated MessageType for protobuf message mito_api.StakingReward
 */
declare const StakingReward = new StakingReward$Type();
/**
 * @generated MessageType for protobuf message mito_api.StakingHistoryResponse
 */
declare const StakingHistoryResponse = new StakingHistoryResponse$Type();
/**
 * @generated MessageType for protobuf message mito_api.StakingActivity
 */
declare const StakingActivity = new StakingActivity$Type();
/**
 * @generated MessageType for protobuf message mito_api.StreamTransfersResponse
 */
declare const StreamTransfersResponse = new StreamTransfersResponse$Type();
/**
 * @generated MessageType for protobuf message mito_api.StreamVaultResponse
 */
declare const StreamVaultResponse = new StreamVaultResponse$Type();
/**
 * @generated MessageType for protobuf message mito_api.StreamHolderSubscriptionResponse
 */
declare const StreamHolderSubscriptionResponse = new StreamHolderSubscriptionResponse$Type();
/**
 * @generated MessageType for protobuf message mito_api.StreamStakingRewardByAccountResponse
 */
declare const StreamStakingRewardByAccountResponse = new StreamStakingRewardByAccountResponse$Type();
/**
 * @generated MessageType for protobuf message mito_api.StreamHistoricalStakingResponse
 */
declare const StreamHistoricalStakingResponse = new StreamHistoricalStakingResponse$Type();
/**
 * @generated MessageType for protobuf message mito_api.MissionsResponse
 */
declare const MissionsResponse = new MissionsResponse$Type();
/**
 * @generated MessageType for protobuf message mito_api.Mission
 */
declare const Mission = new Mission$Type();
/**
 * @generated MessageType for protobuf message mito_api.MissionLeaderboardResponse
 */
declare const MissionLeaderboardResponse = new MissionLeaderboardResponse$Type();
/**
 * @generated MessageType for protobuf message mito_api.MissionLeaderboardEntry
 */
declare const MissionLeaderboardEntry = new MissionLeaderboardEntry$Type();
/**
 * @generated MessageType for protobuf message mito_api.ListIDOsResponse
 */
declare const ListIDOsResponse = new ListIDOsResponse$Type();
/**
 * @generated MessageType for protobuf message mito_api.IDO
 */
declare const IDO = new IDO$Type();
/**
 * @generated MessageType for protobuf message mito_api.TokenInfo
 */
declare const TokenInfo = new TokenInfo$Type();
/**
 * @generated MessageType for protobuf message mito_api.IDOProgress
 */
declare const IDOProgress = new IDOProgress$Type();
/**
 * @generated MessageType for protobuf message mito_api.ArrayOfString
 */
declare const ArrayOfString = new ArrayOfString$Type();
/**
 * @generated MessageType for protobuf message mito_api.InitParams
 */
declare const InitParams = new InitParams$Type();
/**
 * @generated MessageType for protobuf message mito_api.VestingConfigMap
 */
declare const VestingConfigMap = new VestingConfigMap$Type();
/**
 * @generated MessageType for protobuf message mito_api.VestingConfig
 */
declare const VestingConfig = new VestingConfig$Type();
/**
 * @generated MessageType for protobuf message mito_api.GetIDOResponse
 */
declare const GetIDOResponse = new GetIDOResponse$Type();
/**
 * @generated MessageType for protobuf message mito_api.GetIDOSubscribersResponse
 */
declare const GetIDOSubscribersResponse = new GetIDOSubscribersResponse$Type();
/**
 * @generated MessageType for protobuf message mito_api.IDOSubscriber
 */
declare const IDOSubscriber = new IDOSubscriber$Type();
/**
 * @generated MessageType for protobuf message mito_api.GetIDOSubscriptionResponse
 */
declare const GetIDOSubscriptionResponse = new GetIDOSubscriptionResponse$Type();
/**
 * @generated MessageType for protobuf message mito_api.IDOSubscription
 */
declare const IDOSubscription = new IDOSubscription$Type();
/**
 * @generated MessageType for protobuf message mito_api.IDOClaimedCoins
 */
declare const IDOClaimedCoins = new IDOClaimedCoins$Type();
/**
 * @generated MessageType for protobuf message mito_api.GetIDOActivitiesResponse
 */
declare const GetIDOActivitiesResponse = new GetIDOActivitiesResponse$Type();
/**
 * @generated MessageType for protobuf message mito_api.IDOSubscriptionActivity
 */
declare const IDOSubscriptionActivity = new IDOSubscriptionActivity$Type();
/**
 * @generated MessageType for protobuf message mito_api.GetWhitelistResponse
 */
declare const GetWhitelistResponse = new GetWhitelistResponse$Type();
/**
 * @generated MessageType for protobuf message mito_api.WhitelistAccount
 */
declare const WhitelistAccount = new WhitelistAccount$Type();
/**
 * @generated MessageType for protobuf message mito_api.GetClaimReferencesResponse
 */
declare const GetClaimReferencesResponse = new GetClaimReferencesResponse$Type();
/**
 * @generated MessageType for protobuf message mito_api.ClaimReference
 */
declare const ClaimReference = new ClaimReference$Type();
//#endregion
//#region src/client/indexer/types/mito.d.ts
type MitoGaugeStatus = 'active' | 'live';
declare const MitoGaugeStatus: {
  readonly Active: "active";
  readonly Live: "live";
};
interface MitoHolders {
  holderAddress: string;
  vaultAddress: string;
  amount: string;
  updatedAt: number;
  lpAmountPercentage: number;
  redemptionLockTime: string;
  stakedAmount: string;
}
interface MitoPriceSnapshot {
  price: number;
  updatedAt: number;
}
interface MitoChanges {
  allTimeChange: number;
  threeMonthsChange?: number;
  oneMonthChange?: number;
  oneDayChange?: number;
  oneWeekChange?: number;
  oneYearChange?: number;
  threeYearsChange?: number;
  sixMonthsChange?: number;
}
interface MitoDenomBalance {
  denom: string;
  totalBalance: string;
}
interface MitoSubaccountBalance {
  subaccountId: string;
  balancesList: MitoDenomBalance[];
}
interface MitoVault {
  contractAddress: string;
  codeId: string;
  vaultName: string;
  marketId: string;
  currentTvl: number;
  profits?: MitoChanges;
  updatedAt: number;
  vaultType: string;
  lpTokenPrice: number;
  subaccountInfo?: MitoSubaccountBalance;
  masterContractAddress: string;
  totalLpAmount: string;
  slug: string;
  createdAt: number;
  notionalValueCap: string;
  tvlChanges?: MitoChanges;
  apy: number;
  apy7D: number;
  apy7DFq: number;
  apyue: number;
  apyV3: number;
  registrationMode: string;
}
interface MitoSubscription {
  vaultInfo?: MitoVault;
  lpAmount: string;
  holderAddress: string;
  lpAmountPercentage: number;
}
interface MitoPagination {
  total: Number;
}
interface MitoPortfolio {
  totalValue: number;
  pnl: number;
  totalValueChartList: MitoPriceSnapshot[];
  pnlChartList: MitoPriceSnapshot[];
  updatedAt: number;
}
interface MitoLeaderboardEntry {
  address: string;
  pnl: number;
}
interface MitoLeaderboard {
  entriesList: MitoLeaderboardEntry[];
  snapshotBlock: string;
  updatedAt: number;
  epochId: number;
}
interface MitoLeaderboardEpoch {
  epochId: number;
  startAt: number;
  endAt: number;
  isLive: boolean;
}
interface MitoTransfer {
  lpAmount: string;
  coins: Coin[];
  usdValue: string;
  isDeposit: boolean;
  executedAt: number;
  account: string;
  vault: string;
  txHash: string;
  tidByVault: number;
  tidByAccount: number;
}
interface MitoGauge {
  id: string;
  owner: string;
  startTimestamp: number;
  endTimestamp: number;
  rewardTokens: Coin[];
  lastDistribution: number;
  status: MitoGaugeStatus;
}
interface MitoStakingPool {
  vaultName: string;
  vaultAddress: string;
  stakeDenom: string;
  gauges: MitoGauge[];
  apr: number;
  totalLiquidity: number;
  stakingAddress: string;
  aprBreakdown: Record<string, number>;
}
interface MitoStakingReward {
  vaultName: string;
  vaultAddress: string;
  stakedAmount: Coin | undefined;
  apr: number;
  claimableRewards: Coin[];
  lockTimestamp: number;
  lockedAmount: Coin | undefined;
}
interface MitoStakingActivity {
  stakeAmount: Coin | undefined;
  vaultAddress: string;
  action: string;
  txHash: string;
  rewardedTokens: Coin[];
  timestamp: number;
  staker: string;
  numberByAccount: number;
}
interface MitoMission {
  id: string;
  points: string;
  completed: boolean;
  accruedPoints: string;
  updatedAt: number;
  progress: number;
  expected: number;
}
interface MitoMissionLeaderboardEntry {
  address: string;
  accruedPoints: string;
}
interface MitoMissionLeaderboard {
  entries: MitoMissionLeaderboardEntry[];
  updatedAt: number;
  rank?: string;
}
interface MitoTokenInfo {
  denom: string;
  supply: string;
  symbol: string;
  decimal: number;
  logoUrl: string;
}
interface MitoIDOProgress {
  status: string;
  timestamp: number;
}
interface MitoStakeToSubscription {
  stakedAmount: string;
  subscribableAmount: string;
}
interface MitoVestingConfig {
  vestingDurationSeconds?: number;
  vestingStartDelaySeconds?: number;
  schedule?: string;
}
interface MitoVestingConfigMap {
  projectOwnerQuote?: MitoVestingConfig;
  projectOwnerLpTokens?: MitoVestingConfig;
  usersProjectToken?: MitoVestingConfig;
}
interface MitoIDOInitParams {
  vestingConfig?: MitoVestingConfigMap;
}
interface MitoIDO {
  startTime: number;
  endTime: number;
  owner: string;
  status: string;
  tokenInfo?: MitoTokenInfo;
  capPerAddress: string;
  contractAddress: string;
  subscribedAmount: string;
  projectTokenAmount: string;
  targetAmountInQuoteDenom: string;
  secondBeforeStartToSetQuotePrice: number;
  targetAmountInUsd: string;
  tokenPrice: number;
  isAccountWhiteListed: boolean;
  isLaunchWithVault: boolean;
  isVestingScheduleEnabled: boolean;
  name: string;
  progress: MitoIDOProgress[];
  quoteDenom: string;
  stakeToSubscription: MitoStakeToSubscription[];
  useWhitelist: boolean;
  marketId: string;
  vaultAddress: string;
  vestingConfig?: MitoVestingConfigMap;
  projectDescription: string;
  isPermissionless: boolean;
}
interface MitoIDOSubscriber {
  address: string;
  subscribedCoin?: Coin;
  lastSubscribeTime: number;
  estimateTokenReceived?: Coin;
  estimateLpAmount?: Coin | undefined;
  estimateRefundAmount?: Coin | undefined;
  createdAt: number;
}
interface MitoIDOSubscriptionActivity {
  address: string;
  subscribedCoin?: Coin;
  usdValue: number;
  timestamp: number;
  txHash: string;
}
interface MitoIDOClaimedCoins {
  claimedCoins: Coin[];
  updatedAt: number;
}
interface MitoIDOSubscription {
  maxSubscriptionCoin?: Coin;
  committedAmount: string;
  price: number;
  claimableCoins: Coin[];
  rewardClaimed: boolean;
  tokenInfo?: MitoTokenInfo;
  quoteDenom: string;
  updatedAt: number;
  stakedAmount: string;
  claimTxHash?: string;
  ownerClaimableCoins: Coin[];
  marketId: string;
  claimedCoins?: MitoIDOClaimedCoins;
}
interface MitoWhitelistAccount {
  accountAddress: string;
  updatedAt: number;
  weight: string;
}
interface MitoClaimReference {
  denom: string;
  updatedAt: number;
  claimedAmount: string;
  claimableAmount: string;
  accountAddress: string;
  cwContractAddress: string;
  idoContractAddress: string;
  startVestingTime: number;
  vestingDurationSeconds: number;
}
type GrpcMitoIDO = IDO;
type GrpcMitoVault = Vault$1;
type GrpcMitoMission = Mission;
type GrpcMitoChanges = Changes;
type GrpcMitoHolders = Holders;
type GrpcMitoStakingGauge = Gauge;
type GrpcMitoTokenInfo = TokenInfo;
type GrpcMitoPagination = Pagination$1;
type GrpcMitoIDOProgress = IDOProgress;
type GrpcMitoStakingPool = StakingPool;
type GrpcMitoDenomBalance = DenomBalance$1;
type GrpcMitoSubscription = Subscription$2;
type GrpcMitoPriceSnapshot = PriceSnapshot;
type GrpcMitoIDOSubscriber = IDOSubscriber;
type GrpcMitoClaimReference = ClaimReference;
type GrpcMitoIDOClaimedCoins = IDOClaimedCoins;
type GrpcMitoIDOSubscription = IDOSubscription;
type GrpcMitoLeaderboardEntry = LeaderboardEntry;
type GrpcMitoLeaderboardEpoch = LeaderboardEpoch;
type GrpcMitoStakingStakingReward = StakingReward;
type GrpcMitoSubaccountBalance = SubaccountBalance$1;
type GrpcMitoWhitelistAccount = WhitelistAccount;
type GrpcMitoStakingStakingActivity = StakingActivity;
type GrpcMitoMissionLeaderboardEntry = MissionLeaderboardEntry;
type GrpcMitoIDOSubscriptionActivity = IDOSubscriptionActivity;
//#endregion
//#region src/client/indexer/types/account.d.ts
declare const TransferType: {
  readonly Internal: "internal";
  readonly External: "external";
  readonly Withdraw: "withdraw";
  readonly Deposit: "deposit";
};
type TransferType = (typeof TransferType)[keyof typeof TransferType];
interface SubaccountTransfer {
  transferType: TransferType;
  srcSubaccountId: string;
  srcSubaccountAddress: string;
  dstSubaccountId: string;
  dstSubaccountAddress: string;
  amount?: Coin;
  executedAt: number;
}
interface SubaccountDeposit {
  totalBalance: string;
  availableBalance: string;
}
interface SubaccountBalance {
  subaccountId: string;
  accountAddress: string;
  denom: string;
  deposit?: SubaccountDeposit;
}
interface SubaccountPortfolio {
  subaccountId: string;
  availableBalance: string;
  lockedBalance: string;
  unrealizedPnl: string;
}
interface AccountPortfolio {
  portfolioValue: string;
  availableBalance: string;
  lockedBalance: string;
  unrealizedPnl: string;
  subaccountsList: Array<SubaccountPortfolio>;
}
interface TradingReward {
  accountAddress: string;
  rewards: {
    amount: string;
    denom: string;
  }[];
  distributedAt: number;
}
type GrpcTradingReward = Reward;
type GrpcAccountPortfolio = AccountPortfolio$1;
type GrpcSubaccountDeposit = SubaccountDeposit$2;
type GrpcSubaccountBalance = SubaccountBalance$2;
type GrpcSubaccountPortfolio = SubaccountPortfolio$1;
type GrpcSubaccountBalanceTransfer = SubaccountBalanceTransfer;
//#endregion
//#region src/client/indexer/types/trading.d.ts
type ListTradingStrategiesResponse = ListTradingStrategiesResponse$1;
type TradingStrategy = TradingStrategy$1;
declare const MarketType: {
  readonly Spot: "spot";
  readonly Derivative: "derivative";
};
type MarketType = (typeof MarketType)[keyof typeof MarketType];
type GridStrategyType = 'geometric' | 'arithmetic' | 'perpetual';
declare const GridStrategyType: {
  readonly Geometric: "geometric";
  readonly Arithmetic: "arithmetic";
  readonly Perpetual: "perpetual";
};
type GridStrategyStreamResponse = StreamStrategyResponse;
//#endregion
//#region src/client/indexer/types/explorer.d.ts
declare const AccessTypeCode: {
  readonly AccessTypeUnspecified: 0;
  readonly AccessTypeNobody: 1;
  readonly AccessTypeOnlyAddress: 2;
  readonly AccessTypeEverybody: 3;
  readonly AccessTypeAnyOfAddresses: 4;
};
type AccessTypeCode = (typeof AccessTypeCode)[keyof typeof AccessTypeCode];
declare const AccessType: {
  readonly AccessTypeUnspecified: "Unspecified";
  readonly AccessTypeNobody: "Nobody";
  readonly AccessTypeOnlyAddress: "Only Address";
  readonly AccessTypeEverybody: "Everybody";
  readonly AccessTypeAnyOfAddresses: "Any of Addresses";
};
type AccessType = (typeof AccessType)[keyof typeof AccessType];
declare const ValidatorUptimeStatus: {
  readonly Proposed: "proposed";
  readonly Signed: "signed";
  readonly Missed: "missed";
};
type ValidatorUptimeStatus = (typeof ValidatorUptimeStatus)[keyof typeof ValidatorUptimeStatus];
interface Paging {
  from: number;
  to: number;
  total: number;
}
interface EventLogEvent {
  type: string;
  attributes: Array<{
    key: string;
    value: string;
  }>;
}
interface EventLog {
  events: EventLogEvent[];
}
interface Signature {
  pubkey: string;
  address: string;
  signature: string;
  sequence: number;
}
interface Message {
  type: string;
  message: any;
}
interface IBCTransferTx {
  sender: string;
  receiver: string;
  sourcePort: string;
  sourceChannel: string;
  destinationPort: string;
  destinationChannel: string;
  amount: string;
  denom: string;
  timeoutHeight: string;
  timeoutTimestamp: number;
  packetSequence: number;
  dataHex: Uint8Array | string;
  state: string;
  txHashesList: string[];
  createdAt: string;
  updatedAt: string;
}
interface PeggyDepositTx {
  sender: string;
  receiver: string;
  eventNonce: number;
  eventHeight: number;
  amount: string;
  denom: string;
  orchestratorAddress: string;
  state: string;
  claimType: number;
  txHashesList: string[];
  createdAt: string;
  updatedAt: string;
}
interface PeggyWithdrawalTx {
  sender: string;
  receiver: string;
  amount: string;
  denom: string;
  bridgeFee: string;
  outgoingTxId: number;
  batchTimeout: number;
  batchNonce: number;
  orchestratorAddress: string;
  eventNonce: number;
  eventHeight: number;
  state: string;
  claimType: number;
  txHashesList: string[];
  createdAt: string;
  updatedAt: string;
}
interface GasFee {
  amounts: {
    amount: string;
    denom: string;
  }[];
  gasLimit: number;
  payer: string;
  granter: string;
}
interface TxMessage {
  key: string;
  value: string;
}
interface GrpcBankMsgSendMessage {
  type: string;
  value: {
    amount: [{
      amount: string;
      denom: string;
    }];
    from_address: string;
    to_address: string;
  };
}
interface BankMsgSendTransaction {
  blockNumber: number;
  blockTimestamp: string;
  hash: string;
  amount: string;
  denom: string;
  sender: string;
  receiver: string;
}
interface Transaction {
  id: string;
  blockNumber: number;
  blockTimestamp: string;
  hash: string;
  memo?: string;
  code: number;
  data?: Uint8Array | string;
  info: string;
  gasWanted: number;
  gasFee: GasFee;
  gasUsed: number;
  events?: Array<{
    type: string;
    attributes: Record<string, string>;
  }>;
  txType: string;
  signatures: Signature[];
  codespace: string;
  messages?: TxMessage[];
  errorLog?: string;
}
interface IndexerStreamTransaction {
  id: string;
  blockNumber: number;
  blockTimestamp: string;
  hash: string;
  codespace: string;
  messages: string;
  txNumber: number;
  errorLog: string;
  code: number;
}
interface Block$1 {
  height: number;
  proposer: string;
  moniker: string;
  blockHash: string;
  parentHash: string;
  numPreCommits: number;
  numTxs: number;
  timestamp: string;
}
interface BlockWithTxs {
  height: number;
  proposer: string;
  moniker: string;
  blockHash: string;
  parentHash: string;
  numPreCommits: number;
  numTxs: number;
  txs?: Transaction[];
  timestamp: string;
}
interface ExplorerValidatorDescription {
  moniker: string;
  identity: string;
  website: string;
  securityContact: string;
  details: string;
}
interface ValidatorUptime {
  blockNumber: number;
  status: string;
}
interface ValidatorSlashingEvent {
  blockNumber: number;
  blockTimestamp: string;
  address: string;
  power: number;
  reason: string;
  jailed: string;
  missedBlocks: number;
}
interface ExplorerValidator {
  id: string;
  moniker: string;
  operatorAddress: string;
  consensusAddress: string;
  jailed: boolean;
  status: number;
  tokens: string;
  delegatorShares: string;
  description?: ExplorerValidatorDescription;
  unbondingHeight: number;
  unbondingTime: string;
  commissionRate: string;
  commissionMaxRate: string;
  commissionMaxChangeRate: string;
  commissionUpdateTime: string;
  proposed: number;
  signed: number;
  uptimePercentage: number;
  missed: number;
  timestamp: string;
  uptimesList: ValidatorUptime[];
  slashingEventsList: ValidatorSlashingEvent[];
  imageUrl: string;
}
interface CW20Message {
  decimals: number;
  initial_balances: [{
    address: string;
    amount: string;
  }];
  marketing: {};
  mint: {
    minter: string;
  };
  name: string;
  symbol: string;
}
interface ExplorerCW20BalanceWithToken {
  contractAddress: string;
  account: string;
  balance: string;
  updatedAt: number;
  token: TokenStatic;
}
interface Contract {
  label: string;
  address: string;
  txHash: string;
  creator: string;
  executes: number;
  instantiatedAt: number;
  lastExecutedAt: number;
  funds?: number;
  codeId: number;
  admin?: string;
  initMessage?: CW20Message;
  currentMigrateMessage?: CW20Message;
  cw20_metadata?: {
    token_info?: {
      name: string;
      symbol: string;
      decimals: number;
      total_supply: string;
    };
  };
}
interface ContractTransactionWithMessages extends Omit<ContractTransaction, 'messages'> {
  messages: Array<{
    type: string;
    value: {
      sender: string;
      contract: string;
      msg: Record<string, any>;
      funds: string;
    };
  }>;
}
interface WasmCode {
  id: number;
  txHash: string;
  creator: string;
  contractType: string;
  version: string;
  instantiates: number;
  creationDate: number;
  checksum?: CosmWasmChecksum;
  permission?: CosmWasmPermission;
  proposalId?: number;
}
interface BankTransfer {
  sender: string;
  recipient: string;
  amounts: Coin[];
  blockNumber: number;
  blockTimestamp: number;
}
interface ContractTransaction {
  txHash: string;
  type: string;
  code: number;
  messages: Message[];
  amount: BigNumber;
  fee: BigNumber;
  height: number;
  time: number;
  data: string;
  memo: string;
  tx_number: number;
  error_log: string;
  logs: EventLog[];
  signatures: Signature[];
}
interface ExplorerTransaction extends Omit<Transaction, 'messages'> {
  memo: string;
  messages: Message[];
  errorLog?: string;
  logs?: EventLog[];
  claimIds?: number[];
}
interface ExplorerBlockWithTxs extends Omit<BlockWithTxs, 'txs'> {
  txs: ExplorerTransaction[];
}
interface ExplorerValidatorUptime extends Omit<ValidatorUptime, 'status'> {
  status: ValidatorUptimeStatus;
}
interface CosmWasmPermission {
  access_type: AccessTypeCode;
  address: string;
}
interface CosmWasmChecksum {
  algorithm: string;
  hash: string;
}
interface ExplorerStats {
  assets: string | bigint;
  txsTotal: string | bigint;
  addresses: string;
  injSupply: string | bigint;
  txsInPast30Days: string | bigint;
  txsInPast24Hours: string | bigint;
  blockCountInPast24Hours: string | bigint;
  txsPerSecondInPast24Hours: string | bigint;
  txsPerSecondInPast100Blocks: string | bigint;
}
interface ExplorerTxsV2Response {
  data: ExplorerTransactionV2[];
  paging?: Paging$5;
}
interface ExplorerTransactionV2 {
  logs: any;
  id: string;
  code: number;
  hash: string;
  messages: any;
  txNumber: number;
  errorLog?: string;
  codespace: string;
  claimIds: string[];
  blockNumber: number;
  txMsgTypes: string[];
  blockTimestamp: number;
  blockUnixTimestamp: number;
  signatures: Signature$1[];
}
type GrpcIBCTransferTx = IBCTransferTx$1;
type GrpcPeggyDepositTx = PeggyDepositTx$1;
type GrpcPeggyWithdrawalTx = PeggyWithdrawalTx$1;
type GrpcGasFee = GasFee$1;
type GrpcValidatorUptime = ValidatorUptime$1;
type GrpcIndexerValidatorDescription = ValidatorDescription$1;
type GrpcValidatorSlashingEvent = SlashingEvent;
type GrpcExplorerStats = GetStatsResponse;
//#endregion
//#region src/client/indexer/types/swap.d.ts
interface Route {
  steps: string[];
  sourceDenom: string;
  targetDenom: string;
}
interface QuantityAndFees {
  expectedFees: Coin[];
  resultQuantity: string;
}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+indexer-proto-ts-v2@1.17.6/node_modules/@injectivelabs/indexer-proto-ts-v2/esm/generated/injective_spot_exchange_rpc_pb.d.ts
/**
 * @generated from protobuf message injective_spot_exchange_rpc.MarketsResponse
 */
interface MarketsResponse$1 {
  /**
   * Spot Markets list
   *
   * @generated from protobuf field: repeated injective_spot_exchange_rpc.SpotMarketInfo markets = 1
   */
  markets: SpotMarketInfo[];
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.SpotMarketInfo
 */
interface SpotMarketInfo {
  /**
   * SpotMarket ID is keccak265(baseDenom || quoteDenom)
   *
   * @generated from protobuf field: string market_id = 1
   */
  marketId: string;
  /**
   * The status of the market
   *
   * @generated from protobuf field: string market_status = 2
   */
  marketStatus: string;
  /**
   * A name of the pair in format AAA/BBB, where AAA is base asset, BBB is quote
   * asset.
   *
   * @generated from protobuf field: string ticker = 3
   */
  ticker: string;
  /**
   * Coin denom used for the base asset.
   *
   * @generated from protobuf field: string base_denom = 4
   */
  baseDenom: string;
  /**
   * Token metadata for base asset
   *
   * @generated from protobuf field: injective_spot_exchange_rpc.TokenMeta base_token_meta = 5
   */
  baseTokenMeta?: TokenMeta$3;
  /**
   * Coin denom used for the quote asset.
   *
   * @generated from protobuf field: string quote_denom = 6
   */
  quoteDenom: string;
  /**
   * Token metadata for quote asset
   *
   * @generated from protobuf field: injective_spot_exchange_rpc.TokenMeta quote_token_meta = 7
   */
  quoteTokenMeta?: TokenMeta$3;
  /**
   * Defines the fee percentage makers pay when trading (in quote asset)
   *
   * @generated from protobuf field: string maker_fee_rate = 8
   */
  makerFeeRate: string;
  /**
   * Defines the fee percentage takers pay when trading (in quote asset)
   *
   * @generated from protobuf field: string taker_fee_rate = 9
   */
  takerFeeRate: string;
  /**
   * Percentage of the transaction fee shared with the service provider
   *
   * @generated from protobuf field: string service_provider_fee = 10
   */
  serviceProviderFee: string;
  /**
   * Defines the minimum required tick size for the order's price
   *
   * @generated from protobuf field: string min_price_tick_size = 11
   */
  minPriceTickSize: string;
  /**
   * Defines the minimum required tick size for the order's quantity
   *
   * @generated from protobuf field: string min_quantity_tick_size = 12
   */
  minQuantityTickSize: string;
  /**
   * Minimum notional value for the market
   *
   * @generated from protobuf field: string min_notional = 13
   */
  minNotional: string;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.TokenMeta
 */
interface TokenMeta$3 {
  /**
   * Token full name
   *
   * @generated from protobuf field: string name = 1
   */
  name: string;
  /**
   * Token contract address (native or not)
   *
   * @generated from protobuf field: string address = 2
   */
  address: string;
  /**
   * Token symbol short name
   *
   * @generated from protobuf field: string symbol = 3
   */
  symbol: string;
  /**
   * URL to the logo image
   *
   * @generated from protobuf field: string logo = 4
   */
  logo: string;
  /**
   * Token decimals
   *
   * @generated from protobuf field: sint32 decimals = 5
   */
  decimals: number;
  /**
   * Token metadata fetched timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 updated_at = 6
   */
  updatedAt: bigint;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.MarketResponse
 */
interface MarketResponse$1 {
  /**
   * Info about particular spot market
   *
   * @generated from protobuf field: injective_spot_exchange_rpc.SpotMarketInfo market = 1
   */
  market?: SpotMarketInfo;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.StreamMarketsResponse
 */
interface StreamMarketsResponse {
  /**
   * Info about particular spot market
   *
   * @generated from protobuf field: injective_spot_exchange_rpc.SpotMarketInfo market = 1
   */
  market?: SpotMarketInfo;
  /**
   * Update type
   *
   * @generated from protobuf field: string operation_type = 2
   */
  operationType: string;
  /**
   * Operation timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 timestamp = 3
   */
  timestamp: bigint;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.OrderbookV2Response
 */
interface OrderbookV2Response$1 {
  /**
   * Orderbook of a particular spot market
   *
   * @generated from protobuf field: injective_spot_exchange_rpc.SpotLimitOrderbookV2 orderbook = 1
   */
  orderbook?: SpotLimitOrderbookV2;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.SpotLimitOrderbookV2
 */
interface SpotLimitOrderbookV2 {
  /**
   * Array of price levels for buys
   *
   * @generated from protobuf field: repeated injective_spot_exchange_rpc.PriceLevel buys = 1
   */
  buys: PriceLevel$2[];
  /**
   * Array of price levels for sells
   *
   * @generated from protobuf field: repeated injective_spot_exchange_rpc.PriceLevel sells = 2
   */
  sells: PriceLevel$2[];
  /**
   * market orderbook sequence
   *
   * @generated from protobuf field: uint64 sequence = 3
   */
  sequence: bigint;
  /**
   * Last update timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 timestamp = 4
   */
  timestamp: bigint;
  /**
   * Block height at which the orderbook was last updated.
   *
   * @generated from protobuf field: sint64 height = 5
   */
  height: bigint;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.PriceLevel
 */
interface PriceLevel$2 {
  /**
   * Price number of the price level.
   *
   * @generated from protobuf field: string price = 1
   */
  price: string;
  /**
   * Quantity of the price level.
   *
   * @generated from protobuf field: string quantity = 2
   */
  quantity: string;
  /**
   * Price level last updated timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 timestamp = 3
   */
  timestamp: bigint;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.OrderbooksV2Response
 */
interface OrderbooksV2Response$1 {
  /**
   * @generated from protobuf field: repeated injective_spot_exchange_rpc.SingleSpotLimitOrderbookV2 orderbooks = 1
   */
  orderbooks: SingleSpotLimitOrderbookV2[];
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.SingleSpotLimitOrderbookV2
 */
interface SingleSpotLimitOrderbookV2 {
  /**
   * market's ID
   *
   * @generated from protobuf field: string market_id = 1
   */
  marketId: string;
  /**
   * Orderbook of the market
   *
   * @generated from protobuf field: injective_spot_exchange_rpc.SpotLimitOrderbookV2 orderbook = 2
   */
  orderbook?: SpotLimitOrderbookV2;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.StreamOrderbookV2Response
 */
interface StreamOrderbookV2Response$1 {
  /**
   * Orderbook of a Spot Market
   *
   * @generated from protobuf field: injective_spot_exchange_rpc.SpotLimitOrderbookV2 orderbook = 1
   */
  orderbook?: SpotLimitOrderbookV2;
  /**
   * Order update type
   *
   * @generated from protobuf field: string operation_type = 2
   */
  operationType: string;
  /**
   * Operation timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 timestamp = 3
   */
  timestamp: bigint;
  /**
   * MarketId of the market's orderbook
   *
   * @generated from protobuf field: string market_id = 4
   */
  marketId: string;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.StreamOrderbookUpdateResponse
 */
interface StreamOrderbookUpdateResponse$1 {
  /**
   * Orderbook level updates of a Spot Market
   *
   * @generated from protobuf field: injective_spot_exchange_rpc.OrderbookLevelUpdates orderbook_level_updates = 1
   */
  orderbookLevelUpdates?: OrderbookLevelUpdates$1;
  /**
   * Order update type
   *
   * @generated from protobuf field: string operation_type = 2
   */
  operationType: string;
  /**
   * Operation timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 timestamp = 3
   */
  timestamp: bigint;
  /**
   * MarketId of the market's orderbook
   *
   * @generated from protobuf field: string market_id = 4
   */
  marketId: string;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.OrderbookLevelUpdates
 */
interface OrderbookLevelUpdates$1 {
  /**
   * market's ID
   *
   * @generated from protobuf field: string market_id = 1
   */
  marketId: string;
  /**
   * orderbook update sequence
   *
   * @generated from protobuf field: uint64 sequence = 2
   */
  sequence: bigint;
  /**
   * buy levels
   *
   * @generated from protobuf field: repeated injective_spot_exchange_rpc.PriceLevelUpdate buys = 3
   */
  buys: PriceLevelUpdate$1[];
  /**
   * sell levels
   *
   * @generated from protobuf field: repeated injective_spot_exchange_rpc.PriceLevelUpdate sells = 4
   */
  sells: PriceLevelUpdate$1[];
  /**
   * updates timestamp
   *
   * @generated from protobuf field: sint64 updated_at = 5
   */
  updatedAt: bigint;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.PriceLevelUpdate
 */
interface PriceLevelUpdate$1 {
  /**
   * Price number of the price level.
   *
   * @generated from protobuf field: string price = 1
   */
  price: string;
  /**
   * Quantity of the price level.
   *
   * @generated from protobuf field: string quantity = 2
   */
  quantity: string;
  /**
   * Price level status.
   *
   * @generated from protobuf field: bool is_active = 3
   */
  isActive: boolean;
  /**
   * Price level last updated timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 timestamp = 4
   */
  timestamp: bigint;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.OrdersResponse
 */
interface OrdersResponse$1 {
  /**
   * @generated from protobuf field: repeated injective_spot_exchange_rpc.SpotLimitOrder orders = 1
   */
  orders: SpotLimitOrder$1[];
  /**
   * @generated from protobuf field: injective_spot_exchange_rpc.Paging paging = 2
   */
  paging?: Paging$3;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.SpotLimitOrder
 */
interface SpotLimitOrder$1 {
  /**
   * Hash of the order
   *
   * @generated from protobuf field: string order_hash = 1
   */
  orderHash: string;
  /**
   * The side of the order
   *
   * @generated from protobuf field: string order_side = 2
   */
  orderSide: string;
  /**
   * Spot Market ID is keccak265(baseDenom + quoteDenom)
   *
   * @generated from protobuf field: string market_id = 3
   */
  marketId: string;
  /**
   * The subaccountId that this order belongs to
   *
   * @generated from protobuf field: string subaccount_id = 4
   */
  subaccountId: string;
  /**
   * Price of the order
   *
   * @generated from protobuf field: string price = 5
   */
  price: string;
  /**
   * Quantity of the order
   *
   * @generated from protobuf field: string quantity = 6
   */
  quantity: string;
  /**
   * The amount of the quantity remaining unfilled
   *
   * @generated from protobuf field: string unfilled_quantity = 7
   */
  unfilledQuantity: string;
  /**
   * Trigger price is the trigger price used by stop/take orders. 0 if the
   * trigger price is not set.
   *
   * @generated from protobuf field: string trigger_price = 8
   */
  triggerPrice: string;
  /**
   * Fee recipient address
   *
   * @generated from protobuf field: string fee_recipient = 9
   */
  feeRecipient: string;
  /**
   * Order state
   *
   * @generated from protobuf field: string state = 10
   */
  state: string;
  /**
   * Order committed timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 created_at = 11
   */
  createdAt: bigint;
  /**
   * Order updated timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 updated_at = 12
   */
  updatedAt: bigint;
  /**
   * Transaction Hash where order is created. Not all orders have this field
   *
   * @generated from protobuf field: string tx_hash = 13
   */
  txHash: string;
  /**
   * Custom client order ID
   *
   * @generated from protobuf field: string cid = 14
   */
  cid: string;
}
/**
 * Paging defines the structure for required params for handling pagination
 *
 * @generated from protobuf message injective_spot_exchange_rpc.Paging
 */
interface Paging$3 {
  /**
   * total number of txs saved in database
   *
   * @generated from protobuf field: sint64 total = 1
   */
  total: bigint;
  /**
   * can be either block height or index num
   *
   * @generated from protobuf field: sint32 from = 2
   */
  from: number;
  /**
   * can be either block height or index num
   *
   * @generated from protobuf field: sint32 to = 3
   */
  to: number;
  /**
   * count entries by subaccount, serving some places on helix
   *
   * @generated from protobuf field: sint64 count_by_subaccount = 4
   */
  countBySubaccount: bigint;
  /**
   * array of tokens to navigate to the next pages
   *
   * @generated from protobuf field: repeated string next = 5
   */
  next: string[];
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.StreamOrdersResponse
 */
interface StreamOrdersResponse$1 {
  /**
   * Updated market order
   *
   * @generated from protobuf field: injective_spot_exchange_rpc.SpotLimitOrder order = 1
   */
  order?: SpotLimitOrder$1;
  /**
   * Order update type
   *
   * @generated from protobuf field: string operation_type = 2
   */
  operationType: string;
  /**
   * Operation timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 timestamp = 3
   */
  timestamp: bigint;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.TradesResponse
 */
interface TradesResponse$1 {
  /**
   * Trades of a Spot Market
   *
   * @generated from protobuf field: repeated injective_spot_exchange_rpc.SpotTrade trades = 1
   */
  trades: SpotTrade$1[];
  /**
   * Paging indicates pages response is on
   *
   * @generated from protobuf field: injective_spot_exchange_rpc.Paging paging = 2
   */
  paging?: Paging$3;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.SpotTrade
 */
interface SpotTrade$1 {
  /**
   * Maker order hash.
   *
   * @generated from protobuf field: string order_hash = 1
   */
  orderHash: string;
  /**
   * The subaccountId that executed the trade
   *
   * @generated from protobuf field: string subaccount_id = 2
   */
  subaccountId: string;
  /**
   * The ID of the market that this trade is in
   *
   * @generated from protobuf field: string market_id = 3
   */
  marketId: string;
  /**
   * The execution type of the trade
   *
   * @generated from protobuf field: string trade_execution_type = 4
   */
  tradeExecutionType: string;
  /**
   * The direction the trade
   *
   * @generated from protobuf field: string trade_direction = 5
   */
  tradeDirection: string;
  /**
   * Price level at which trade has been executed
   *
   * @generated from protobuf field: injective_spot_exchange_rpc.PriceLevel price = 6
   */
  price?: PriceLevel$2;
  /**
   * The fee associated with the trade (quote asset denom)
   *
   * @generated from protobuf field: string fee = 7
   */
  fee: string;
  /**
   * Timestamp of trade execution in UNIX millis
   *
   * @generated from protobuf field: sint64 executed_at = 8
   */
  executedAt: bigint;
  /**
   * Fee recipient address
   *
   * @generated from protobuf field: string fee_recipient = 9
   */
  feeRecipient: string;
  /**
   * A unique string that helps differentiate between trades
   *
   * @generated from protobuf field: string trade_id = 10
   */
  tradeId: string;
  /**
   * Trade's execution side, marker/taker
   *
   * @generated from protobuf field: string execution_side = 11
   */
  executionSide: string;
  /**
   * Custom client order ID
   *
   * @generated from protobuf field: string cid = 12
   */
  cid: string;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.StreamTradesResponse
 */
interface StreamTradesResponse$1 {
  /**
   * New spot market trade
   *
   * @generated from protobuf field: injective_spot_exchange_rpc.SpotTrade trade = 1
   */
  trade?: SpotTrade$1;
  /**
   * Executed trades update type
   *
   * @generated from protobuf field: string operation_type = 2
   */
  operationType: string;
  /**
   * Operation timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 timestamp = 3
   */
  timestamp: bigint;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.SubaccountTradesListResponse
 */
interface SubaccountTradesListResponse$1 {
  /**
   * List of spot market trades
   *
   * @generated from protobuf field: repeated injective_spot_exchange_rpc.SpotTrade trades = 1
   */
  trades: SpotTrade$1[];
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.OrdersHistoryResponse
 */
interface OrdersHistoryResponse$1 {
  /**
   * List of history spot orders
   *
   * @generated from protobuf field: repeated injective_spot_exchange_rpc.SpotOrderHistory orders = 1
   */
  orders: SpotOrderHistory$1[];
  /**
   * @generated from protobuf field: injective_spot_exchange_rpc.Paging paging = 2
   */
  paging?: Paging$3;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.SpotOrderHistory
 */
interface SpotOrderHistory$1 {
  /**
   * Hash of the order
   *
   * @generated from protobuf field: string order_hash = 1
   */
  orderHash: string;
  /**
   * Spot Market ID is keccak265(baseDenom + quoteDenom)
   *
   * @generated from protobuf field: string market_id = 2
   */
  marketId: string;
  /**
   * active state of the order
   *
   * @generated from protobuf field: bool is_active = 3
   */
  isActive: boolean;
  /**
   * The subaccountId that this order belongs to
   *
   * @generated from protobuf field: string subaccount_id = 4
   */
  subaccountId: string;
  /**
   * The execution type
   *
   * @generated from protobuf field: string execution_type = 5
   */
  executionType: string;
  /**
   * The side of the order
   *
   * @generated from protobuf field: string order_type = 6
   */
  orderType: string;
  /**
   * Price of the order
   *
   * @generated from protobuf field: string price = 7
   */
  price: string;
  /**
   * Trigger price
   *
   * @generated from protobuf field: string trigger_price = 8
   */
  triggerPrice: string;
  /**
   * Quantity of the order
   *
   * @generated from protobuf field: string quantity = 9
   */
  quantity: string;
  /**
   * Filled amount
   *
   * @generated from protobuf field: string filled_quantity = 10
   */
  filledQuantity: string;
  /**
   * Order state
   *
   * @generated from protobuf field: string state = 11
   */
  state: string;
  /**
   * Order committed timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 created_at = 12
   */
  createdAt: bigint;
  /**
   * Order updated timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 updated_at = 13
   */
  updatedAt: bigint;
  /**
   * Order direction (order side)
   *
   * @generated from protobuf field: string direction = 14
   */
  direction: string;
  /**
   * Transaction Hash where order is created. Not all orders have this field
   *
   * @generated from protobuf field: string tx_hash = 15
   */
  txHash: string;
  /**
   * Custom client order ID
   *
   * @generated from protobuf field: string cid = 16
   */
  cid: string;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.StreamOrdersHistoryResponse
 */
interface StreamOrdersHistoryResponse$1 {
  /**
   * Updated order
   *
   * @generated from protobuf field: injective_spot_exchange_rpc.SpotOrderHistory order = 1
   */
  order?: SpotOrderHistory$1;
  /**
   * Order update type
   *
   * @generated from protobuf field: string operation_type = 2
   */
  operationType: string;
  /**
   * Operation timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 timestamp = 3
   */
  timestamp: bigint;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.AtomicSwapHistoryResponse
 */
interface AtomicSwapHistoryResponse {
  /**
   * Paging indicates total number of records with this filter
   *
   * @generated from protobuf field: injective_spot_exchange_rpc.Paging paging = 1
   */
  paging?: Paging$3;
  /**
   * swap data
   *
   * @generated from protobuf field: repeated injective_spot_exchange_rpc.AtomicSwap data = 2
   */
  data: AtomicSwap$1[];
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.AtomicSwap
 */
interface AtomicSwap$1 {
  /**
   * executor of the swap
   *
   * @generated from protobuf field: string sender = 1
   */
  sender: string;
  /**
   * swap route
   *
   * @generated from protobuf field: string route = 2
   */
  route: string;
  /**
   * source coin
   *
   * @generated from protobuf field: injective_spot_exchange_rpc.Coin source_coin = 3
   */
  sourceCoin?: Coin$5;
  /**
   * destination received coin
   *
   * @generated from protobuf field: injective_spot_exchange_rpc.Coin dest_coin = 4
   */
  destCoin?: Coin$5;
  /**
   * fees of each steps in route
   *
   * @generated from protobuf field: repeated injective_spot_exchange_rpc.Coin fees = 5
   */
  fees: Coin$5[];
  /**
   * contract address that executes to make this swap
   *
   * @generated from protobuf field: string contract_address = 6
   */
  contractAddress: string;
  /**
   * Numerical index by sender to use in pagination from_number and to_number
   *
   * @generated from protobuf field: sint32 index_by_sender = 7
   */
  indexBySender: number;
  /**
   * Numerical index by sender + acontract to use in pagination from_number and
   * to_number, that support contract filter
   *
   * @generated from protobuf field: sint32 index_by_sender_contract = 8
   */
  indexBySenderContract: number;
  /**
   * transaction hash of the swap
   *
   * @generated from protobuf field: string tx_hash = 9
   */
  txHash: string;
  /**
   * transaction timestamp of the swap
   *
   * @generated from protobuf field: sint64 executed_at = 10
   */
  executedAt: bigint;
  /**
   * Refunded amount of the swap
   *
   * @generated from protobuf field: string refund_amount = 11
   */
  refundAmount: string;
}
/**
 * @generated from protobuf message injective_spot_exchange_rpc.Coin
 */
interface Coin$5 {
  /**
   * Denom of the coin
   *
   * @generated from protobuf field: string denom = 1
   */
  denom: string;
  /**
   * @generated from protobuf field: string amount = 2
   */
  amount: string;
  /**
   * @generated from protobuf field: string usd_value = 3
   */
  usdValue: string;
}
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.MarketsResponse
 */
declare const MarketsResponse$1 = new MarketsResponse$Type();
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.SpotMarketInfo
 */
declare const SpotMarketInfo = new SpotMarketInfo$Type();
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.TokenMeta
 */
declare const TokenMeta$3 = new TokenMeta$Type();
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.MarketResponse
 */
declare const MarketResponse$1 = new MarketResponse$Type();
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.StreamMarketsResponse
 */
declare const StreamMarketsResponse = new StreamMarketsResponse$Type();
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.OrderbookV2Response
 */
declare const OrderbookV2Response$1 = new OrderbookV2Response$Type();
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.SpotLimitOrderbookV2
 */
declare const SpotLimitOrderbookV2 = new SpotLimitOrderbookV2$Type();
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.PriceLevel
 */
declare const PriceLevel$2 = new PriceLevel$Type();
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.OrderbooksV2Response
 */
declare const OrderbooksV2Response$1 = new OrderbooksV2Response$Type();
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.SingleSpotLimitOrderbookV2
 */
declare const SingleSpotLimitOrderbookV2 = new SingleSpotLimitOrderbookV2$Type();
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.StreamOrderbookV2Response
 */
declare const StreamOrderbookV2Response$1 = new StreamOrderbookV2Response$Type();
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.StreamOrderbookUpdateResponse
 */
declare const StreamOrderbookUpdateResponse$1 = new StreamOrderbookUpdateResponse$Type();
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.OrderbookLevelUpdates
 */
declare const OrderbookLevelUpdates$1 = new OrderbookLevelUpdates$Type();
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.PriceLevelUpdate
 */
declare const PriceLevelUpdate$1 = new PriceLevelUpdate$Type();
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.OrdersResponse
 */
declare const OrdersResponse$1 = new OrdersResponse$Type();
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.SpotLimitOrder
 */
declare const SpotLimitOrder$1 = new SpotLimitOrder$Type();
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.Paging
 */
declare const Paging$3 = new Paging$Type();
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.StreamOrdersResponse
 */
declare const StreamOrdersResponse$1 = new StreamOrdersResponse$Type();
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.TradesResponse
 */
declare const TradesResponse$1 = new TradesResponse$Type();
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.SpotTrade
 */
declare const SpotTrade$1 = new SpotTrade$Type();
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.StreamTradesResponse
 */
declare const StreamTradesResponse$1 = new StreamTradesResponse$Type();
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.SubaccountTradesListResponse
 */
declare const SubaccountTradesListResponse$1 = new SubaccountTradesListResponse$Type();
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.OrdersHistoryResponse
 */
declare const OrdersHistoryResponse$1 = new OrdersHistoryResponse$Type();
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.SpotOrderHistory
 */
declare const SpotOrderHistory$1 = new SpotOrderHistory$Type();
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.StreamOrdersHistoryResponse
 */
declare const StreamOrdersHistoryResponse$1 = new StreamOrdersHistoryResponse$Type();
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.AtomicSwapHistoryResponse
 */
declare const AtomicSwapHistoryResponse = new AtomicSwapHistoryResponse$Type();
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.AtomicSwap
 */
declare const AtomicSwap$1 = new AtomicSwap$Type();
/**
 * @generated MessageType for protobuf message injective_spot_exchange_rpc.Coin
 */
declare const Coin$5 = new Coin$Type();
//#endregion
//#region src/client/indexer/types/exchange.d.ts
interface PriceLevel {
  price: string;
  quantity: string;
  timestamp: number;
}
interface Orderbook {
  buys: PriceLevel[];
  sells: PriceLevel[];
}
interface OrderbookWithSequence {
  sequence: number;
  buys: PriceLevel[];
  sells: PriceLevel[];
}
type GrpcTokenMeta = TokenMeta$3;
type GrpcPriceLevel = PriceLevel$2;
interface IndexerTokenMeta extends Omit<GrpcTokenMeta, 'updatedAt'> {
  coinGeckoId: string;
  tokenType: TokenType;
  updatedAt: number;
}
//#endregion
//#region src/client/indexer/types/spot.d.ts
interface SpotMarket {
  marketId: string;
  marketStatus: string;
  ticker: string;
  baseDenom: string;
  quoteDenom: string;
  makerFeeRate: string;
  quoteToken: TokenMeta | undefined;
  baseToken: TokenMeta | undefined;
  takerFeeRate: string;
  serviceProviderFee: string;
  minPriceTickSize: number;
  minQuantityTickSize: number;
  minNotional: number;
}
interface SpotLimitOrder {
  cid: string;
  orderHash: string;
  orderSide: OrderSide;
  marketId: string;
  subaccountId: string;
  price: string;
  state: OrderState;
  quantity: string;
  unfilledQuantity: string;
  triggerPrice: string;
  feeRecipient: string;
  createdAt: number;
  updatedAt: number;
}
interface SpotOrderHistory {
  orderHash: string;
  marketId: string;
  cid: string;
  active: boolean;
  subaccountId: string;
  executionType: string;
  orderType: string;
  price: string;
  triggerPrice: string;
  quantity: string;
  filledQuantity: string;
  state: string;
  createdAt: number;
  updatedAt: number;
  direction: string;
}
interface SpotTrade extends PriceLevel {
  orderHash: string;
  subaccountId: string;
  marketId: string;
  cid: string;
  tradeId: string;
  executedAt: number;
  tradeExecutionType: TradeExecutionType;
  executionSide: TradeExecutionSide;
  tradeDirection: TradeDirection;
  fee: string;
  feeRecipient: string;
}
interface SpotLimitOrderParams {
  orderType: GrpcOrderType;
  triggerPrice?: string;
  feeRecipient: string;
  price: string;
  quantity: string;
}
interface SpotOrderCancelParams {
  orderHash: string;
}
interface BatchSpotOrderCancelParams {
  orderHash: string;
  subaccountId: string;
  marketId: string;
}
interface AtomicSwap {
  sender: string;
  route: string;
  sourceCoin: Coin | undefined;
  destinationCoin: Coin | undefined;
  fees: Coin[];
  contractAddress: string;
  indexBySender: number;
  indexBySenderContract: number;
  txHash: string;
  executedAt: number;
}
type GrpcSpotTrade = SpotTrade$1;
type GrpcSpotMarketInfo = SpotMarketInfo;
type GrpcSpotLimitOrder = SpotLimitOrder$1;
type GrpcSpotOrderHistory = SpotOrderHistory$1;
type GrpcAtomicSwap = AtomicSwap$1;
//#endregion
//#region src/client/indexer/types/oracle.d.ts
type GrpcOracle = Oracle$1;
interface Oracle extends GrpcOracle {}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+indexer-proto-ts-v2@1.17.6/node_modules/@injectivelabs/indexer-proto-ts-v2/esm/generated/injective_auction_rpc_pb.d.ts
/**
 * @generated from protobuf message injective_auction_rpc.AuctionEndpointResponse
 */
interface AuctionEndpointResponse {
  /**
   * The auction
   *
   * @generated from protobuf field: injective_auction_rpc.Auction auction = 1
   */
  auction?: Auction$1;
  /**
   * Bids of the auction
   *
   * @generated from protobuf field: repeated injective_auction_rpc.Bid bids = 2
   */
  bids: Bid$1[];
}
/**
 * @generated from protobuf message injective_auction_rpc.Auction
 */
interface Auction$1 {
  /**
   * Account address of the auction winner
   *
   * @generated from protobuf field: string winner = 1
   */
  winner: string;
  /**
   * Coins in the basket
   *
   * @generated from protobuf field: repeated injective_auction_rpc.Coin basket = 2
   */
  basket: Coin$4[];
  /**
   * @generated from protobuf field: string winning_bid_amount = 3
   */
  winningBidAmount: string;
  /**
   * @generated from protobuf field: uint64 round = 4
   */
  round: bigint;
  /**
   * Auction end timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 end_timestamp = 5
   */
  endTimestamp: bigint;
  /**
   * UpdatedAt timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 updated_at = 6
   */
  updatedAt: bigint;
  /**
   * @generated from protobuf field: injective_auction_rpc.AuctionContract contract = 7
   */
  contract?: AuctionContract$1;
}
/**
 * @generated from protobuf message injective_auction_rpc.Coin
 */
interface Coin$4 {
  /**
   * Denom of the coin
   *
   * @generated from protobuf field: string denom = 1
   */
  denom: string;
  /**
   * @generated from protobuf field: string amount = 2
   */
  amount: string;
  /**
   * @generated from protobuf field: string usd_value = 3
   */
  usdValue: string;
}
/**
 * @generated from protobuf message injective_auction_rpc.AuctionContract
 */
interface AuctionContract$1 {
  /**
   * @generated from protobuf field: uint64 id = 1
   */
  id: bigint;
  /**
   * Bid target of the auction
   *
   * @generated from protobuf field: string bid_target = 2
   */
  bidTarget: string;
  /**
   * Total slots of the auction
   *
   * @generated from protobuf field: uint64 current_slots = 3
   */
  currentSlots: bigint;
  /**
   * Total slots of the auction
   *
   * @generated from protobuf field: uint64 total_slots = 4
   */
  totalSlots: bigint;
  /**
   * Max user allocation of the auction
   *
   * @generated from protobuf field: string max_user_allocation = 5
   */
  maxUserAllocation: string;
  /**
   * Total committed amount of the auction
   *
   * @generated from protobuf field: string total_committed = 6
   */
  totalCommitted: string;
  /**
   * Whitelist addresses for the auction
   *
   * @generated from protobuf field: repeated string whitelist_addresses = 7
   */
  whitelistAddresses: string[];
  /**
   * Auction start timestamp in UNIX millis.
   *
   * @generated from protobuf field: uint64 start_timestamp = 8
   */
  startTimestamp: bigint;
  /**
   * Auction end timestamp in UNIX millis.
   *
   * @generated from protobuf field: uint64 end_timestamp = 9
   */
  endTimestamp: bigint;
  /**
   * Max round allocation of the auction
   *
   * @generated from protobuf field: string max_round_allocation = 10
   */
  maxRoundAllocation: string;
  /**
   * Whether any bid has been placed in the auction.
   *
   * @generated from protobuf field: bool is_bid_placed = 11
   */
  isBidPlaced: boolean;
}
/**
 * @generated from protobuf message injective_auction_rpc.Bid
 */
interface Bid$1 {
  /**
   * Account address of the bidder
   *
   * @generated from protobuf field: string bidder = 1
   */
  bidder: string;
  /**
   * @generated from protobuf field: string amount = 2
   */
  amount: string;
  /**
   * Bid timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 timestamp = 3
   */
  timestamp: bigint;
}
/**
 * @generated from protobuf message injective_auction_rpc.AuctionsResponse
 */
interface AuctionsResponse {
  /**
   * The historical auctions
   *
   * @generated from protobuf field: repeated injective_auction_rpc.Auction auctions = 1
   */
  auctions: Auction$1[];
}
/**
 * @generated from protobuf message injective_auction_rpc.AuctionsHistoryV2Response
 */
interface AuctionsHistoryV2Response {
  /**
   * The historical auctions
   *
   * @generated from protobuf field: repeated injective_auction_rpc.AuctionV2Result auctions = 1
   */
  auctions: AuctionV2Result[];
  /**
   * Next tokens for pagination
   *
   * @generated from protobuf field: repeated string next = 2
   */
  next: string[];
}
/**
 * @generated from protobuf message injective_auction_rpc.AuctionV2Result
 */
interface AuctionV2Result {
  /**
   * Account address of the auction winner
   *
   * @generated from protobuf field: string winner = 1
   */
  winner: string;
  /**
   * Coins in the basket
   *
   * @generated from protobuf field: repeated injective_auction_rpc.CoinPrices basket = 2
   */
  basket: CoinPrices[];
  /**
   * @generated from protobuf field: string winning_bid_amount = 3
   */
  winningBidAmount: string;
  /**
   * @generated from protobuf field: uint64 round = 4
   */
  round: bigint;
  /**
   * Auction end timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 end_timestamp = 5
   */
  endTimestamp: bigint;
  /**
   * UpdatedAt timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 updated_at = 6
   */
  updatedAt: bigint;
  /**
   * @generated from protobuf field: injective_auction_rpc.AuctionContract contract = 7
   */
  contract?: AuctionContract$1;
  /**
   * @generated from protobuf field: string winning_bid_amount_usd = 8
   */
  winningBidAmountUsd: string;
}
/**
 * @generated from protobuf message injective_auction_rpc.CoinPrices
 */
interface CoinPrices {
  /**
   * Denom of the coin
   *
   * @generated from protobuf field: string denom = 1
   */
  denom: string;
  /**
   * @generated from protobuf field: string amount = 2
   */
  amount: string;
  /**
   * Map of historical prices.
   *
   * @generated from protobuf field: map<string, string> prices = 3
   */
  prices: {
    [key: string]: string;
  };
}
/**
 * @generated from protobuf message injective_auction_rpc.AccountAuctionsV2Response
 */
interface AccountAuctionsV2Response {
  /**
   * The historical auctions
   *
   * @generated from protobuf field: repeated injective_auction_rpc.AccountAuctionV2 auctions = 1
   */
  auctions: AccountAuctionV2$1[];
  /**
   * Next tokens for pagination
   *
   * @generated from protobuf field: repeated string next = 2
   */
  next: string[];
  /**
   * Total number of auctions
   *
   * @generated from protobuf field: sint64 total = 3
   */
  total: bigint;
}
/**
 * @generated from protobuf message injective_auction_rpc.AccountAuctionV2
 */
interface AccountAuctionV2$1 {
  /**
   * @generated from protobuf field: uint64 id = 1
   */
  id: bigint;
  /**
   * @generated from protobuf field: uint64 round = 2
   */
  round: bigint;
  /**
   * @generated from protobuf field: string amount_deposited = 3
   */
  amountDeposited: string;
  /**
   * Whether the auction rewards can be claimed.
   *
   * @generated from protobuf field: bool is_claimable = 4
   */
  isClaimable: boolean;
  /**
   * @generated from protobuf field: repeated injective_auction_rpc.CoinPrices claimed_assets = 5
   */
  claimedAssets: CoinPrices[];
}
/**
 * @generated from protobuf message injective_auction_rpc.AuctionAccountStatusResponse
 */
interface AuctionAccountStatusResponse {
  /**
   * The allowlist status of the account
   *
   * @generated from protobuf field: string status = 1
   */
  status: string;
}
/**
 * @generated from protobuf message injective_auction_rpc.StreamBidsResponse
 */
interface StreamBidsResponse$1 {
  /**
   * Account address of the bidder
   *
   * @generated from protobuf field: string bidder = 1
   */
  bidder: string;
  /**
   * @generated from protobuf field: string bid_amount = 2
   */
  bidAmount: string;
  /**
   * @generated from protobuf field: uint64 round = 3
   */
  round: bigint;
  /**
   * Operation timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 timestamp = 4
   */
  timestamp: bigint;
}
/**
 * @generated from protobuf message injective_auction_rpc.AuctionsStatsResponse
 */
interface AuctionsStatsResponse {
  /**
   * Total cumulative amount of INJ burnt in auctions
   *
   * @generated from protobuf field: string total_burnt = 1
   */
  totalBurnt: string;
  /**
   * Total cumulative historical basket value in USD of all auctions
   *
   * @generated from protobuf field: string total_usd_value = 2
   */
  totalUsdValue: string;
}
/**
 * @generated MessageType for protobuf message injective_auction_rpc.AuctionEndpointResponse
 */
declare const AuctionEndpointResponse = new AuctionEndpointResponse$Type();
/**
 * @generated MessageType for protobuf message injective_auction_rpc.Auction
 */
declare const Auction$1 = new Auction$Type();
/**
 * @generated MessageType for protobuf message injective_auction_rpc.Coin
 */
declare const Coin$4 = new Coin$Type();
/**
 * @generated MessageType for protobuf message injective_auction_rpc.AuctionContract
 */
declare const AuctionContract$1 = new AuctionContract$Type();
/**
 * @generated MessageType for protobuf message injective_auction_rpc.Bid
 */
declare const Bid$1 = new Bid$Type();
/**
 * @generated MessageType for protobuf message injective_auction_rpc.AuctionsResponse
 */
declare const AuctionsResponse = new AuctionsResponse$Type();
/**
 * @generated MessageType for protobuf message injective_auction_rpc.AuctionsHistoryV2Response
 */
declare const AuctionsHistoryV2Response = new AuctionsHistoryV2Response$Type();
/**
 * @generated MessageType for protobuf message injective_auction_rpc.AuctionV2Result
 */
declare const AuctionV2Result = new AuctionV2Result$Type();
/**
 * @generated MessageType for protobuf message injective_auction_rpc.CoinPrices
 */
declare const CoinPrices = new CoinPrices$Type();
/**
 * @generated MessageType for protobuf message injective_auction_rpc.AccountAuctionsV2Response
 */
declare const AccountAuctionsV2Response = new AccountAuctionsV2Response$Type();
/**
 * @generated MessageType for protobuf message injective_auction_rpc.AccountAuctionV2
 */
declare const AccountAuctionV2$1 = new AccountAuctionV2$Type();
/**
 * @generated MessageType for protobuf message injective_auction_rpc.AuctionAccountStatusResponse
 */
declare const AuctionAccountStatusResponse = new AuctionAccountStatusResponse$Type();
/**
 * @generated MessageType for protobuf message injective_auction_rpc.StreamBidsResponse
 */
declare const StreamBidsResponse$1 = new StreamBidsResponse$Type();
/**
 * @generated MessageType for protobuf message injective_auction_rpc.AuctionsStatsResponse
 */
declare const AuctionsStatsResponse = new AuctionsStatsResponse$Type();
//#endregion
//#region src/client/indexer/types/auction.d.ts
interface IndexerAuctionBid {
  bidder: string;
  bidAmount: string;
  bidTimestamp: number;
}
interface AuctionCoin {
  denom: string;
  amount: string;
  usdValue: string;
}
interface AuctionCoinPrices {
  denom: string;
  amount: string;
  prices: {
    [key: string]: string;
  };
}
interface AuctionContract {
  id: string;
  bidTarget: string;
  currentSlots: string;
  totalSlots: string;
  maxUserAllocation: string;
  totalCommitted: string;
  whitelistAddresses: string[];
  startTimestamp: string;
  endTimestamp: string;
  maxRoundAllocation: string;
  isBidPlaced: boolean;
}
interface Auction {
  winner: string;
  basket: AuctionCoin[];
  winningBidAmount: string;
  round: number;
  endTimestamp: number;
  updatedAt: number;
  contract?: AuctionContract;
}
interface AuctionV2 {
  winner: string;
  basket: AuctionCoinPrices[];
  winningBidAmount: string;
  winningBidAmountUsd: string;
  round: number;
  endTimestamp: number;
  updatedAt: number;
  contract?: AuctionContract;
}
interface AccountAuctionV2 {
  id: string;
  round: number;
  amountDeposited: string;
  isClaimable: boolean;
  claimedAssets: AuctionCoinPrices[];
}
interface AuctionsStats {
  totalBurnt: string;
  totalBurntInUsd: string;
}
interface AccountAuctionStatus {
  status: string;
}
type GrpcAuction = Auction$1;
type GrpcAuctionCoin = Coin$4;
type GrpcIndexerAuctionBid = Bid$1;
type GrpcAuctionV2 = AuctionV2Result;
type GrpcAuctionCoinPrices = CoinPrices;
type GrpcAccountAuctionV2 = AccountAuctionV2$1;
type GrpcAuctionContract = AuctionContract$1;
type StreamBidsResponse = StreamBidsResponse$1;
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+indexer-proto-ts-v2@1.17.6/node_modules/@injectivelabs/indexer-proto-ts-v2/esm/generated/injective_archiver_rpc_pb.d.ts
/**
 * @generated from protobuf message injective_archiver_rpc.BalanceResponse
 */
interface BalanceResponse {
  /**
   * @generated from protobuf field: injective_archiver_rpc.HistoricalBalance historical_balance = 1
   */
  historicalBalance?: HistoricalBalance$1;
}
/**
 * @generated from protobuf message injective_archiver_rpc.HistoricalBalance
 */
interface HistoricalBalance$1 {
  /**
   * Time, Unix timestamp (UTC)
   *
   * @generated from protobuf field: repeated sint32 t = 1
   */
  t: number[];
  /**
   * Balance value
   *
   * @generated from protobuf field: repeated double v = 2
   */
  v: number[];
  /**
   * Detailed Balance value
   *
   * @generated from protobuf field: repeated injective_archiver_rpc.HistoricalDetailedBalance dv = 3
   */
  dv: HistoricalDetailedBalance[];
}
/**
 * @generated from protobuf message injective_archiver_rpc.HistoricalDetailedBalance
 */
interface HistoricalDetailedBalance {
  /**
   * Spot amount value
   *
   * @generated from protobuf field: double spot = 1
   */
  spot: number;
  /**
   * Perpetual amount value
   *
   * @generated from protobuf field: double perp = 2
   */
  perp: number;
  /**
   * Staking amount value
   *
   * @generated from protobuf field: double staking = 3
   */
  staking: number;
}
/**
 * @generated from protobuf message injective_archiver_rpc.AccountStatsResponse
 */
interface AccountStatsResponse {
  /**
   * Account address
   *
   * @generated from protobuf field: string account = 1
   */
  account: string;
  /**
   * Realized profit and loss (USD)
   *
   * @generated from protobuf field: double pnl = 2
   */
  pnl: number;
  /**
   * Trade volume (USD)
   *
   * @generated from protobuf field: double volume = 3
   */
  volume: number;
  /**
   * Staking amount (INJ)
   *
   * @generated from protobuf field: string stake = 4
   */
  stake: string;
}
/**
 * @generated from protobuf message injective_archiver_rpc.RpnlResponse
 */
interface RpnlResponse {
  /**
   * @generated from protobuf field: injective_archiver_rpc.HistoricalRPNL historical_rpnl = 1
   */
  historicalRpnl?: HistoricalRPNL$1;
}
/**
 * @generated from protobuf message injective_archiver_rpc.HistoricalRPNL
 */
interface HistoricalRPNL$1 {
  /**
   * Time, Unix timestamp (UTC)
   *
   * @generated from protobuf field: repeated sint32 t = 1
   */
  t: number[];
  /**
   * Realized Profit and Loss value
   *
   * @generated from protobuf field: repeated double v = 2
   */
  v: number[];
  /**
   * Detailed Profit and Loss value
   *
   * @generated from protobuf field: repeated injective_archiver_rpc.HistoricalDetailedPNL dv = 3
   */
  dv: HistoricalDetailedPNL[];
}
/**
 * @generated from protobuf message injective_archiver_rpc.HistoricalDetailedPNL
 */
interface HistoricalDetailedPNL {
  /**
   * Realized Profit and Loss value
   *
   * @generated from protobuf field: double rpnl = 1
   */
  rpnl: number;
  /**
   * Unrealized Profit and Loss value
   *
   * @generated from protobuf field: double upnl = 2
   */
  upnl: number;
}
/**
 * @generated from protobuf message injective_archiver_rpc.VolumesResponse
 */
interface VolumesResponse {
  /**
   * @generated from protobuf field: injective_archiver_rpc.HistoricalVolumes historical_volumes = 1
   */
  historicalVolumes?: HistoricalVolumes$1;
}
/**
 * @generated from protobuf message injective_archiver_rpc.HistoricalVolumes
 */
interface HistoricalVolumes$1 {
  /**
   * Time, Unix timestamp (UTC)
   *
   * @generated from protobuf field: repeated sint32 t = 1
   */
  t: number[];
  /**
   * Volume value
   *
   * @generated from protobuf field: repeated double v = 2
   */
  v: number[];
}
/**
 * @generated from protobuf message injective_archiver_rpc.PnlLeaderboardResponse
 */
interface PnlLeaderboardResponse {
  /**
   * First date of snapshots used for the leaderboard period
   *
   * @generated from protobuf field: string first_date = 1
   */
  firstDate: string;
  /**
   * Last date of snapshots used for the leaderboard period
   *
   * @generated from protobuf field: string last_date = 2
   */
  lastDate: string;
  /**
   * Leaderboard entries
   *
   * @generated from protobuf field: repeated injective_archiver_rpc.LeaderboardRow leaders = 3
   */
  leaders: LeaderboardRow$1[];
  /**
   * Leaderboard entry for the querying account
   *
   * @generated from protobuf field: injective_archiver_rpc.LeaderboardRow account_row = 4
   */
  accountRow?: LeaderboardRow$1;
}
/**
 * @generated from protobuf message injective_archiver_rpc.LeaderboardRow
 */
interface LeaderboardRow$1 {
  /**
   * Account address
   *
   * @generated from protobuf field: string account = 1
   */
  account: string;
  /**
   * Realized profit and loss (USD)
   *
   * @generated from protobuf field: double pnl = 2
   */
  pnl: number;
  /**
   * Trade volume (USD)
   *
   * @generated from protobuf field: double volume = 3
   */
  volume: number;
  /**
   * Rank in leaderboard
   *
   * @generated from protobuf field: sint32 rank = 4
   */
  rank: number;
}
/**
 * @generated from protobuf message injective_archiver_rpc.VolLeaderboardResponse
 */
interface VolLeaderboardResponse {
  /**
   * First date of snapshots used for the leaderboard period
   *
   * @generated from protobuf field: string first_date = 1
   */
  firstDate: string;
  /**
   * Last date of snapshots used for the leaderboard period
   *
   * @generated from protobuf field: string last_date = 2
   */
  lastDate: string;
  /**
   * Leaderboard entries
   *
   * @generated from protobuf field: repeated injective_archiver_rpc.LeaderboardRow leaders = 3
   */
  leaders: LeaderboardRow$1[];
  /**
   * Leaderboard entry for the querying account
   *
   * @generated from protobuf field: injective_archiver_rpc.LeaderboardRow account_row = 4
   */
  accountRow?: LeaderboardRow$1;
}
/**
 * @generated from protobuf message injective_archiver_rpc.PnlLeaderboardFixedResolutionResponse
 */
interface PnlLeaderboardFixedResolutionResponse {
  /**
   * First date of snapshots used for the leaderboard period
   *
   * @generated from protobuf field: string first_date = 1
   */
  firstDate: string;
  /**
   * Last date of snapshots used for the leaderboard period
   *
   * @generated from protobuf field: string last_date = 2
   */
  lastDate: string;
  /**
   * Leaderboard entries
   *
   * @generated from protobuf field: repeated injective_archiver_rpc.LeaderboardRow leaders = 3
   */
  leaders: LeaderboardRow$1[];
  /**
   * Leaderboard entry for the querying account
   *
   * @generated from protobuf field: injective_archiver_rpc.LeaderboardRow account_row = 4
   */
  accountRow?: LeaderboardRow$1;
}
/**
 * @generated from protobuf message injective_archiver_rpc.VolLeaderboardFixedResolutionResponse
 */
interface VolLeaderboardFixedResolutionResponse {
  /**
   * First date of snapshots used for the leaderboard period
   *
   * @generated from protobuf field: string first_date = 1
   */
  firstDate: string;
  /**
   * Last date of snapshots used for the leaderboard period
   *
   * @generated from protobuf field: string last_date = 2
   */
  lastDate: string;
  /**
   * Leaderboard entries
   *
   * @generated from protobuf field: repeated injective_archiver_rpc.LeaderboardRow leaders = 3
   */
  leaders: LeaderboardRow$1[];
  /**
   * Leaderboard entry for the querying account
   *
   * @generated from protobuf field: injective_archiver_rpc.LeaderboardRow account_row = 4
   */
  accountRow?: LeaderboardRow$1;
}
/**
 * @generated from protobuf message injective_archiver_rpc.DenomHoldersResponse
 */
interface DenomHoldersResponse {
  /**
   * @generated from protobuf field: repeated injective_archiver_rpc.Holder holders = 1
   */
  holders: Holder$1[];
  /**
   * Next tokens for pagination
   *
   * @generated from protobuf field: repeated string next = 2
   */
  next: string[];
  /**
   * Total number of holders
   *
   * @generated from protobuf field: sint32 total = 3
   */
  total: number;
}
/**
 * @generated from protobuf message injective_archiver_rpc.Holder
 */
interface Holder$1 {
  /**
   * Account address for the holder
   *
   * @generated from protobuf field: string account_address = 1
   */
  accountAddress: string;
  /**
   * The balance of the holder
   *
   * @generated from protobuf field: string balance = 2
   */
  balance: string;
}
/**
 * @generated from protobuf message injective_archiver_rpc.StreamSpotAverageEntriesResponse
 */
interface StreamSpotAverageEntriesResponse {
  /**
   * List of spot average entries
   *
   * @generated from protobuf field: injective_archiver_rpc.SpotAverageEntry average_entry = 1
   */
  averageEntry?: SpotAverageEntry$1;
  /**
   * Operation timestamp in UNIX.
   *
   * @generated from protobuf field: sint64 timestamp = 2
   */
  timestamp: bigint;
}
/**
 * @generated from protobuf message injective_archiver_rpc.SpotAverageEntry
 */
interface SpotAverageEntry$1 {
  /**
   * The ID of the market
   *
   * @generated from protobuf field: string market_id = 1
   */
  marketId: string;
  /**
   * The average entry price for the spot market
   *
   * @generated from protobuf field: string average_entry_price = 2
   */
  averageEntryPrice: string;
  /**
   * The total quantity held in the spot market
   *
   * @generated from protobuf field: string quantity = 3
   */
  quantity: string;
  /**
   * The USD value of the total quantity held in the spot market
   *
   * @generated from protobuf field: string usd_value = 4
   */
  usdValue: string;
}
/**
 * @generated MessageType for protobuf message injective_archiver_rpc.BalanceResponse
 */
declare const BalanceResponse = new BalanceResponse$Type();
/**
 * @generated MessageType for protobuf message injective_archiver_rpc.HistoricalBalance
 */
declare const HistoricalBalance$1 = new HistoricalBalance$Type();
/**
 * @generated MessageType for protobuf message injective_archiver_rpc.HistoricalDetailedBalance
 */
declare const HistoricalDetailedBalance = new HistoricalDetailedBalance$Type();
/**
 * @generated MessageType for protobuf message injective_archiver_rpc.AccountStatsResponse
 */
declare const AccountStatsResponse = new AccountStatsResponse$Type();
/**
 * @generated MessageType for protobuf message injective_archiver_rpc.RpnlResponse
 */
declare const RpnlResponse = new RpnlResponse$Type();
/**
 * @generated MessageType for protobuf message injective_archiver_rpc.HistoricalRPNL
 */
declare const HistoricalRPNL$1 = new HistoricalRPNL$Type();
/**
 * @generated MessageType for protobuf message injective_archiver_rpc.HistoricalDetailedPNL
 */
declare const HistoricalDetailedPNL = new HistoricalDetailedPNL$Type();
/**
 * @generated MessageType for protobuf message injective_archiver_rpc.VolumesResponse
 */
declare const VolumesResponse = new VolumesResponse$Type();
/**
 * @generated MessageType for protobuf message injective_archiver_rpc.HistoricalVolumes
 */
declare const HistoricalVolumes$1 = new HistoricalVolumes$Type();
/**
 * @generated MessageType for protobuf message injective_archiver_rpc.PnlLeaderboardResponse
 */
declare const PnlLeaderboardResponse = new PnlLeaderboardResponse$Type();
/**
 * @generated MessageType for protobuf message injective_archiver_rpc.LeaderboardRow
 */
declare const LeaderboardRow$1 = new LeaderboardRow$Type();
/**
 * @generated MessageType for protobuf message injective_archiver_rpc.VolLeaderboardResponse
 */
declare const VolLeaderboardResponse = new VolLeaderboardResponse$Type();
/**
 * @generated MessageType for protobuf message injective_archiver_rpc.PnlLeaderboardFixedResolutionResponse
 */
declare const PnlLeaderboardFixedResolutionResponse = new PnlLeaderboardFixedResolutionResponse$Type();
/**
 * @generated MessageType for protobuf message injective_archiver_rpc.VolLeaderboardFixedResolutionResponse
 */
declare const VolLeaderboardFixedResolutionResponse = new VolLeaderboardFixedResolutionResponse$Type();
/**
 * @generated MessageType for protobuf message injective_archiver_rpc.DenomHoldersResponse
 */
declare const DenomHoldersResponse = new DenomHoldersResponse$Type();
/**
 * @generated MessageType for protobuf message injective_archiver_rpc.Holder
 */
declare const Holder$1 = new Holder$Type();
/**
 * @generated MessageType for protobuf message injective_archiver_rpc.StreamSpotAverageEntriesResponse
 */
declare const StreamSpotAverageEntriesResponse = new StreamSpotAverageEntriesResponse$Type();
/**
 * @generated MessageType for protobuf message injective_archiver_rpc.SpotAverageEntry
 */
declare const SpotAverageEntry$1 = new SpotAverageEntry$Type();
//#endregion
//#region src/client/indexer/types/archiver.d.ts
interface HistoricalBalance {
  t: number[];
  v: number[];
}
interface HistoricalRPNL {
  t: number[];
  v: number[];
}
interface HistoricalVolumes {
  t: number[];
  v: number[];
}
interface LeaderboardRow {
  account: string;
  pnl: number;
  volume: number;
  rank: number;
}
interface PnlLeaderboard {
  firstDate: string;
  lastDate: string;
  leaders: LeaderboardRow[];
  accountRow: LeaderboardRow | undefined;
}
interface VolLeaderboard {
  firstDate: string;
  lastDate: string;
  leaders: LeaderboardRow[];
  accountRow: LeaderboardRow | undefined;
}
interface Holder {
  accountAddress: string;
  balance: string;
}
interface DenomHolders {
  holders: Holder[];
  next: string[];
  total: number;
}
interface AccountStats {
  pnl: number;
  stake: string;
  volume: number;
}
interface SpotAverageEntry {
  marketId: string;
  averageEntryPrice: string;
  quantity: string;
  usdValue: string;
}
type GrpcHistoricalRPNL = HistoricalRPNL$1;
type GrpcLeaderboardRow = LeaderboardRow$1;
type GrpcDenomHolders = DenomHoldersResponse;
type GrpcSpotAverageEntry = SpotAverageEntry$1;
type GrpcHistoricalBalance = HistoricalBalance$1;
type GrpcHistoricalVolumes = HistoricalVolumes$1;
type GrpcPnlLeaderboard = PnlLeaderboardResponse | PnlLeaderboardFixedResolutionResponse;
type GrpcVolLeaderboard = VolLeaderboardResponse | VolLeaderboardFixedResolutionResponse;
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+indexer-proto-ts-v2@1.17.6/node_modules/@injectivelabs/indexer-proto-ts-v2/esm/generated/injective_referral_rpc_pb.d.ts
/**
 * @generated from protobuf message injective_referral_rpc.GetReferrerDetailsResponse
 */
interface GetReferrerDetailsResponse {
  /**
   * List of invitees
   *
   * @generated from protobuf field: repeated injective_referral_rpc.ReferralInvitee invitees = 1
   */
  invitees: ReferralInvitee[];
  /**
   * Total commission earned
   *
   * @generated from protobuf field: string total_commission = 2
   */
  totalCommission: string;
  /**
   * Total trading volume
   *
   * @generated from protobuf field: string total_trading_volume = 3
   */
  totalTradingVolume: string;
  /**
   * Referrer code
   *
   * @generated from protobuf field: string referrer_code = 4
   */
  referrerCode: string;
}
/**
 * @generated from protobuf message injective_referral_rpc.ReferralInvitee
 */
interface ReferralInvitee {
  /**
   * Address of the invitee
   *
   * @generated from protobuf field: string address = 1
   */
  address: string;
  /**
   * Commission earned from this invitee
   *
   * @generated from protobuf field: string commission = 2
   */
  commission: string;
  /**
   * Trading volume of this invitee
   *
   * @generated from protobuf field: string trading_volume = 3
   */
  tradingVolume: string;
  /**
   * Join date in ISO 8601 format
   *
   * @generated from protobuf field: string join_date = 4
   */
  joinDate: string;
}
/**
 * @generated from protobuf message injective_referral_rpc.GetInviteeDetailsResponse
 */
interface GetInviteeDetailsResponse {
  /**
   * Address of the referrer
   *
   * @generated from protobuf field: string referrer = 1
   */
  referrer: string;
  /**
   * Referral code used
   *
   * @generated from protobuf field: string used_code = 2
   */
  usedCode: string;
  /**
   * Total trading volume
   *
   * @generated from protobuf field: string trading_volume = 3
   */
  tradingVolume: string;
  /**
   * Join date in ISO 8601 format
   *
   * @generated from protobuf field: string joined_at = 4
   */
  joinedAt: string;
  /**
   * Whether the referral is still active
   *
   * @generated from protobuf field: bool active = 5
   */
  active: boolean;
}
/**
 * @generated from protobuf message injective_referral_rpc.GetReferrerByCodeResponse
 */
interface GetReferrerByCodeResponse {
  /**
   * Address of the referrer
   *
   * @generated from protobuf field: string referrer_address = 1
   */
  referrerAddress: string;
}
/**
 * @generated MessageType for protobuf message injective_referral_rpc.GetReferrerDetailsResponse
 */
declare const GetReferrerDetailsResponse = new GetReferrerDetailsResponse$Type();
/**
 * @generated MessageType for protobuf message injective_referral_rpc.ReferralInvitee
 */
declare const ReferralInvitee = new ReferralInvitee$Type();
/**
 * @generated MessageType for protobuf message injective_referral_rpc.GetInviteeDetailsResponse
 */
declare const GetInviteeDetailsResponse = new GetInviteeDetailsResponse$Type();
/**
 * @generated MessageType for protobuf message injective_referral_rpc.GetReferrerByCodeResponse
 */
declare const GetReferrerByCodeResponse = new GetReferrerByCodeResponse$Type();
//#endregion
//#region src/client/indexer/types/referral.d.ts
interface ReferralDetails {
  referrerCode: string;
  referrerAddress: string;
  totalCommission: BigNumber;
  totalTradingVolume: BigNumber;
  invitees: ReferralInvitee[];
}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+indexer-proto-ts-v2@1.17.6/node_modules/@injectivelabs/indexer-proto-ts-v2/esm/generated/injective_campaign_rpc_pb.d.ts
/**
 * @generated from protobuf message injective_campaign_rpc.RankingResponse
 */
interface RankingResponse {
  /**
   * The campaign information
   *
   * @generated from protobuf field: injective_campaign_rpc.Campaign campaign = 1
   */
  campaign?: Campaign$1;
  /**
   * The campaign users
   *
   * @generated from protobuf field: repeated injective_campaign_rpc.CampaignUser users = 2
   */
  users: CampaignUser$1[];
  /**
   * @generated from protobuf field: injective_campaign_rpc.Paging paging = 3
   */
  paging?: Paging$2;
}
/**
 * @generated from protobuf message injective_campaign_rpc.Campaign
 */
interface Campaign$1 {
  /**
   * @generated from protobuf field: string campaign_id = 1
   */
  campaignId: string;
  /**
   * MarketId of the trading strategy
   *
   * @generated from protobuf field: string market_id = 2
   */
  marketId: string;
  /**
   * Total campaign score
   *
   * @generated from protobuf field: string total_score = 4
   */
  totalScore: string;
  /**
   * Last time the campaign score has been updated.
   *
   * @generated from protobuf field: sint64 last_updated = 5
   */
  lastUpdated: bigint;
  /**
   * Campaign start date in UNIX millis.
   *
   * @generated from protobuf field: sint64 start_date = 6
   */
  startDate: bigint;
  /**
   * Campaign end date in UNIX millis.
   *
   * @generated from protobuf field: sint64 end_date = 7
   */
  endDate: bigint;
  /**
   * Whether the campaign rewards can be claimed.
   *
   * @generated from protobuf field: bool is_claimable = 8
   */
  isClaimable: boolean;
  /**
   * Campaigns round ID
   *
   * @generated from protobuf field: sint32 round_id = 9
   */
  roundId: number;
  /**
   * Contract address that controls this campaign
   *
   * @generated from protobuf field: string manager_contract = 10
   */
  managerContract: string;
  /**
   * Reward tokens of this campaign
   *
   * @generated from protobuf field: repeated injective_campaign_rpc.Coin rewards = 11
   */
  rewards: Coin$3[];
  /**
   * Total user score if accountAddress is passed, this is useful to estimate
   * account's reward
   *
   * @generated from protobuf field: string user_score = 12
   */
  userScore: string;
  /**
   * Return true if user claimed the reward of this campaign
   *
   * @generated from protobuf field: bool user_claimed = 13
   */
  userClaimed: boolean;
  /**
   * Suffix of the subaccount that eligible for volume score
   *
   * @generated from protobuf field: string subaccount_id_suffix = 14
   */
  subaccountIdSuffix: string;
  /**
   * Contract that manage users reward
   *
   * @generated from protobuf field: string reward_contract = 15
   */
  rewardContract: string;
  /**
   * Version of reward contract, UI use this to determine the message that need
   * to be sent
   *
   * @generated from protobuf field: string version = 16
   */
  version: string;
  /**
   * Campaign type
   *
   * @generated from protobuf field: string type = 17
   */
  type: string;
}
/**
 * @generated from protobuf message injective_campaign_rpc.Coin
 */
interface Coin$3 {
  /**
   * Denom of the coin
   *
   * @generated from protobuf field: string denom = 1
   */
  denom: string;
  /**
   * @generated from protobuf field: string amount = 2
   */
  amount: string;
  /**
   * @generated from protobuf field: string usd_value = 3
   */
  usdValue: string;
}
/**
 * @generated from protobuf message injective_campaign_rpc.CampaignUser
 */
interface CampaignUser$1 {
  /**
   * @generated from protobuf field: string campaign_id = 1
   */
  campaignId: string;
  /**
   * MarketId of the trading strategy
   *
   * @generated from protobuf field: string market_id = 2
   */
  marketId: string;
  /**
   * Account address
   *
   * @generated from protobuf field: string account_address = 3
   */
  accountAddress: string;
  /**
   * Campaign score
   *
   * @generated from protobuf field: string score = 4
   */
  score: string;
  /**
   * Whether the distribution contract has been updated with the latest score
   *
   * @generated from protobuf field: bool contract_updated = 5
   */
  contractUpdated: boolean;
  /**
   * Block height when the score has been updated.
   *
   * @generated from protobuf field: sint64 block_height = 6
   */
  blockHeight: bigint;
  /**
   * Block time timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 block_time = 7
   */
  blockTime: bigint;
  /**
   * Amount swapped but only count base denom of the market
   *
   * @generated from protobuf field: string purchased_amount = 8
   */
  purchasedAmount: string;
  /**
   * True if this user is updated to be in Galxe Campain list, only eligible
   * address are added
   *
   * @generated from protobuf field: bool galxe_updated = 9
   */
  galxeUpdated: boolean;
  /**
   * True if this user claimed the reward
   *
   * @generated from protobuf field: bool reward_claimed = 10
   */
  rewardClaimed: boolean;
}
/**
 * Paging defines the structure for required params for handling pagination
 *
 * @generated from protobuf message injective_campaign_rpc.Paging
 */
interface Paging$2 {
  /**
   * total number of txs saved in database
   *
   * @generated from protobuf field: sint64 total = 1
   */
  total: bigint;
  /**
   * can be either block height or index num
   *
   * @generated from protobuf field: sint32 from = 2
   */
  from: number;
  /**
   * can be either block height or index num
   *
   * @generated from protobuf field: sint32 to = 3
   */
  to: number;
  /**
   * count entries by subaccount, serving some places on helix
   *
   * @generated from protobuf field: sint64 count_by_subaccount = 4
   */
  countBySubaccount: bigint;
  /**
   * array of tokens to navigate to the next pages
   *
   * @generated from protobuf field: repeated string next = 5
   */
  next: string[];
}
/**
 * @generated from protobuf message injective_campaign_rpc.CampaignsResponse
 */
interface CampaignsResponse {
  /**
   * @generated from protobuf field: repeated injective_campaign_rpc.Campaign campaigns = 1
   */
  campaigns: Campaign$1[];
  /**
   * @generated from protobuf field: repeated injective_campaign_rpc.Coin accumulated_rewards = 2
   */
  accumulatedRewards: Coin$3[];
  /**
   * @generated from protobuf field: sint32 reward_count = 3
   */
  rewardCount: number;
}
/**
 * @generated from protobuf message injective_campaign_rpc.CampaignsV2Response
 */
interface CampaignsV2Response {
  /**
   * @generated from protobuf field: repeated injective_campaign_rpc.CampaignV2 campaigns = 1
   */
  campaigns: CampaignV2$1[];
  /**
   * @generated from protobuf field: string cursor = 2
   */
  cursor: string;
}
/**
 * @generated from protobuf message injective_campaign_rpc.CampaignV2
 */
interface CampaignV2$1 {
  /**
   * @generated from protobuf field: string campaign_id = 1
   */
  campaignId: string;
  /**
   * MarketId of the trading strategy
   *
   * @generated from protobuf field: string market_id = 2
   */
  marketId: string;
  /**
   * Total campaign score
   *
   * @generated from protobuf field: string total_score = 4
   */
  totalScore: string;
  /**
   * Campaign creation date in UNIX millis.
   *
   * @generated from protobuf field: sint64 created_at = 5
   */
  createdAt: bigint;
  /**
   * Campaign last update date in UNIX millis.
   *
   * @generated from protobuf field: sint64 updated_at = 6
   */
  updatedAt: bigint;
  /**
   * Campaign start date in UNIX millis.
   *
   * @generated from protobuf field: sint64 start_date = 7
   */
  startDate: bigint;
  /**
   * Campaign end date in UNIX millis.
   *
   * @generated from protobuf field: sint64 end_date = 8
   */
  endDate: bigint;
  /**
   * Whether the campaign rewards can be claimed.
   *
   * @generated from protobuf field: bool is_claimable = 9
   */
  isClaimable: boolean;
  /**
   * Campaigns round ID
   *
   * @generated from protobuf field: sint32 round_id = 10
   */
  roundId: number;
  /**
   * Contract address that controls this campaign
   *
   * @generated from protobuf field: string manager_contract = 11
   */
  managerContract: string;
  /**
   * Reward tokens of this campaign
   *
   * @generated from protobuf field: repeated injective_campaign_rpc.Coin rewards = 12
   */
  rewards: Coin$3[];
  /**
   * Suffix of the subaccount that eligible for volume score
   *
   * @generated from protobuf field: string subaccount_id_suffix = 13
   */
  subaccountIdSuffix: string;
  /**
   * Contract that manage users reward
   *
   * @generated from protobuf field: string reward_contract = 14
   */
  rewardContract: string;
  /**
   * Campaign type
   *
   * @generated from protobuf field: string type = 15
   */
  type: string;
  /**
   * Version of reward contract, UI use this to determine the message that need
   * to be sent
   *
   * @generated from protobuf field: string version = 16
   */
  version: string;
  /**
   * Campaign name
   *
   * @generated from protobuf field: string name = 17
   */
  name: string;
  /**
   * Campaign description
   *
   * @generated from protobuf field: string description = 18
   */
  description: string;
}
/**
 * @generated from protobuf message injective_campaign_rpc.ListGuildsResponse
 */
interface ListGuildsResponse {
  /**
   * @generated from protobuf field: repeated injective_campaign_rpc.Guild guilds = 1
   */
  guilds: Guild$1[];
  /**
   * @generated from protobuf field: injective_campaign_rpc.Paging paging = 2
   */
  paging?: Paging$2;
  /**
   * Snapshot updated at time in UNIX milli
   *
   * @generated from protobuf field: sint64 updated_at = 3
   */
  updatedAt: bigint;
  /**
   * Summary of the campaign
   *
   * @generated from protobuf field: injective_campaign_rpc.CampaignSummary campaign_summary = 4
   */
  campaignSummary?: CampaignSummary;
}
/**
 * @generated from protobuf message injective_campaign_rpc.Guild
 */
interface Guild$1 {
  /**
   * @generated from protobuf field: string campaign_contract = 1
   */
  campaignContract: string;
  /**
   * Guild ID
   *
   * @generated from protobuf field: string guild_id = 2
   */
  guildId: string;
  /**
   * Guild's master address
   *
   * @generated from protobuf field: string master_address = 3
   */
  masterAddress: string;
  /**
   * Guild creation date (in UNIX milliseconds)
   *
   * @generated from protobuf field: sint64 created_at = 4
   */
  createdAt: bigint;
  /**
   * Average TVL score
   *
   * @generated from protobuf field: string tvl_score = 5
   */
  tvlScore: string;
  /**
   * Total volume score
   *
   * @generated from protobuf field: string volume_score = 6
   */
  volumeScore: string;
  /**
   * guild's rank by volume
   *
   * @generated from protobuf field: sint32 rank_by_volume = 7
   */
  rankByVolume: number;
  /**
   * guild's rank by TVL
   *
   * @generated from protobuf field: sint32 rank_by_tvl = 8
   */
  rankByTvl: number;
  /**
   * guild's logo, at the moment it supports numberic string (i.e '1', '2' and so
   * on) not a random URL because of front end limitation
   *
   * @generated from protobuf field: string logo = 9
   */
  logo: string;
  /**
   * guild's total TVL
   *
   * @generated from protobuf field: string total_tvl = 10
   */
  totalTvl: string;
  /**
   * Snapshot updated at time in UNIX milli
   *
   * @generated from protobuf field: sint64 updated_at = 11
   */
  updatedAt: bigint;
  /**
   * Guild name
   *
   * @generated from protobuf field: string name = 14
   */
  name: string;
  /**
   * Active status of guild, true when master total tvl meets the minimum
   * requirements
   *
   * @generated from protobuf field: bool is_active = 13
   */
  isActive: boolean;
  /**
   * Master balance (in current campaigns denom)
   *
   * @generated from protobuf field: string master_balance = 15
   */
  masterBalance: string;
  /**
   * Guild description, set by master of the guild
   *
   * @generated from protobuf field: string description = 16
   */
  description: string;
}
/**
 * @generated from protobuf message injective_campaign_rpc.CampaignSummary
 */
interface CampaignSummary {
  /**
   * Campaign id
   *
   * @generated from protobuf field: string campaign_id = 1
   */
  campaignId: string;
  /**
   * Guild manager contract address
   *
   * @generated from protobuf field: string campaign_contract = 2
   */
  campaignContract: string;
  /**
   * Number of guild in the campaign
   *
   * @generated from protobuf field: sint32 total_guilds_count = 3
   */
  totalGuildsCount: number;
  /**
   * Total TVL
   *
   * @generated from protobuf field: string total_tvl = 4
   */
  totalTvl: string;
  /**
   * Sum average TVL of all guilds
   *
   * @generated from protobuf field: string total_average_tvl = 5
   */
  totalAverageTvl: string;
  /**
   * Total volume across all guilds (in market quote denom, often USDT)
   *
   * @generated from protobuf field: string total_volume = 6
   */
  totalVolume: string;
  /**
   * Snapshot updated at time in UNIX milli
   *
   * @generated from protobuf field: sint64 updated_at = 7
   */
  updatedAt: bigint;
  /**
   * Total member joined the campaign (include guild masters)
   *
   * @generated from protobuf field: sint32 total_members_count = 8
   */
  totalMembersCount: number;
  /**
   * Campaign start time
   *
   * @generated from protobuf field: sint64 start_time = 9
   */
  startTime: bigint;
  /**
   * Campaign end time
   *
   * @generated from protobuf field: sint64 end_time = 10
   */
  endTime: bigint;
}
/**
 * @generated from protobuf message injective_campaign_rpc.ListGuildMembersResponse
 */
interface ListGuildMembersResponse {
  /**
   * @generated from protobuf field: repeated injective_campaign_rpc.GuildMember members = 1
   */
  members: GuildMember$1[];
  /**
   * @generated from protobuf field: injective_campaign_rpc.Paging paging = 2
   */
  paging?: Paging$2;
  /**
   * @generated from protobuf field: injective_campaign_rpc.Guild guild_info = 3
   */
  guildInfo?: Guild$1;
}
/**
 * @generated from protobuf message injective_campaign_rpc.GuildMember
 */
interface GuildMember$1 {
  /**
   * Guild manager contract address
   *
   * @generated from protobuf field: string campaign_contract = 1
   */
  campaignContract: string;
  /**
   * Guild ID
   *
   * @generated from protobuf field: string guild_id = 2
   */
  guildId: string;
  /**
   * Guild member address
   *
   * @generated from protobuf field: string address = 3
   */
  address: string;
  /**
   * Guild enrollment date (in UNIX milliseconds)
   *
   * @generated from protobuf field: sint64 joined_at = 4
   */
  joinedAt: bigint;
  /**
   * Average TVL score
   *
   * @generated from protobuf field: string tvl_score = 5
   */
  tvlScore: string;
  /**
   * Total volume score
   *
   * @generated from protobuf field: string volume_score = 6
   */
  volumeScore: string;
  /**
   * Total volume score
   *
   * @generated from protobuf field: string total_tvl = 7
   */
  totalTvl: string;
  /**
   * Volume percentage out of guilds total volume
   *
   * @generated from protobuf field: double volume_score_percentage = 8
   */
  volumeScorePercentage: number;
  /**
   * TVL percentage out of guilds total TVL score
   *
   * @generated from protobuf field: double tvl_score_percentage = 9
   */
  tvlScorePercentage: number;
  /**
   * Rewards for volume campaign (amount+denom)
   *
   * @generated from protobuf field: repeated injective_campaign_rpc.Coin tvl_reward = 10
   */
  tvlReward: Coin$3[];
  /**
   * Rewards for TVL campaign (amount+denom)
   *
   * @generated from protobuf field: repeated injective_campaign_rpc.Coin volume_reward = 11
   */
  volumeReward: Coin$3[];
}
/**
 * @generated from protobuf message injective_campaign_rpc.GetGuildMemberResponse
 */
interface GetGuildMemberResponse {
  /**
   * @generated from protobuf field: injective_campaign_rpc.GuildMember info = 1
   */
  info?: GuildMember$1;
}
/**
 * @generated MessageType for protobuf message injective_campaign_rpc.RankingResponse
 */
declare const RankingResponse = new RankingResponse$Type();
/**
 * @generated MessageType for protobuf message injective_campaign_rpc.Campaign
 */
declare const Campaign$1 = new Campaign$Type();
/**
 * @generated MessageType for protobuf message injective_campaign_rpc.Coin
 */
declare const Coin$3 = new Coin$Type();
/**
 * @generated MessageType for protobuf message injective_campaign_rpc.CampaignUser
 */
declare const CampaignUser$1 = new CampaignUser$Type();
/**
 * @generated MessageType for protobuf message injective_campaign_rpc.Paging
 */
declare const Paging$2 = new Paging$Type();
/**
 * @generated MessageType for protobuf message injective_campaign_rpc.CampaignsResponse
 */
declare const CampaignsResponse = new CampaignsResponse$Type();
/**
 * @generated MessageType for protobuf message injective_campaign_rpc.CampaignsV2Response
 */
declare const CampaignsV2Response = new CampaignsV2Response$Type();
/**
 * @generated MessageType for protobuf message injective_campaign_rpc.CampaignV2
 */
declare const CampaignV2$1 = new CampaignV2$Type();
/**
 * @generated MessageType for protobuf message injective_campaign_rpc.ListGuildsResponse
 */
declare const ListGuildsResponse = new ListGuildsResponse$Type();
/**
 * @generated MessageType for protobuf message injective_campaign_rpc.Guild
 */
declare const Guild$1 = new Guild$Type();
/**
 * @generated MessageType for protobuf message injective_campaign_rpc.CampaignSummary
 */
declare const CampaignSummary = new CampaignSummary$Type();
/**
 * @generated MessageType for protobuf message injective_campaign_rpc.ListGuildMembersResponse
 */
declare const ListGuildMembersResponse = new ListGuildMembersResponse$Type();
/**
 * @generated MessageType for protobuf message injective_campaign_rpc.GuildMember
 */
declare const GuildMember$1 = new GuildMember$Type();
/**
 * @generated MessageType for protobuf message injective_campaign_rpc.GetGuildMemberResponse
 */
declare const GetGuildMemberResponse = new GetGuildMemberResponse$Type();
//#endregion
//#region src/client/indexer/types/campaign.d.ts
interface Campaign {
  campaignId: string;
  marketId: string;
  totalScore: string;
  lastUpdated: number;
  startDate: number;
  endDate: number;
  isClaimable: boolean;
  rewards: Coin[];
  roundId: number;
  userClaimed: boolean;
  userScore: string;
  rewardContract: string;
  version: string;
}
interface CampaignUser {
  campaignId: string;
  marketId: string;
  accountAddress: string;
  score: string;
  contractUpdated: boolean;
  blockHeight: string;
  blockTime: number;
  purchasedAmount: string;
  galxeUpdated: boolean;
}
interface Guild {
  campaignContract: string;
  guildId: string;
  masterAddress: string;
  createdAt: number;
  tvlScore: string;
  volumeScore: string;
  rankByVolume: number;
  rankByTvl: number;
  logo: string;
  totalTvl: string;
  updatedAt: number;
  name: string;
  isActive: boolean;
  description: string;
  masterBalance: string;
}
interface GuildMember {
  campaignContract: string;
  guildId: string;
  address: string;
  joinedAt: number;
  tvlScore: string;
  volumeScore: string;
  totalTvl: string;
  volumeScorePercentage: number;
  tvlScorePercentage: number;
  tvlReward: Coin[];
  volumeReward: Coin[];
}
interface GuildCampaignSummary {
  campaignId: string;
  campaignContract: string;
  totalGuildsCount: number;
  totalTvl: string;
  totalAverageTvl: string;
  totalVolume: string;
  updatedAt: number;
  totalMembersCount: number;
  startTime: number;
  endTime: number;
}
interface CampaignV2 {
  campaignId: string;
  marketId: string;
  totalScore: string;
  createdAt: number;
  updatedAt: number;
  startDate: number;
  endDate: number;
  isClaimable: boolean;
  roundId: number;
  managerContract: string;
  rewards: Coin[];
  subaccountIdSuffix: string;
  rewardContract: string;
  type: string;
  version: string;
  name: string;
  description: string;
}
type GrpcGuild = Guild$1;
type GrpcCampaign = Campaign$1;
type GrpcGuildMember = GuildMember$1;
type GrpcCampaignUser = CampaignUser$1;
type GrpcCampaignV2 = CampaignV2$1;
//#endregion
//#region src/client/indexer/types/spot-rest.d.ts
type ChronosSpotMarketSummary = {
  change: number;
  high: number;
  low: number;
  open: number;
  price: number;
  volume: number;
};
type AllChronosSpotMarketSummary = {
  change: number;
  high: number;
  low: number;
  open: number;
  price: number;
  volume: number;
  marketId: string;
};
interface ChronosSpotMarketSummaryResponse {
  data: ChronosSpotMarketSummary;
}
interface AllSpotMarketSummaryResponse {
  data: AllChronosSpotMarketSummary[];
}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+indexer-proto-ts-v2@1.17.6/node_modules/@injectivelabs/indexer-proto-ts-v2/esm/generated/injective_megavault_rpc_pb.d.ts
/**
 * @generated from protobuf message injective_megavault_rpc.GetVaultResponse
 */
interface GetVaultResponse {
  /**
   * The vault
   *
   * @generated from protobuf field: injective_megavault_rpc.Vault vault = 1
   */
  vault?: Vault;
}
/**
 * @generated from protobuf message injective_megavault_rpc.Vault
 */
interface Vault {
  /**
   * Contract address
   *
   * @generated from protobuf field: string contract_address = 1
   */
  contractAddress: string;
  /**
   * Contract name
   *
   * @generated from protobuf field: string contract_name = 2
   */
  contractName: string;
  /**
   * Contract version
   *
   * @generated from protobuf field: string contract_version = 3
   */
  contractVersion: string;
  /**
   * Admin
   *
   * @generated from protobuf field: string admin = 4
   */
  admin: string;
  /**
   * LP denom
   *
   * @generated from protobuf field: string lp_denom = 5
   */
  lpDenom: string;
  /**
   * Quote denom
   *
   * @generated from protobuf field: string quote_denom = 6
   */
  quoteDenom: string;
  /**
   * Operators
   *
   * @generated from protobuf field: repeated injective_megavault_rpc.Operator operators = 7
   */
  operators: Operator[];
  /**
   * Incentives
   *
   * @generated from protobuf field: injective_megavault_rpc.Incentives incentives = 8
   */
  incentives?: Incentives;
  /**
   * TargetApr
   *
   * @generated from protobuf field: injective_megavault_rpc.TargetApr target_apr = 9
   */
  targetApr?: TargetApr;
  /**
   * Operators
   *
   * @generated from protobuf field: injective_megavault_rpc.VaultStats stats = 10
   */
  stats?: VaultStats;
  /**
   * Block height when the vault was created.
   *
   * @generated from protobuf field: sint64 created_height = 11
   */
  createdHeight: bigint;
  /**
   * CreatedAt timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 created_at = 12
   */
  createdAt: bigint;
  /**
   * Block height when the vault was updated.
   *
   * @generated from protobuf field: sint64 updated_height = 13
   */
  updatedHeight: bigint;
  /**
   * UpdatedAt timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 updated_at = 14
   */
  updatedAt: bigint;
}
/**
 * @generated from protobuf message injective_megavault_rpc.Operator
 */
interface Operator {
  /**
   * Operator address
   *
   * @generated from protobuf field: string address = 1
   */
  address: string;
  /**
   * Total amount
   *
   * @generated from protobuf field: string total_amount = 2
   */
  totalAmount: string;
  /**
   * Total liquid amount
   *
   * @generated from protobuf field: string total_liquid_amount = 3
   */
  totalLiquidAmount: string;
  /**
   * Block height when the operator was updated.
   *
   * @generated from protobuf field: sint64 updated_height = 4
   */
  updatedHeight: bigint;
  /**
   * UpdatedAt timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 updated_at = 5
   */
  updatedAt: bigint;
  /**
   * Percentage of the operator
   *
   * @generated from protobuf field: string percentage = 6
   */
  percentage: string;
  /**
   * Subaccount ID of the operator
   *
   * @generated from protobuf field: string subaccount_id = 7
   */
  subaccountId: string;
}
/**
 * @generated from protobuf message injective_megavault_rpc.Incentives
 */
interface Incentives {
  /**
   * Operator address
   *
   * @generated from protobuf field: string address = 1
   */
  address: string;
  /**
   * Amount
   *
   * @generated from protobuf field: string amount = 2
   */
  amount: string;
  /**
   * Block height when the target APR was updated.
   *
   * @generated from protobuf field: sint64 updated_height = 3
   */
  updatedHeight: bigint;
  /**
   * UpdatedAt timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 updated_at = 4
   */
  updatedAt: bigint;
}
/**
 * @generated from protobuf message injective_megavault_rpc.TargetApr
 */
interface TargetApr {
  /**
   * APR
   *
   * @generated from protobuf field: string apr = 1
   */
  apr: string;
  /**
   * Upper threshold
   *
   * @generated from protobuf field: string upper_threshold = 2
   */
  upperThreshold: string;
  /**
   * Lower threshold
   *
   * @generated from protobuf field: string lower_threshold = 3
   */
  lowerThreshold: string;
  /**
   * Block height when the target APR was updated.
   *
   * @generated from protobuf field: sint64 updated_height = 4
   */
  updatedHeight: bigint;
  /**
   * UpdatedAt timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 updated_at = 5
   */
  updatedAt: bigint;
}
/**
 * @generated from protobuf message injective_megavault_rpc.VaultStats
 */
interface VaultStats {
  /**
   * Total subscribed amount in the vault
   *
   * @generated from protobuf field: string total_subscribed_amount = 1
   */
  totalSubscribedAmount: string;
  /**
   * Total redeemed amount in the vault
   *
   * @generated from protobuf field: string total_redeemed_amount = 2
   */
  totalRedeemedAmount: string;
  /**
   * Current amount in the vault
   *
   * @generated from protobuf field: string current_amount = 3
   */
  currentAmount: string;
  /**
   * Current amount in the vault without taking into account the incentives
   *
   * @generated from protobuf field: string current_amount_without_incentives = 4
   */
  currentAmountWithoutIncentives: string;
  /**
   * Current amount of LP tokens in the vault
   *
   * @generated from protobuf field: string current_lp_amount = 5
   */
  currentLpAmount: string;
  /**
   * Current LP price
   *
   * @generated from protobuf field: string current_lp_price = 6
   */
  currentLpPrice: string;
  /**
   * PnL statistics
   *
   * @generated from protobuf field: injective_megavault_rpc.PnlStats pnl = 7
   */
  pnl?: PnlStats;
  /**
   * Volatility statistics
   *
   * @generated from protobuf field: injective_megavault_rpc.VolatilityStats volatility = 8
   */
  volatility?: VolatilityStats;
  /**
   * APR statistics
   *
   * @generated from protobuf field: injective_megavault_rpc.AprStats apr = 9
   */
  apr?: AprStats;
  /**
   * Max drawdown
   *
   * @generated from protobuf field: injective_megavault_rpc.MaxDrawdown max_drawdown = 10
   */
  maxDrawdown?: MaxDrawdown;
}
/**
 * @generated from protobuf message injective_megavault_rpc.PnlStats
 */
interface PnlStats {
  /**
   * Unrealized PnL
   *
   * @generated from protobuf field: injective_megavault_rpc.UnrealizedPnl unrealized = 1
   */
  unrealized?: UnrealizedPnl;
  /**
   * All-time PnL
   *
   * @generated from protobuf field: injective_megavault_rpc.Pnl all_time = 2
   */
  allTime?: Pnl;
}
/**
 * @generated from protobuf message injective_megavault_rpc.UnrealizedPnl
 */
interface UnrealizedPnl {
  /**
   * Unrealized PnL value
   *
   * @generated from protobuf field: string value = 1
   */
  value: string;
  /**
   * Unrealized PnL percentage
   *
   * @generated from protobuf field: string percentage = 2
   */
  percentage: string;
}
/**
 * @generated from protobuf message injective_megavault_rpc.Pnl
 */
interface Pnl {
  /**
   * PnL value
   *
   * @generated from protobuf field: string value = 1
   */
  value: string;
  /**
   * PnL percentage
   *
   * @generated from protobuf field: string percentage = 2
   */
  percentage: string;
  /**
   * Total amount subscribed
   *
   * @generated from protobuf field: string total_amount_subscribed = 3
   */
  totalAmountSubscribed: string;
  /**
   * Total amount redeemed
   *
   * @generated from protobuf field: string total_amount_redeemed = 4
   */
  totalAmountRedeemed: string;
  /**
   * Current amount
   *
   * @generated from protobuf field: string current_amount = 5
   */
  currentAmount: string;
}
/**
 * @generated from protobuf message injective_megavault_rpc.VolatilityStats
 */
interface VolatilityStats {
  /**
   * 30-days volatility
   *
   * @generated from protobuf field: injective_megavault_rpc.Volatility thirty_days = 1
   */
  thirtyDays?: Volatility;
}
/**
 * @generated from protobuf message injective_megavault_rpc.Volatility
 */
interface Volatility {
  /**
   * Volatility value
   *
   * @generated from protobuf field: string value = 1
   */
  value: string;
}
/**
 * @generated from protobuf message injective_megavault_rpc.AprStats
 */
interface AprStats {
  /**
   * 30-day APR
   *
   * @generated from protobuf field: injective_megavault_rpc.Apr thirty_days = 1
   */
  thirtyDays?: Apr;
}
/**
 * @generated from protobuf message injective_megavault_rpc.Apr
 */
interface Apr {
  /**
   * APR value
   *
   * @generated from protobuf field: string value = 1
   */
  value: string;
  /**
   * Original LP price
   *
   * @generated from protobuf field: string original_lp_price = 2
   */
  originalLpPrice: string;
  /**
   * Current LP price
   *
   * @generated from protobuf field: string current_lp_price = 3
   */
  currentLpPrice: string;
}
/**
 * @generated from protobuf message injective_megavault_rpc.MaxDrawdown
 */
interface MaxDrawdown {
  /**
   * Max drawdown value
   *
   * @generated from protobuf field: string value = 1
   */
  value: string;
  /**
   * Latest PnL peak
   *
   * @generated from protobuf field: string latest_pn_l_peak = 2
   */
  latestPnLPeak: string;
}
/**
 * @generated from protobuf message injective_megavault_rpc.GetUserResponse
 */
interface GetUserResponse {
  /**
   * The user
   *
   * @generated from protobuf field: injective_megavault_rpc.User user = 1
   */
  user?: User;
}
/**
 * @generated from protobuf message injective_megavault_rpc.User
 */
interface User {
  /**
   * User address
   *
   * @generated from protobuf field: string address = 1
   */
  address: string;
  /**
   * Contract address
   *
   * @generated from protobuf field: string contract_address = 2
   */
  contractAddress: string;
  /**
   * User stats
   *
   * @generated from protobuf field: injective_megavault_rpc.UserStats stats = 3
   */
  stats?: UserStats;
  /**
   * Block height when the vault was created.
   *
   * @generated from protobuf field: sint64 created_height = 4
   */
  createdHeight: bigint;
  /**
   * CreatedAt timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 created_at = 5
   */
  createdAt: bigint;
  /**
   * Block height when the vault was updated.
   *
   * @generated from protobuf field: sint64 updated_height = 6
   */
  updatedHeight: bigint;
  /**
   * UpdatedAt timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 updated_at = 7
   */
  updatedAt: bigint;
}
/**
 * @generated from protobuf message injective_megavault_rpc.UserStats
 */
interface UserStats {
  /**
   * Current subscribed amount in the vault
   *
   * @generated from protobuf field: string current_amount = 1
   */
  currentAmount: string;
  /**
   * Current amount of LP tokens in the vault
   *
   * @generated from protobuf field: string current_lp_amount = 2
   */
  currentLpAmount: string;
  /**
   * PnL statistics
   *
   * @generated from protobuf field: injective_megavault_rpc.PnlStats pnl = 3
   */
  pnl?: PnlStats;
  /**
   * Current deposisted value
   *
   * @generated from protobuf field: string deposited_value = 4
   */
  depositedValue: string;
}
/**
 * @generated from protobuf message injective_megavault_rpc.ListSubscriptionsResponse
 */
interface ListSubscriptionsResponse {
  /**
   * List of subscriptions
   *
   * @generated from protobuf field: repeated injective_megavault_rpc.Subscription subscriptions = 1
   */
  subscriptions: Subscription$1[];
  /**
   * Next tokens for pagination
   *
   * @generated from protobuf field: repeated string next = 2
   */
  next: string[];
}
/**
 * @generated from protobuf message injective_megavault_rpc.Subscription
 */
interface Subscription$1 {
  /**
   * Contract address
   *
   * @generated from protobuf field: string contract_address = 1
   */
  contractAddress: string;
  /**
   * User
   *
   * @generated from protobuf field: string user = 2
   */
  user: string;
  /**
   * Index number of the subscription
   *
   * @generated from protobuf field: sint64 index = 3
   */
  index: bigint;
  /**
   * Amount of LP tokens given to the user for the subscription
   *
   * @generated from protobuf field: string lp_amount = 4
   */
  lpAmount: string;
  /**
   * Amount in USDT the user gave for the subscription
   *
   * @generated from protobuf field: string amount = 5
   */
  amount: string;
  /**
   * Status of the subscription
   *
   * @generated from protobuf field: string status = 6
   */
  status: string;
  /**
   * Block height when the subscription was created.
   *
   * @generated from protobuf field: sint64 created_height = 7
   */
  createdHeight: bigint;
  /**
   * CreatedAt timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 created_at = 8
   */
  createdAt: bigint;
  /**
   * Block height when the subscription was executed.
   *
   * @generated from protobuf field: sint64 executed_height = 9
   */
  executedHeight: bigint;
  /**
   * ExecutedAt timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 executed_at = 10
   */
  executedAt: bigint;
  /**
   * Subscription status log
   *
   * @generated from protobuf field: repeated injective_megavault_rpc.OperationStatusLogEntry log = 11
   */
  log: OperationStatusLogEntry$1[];
}
/**
 * @generated from protobuf message injective_megavault_rpc.OperationStatusLogEntry
 */
interface OperationStatusLogEntry$1 {
  /**
   * Status of the subscription at this log entry
   *
   * @generated from protobuf field: string status = 1
   */
  status: string;
  /**
   * Transaction hash associated with this log entry
   *
   * @generated from protobuf field: string tx_hash = 2
   */
  txHash: string;
  /**
   * Block height when this log entry occurred
   *
   * @generated from protobuf field: sint64 block_height = 3
   */
  blockHeight: bigint;
  /**
   * Timestamp when this log entry occurred in UNIX millis.
   *
   * @generated from protobuf field: sint64 block_time = 4
   */
  blockTime: bigint;
}
/**
 * @generated from protobuf message injective_megavault_rpc.ListRedemptionsResponse
 */
interface ListRedemptionsResponse {
  /**
   * List of subscriptions
   *
   * @generated from protobuf field: repeated injective_megavault_rpc.Redemption redemptions = 1
   */
  redemptions: Redemption$1[];
  /**
   * Next tokens for pagination
   *
   * @generated from protobuf field: repeated string next = 2
   */
  next: string[];
}
/**
 * @generated from protobuf message injective_megavault_rpc.Redemption
 */
interface Redemption$1 {
  /**
   * Contract address
   *
   * @generated from protobuf field: string contract_address = 1
   */
  contractAddress: string;
  /**
   * User
   *
   * @generated from protobuf field: string user = 2
   */
  user: string;
  /**
   * Index number of the redemption
   *
   * @generated from protobuf field: sint64 index = 3
   */
  index: bigint;
  /**
   * Amount of LP tokens given to the user for the redemption
   *
   * @generated from protobuf field: string lp_amount = 4
   */
  lpAmount: string;
  /**
   * Amount in USDT the user gave for the redemption
   *
   * @generated from protobuf field: string amount = 5
   */
  amount: string;
  /**
   * Status of the subscription
   *
   * @generated from protobuf field: string status = 6
   */
  status: string;
  /**
   * DueAt timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 due_at = 7
   */
  dueAt: bigint;
  /**
   * Block height when the subscription was created.
   *
   * @generated from protobuf field: sint64 created_height = 8
   */
  createdHeight: bigint;
  /**
   * CreatedAt timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 created_at = 9
   */
  createdAt: bigint;
  /**
   * Block height when the subscription was executed.
   *
   * @generated from protobuf field: sint64 executed_height = 10
   */
  executedHeight: bigint;
  /**
   * ExecutedAt timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 executed_at = 11
   */
  executedAt: bigint;
  /**
   * Redemption status log
   *
   * @generated from protobuf field: repeated injective_megavault_rpc.OperationStatusLogEntry log = 12
   */
  log: OperationStatusLogEntry$1[];
}
/**
 * @generated from protobuf message injective_megavault_rpc.GetOperatorRedemptionBucketsResponse
 */
interface GetOperatorRedemptionBucketsResponse {
  /**
   * The redemption buckets
   *
   * @generated from protobuf field: repeated injective_megavault_rpc.RedemptionBucket buckets = 1
   */
  buckets: RedemptionBucket[];
}
/**
 * @generated from protobuf message injective_megavault_rpc.RedemptionBucket
 */
interface RedemptionBucket {
  /**
   * Bucket
   *
   * @generated from protobuf field: string bucket = 1
   */
  bucket: string;
  /**
   * Amount of LP tokens to redeem
   *
   * @generated from protobuf field: string lp_amount_to_redeem = 2
   */
  lpAmountToRedeem: string;
  /**
   * Amount needed to cover all the redemptions in the bucket
   *
   * @generated from protobuf field: string needed_amount = 3
   */
  neededAmount: string;
  /**
   * Amount of liquidity missing needed to cover all the redemptions in the bucket
   *
   * @generated from protobuf field: string missing_liquidity = 4
   */
  missingLiquidity: string;
}
/**
 * @generated from protobuf message injective_megavault_rpc.TvlHistoryResponse
 */
interface TvlHistoryResponse {
  /**
   * @generated from protobuf field: repeated injective_megavault_rpc.HistoricalTVL history = 1
   */
  history: HistoricalTVL[];
}
/**
 * @generated from protobuf message injective_megavault_rpc.HistoricalTVL
 */
interface HistoricalTVL {
  /**
   * Time, Unix timestamp in milliseconds (UTC)
   *
   * @generated from protobuf field: sint64 t = 1
   */
  t: bigint;
  /**
   * TVL Value
   *
   * @generated from protobuf field: string v = 2
   */
  v: string;
}
/**
 * @generated from protobuf message injective_megavault_rpc.PnlHistoryResponse
 */
interface PnlHistoryResponse {
  /**
   * @generated from protobuf field: repeated injective_megavault_rpc.HistoricalPnL history = 1
   */
  history: HistoricalPnL[];
}
/**
 * @generated from protobuf message injective_megavault_rpc.HistoricalPnL
 */
interface HistoricalPnL {
  /**
   * Time, Unix timestamp in milliseconds (UTC)
   *
   * @generated from protobuf field: sint64 t = 1
   */
  t: bigint;
  /**
   * PnL Value
   *
   * @generated from protobuf field: string v = 2
   */
  v: string;
}
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.GetVaultResponse
 */
declare const GetVaultResponse = new GetVaultResponse$Type();
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.Vault
 */
declare const Vault = new Vault$Type();
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.Operator
 */
declare const Operator = new Operator$Type();
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.Incentives
 */
declare const Incentives = new Incentives$Type();
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.TargetApr
 */
declare const TargetApr = new TargetApr$Type();
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.VaultStats
 */
declare const VaultStats = new VaultStats$Type();
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.PnlStats
 */
declare const PnlStats = new PnlStats$Type();
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.UnrealizedPnl
 */
declare const UnrealizedPnl = new UnrealizedPnl$Type();
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.Pnl
 */
declare const Pnl = new Pnl$Type();
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.VolatilityStats
 */
declare const VolatilityStats = new VolatilityStats$Type();
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.Volatility
 */
declare const Volatility = new Volatility$Type();
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.AprStats
 */
declare const AprStats = new AprStats$Type();
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.Apr
 */
declare const Apr = new Apr$Type();
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.MaxDrawdown
 */
declare const MaxDrawdown = new MaxDrawdown$Type();
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.GetUserResponse
 */
declare const GetUserResponse = new GetUserResponse$Type();
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.User
 */
declare const User = new User$Type();
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.UserStats
 */
declare const UserStats = new UserStats$Type();
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.ListSubscriptionsResponse
 */
declare const ListSubscriptionsResponse = new ListSubscriptionsResponse$Type();
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.Subscription
 */
declare const Subscription$1 = new Subscription$Type();
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.OperationStatusLogEntry
 */
declare const OperationStatusLogEntry$1 = new OperationStatusLogEntry$Type();
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.ListRedemptionsResponse
 */
declare const ListRedemptionsResponse = new ListRedemptionsResponse$Type();
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.Redemption
 */
declare const Redemption$1 = new Redemption$Type();
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.GetOperatorRedemptionBucketsResponse
 */
declare const GetOperatorRedemptionBucketsResponse = new GetOperatorRedemptionBucketsResponse$Type();
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.RedemptionBucket
 */
declare const RedemptionBucket = new RedemptionBucket$Type();
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.TvlHistoryResponse
 */
declare const TvlHistoryResponse = new TvlHistoryResponse$Type();
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.HistoricalTVL
 */
declare const HistoricalTVL = new HistoricalTVL$Type();
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.PnlHistoryResponse
 */
declare const PnlHistoryResponse = new PnlHistoryResponse$Type();
/**
 * @generated MessageType for protobuf message injective_megavault_rpc.HistoricalPnL
 */
declare const HistoricalPnL = new HistoricalPnL$Type();
//#endregion
//#region src/client/indexer/types/mega-vault.d.ts
interface OperationStatusLogEntry {
  status: string;
  txHash: string;
  blockTime: string;
  blockHeight: string;
}
interface MegaVaultOperator {
  address: string;
  updatedAt: string;
  percentage: string;
  totalAmount: string;
  subaccountId: string;
  updatedHeight: string;
  totalLiquidAmount: string;
}
interface MegaVault {
  admin: string;
  lpDenom: string;
  createdAt: string;
  updatedAt: string;
  quoteDenom: string;
  contractName: string;
  createdHeight: string;
  updatedHeight: string;
  contractAddress: string;
  contractVersion: string;
  operators: MegaVaultOperator[];
  stats: MegaVaultStats | undefined;
  incentives: MegaVaultIncentives | undefined;
  targetApr: MegaVaultTargetApr | undefined;
}
interface MegaVaultIncentives {
  amount: string;
  address: string;
  updatedAt: string;
  updatedHeight: string;
}
interface MegaVaultStats {
  currentAmount: string;
  currentLpPrice: string;
  currentLpAmount: string;
  totalRedeemedAmount: string;
  totalSubscribedAmount: string;
  apr: MegaVaultAprStats | undefined;
  pnl: MegaVaultPnlStats | undefined;
  currentAmountWithoutIncentives: string;
  maxDrawdown: MegaVaultMaxDrawdown | undefined;
  volatility: MegaVaultVolatilityStats | undefined;
}
interface MegaVaultPnlStats {
  allTime: MegaVaultPnl | undefined;
  unrealized: MegaVaultUnrealizedPnl | undefined;
}
interface MegaVaultUnrealizedPnl {
  value: string;
  percentage: string;
}
interface MegaVaultPnl {
  value: string;
  percentage: string;
  currentAmount: string;
  totalAmountRedeemed: string;
  totalAmountSubscribed: string;
}
interface MegaVaultMaxDrawdown {
  value: string;
  latestPnLPeak: string;
}
interface MegaVaultVolatilityStats {
  thirtyDays: MegaVaultVolatility | undefined;
}
interface MegaVaultVolatility {
  value: string;
}
interface MegaVaultAprStats {
  thirtyDays: MegaVaultApr | undefined;
}
interface MegaVaultApr {
  value: string;
  currentLpPrice: string;
  originalLpPrice: string;
}
interface MegaVaultUser {
  address: string;
  updatedAt: string;
  updatedHeight: string;
  contractAddress: string;
  stats: MegaVaultUserStats | undefined;
}
interface MegaVaultUserStats {
  currentAmount: string;
  depositedValue: string;
  currentLpAmount: string;
  pnl: MegaVaultPnlStats | undefined;
}
interface MegaVaultSubscription {
  user: string;
  index: string;
  amount: string;
  status: string;
  lpAmount: string;
  createdAt: string;
  executedAt: string;
  createdHeight: string;
  executedHeight: string;
  contractAddress: string;
  log: OperationStatusLogEntry[];
}
interface MegaVaultRedemption {
  user: string;
  index: string;
  dueAt: string;
  amount: string;
  status: string;
  lpAmount: string;
  createdAt: string;
  executedAt: string;
  createdHeight: string;
  executedHeight: string;
  contractAddress: string;
  log: OperationStatusLogEntry[];
}
interface MegaVaultOperatorRedemptionBucket {
  bucket: string;
  neededAmount: string;
  lpAmountToRedeem: string;
  missingLiquidity: string;
}
interface MegaVaultHistoricalTVL {
  t: string;
  v: string;
}
interface MegaVaultHistoricalPnL {
  t: string;
  v: string;
}
interface MegaVaultTargetApr {
  apr: string;
  updatedAt: string;
  updatedHeight: string;
  upperThreshold: string;
  lowerThreshold: string;
}
type MegaVaultRedemptionStatus = 'pending' | 'executed' | 'executing';
declare const MegaVaultRedemptionStatus: {
  readonly Pending: "pending";
  readonly Executed: "executed";
  readonly Executing: "executing";
};
type MegaVaultSubscriptionStatus = 'pending' | 'executed' | 'executing';
declare const MegaVaultSubscriptionStatus: {
  readonly Pending: "pending";
  readonly Executed: "executed";
  readonly Executing: "executing";
};
type GrpcMegaVaultApr = Apr;
type GrpcMegaVaultPnl = Pnl;
type GrpcMegaVaultAprStats = AprStats;
type GrpcMegaVaultPnlStats = PnlStats;
type GrpcMegaVaultOperator = Operator;
type GrpcMegaVaultTargetApr = TargetApr;
type GrpcMegaVaultUserStats = UserStats;
type GrpcMegaVaultIncentives = Incentives;
type GrpcMegaVaultVaultStats = VaultStats;
type GrpcMegaVaultVolatility = Volatility;
type GrpcMegaVaultRedemption = Redemption$1;
type GrpcMegaVaultMaxDrawdown = MaxDrawdown;
type GrpcMegaVaultSubscription = Subscription$1;
type GrpcMegaVaultHistoricalPnL = HistoricalPnL;
type GrpcMegaVaultHistoricalTVL = HistoricalTVL;
type GrpcMegaVaultUnrealizedPnl = UnrealizedPnl;
type GrpcMegaVaultVolatilityStats = VolatilityStats;
type GrpcMegaVaultOperatorRedemptionBucket = RedemptionBucket;
type GrpcMegaVaultOperationStatusLogEntry = OperationStatusLogEntry$1;
//#endregion
//#region src/client/indexer/types/incentives.d.ts
interface IncentivesRound {
  id: number;
  name: string;
  endDate: number;
  startDate: number;
  campaigns: string[];
}
interface IncentivesCampaign {
  id: number;
  name: string;
  rewards: Coin[];
  inRound: number;
  marketId: string;
  isFunded: boolean;
  description: string;
  totalRewards: string;
  isFinalized: boolean;
  subaccountIdSuffix: string;
}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+indexer-proto-ts-v2@1.17.6/node_modules/@injectivelabs/indexer-proto-ts-v2/esm/generated/injective_insurance_rpc_pb.d.ts
/**
 * @generated from protobuf message injective_insurance_rpc.FundsResponse
 */
interface FundsResponse {
  /**
   * @generated from protobuf field: repeated injective_insurance_rpc.InsuranceFund funds = 1
   */
  funds: InsuranceFund$2[];
}
/**
 * @generated from protobuf message injective_insurance_rpc.InsuranceFund
 */
interface InsuranceFund$2 {
  /**
   * Ticker of the derivative market.
   *
   * @generated from protobuf field: string market_ticker = 1
   */
  marketTicker: string;
  /**
   * Derivative Market ID
   *
   * @generated from protobuf field: string market_id = 2
   */
  marketId: string;
  /**
   * Coin denom used for the underwriting of the insurance fund.
   *
   * @generated from protobuf field: string deposit_denom = 3
   */
  depositDenom: string;
  /**
   * Pool token denom
   *
   * @generated from protobuf field: string pool_token_denom = 4
   */
  poolTokenDenom: string;
  /**
   * Redemption notice period duration in seconds.
   *
   * @generated from protobuf field: sint64 redemption_notice_period_duration = 5
   */
  redemptionNoticePeriodDuration: bigint;
  /**
   * @generated from protobuf field: string balance = 6
   */
  balance: string;
  /**
   * @generated from protobuf field: string total_share = 7
   */
  totalShare: string;
  /**
   * Oracle base currency
   *
   * @generated from protobuf field: string oracle_base = 8
   */
  oracleBase: string;
  /**
   * Oracle quote currency
   *
   * @generated from protobuf field: string oracle_quote = 9
   */
  oracleQuote: string;
  /**
   * Oracle Type
   *
   * @generated from protobuf field: string oracle_type = 10
   */
  oracleType: string;
  /**
   * Defines the expiry, if any
   *
   * @generated from protobuf field: sint64 expiry = 11
   */
  expiry: bigint;
  /**
   * Token metadata for the deposit asset
   *
   * @generated from protobuf field: injective_insurance_rpc.TokenMeta deposit_token_meta = 12
   */
  depositTokenMeta?: TokenMeta$2;
}
/**
 * @generated from protobuf message injective_insurance_rpc.TokenMeta
 */
interface TokenMeta$2 {
  /**
   * Token full name
   *
   * @generated from protobuf field: string name = 1
   */
  name: string;
  /**
   * Token contract address (native or not)
   *
   * @generated from protobuf field: string address = 2
   */
  address: string;
  /**
   * Token symbol short name
   *
   * @generated from protobuf field: string symbol = 3
   */
  symbol: string;
  /**
   * URL to the logo image
   *
   * @generated from protobuf field: string logo = 4
   */
  logo: string;
  /**
   * Token decimals
   *
   * @generated from protobuf field: sint32 decimals = 5
   */
  decimals: number;
  /**
   * Token metadata fetched timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 updated_at = 6
   */
  updatedAt: bigint;
}
/**
 * @generated from protobuf message injective_insurance_rpc.RedemptionsResponse
 */
interface RedemptionsResponse {
  /**
   * @generated from protobuf field: repeated injective_insurance_rpc.RedemptionSchedule redemption_schedules = 1
   */
  redemptionSchedules: RedemptionSchedule[];
}
/**
 * @generated from protobuf message injective_insurance_rpc.RedemptionSchedule
 */
interface RedemptionSchedule {
  /**
   * Redemption ID.
   *
   * @generated from protobuf field: uint64 redemption_id = 1
   */
  redemptionId: bigint;
  /**
   * Status of the redemption. Either pending or disbursed.
   *
   * @generated from protobuf field: string status = 2
   */
  status: string;
  /**
   * Account address of the redemption owner
   *
   * @generated from protobuf field: string redeemer = 3
   */
  redeemer: string;
  /**
   * Claimable redemption time in seconds
   *
   * @generated from protobuf field: sint64 claimable_redemption_time = 4
   */
  claimableRedemptionTime: bigint;
  /**
   * Amount of pool tokens being redeemed.
   *
   * @generated from protobuf field: string redemption_amount = 5
   */
  redemptionAmount: string;
  /**
   * Pool token denom being redeemed.
   *
   * @generated from protobuf field: string redemption_denom = 6
   */
  redemptionDenom: string;
  /**
   * Redemption request time in unix milliseconds.
   *
   * @generated from protobuf field: sint64 requested_at = 7
   */
  requestedAt: bigint;
  /**
   * Amount of quote tokens disbursed
   *
   * @generated from protobuf field: string disbursed_amount = 8
   */
  disbursedAmount: string;
  /**
   * Denom of the quote tokens disbursed
   *
   * @generated from protobuf field: string disbursed_denom = 9
   */
  disbursedDenom: string;
  /**
   * Redemption disbursement time in unix milliseconds.
   *
   * @generated from protobuf field: sint64 disbursed_at = 10
   */
  disbursedAt: bigint;
}
/**
 * @generated MessageType for protobuf message injective_insurance_rpc.FundsResponse
 */
declare const FundsResponse = new FundsResponse$Type();
/**
 * @generated MessageType for protobuf message injective_insurance_rpc.InsuranceFund
 */
declare const InsuranceFund$2 = new InsuranceFund$Type();
/**
 * @generated MessageType for protobuf message injective_insurance_rpc.TokenMeta
 */
declare const TokenMeta$2 = new TokenMeta$Type();
/**
 * @generated MessageType for protobuf message injective_insurance_rpc.RedemptionsResponse
 */
declare const RedemptionsResponse = new RedemptionsResponse$Type();
/**
 * @generated MessageType for protobuf message injective_insurance_rpc.RedemptionSchedule
 */
declare const RedemptionSchedule = new RedemptionSchedule$Type();
//#endregion
//#region src/client/indexer/types/insurance-funds.d.ts
interface IndexerInsuranceFund {
  depositDenom: string;
  insurancePoolTokenDenom: string;
  redemptionNoticePeriodDuration?: number;
  depositTokenMeta?: any;
  balance: string;
  totalShare: string;
  marketId: string;
  marketTicker: string;
  oracleBase: string;
  oracleQuote: string;
  oracleType: OracleType;
  expiry: number;
}
type RedemptionStatus = 'pending' | 'disbursed';
declare const RedemptionStatus: {
  readonly Pending: "pending";
  readonly Disbursed: "disbursed";
};
interface Redemption {
  redemptionId: number;
  status: RedemptionStatus;
  redeemer: string;
  claimableRedemptionTime: number;
  redemptionAmount: string;
  redemptionDenom: string;
  requestedAt: number;
  disbursedAmount: string;
  disbursedDenom: string;
  disbursedAt: number;
}
interface InsuranceFundCreateParams {
  ticker: string;
  quoteDenom: string;
  oracleBase: string;
  oracleQuote: string;
  oracleType: OracleType;
  expiry?: number;
}
type GrpcIndexerInsuranceFund = InsuranceFund$2;
type GrpcIndexerRedemptionSchedule = RedemptionSchedule;
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+indexer-proto-ts-v2@1.17.6/node_modules/@injectivelabs/indexer-proto-ts-v2/esm/generated/injective_derivative_exchange_rpc_pb.d.ts
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.MarketsResponse
 */
interface MarketsResponse {
  /**
   * Derivative Markets list
   *
   * @generated from protobuf field: repeated injective_derivative_exchange_rpc.DerivativeMarketInfo markets = 1
   */
  markets: DerivativeMarketInfo[];
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.DerivativeMarketInfo
 */
interface DerivativeMarketInfo {
  /**
   * DerivativeMarket ID is crypto.Keccak256Hash([]byte((oracleType.String() +
   * ticker + quoteDenom + oracleBase + oracleQuote))) for perpetual markets and
   * crypto.Keccak256Hash([]byte((oracleType.String() + ticker + quoteDenom +
   * oracleBase + oracleQuote + strconv.Itoa(int(expiry))))) for expiry futures
   * markets
   *
   * @generated from protobuf field: string market_id = 1
   */
  marketId: string;
  /**
   * The status of the market
   *
   * @generated from protobuf field: string market_status = 2
   */
  marketStatus: string;
  /**
   * A name of the pair in format AAA/BBB, where AAA is base asset, BBB is quote
   * asset.
   *
   * @generated from protobuf field: string ticker = 3
   */
  ticker: string;
  /**
   * Oracle base currency
   *
   * @generated from protobuf field: string oracle_base = 4
   */
  oracleBase: string;
  /**
   * Oracle quote currency
   *
   * @generated from protobuf field: string oracle_quote = 5
   */
  oracleQuote: string;
  /**
   * Oracle Type
   *
   * @generated from protobuf field: string oracle_type = 6
   */
  oracleType: string;
  /**
   * OracleScaleFactor
   *
   * @generated from protobuf field: uint32 oracle_scale_factor = 7
   */
  oracleScaleFactor: number;
  /**
   * Defines the initial margin ratio of a derivative market
   *
   * @generated from protobuf field: string initial_margin_ratio = 8
   */
  initialMarginRatio: string;
  /**
   * Defines the maintenance margin ratio of a derivative market
   *
   * @generated from protobuf field: string maintenance_margin_ratio = 9
   */
  maintenanceMarginRatio: string;
  /**
   * Coin denom used for the quote asset.
   *
   * @generated from protobuf field: string quote_denom = 10
   */
  quoteDenom: string;
  /**
   * Token metadata for quote asset
   *
   * @generated from protobuf field: injective_derivative_exchange_rpc.TokenMeta quote_token_meta = 11
   */
  quoteTokenMeta?: TokenMeta$1;
  /**
   * Defines the fee percentage makers pay when trading (in quote asset)
   *
   * @generated from protobuf field: string maker_fee_rate = 12
   */
  makerFeeRate: string;
  /**
   * Defines the fee percentage takers pay when trading (in quote asset)
   *
   * @generated from protobuf field: string taker_fee_rate = 13
   */
  takerFeeRate: string;
  /**
   * Percentage of the transaction fee shared with the service provider
   *
   * @generated from protobuf field: string service_provider_fee = 14
   */
  serviceProviderFee: string;
  /**
   * True if the market is a perpetual swap market
   *
   * @generated from protobuf field: bool is_perpetual = 15
   */
  isPerpetual: boolean;
  /**
   * Defines the minimum required tick size for the order's price
   *
   * @generated from protobuf field: string min_price_tick_size = 16
   */
  minPriceTickSize: string;
  /**
   * Defines the minimum required tick size for the order's quantity
   *
   * @generated from protobuf field: string min_quantity_tick_size = 17
   */
  minQuantityTickSize: string;
  /**
   * @generated from protobuf field: injective_derivative_exchange_rpc.PerpetualMarketInfo perpetual_market_info = 18
   */
  perpetualMarketInfo?: PerpetualMarketInfo$1;
  /**
   * @generated from protobuf field: injective_derivative_exchange_rpc.PerpetualMarketFunding perpetual_market_funding = 19
   */
  perpetualMarketFunding?: PerpetualMarketFunding$1;
  /**
   * @generated from protobuf field: injective_derivative_exchange_rpc.ExpiryFuturesMarketInfo expiry_futures_market_info = 20
   */
  expiryFuturesMarketInfo?: ExpiryFuturesMarketInfo$1;
  /**
   * Minimum notional value for the order
   *
   * @generated from protobuf field: string min_notional = 21
   */
  minNotional: string;
  /**
   * Defines the reduce margin ratio of a derivative market
   *
   * @generated from protobuf field: string reduce_margin_ratio = 22
   */
  reduceMarginRatio: string;
  /**
   * The open notional cap of the market, if any
   *
   * @generated from protobuf field: injective_derivative_exchange_rpc.OpenNotionalCap open_notional_cap = 23
   */
  openNotionalCap?: OpenNotionalCap;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.TokenMeta
 */
interface TokenMeta$1 {
  /**
   * Token full name
   *
   * @generated from protobuf field: string name = 1
   */
  name: string;
  /**
   * Token contract address (native or not)
   *
   * @generated from protobuf field: string address = 2
   */
  address: string;
  /**
   * Token symbol short name
   *
   * @generated from protobuf field: string symbol = 3
   */
  symbol: string;
  /**
   * URL to the logo image
   *
   * @generated from protobuf field: string logo = 4
   */
  logo: string;
  /**
   * Token decimals
   *
   * @generated from protobuf field: sint32 decimals = 5
   */
  decimals: number;
  /**
   * Token metadata fetched timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 updated_at = 6
   */
  updatedAt: bigint;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.PerpetualMarketInfo
 */
interface PerpetualMarketInfo$1 {
  /**
   * Defines the default maximum absolute value of the hourly funding rate of the
   * perpetual market.
   *
   * @generated from protobuf field: string hourly_funding_rate_cap = 1
   */
  hourlyFundingRateCap: string;
  /**
   * Defines the hourly interest rate of the perpetual market.
   *
   * @generated from protobuf field: string hourly_interest_rate = 2
   */
  hourlyInterestRate: string;
  /**
   * Defines the next funding timestamp in seconds of a perpetual market in UNIX
   * seconds.
   *
   * @generated from protobuf field: sint64 next_funding_timestamp = 3
   */
  nextFundingTimestamp: bigint;
  /**
   * Defines the funding interval in seconds of a perpetual market in seconds.
   *
   * @generated from protobuf field: sint64 funding_interval = 4
   */
  fundingInterval: bigint;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.PerpetualMarketFunding
 */
interface PerpetualMarketFunding$1 {
  /**
   * Defines the cumulative funding of a perpetual market.
   *
   * @generated from protobuf field: string cumulative_funding = 1
   */
  cumulativeFunding: string;
  /**
   * Defines defines the cumulative price for the current hour up to the last
   * timestamp.
   *
   * @generated from protobuf field: string cumulative_price = 2
   */
  cumulativePrice: string;
  /**
   * Defines the last funding timestamp in seconds of a perpetual market in UNIX
   * seconds.
   *
   * @generated from protobuf field: sint64 last_timestamp = 3
   */
  lastTimestamp: bigint;
  /**
   * Defines the last funding rate of a perpetual market.
   *
   * @generated from protobuf field: string last_funding_rate = 4
   */
  lastFundingRate: string;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.ExpiryFuturesMarketInfo
 */
interface ExpiryFuturesMarketInfo$1 {
  /**
   * Defines the expiration time for a time expiry futures market in UNIX seconds.
   *
   * @generated from protobuf field: sint64 expiration_timestamp = 1
   */
  expirationTimestamp: bigint;
  /**
   * Defines the settlement price for a time expiry futures market.
   *
   * @generated from protobuf field: string settlement_price = 2
   */
  settlementPrice: string;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.OpenNotionalCap
 */
interface OpenNotionalCap {
  /**
   * The open notional cap of the market
   *
   * @generated from protobuf field: string cap = 1
   */
  cap: string;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.MarketResponse
 */
interface MarketResponse {
  /**
   * Info about particular derivative market
   *
   * @generated from protobuf field: injective_derivative_exchange_rpc.DerivativeMarketInfo market = 1
   */
  market?: DerivativeMarketInfo;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.StreamMarketResponse
 */
interface StreamMarketResponse {
  /**
   * Info about particular derivative market
   *
   * @generated from protobuf field: injective_derivative_exchange_rpc.DerivativeMarketInfo market = 1
   */
  market?: DerivativeMarketInfo;
  /**
   * Update type
   *
   * @generated from protobuf field: string operation_type = 2
   */
  operationType: string;
  /**
   * Operation timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 timestamp = 3
   */
  timestamp: bigint;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.BinaryOptionsMarketsResponse
 */
interface BinaryOptionsMarketsResponse {
  /**
   * Binary Options Markets list
   *
   * @generated from protobuf field: repeated injective_derivative_exchange_rpc.BinaryOptionsMarketInfo markets = 1
   */
  markets: BinaryOptionsMarketInfo[];
  /**
   * @generated from protobuf field: injective_derivative_exchange_rpc.Paging paging = 2
   */
  paging?: Paging$1;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.BinaryOptionsMarketInfo
 */
interface BinaryOptionsMarketInfo {
  /**
   * Binary Options Market ID is crypto.Keccak256Hash([]byte((oracleType.String()
   * + ticker + quoteDenom + oracleSymbol + oracleProvider)))
   *
   * @generated from protobuf field: string market_id = 1
   */
  marketId: string;
  /**
   * The status of the market
   *
   * @generated from protobuf field: string market_status = 2
   */
  marketStatus: string;
  /**
   * A name of the binary options market.
   *
   * @generated from protobuf field: string ticker = 3
   */
  ticker: string;
  /**
   * Oracle symbol
   *
   * @generated from protobuf field: string oracle_symbol = 4
   */
  oracleSymbol: string;
  /**
   * Oracle provider
   *
   * @generated from protobuf field: string oracle_provider = 5
   */
  oracleProvider: string;
  /**
   * Oracle Type
   *
   * @generated from protobuf field: string oracle_type = 6
   */
  oracleType: string;
  /**
   * OracleScaleFactor
   *
   * @generated from protobuf field: uint32 oracle_scale_factor = 7
   */
  oracleScaleFactor: number;
  /**
   * Defines the expiration time for the market in UNIX seconds.
   *
   * @generated from protobuf field: sint64 expiration_timestamp = 8
   */
  expirationTimestamp: bigint;
  /**
   * Defines the settlement time for the market in UNIX seconds.
   *
   * @generated from protobuf field: sint64 settlement_timestamp = 9
   */
  settlementTimestamp: bigint;
  /**
   * Coin denom used for the quote asset.
   *
   * @generated from protobuf field: string quote_denom = 10
   */
  quoteDenom: string;
  /**
   * Token metadata for quote asset
   *
   * @generated from protobuf field: injective_derivative_exchange_rpc.TokenMeta quote_token_meta = 11
   */
  quoteTokenMeta?: TokenMeta$1;
  /**
   * Defines the fee percentage makers pay when trading (in quote asset)
   *
   * @generated from protobuf field: string maker_fee_rate = 12
   */
  makerFeeRate: string;
  /**
   * Defines the fee percentage takers pay when trading (in quote asset)
   *
   * @generated from protobuf field: string taker_fee_rate = 13
   */
  takerFeeRate: string;
  /**
   * Percentage of the transaction fee shared with the service provider
   *
   * @generated from protobuf field: string service_provider_fee = 14
   */
  serviceProviderFee: string;
  /**
   * Defines the minimum required tick size for the order's price
   *
   * @generated from protobuf field: string min_price_tick_size = 15
   */
  minPriceTickSize: string;
  /**
   * Defines the minimum required tick size for the order's quantity
   *
   * @generated from protobuf field: string min_quantity_tick_size = 16
   */
  minQuantityTickSize: string;
  /**
   * Defines the settlement price of the market
   *
   * @generated from protobuf field: string settlement_price = 17
   */
  settlementPrice: string;
  /**
   * Defines the minimum notional value for the market
   *
   * @generated from protobuf field: string min_notional = 18
   */
  minNotional: string;
}
/**
 * Paging defines the structure for required params for handling pagination
 *
 * @generated from protobuf message injective_derivative_exchange_rpc.Paging
 */
interface Paging$1 {
  /**
   * total number of txs saved in database
   *
   * @generated from protobuf field: sint64 total = 1
   */
  total: bigint;
  /**
   * can be either block height or index num
   *
   * @generated from protobuf field: sint32 from = 2
   */
  from: number;
  /**
   * can be either block height or index num
   *
   * @generated from protobuf field: sint32 to = 3
   */
  to: number;
  /**
   * count entries by subaccount, serving some places on helix
   *
   * @generated from protobuf field: sint64 count_by_subaccount = 4
   */
  countBySubaccount: bigint;
  /**
   * array of tokens to navigate to the next pages
   *
   * @generated from protobuf field: repeated string next = 5
   */
  next: string[];
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.BinaryOptionsMarketResponse
 */
interface BinaryOptionsMarketResponse {
  /**
   * Info about particular derivative market
   *
   * @generated from protobuf field: injective_derivative_exchange_rpc.BinaryOptionsMarketInfo market = 1
   */
  market?: BinaryOptionsMarketInfo;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.OrderbookV2Response
 */
interface OrderbookV2Response {
  /**
   * Orderbook of a particular derivative market
   *
   * @generated from protobuf field: injective_derivative_exchange_rpc.DerivativeLimitOrderbookV2 orderbook = 1
   */
  orderbook?: DerivativeLimitOrderbookV2;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.DerivativeLimitOrderbookV2
 */
interface DerivativeLimitOrderbookV2 {
  /**
   * Array of price levels for buys
   *
   * @generated from protobuf field: repeated injective_derivative_exchange_rpc.PriceLevel buys = 1
   */
  buys: PriceLevel$1[];
  /**
   * Array of price levels for sells
   *
   * @generated from protobuf field: repeated injective_derivative_exchange_rpc.PriceLevel sells = 2
   */
  sells: PriceLevel$1[];
  /**
   * market orderbook sequence
   *
   * @generated from protobuf field: uint64 sequence = 3
   */
  sequence: bigint;
  /**
   * Last update timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 timestamp = 4
   */
  timestamp: bigint;
  /**
   * Block height at which the orderbook was last updated.
   *
   * @generated from protobuf field: sint64 height = 5
   */
  height: bigint;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.PriceLevel
 */
interface PriceLevel$1 {
  /**
   * Price number of the price level.
   *
   * @generated from protobuf field: string price = 1
   */
  price: string;
  /**
   * Quantity of the price level.
   *
   * @generated from protobuf field: string quantity = 2
   */
  quantity: string;
  /**
   * Price level last updated timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 timestamp = 3
   */
  timestamp: bigint;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.OrderbooksV2Response
 */
interface OrderbooksV2Response {
  /**
   * @generated from protobuf field: repeated injective_derivative_exchange_rpc.SingleDerivativeLimitOrderbookV2 orderbooks = 1
   */
  orderbooks: SingleDerivativeLimitOrderbookV2[];
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.SingleDerivativeLimitOrderbookV2
 */
interface SingleDerivativeLimitOrderbookV2 {
  /**
   * market's ID
   *
   * @generated from protobuf field: string market_id = 1
   */
  marketId: string;
  /**
   * Orderbook of the market
   *
   * @generated from protobuf field: injective_derivative_exchange_rpc.DerivativeLimitOrderbookV2 orderbook = 2
   */
  orderbook?: DerivativeLimitOrderbookV2;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.StreamOrderbookV2Response
 */
interface StreamOrderbookV2Response {
  /**
   * Orderbook of a Derivative Market
   *
   * @generated from protobuf field: injective_derivative_exchange_rpc.DerivativeLimitOrderbookV2 orderbook = 1
   */
  orderbook?: DerivativeLimitOrderbookV2;
  /**
   * Order update type
   *
   * @generated from protobuf field: string operation_type = 2
   */
  operationType: string;
  /**
   * Operation timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 timestamp = 3
   */
  timestamp: bigint;
  /**
   * MarketId of the market's orderbook
   *
   * @generated from protobuf field: string market_id = 4
   */
  marketId: string;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.StreamOrderbookUpdateResponse
 */
interface StreamOrderbookUpdateResponse {
  /**
   * Orderbook level updates of a Derivative Market
   *
   * @generated from protobuf field: injective_derivative_exchange_rpc.OrderbookLevelUpdates orderbook_level_updates = 1
   */
  orderbookLevelUpdates?: OrderbookLevelUpdates;
  /**
   * Order update type
   *
   * @generated from protobuf field: string operation_type = 2
   */
  operationType: string;
  /**
   * Operation timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 timestamp = 3
   */
  timestamp: bigint;
  /**
   * MarketId of the market's orderbook
   *
   * @generated from protobuf field: string market_id = 4
   */
  marketId: string;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.OrderbookLevelUpdates
 */
interface OrderbookLevelUpdates {
  /**
   * market's ID
   *
   * @generated from protobuf field: string market_id = 1
   */
  marketId: string;
  /**
   * orderbook update sequence
   *
   * @generated from protobuf field: uint64 sequence = 2
   */
  sequence: bigint;
  /**
   * buy levels
   *
   * @generated from protobuf field: repeated injective_derivative_exchange_rpc.PriceLevelUpdate buys = 3
   */
  buys: PriceLevelUpdate[];
  /**
   * sell levels
   *
   * @generated from protobuf field: repeated injective_derivative_exchange_rpc.PriceLevelUpdate sells = 4
   */
  sells: PriceLevelUpdate[];
  /**
   * updates timestamp
   *
   * @generated from protobuf field: sint64 updated_at = 5
   */
  updatedAt: bigint;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.PriceLevelUpdate
 */
interface PriceLevelUpdate {
  /**
   * Price number of the price level.
   *
   * @generated from protobuf field: string price = 1
   */
  price: string;
  /**
   * Quantity of the price level.
   *
   * @generated from protobuf field: string quantity = 2
   */
  quantity: string;
  /**
   * Price level status.
   *
   * @generated from protobuf field: bool is_active = 3
   */
  isActive: boolean;
  /**
   * Price level last updated timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 timestamp = 4
   */
  timestamp: bigint;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.OrdersResponse
 */
interface OrdersResponse {
  /**
   * @generated from protobuf field: repeated injective_derivative_exchange_rpc.DerivativeLimitOrder orders = 1
   */
  orders: DerivativeLimitOrder$1[];
  /**
   * @generated from protobuf field: injective_derivative_exchange_rpc.Paging paging = 2
   */
  paging?: Paging$1;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.DerivativeLimitOrder
 */
interface DerivativeLimitOrder$1 {
  /**
   * Hash of the order
   *
   * @generated from protobuf field: string order_hash = 1
   */
  orderHash: string;
  /**
   * The side of the order
   *
   * @generated from protobuf field: string order_side = 2
   */
  orderSide: string;
  /**
   * Derivative Market ID
   *
   * @generated from protobuf field: string market_id = 3
   */
  marketId: string;
  /**
   * The subaccountId that this order belongs to
   *
   * @generated from protobuf field: string subaccount_id = 4
   */
  subaccountId: string;
  /**
   * True if the order is a reduce-only order
   *
   * @generated from protobuf field: bool is_reduce_only = 5
   */
  isReduceOnly: boolean;
  /**
   * Margin of the order
   *
   * @generated from protobuf field: string margin = 6
   */
  margin: string;
  /**
   * Price of the order
   *
   * @generated from protobuf field: string price = 7
   */
  price: string;
  /**
   * Quantity of the order
   *
   * @generated from protobuf field: string quantity = 8
   */
  quantity: string;
  /**
   * The amount of the quantity remaining unfilled
   *
   * @generated from protobuf field: string unfilled_quantity = 9
   */
  unfilledQuantity: string;
  /**
   * Trigger price is the trigger price used by stop/take orders
   *
   * @generated from protobuf field: string trigger_price = 10
   */
  triggerPrice: string;
  /**
   * Fee recipient address
   *
   * @generated from protobuf field: string fee_recipient = 11
   */
  feeRecipient: string;
  /**
   * Order state
   *
   * @generated from protobuf field: string state = 12
   */
  state: string;
  /**
   * Order committed timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 created_at = 13
   */
  createdAt: bigint;
  /**
   * Order updated timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 updated_at = 14
   */
  updatedAt: bigint;
  /**
   * Order number of subaccount
   *
   * @generated from protobuf field: sint64 order_number = 15
   */
  orderNumber: bigint;
  /**
   * Order type
   *
   * @generated from protobuf field: string order_type = 16
   */
  orderType: string;
  /**
   * Order type
   *
   * @generated from protobuf field: bool is_conditional = 17
   */
  isConditional: boolean;
  /**
   * Trigger timestamp, only exists for conditional orders
   *
   * @generated from protobuf field: uint64 trigger_at = 18
   */
  triggerAt: bigint;
  /**
   * OrderHash of order that is triggered by this conditional order
   *
   * @generated from protobuf field: string placed_order_hash = 19
   */
  placedOrderHash: string;
  /**
   * Execution type of conditional order
   *
   * @generated from protobuf field: string execution_type = 20
   */
  executionType: string;
  /**
   * Transaction Hash where order is created. Not all orders have this field
   *
   * @generated from protobuf field: string tx_hash = 21
   */
  txHash: string;
  /**
   * Custom client order ID
   *
   * @generated from protobuf field: string cid = 22
   */
  cid: string;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.PositionsResponse
 */
interface PositionsResponse {
  /**
   * @generated from protobuf field: repeated injective_derivative_exchange_rpc.DerivativePosition positions = 1
   */
  positions: DerivativePosition$1[];
  /**
   * @generated from protobuf field: injective_derivative_exchange_rpc.Paging paging = 2
   */
  paging?: Paging$1;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.DerivativePosition
 */
interface DerivativePosition$1 {
  /**
   * Ticker of the derivative market
   *
   * @generated from protobuf field: string ticker = 1
   */
  ticker: string;
  /**
   * Derivative Market ID
   *
   * @generated from protobuf field: string market_id = 2
   */
  marketId: string;
  /**
   * The subaccountId that the position belongs to
   *
   * @generated from protobuf field: string subaccount_id = 3
   */
  subaccountId: string;
  /**
   * Direction of the position
   *
   * @generated from protobuf field: string direction = 4
   */
  direction: string;
  /**
   * Quantity of the position
   *
   * @generated from protobuf field: string quantity = 5
   */
  quantity: string;
  /**
   * Price of the position
   *
   * @generated from protobuf field: string entry_price = 6
   */
  entryPrice: string;
  /**
   * Margin of the position
   *
   * @generated from protobuf field: string margin = 7
   */
  margin: string;
  /**
   * LiquidationPrice of the position
   *
   * @generated from protobuf field: string liquidation_price = 8
   */
  liquidationPrice: string;
  /**
   * MarkPrice of the position
   *
   * @generated from protobuf field: string mark_price = 9
   */
  markPrice: string;
  /**
   * Aggregate Quantity of the Reduce Only orders associated with the position
   *
   * @generated from protobuf field: string aggregate_reduce_only_quantity = 11
   */
  aggregateReduceOnlyQuantity: string;
  /**
   * Position updated timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 updated_at = 12
   */
  updatedAt: bigint;
  /**
   * Position created timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 created_at = 13
   */
  createdAt: bigint;
  /**
   * Last funding fees since position opened
   *
   * @generated from protobuf field: string funding_last = 14
   */
  fundingLast: string;
  /**
   * Net funding fees since position opened
   *
   * @generated from protobuf field: string funding_sum = 15
   */
  fundingSum: string;
  /**
   * Cumulative funding entry of the position
   *
   * @generated from protobuf field: string cumulative_funding_entry = 16
   */
  cumulativeFundingEntry: string;
  /**
   * Effective cumulative funding entry of the position
   *
   * @generated from protobuf field: string effective_cumulative_funding_entry = 17
   */
  effectiveCumulativeFundingEntry: string;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.PositionsV2Response
 */
interface PositionsV2Response {
  /**
   * @generated from protobuf field: repeated injective_derivative_exchange_rpc.DerivativePositionV2 positions = 1
   */
  positions: DerivativePositionV2[];
  /**
   * @generated from protobuf field: injective_derivative_exchange_rpc.Paging paging = 2
   */
  paging?: Paging$1;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.DerivativePositionV2
 */
interface DerivativePositionV2 {
  /**
   * Ticker of the derivative market
   *
   * @generated from protobuf field: string ticker = 1
   */
  ticker: string;
  /**
   * Derivative Market ID
   *
   * @generated from protobuf field: string market_id = 2
   */
  marketId: string;
  /**
   * The subaccountId that the position belongs to
   *
   * @generated from protobuf field: string subaccount_id = 3
   */
  subaccountId: string;
  /**
   * Direction of the position
   *
   * @generated from protobuf field: string direction = 4
   */
  direction: string;
  /**
   * Quantity of the position
   *
   * @generated from protobuf field: string quantity = 5
   */
  quantity: string;
  /**
   * Price of the position
   *
   * @generated from protobuf field: string entry_price = 6
   */
  entryPrice: string;
  /**
   * Margin of the position
   *
   * @generated from protobuf field: string margin = 7
   */
  margin: string;
  /**
   * LiquidationPrice of the position
   *
   * @generated from protobuf field: string liquidation_price = 8
   */
  liquidationPrice: string;
  /**
   * MarkPrice of the position
   *
   * @generated from protobuf field: string mark_price = 9
   */
  markPrice: string;
  /**
   * Position updated timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 updated_at = 11
   */
  updatedAt: bigint;
  /**
   * Market quote denom
   *
   * @generated from protobuf field: string denom = 12
   */
  denom: string;
  /**
   * Last funding fees since position opened
   *
   * @generated from protobuf field: string funding_last = 13
   */
  fundingLast: string;
  /**
   * Net funding fees since position opened
   *
   * @generated from protobuf field: string funding_sum = 14
   */
  fundingSum: string;
  /**
   * Cumulative funding entry of the position
   *
   * @generated from protobuf field: string cumulative_funding_entry = 15
   */
  cumulativeFundingEntry: string;
  /**
   * Effective cumulative funding entry of the position
   *
   * @generated from protobuf field: string effective_cumulative_funding_entry = 16
   */
  effectiveCumulativeFundingEntry: string;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.FundingPaymentsResponse
 */
interface FundingPaymentsResponse {
  /**
   * List of funding payments
   *
   * @generated from protobuf field: repeated injective_derivative_exchange_rpc.FundingPayment payments = 1
   */
  payments: FundingPayment$1[];
  /**
   * @generated from protobuf field: injective_derivative_exchange_rpc.Paging paging = 2
   */
  paging?: Paging$1;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.FundingPayment
 */
interface FundingPayment$1 {
  /**
   * Derivative Market ID
   *
   * @generated from protobuf field: string market_id = 1
   */
  marketId: string;
  /**
   * The subaccountId that the position belongs to
   *
   * @generated from protobuf field: string subaccount_id = 2
   */
  subaccountId: string;
  /**
   * Amount of the funding payment
   *
   * @generated from protobuf field: string amount = 3
   */
  amount: string;
  /**
   * Timestamp of funding payment in UNIX millis
   *
   * @generated from protobuf field: sint64 timestamp = 4
   */
  timestamp: bigint;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.FundingRatesResponse
 */
interface FundingRatesResponse {
  /**
   * List of funding rates
   *
   * @generated from protobuf field: repeated injective_derivative_exchange_rpc.FundingRate funding_rates = 1
   */
  fundingRates: FundingRate$1[];
  /**
   * @generated from protobuf field: injective_derivative_exchange_rpc.Paging paging = 2
   */
  paging?: Paging$1;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.FundingRate
 */
interface FundingRate$1 {
  /**
   * Derivative Market ID
   *
   * @generated from protobuf field: string market_id = 1
   */
  marketId: string;
  /**
   * Value of the funding rate
   *
   * @generated from protobuf field: string rate = 2
   */
  rate: string;
  /**
   * Timestamp of funding rate in UNIX millis
   *
   * @generated from protobuf field: sint64 timestamp = 3
   */
  timestamp: bigint;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.StreamPositionsResponse
 */
interface StreamPositionsResponse {
  /**
   * Updated derivative Position
   *
   * @generated from protobuf field: injective_derivative_exchange_rpc.DerivativePosition position = 1
   */
  position?: DerivativePosition$1;
  /**
   * Operation timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 timestamp = 2
   */
  timestamp: bigint;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.StreamPositionsV2Response
 */
interface StreamPositionsV2Response {
  /**
   * Updated derivative Position
   *
   * @generated from protobuf field: injective_derivative_exchange_rpc.DerivativePositionV2 position = 1
   */
  position?: DerivativePositionV2;
  /**
   * Operation timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 timestamp = 2
   */
  timestamp: bigint;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.StreamOrdersResponse
 */
interface StreamOrdersResponse {
  /**
   * Updated market order
   *
   * @generated from protobuf field: injective_derivative_exchange_rpc.DerivativeLimitOrder order = 1
   */
  order?: DerivativeLimitOrder$1;
  /**
   * Order update type
   *
   * @generated from protobuf field: string operation_type = 2
   */
  operationType: string;
  /**
   * Operation timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 timestamp = 3
   */
  timestamp: bigint;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.TradesResponse
 */
interface TradesResponse {
  /**
   * Trades of a Derivative Market
   *
   * @generated from protobuf field: repeated injective_derivative_exchange_rpc.DerivativeTrade trades = 1
   */
  trades: DerivativeTrade$1[];
  /**
   * @generated from protobuf field: injective_derivative_exchange_rpc.Paging paging = 2
   */
  paging?: Paging$1;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.DerivativeTrade
 */
interface DerivativeTrade$1 {
  /**
   * Order hash.
   *
   * @generated from protobuf field: string order_hash = 1
   */
  orderHash: string;
  /**
   * The subaccountId that executed the trade
   *
   * @generated from protobuf field: string subaccount_id = 2
   */
  subaccountId: string;
  /**
   * The ID of the market that this trade is in
   *
   * @generated from protobuf field: string market_id = 3
   */
  marketId: string;
  /**
   * The execution type of the trade
   *
   * @generated from protobuf field: string trade_execution_type = 4
   */
  tradeExecutionType: string;
  /**
   * True if the trade is a liquidation
   *
   * @generated from protobuf field: bool is_liquidation = 5
   */
  isLiquidation: boolean;
  /**
   * Position Delta from the trade
   *
   * @generated from protobuf field: injective_derivative_exchange_rpc.PositionDelta position_delta = 6
   */
  positionDelta?: PositionDelta$1;
  /**
   * The payout associated with the trade
   *
   * @generated from protobuf field: string payout = 7
   */
  payout: string;
  /**
   * The fee associated with the trade
   *
   * @generated from protobuf field: string fee = 8
   */
  fee: string;
  /**
   * Timestamp of trade execution in UNIX millis
   *
   * @generated from protobuf field: sint64 executed_at = 9
   */
  executedAt: bigint;
  /**
   * Fee recipient address
   *
   * @generated from protobuf field: string fee_recipient = 10
   */
  feeRecipient: string;
  /**
   * A unique string that helps differentiate between trades
   *
   * @generated from protobuf field: string trade_id = 11
   */
  tradeId: string;
  /**
   * Trade's execution side, marker/taker
   *
   * @generated from protobuf field: string execution_side = 12
   */
  executionSide: string;
  /**
   * Custom client order ID
   *
   * @generated from protobuf field: string cid = 13
   */
  cid: string;
  /**
   * Profit and loss of the trade
   *
   * @generated from protobuf field: string pnl = 14
   */
  pnl: string;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.PositionDelta
 */
interface PositionDelta$1 {
  /**
   * The direction the trade
   *
   * @generated from protobuf field: string trade_direction = 1
   */
  tradeDirection: string;
  /**
   * Execution Price of the trade.
   *
   * @generated from protobuf field: string execution_price = 2
   */
  executionPrice: string;
  /**
   * Execution Quantity of the trade.
   *
   * @generated from protobuf field: string execution_quantity = 3
   */
  executionQuantity: string;
  /**
   * Execution Margin of the trade.
   *
   * @generated from protobuf field: string execution_margin = 4
   */
  executionMargin: string;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.StreamTradesResponse
 */
interface StreamTradesResponse {
  /**
   * New derivative market trade
   *
   * @generated from protobuf field: injective_derivative_exchange_rpc.DerivativeTrade trade = 1
   */
  trade?: DerivativeTrade$1;
  /**
   * Executed trades update type
   *
   * @generated from protobuf field: string operation_type = 2
   */
  operationType: string;
  /**
   * Operation timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 timestamp = 3
   */
  timestamp: bigint;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.SubaccountTradesListResponse
 */
interface SubaccountTradesListResponse {
  /**
   * List of derivative market trades
   *
   * @generated from protobuf field: repeated injective_derivative_exchange_rpc.DerivativeTrade trades = 1
   */
  trades: DerivativeTrade$1[];
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.OrdersHistoryResponse
 */
interface OrdersHistoryResponse {
  /**
   * List of historical derivative orders
   *
   * @generated from protobuf field: repeated injective_derivative_exchange_rpc.DerivativeOrderHistory orders = 1
   */
  orders: DerivativeOrderHistory$1[];
  /**
   * @generated from protobuf field: injective_derivative_exchange_rpc.Paging paging = 2
   */
  paging?: Paging$1;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.DerivativeOrderHistory
 */
interface DerivativeOrderHistory$1 {
  /**
   * Hash of the order
   *
   * @generated from protobuf field: string order_hash = 1
   */
  orderHash: string;
  /**
   * Spot Market ID is keccak265(baseDenom + quoteDenom)
   *
   * @generated from protobuf field: string market_id = 2
   */
  marketId: string;
  /**
   * active state of the order
   *
   * @generated from protobuf field: bool is_active = 3
   */
  isActive: boolean;
  /**
   * The subaccountId that this order belongs to
   *
   * @generated from protobuf field: string subaccount_id = 4
   */
  subaccountId: string;
  /**
   * The execution type
   *
   * @generated from protobuf field: string execution_type = 5
   */
  executionType: string;
  /**
   * The side of the order
   *
   * @generated from protobuf field: string order_type = 6
   */
  orderType: string;
  /**
   * Price of the order
   *
   * @generated from protobuf field: string price = 7
   */
  price: string;
  /**
   * Trigger price
   *
   * @generated from protobuf field: string trigger_price = 8
   */
  triggerPrice: string;
  /**
   * Quantity of the order
   *
   * @generated from protobuf field: string quantity = 9
   */
  quantity: string;
  /**
   * Filled amount
   *
   * @generated from protobuf field: string filled_quantity = 10
   */
  filledQuantity: string;
  /**
   * Order state
   *
   * @generated from protobuf field: string state = 11
   */
  state: string;
  /**
   * Order committed timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 created_at = 12
   */
  createdAt: bigint;
  /**
   * Order updated timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 updated_at = 13
   */
  updatedAt: bigint;
  /**
   * True if an order is reduce only
   *
   * @generated from protobuf field: bool is_reduce_only = 14
   */
  isReduceOnly: boolean;
  /**
   * Order direction (order side)
   *
   * @generated from protobuf field: string direction = 15
   */
  direction: string;
  /**
   * True if this is conditional order, otherwise false
   *
   * @generated from protobuf field: bool is_conditional = 16
   */
  isConditional: boolean;
  /**
   * Trigger timestamp in unix milli
   *
   * @generated from protobuf field: uint64 trigger_at = 17
   */
  triggerAt: bigint;
  /**
   * Order hash placed when this triggers
   *
   * @generated from protobuf field: string placed_order_hash = 18
   */
  placedOrderHash: string;
  /**
   * Order's margin
   *
   * @generated from protobuf field: string margin = 19
   */
  margin: string;
  /**
   * Transaction Hash where order is created. Not all orders have this field
   *
   * @generated from protobuf field: string tx_hash = 20
   */
  txHash: string;
  /**
   * Custom client order ID
   *
   * @generated from protobuf field: string cid = 21
   */
  cid: string;
}
/**
 * @generated from protobuf message injective_derivative_exchange_rpc.StreamOrdersHistoryResponse
 */
interface StreamOrdersHistoryResponse {
  /**
   * Updated order
   *
   * @generated from protobuf field: injective_derivative_exchange_rpc.DerivativeOrderHistory order = 1
   */
  order?: DerivativeOrderHistory$1;
  /**
   * Order update type
   *
   * @generated from protobuf field: string operation_type = 2
   */
  operationType: string;
  /**
   * Operation timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 timestamp = 3
   */
  timestamp: bigint;
}
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.MarketsResponse
 */
declare const MarketsResponse = new MarketsResponse$Type();
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.DerivativeMarketInfo
 */
declare const DerivativeMarketInfo = new DerivativeMarketInfo$Type();
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.TokenMeta
 */
declare const TokenMeta$1 = new TokenMeta$Type();
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.PerpetualMarketInfo
 */
declare const PerpetualMarketInfo$1 = new PerpetualMarketInfo$Type();
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.PerpetualMarketFunding
 */
declare const PerpetualMarketFunding$1 = new PerpetualMarketFunding$Type();
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.ExpiryFuturesMarketInfo
 */
declare const ExpiryFuturesMarketInfo$1 = new ExpiryFuturesMarketInfo$Type();
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.OpenNotionalCap
 */
declare const OpenNotionalCap = new OpenNotionalCap$Type();
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.MarketResponse
 */
declare const MarketResponse = new MarketResponse$Type();
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.StreamMarketResponse
 */
declare const StreamMarketResponse = new StreamMarketResponse$Type();
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.BinaryOptionsMarketsResponse
 */
declare const BinaryOptionsMarketsResponse = new BinaryOptionsMarketsResponse$Type();
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.BinaryOptionsMarketInfo
 */
declare const BinaryOptionsMarketInfo = new BinaryOptionsMarketInfo$Type();
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.Paging
 */
declare const Paging$1 = new Paging$Type();
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.BinaryOptionsMarketResponse
 */
declare const BinaryOptionsMarketResponse = new BinaryOptionsMarketResponse$Type();
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.OrderbookV2Response
 */
declare const OrderbookV2Response = new OrderbookV2Response$Type();
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.DerivativeLimitOrderbookV2
 */
declare const DerivativeLimitOrderbookV2 = new DerivativeLimitOrderbookV2$Type();
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.PriceLevel
 */
declare const PriceLevel$1 = new PriceLevel$Type();
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.OrderbooksV2Response
 */
declare const OrderbooksV2Response = new OrderbooksV2Response$Type();
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.SingleDerivativeLimitOrderbookV2
 */
declare const SingleDerivativeLimitOrderbookV2 = new SingleDerivativeLimitOrderbookV2$Type();
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.StreamOrderbookV2Response
 */
declare const StreamOrderbookV2Response = new StreamOrderbookV2Response$Type();
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.StreamOrderbookUpdateResponse
 */
declare const StreamOrderbookUpdateResponse = new StreamOrderbookUpdateResponse$Type();
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.OrderbookLevelUpdates
 */
declare const OrderbookLevelUpdates = new OrderbookLevelUpdates$Type();
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.PriceLevelUpdate
 */
declare const PriceLevelUpdate = new PriceLevelUpdate$Type();
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.OrdersResponse
 */
declare const OrdersResponse = new OrdersResponse$Type();
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.DerivativeLimitOrder
 */
declare const DerivativeLimitOrder$1 = new DerivativeLimitOrder$Type();
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.PositionsResponse
 */
declare const PositionsResponse = new PositionsResponse$Type();
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.DerivativePosition
 */
declare const DerivativePosition$1 = new DerivativePosition$Type();
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.PositionsV2Response
 */
declare const PositionsV2Response = new PositionsV2Response$Type();
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.DerivativePositionV2
 */
declare const DerivativePositionV2 = new DerivativePositionV2$Type();
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.FundingPaymentsResponse
 */
declare const FundingPaymentsResponse = new FundingPaymentsResponse$Type();
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.FundingPayment
 */
declare const FundingPayment$1 = new FundingPayment$Type();
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.FundingRatesResponse
 */
declare const FundingRatesResponse = new FundingRatesResponse$Type();
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.FundingRate
 */
declare const FundingRate$1 = new FundingRate$Type();
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.StreamPositionsResponse
 */
declare const StreamPositionsResponse = new StreamPositionsResponse$Type();
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.StreamPositionsV2Response
 */
declare const StreamPositionsV2Response = new StreamPositionsV2Response$Type();
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.StreamOrdersResponse
 */
declare const StreamOrdersResponse = new StreamOrdersResponse$Type();
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.TradesResponse
 */
declare const TradesResponse = new TradesResponse$Type();
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.DerivativeTrade
 */
declare const DerivativeTrade$1 = new DerivativeTrade$Type();
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.PositionDelta
 */
declare const PositionDelta$1 = new PositionDelta$Type();
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.StreamTradesResponse
 */
declare const StreamTradesResponse = new StreamTradesResponse$Type();
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.SubaccountTradesListResponse
 */
declare const SubaccountTradesListResponse = new SubaccountTradesListResponse$Type();
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.OrdersHistoryResponse
 */
declare const OrdersHistoryResponse = new OrdersHistoryResponse$Type();
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.DerivativeOrderHistory
 */
declare const DerivativeOrderHistory$1 = new DerivativeOrderHistory$Type();
/**
 * @generated MessageType for protobuf message injective_derivative_exchange_rpc.StreamOrdersHistoryResponse
 */
declare const StreamOrdersHistoryResponse = new StreamOrdersHistoryResponse$Type();
//#endregion
//#region src/client/indexer/types/derivatives.d.ts
interface PositionDelta {
  tradeDirection: TradeDirection;
  executionPrice: string;
  executionQuantity: string;
  executionMargin: string;
}
interface Position {
  marketId: string;
  subaccountId: string;
  direction: TradeDirection;
  quantity: string;
  entryPrice: string;
  margin: string;
  liquidationPrice: string;
  markPrice: string;
  ticker: string;
  aggregateReduceOnlyQuantity: string;
  updatedAt: number;
}
interface PositionV2 extends Omit<Position, 'aggregateReduceOnlyQuantity'> {
  denom: string;
  fundingSum: string;
  fundingLast: string;
  cumulativeFundingEntry: string;
  effectiveCumulativeFundingEntry: string;
}
interface PerpetualMarketInfo {
  hourlyFundingRateCap: string;
  hourlyInterestRate: string;
  nextFundingTimestamp: number;
  fundingInterval: number;
}
interface PerpetualMarketFunding {
  cumulativeFunding: string;
  cumulativePrice: string;
  lastTimestamp: number;
}
interface ExpiryFuturesMarketInfo {
  expirationTimestamp: number;
  settlementPrice: string;
}
interface BaseDerivativeMarket {
  oracleType: string;
  marketId: string;
  marketStatus: string;
  ticker: string;
  quoteDenom: string;
  makerFeeRate: string;
  quoteToken: TokenMeta | undefined;
  takerFeeRate: string;
  serviceProviderFee: string;
  minPriceTickSize: number;
  minQuantityTickSize: number;
  minNotional: number;
}
interface PerpetualMarket extends BaseDerivativeMarket {
  reduceMarginRatio: string;
  initialMarginRatio: string;
  maintenanceMarginRatio: string;
  isPerpetual: boolean;
  oracleBase: string;
  oracleQuote: string;
  oracleScaleFactor: number;
  perpetualMarketInfo?: PerpetualMarketInfo;
  perpetualMarketFunding?: PerpetualMarketFunding;
}
interface ExpiryFuturesMarket extends BaseDerivativeMarket {
  reduceMarginRatio: string;
  initialMarginRatio: string;
  maintenanceMarginRatio: string;
  isPerpetual: boolean;
  oracleBase: string;
  oracleQuote: string;
  oracleScaleFactor: number;
  expiryFuturesMarketInfo?: ExpiryFuturesMarketInfo;
}
interface BinaryOptionsMarket extends Omit<BaseDerivativeMarket, 'minPriceTickSize' | 'minQuantityTickSize'> {
  oracleSymbol: string;
  oracleProvider: string;
  oracleScaleFactor: number;
  expirationTimestamp: number;
  settlementTimestamp: number;
  serviceProviderFee: string;
  minPriceTickSize: number;
  minQuantityTickSize: number;
  minNotional: number;
  settlementPrice: string;
}
type DerivativeMarket = PerpetualMarket | ExpiryFuturesMarket | BinaryOptionsMarket;
type DerivativeMarketWithoutBinaryOptions = PerpetualMarket | ExpiryFuturesMarket;
interface DerivativeLimitOrder {
  orderHash: string;
  orderSide: OrderSide;
  marketId: string;
  cid: string;
  subaccountId: string;
  isReduceOnly: boolean;
  margin: string;
  price: string;
  quantity: string;
  unfilledQuantity: string;
  triggerPrice: string;
  feeRecipient: string;
  state: OrderState;
  createdAt: number;
  updatedAt: number;
  orderNumber: number;
  orderType: string;
  isConditional: boolean;
  triggerAt: number;
  placedOrderHash: string;
  executionType: string;
}
interface DerivativeOrderHistory {
  orderHash: string;
  marketId: string;
  cid: string;
  isActive: boolean;
  subaccountId: string;
  executionType: string;
  orderType: string;
  price: string;
  triggerPrice: string;
  quantity: string;
  filledQuantity: string;
  state: string;
  createdAt: number;
  updatedAt: number;
  isReduceOnly: boolean;
  direction: string;
  isConditional: boolean;
  triggerAt: number;
  placedOrderHash: string;
  margin: string;
}
interface DerivativeTrade extends PositionDelta {
  orderHash: string;
  subaccountId: string;
  tradeId: string;
  cid: string;
  marketId: string;
  executedAt: number;
  tradeExecutionType: TradeExecutionType;
  tradeDirection: TradeDirection;
  executionSide: TradeExecutionSide;
  fee: string;
  feeRecipient: string;
  isLiquidation: boolean;
  payout: string;
  pnl: string;
}
interface DerivativeLimitOrderParams {
  orderType: GrpcOrderType;
  triggerPrice?: string;
  feeRecipient: string;
  price: string;
  margin: string;
  quantity: string;
}
interface DerivativeOrderCancelParams {
  orderHash: string;
}
interface BatchDerivativeOrderCancelParams {
  marketId: string;
  subaccountId: string;
  orderHash: string;
}
interface FundingPayment {
  marketId: string;
  subaccountId: string;
  amount: string;
  timestamp: number;
}
interface FundingRate {
  marketId: string;
  rate: string;
  timestamp: number;
}
type GrpcFundingRate = FundingRate$1;
type GrpcPositionDelta = PositionDelta$1;
type GrpcFundingPayment = FundingPayment$1;
type GrpcDerivativeTrade = DerivativeTrade$1;
type GrpcDerivativePosition = DerivativePosition$1;
type GrpcDerivativePositionV2 = DerivativePositionV2;
type GrpcPerpetualMarketInfo = PerpetualMarketInfo$1;
type GrpcDerivativeMarketInfo = DerivativeMarketInfo;
type GrpcDerivativeLimitOrder = DerivativeLimitOrder$1;
type GrpcPerpetualMarketFunding = PerpetualMarketFunding$1;
type GrpcExpiryFuturesMarketInfo = ExpiryFuturesMarketInfo$1;
type GrpcBinaryOptionsMarketInfo = BinaryOptionsMarketInfo;
type GrpcDerivativeOrderHistory = DerivativeOrderHistory$1;
//#endregion
//#region src/client/indexer/types/explorer-rest.d.ts
interface ExplorerApiResponse<T> {
  data: T;
}
interface ExplorerApiResponseWithPagination<T> {
  data: {
    paging: Paging;
    data: T;
  };
}
interface TransactionFromExplorerApiResponse {
  id: string;
  block_number: number;
  block_timestamp: string;
  signatures: Signature[];
  tx_type: string;
  hash: string;
  code: number;
  memo?: string;
  data?: Uint8Array | string;
  info: string;
  gas_wanted: number;
  gas_used: number;
  gas_fee: {
    amount: {
      amount: string;
      denom: string;
    }[];
    gas_limit: number;
    payer: string;
    granter: string;
  };
  events: Array<any>;
  codespace: string;
  logs: EventLog[];
  messages: Array<{
    value: any;
    type: string;
  }>;
  error_log?: string;
  claim_id?: number[];
}
interface BlockFromExplorerApiResponse {
  height: number;
  proposer: string;
  moniker: string;
  block_hash: string;
  parent_hash: string;
  num_pre_commits: number;
  num_txs: number;
  total_txs: number;
  timestamp: string;
  txs: TransactionFromExplorerApiResponse[];
}
interface ExplorerTransactionApiResponse {
  paging: any;
  data: TransactionFromExplorerApiResponse[];
}
interface ExplorerBlockApiResponse {
  paging: any;
  data: BlockFromExplorerApiResponse[];
}
interface ValidatorUptimeFromExplorerApiResponse {
  block_number: number;
  status: ValidatorUptimeStatus;
}
interface WasmCodeExplorerApiResponse {
  checksum: CosmWasmChecksum;
  code_id: number;
  code_schema: string;
  code_view: string;
  contract_type: string;
  created_at: number;
  creator: string;
  instantiates: number;
  permission: CosmWasmPermission;
  tx_hash: string;
  version: string;
  proposal_id?: number;
}
interface ContractExplorerApiResponse {
  label: string;
  address: string;
  tx_hash: string;
  creator: string;
  executes: number;
  instantiated_at: number;
  init_message: string;
  last_executed_at: number;
  funds?: number;
  code_id: number;
  admin?: string;
  current_migrate_message: string;
  cw20_metadata?: {
    token_info?: {
      name: string;
      symbol: string;
      decimals: number;
      total_supply: string;
    };
  };
}
interface ContractTransactionExplorerApiResponse {
  hash: string;
  code: number;
  block_number: number;
  data: string;
  memo: string;
  tx_number: number;
  error_log: string;
  block_unix_timestamp: number;
  gas_fee: {
    amount: [{
      amount: number;
    }];
  };
  messages: [{
    type: string;
    value: {
      sender: string;
      contract: string;
      msg: Record<string, any>;
      funds: string;
    };
  }];
  logs: EventLog[];
  signatures: Signature[];
}
interface CW20BalanceExplorerApiResponse {
  contract_address: string;
  account: string;
  balance: string;
  updated_at: number;
  cw20_metadata: {
    token_info: {
      name: string;
      symbol: string;
      decimals: number;
      total_supply: string;
    };
    marketing_info: {
      project?: string;
      description?: string;
      logo?: string;
      marketing?: string;
    };
  };
}
interface BankTransferFromExplorerApiResponse {
  sender: string;
  recipient: string;
  amounts: Coin[];
  block_number: number;
  block_timestamp: string;
}
//#endregion
//#region src/client/indexer/types/derivatives-rest.d.ts
type ChronosDerivativeMarketSummary = {
  change: number;
  high: number;
  low: number;
  open: number;
  price: number;
  volume: number;
};
type AllChronosDerivativeMarketSummary = {
  change: number;
  high: number;
  low: number;
  open: number;
  price: number;
  volume: number;
  marketId: string;
};
interface ChronosDerivativeMarketSummaryResponse {
  data: ChronosDerivativeMarketSummary;
}
interface AllDerivativeMarketSummaryResponse {
  data: AllChronosDerivativeMarketSummary[];
}
//#endregion
//#region src/client/indexer/types/leaderboard-rest.d.ts
type ChronosLeaderboardEntry = {
  accountID: string;
  perc: string;
  volume: string;
};
type ChronosLeaderboard = {
  entries: Array<ChronosLeaderboardEntry>;
  resolution: string;
  updatedAt: number;
};
interface ChronosLeaderboardResponse {
  data: ChronosLeaderboard;
}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+indexer-proto-ts-v2@1.17.6/node_modules/@injectivelabs/indexer-proto-ts-v2/esm/generated/injective_portfolio_rpc_pb.d.ts
/**
 * @generated from protobuf message injective_portfolio_rpc.AccountPortfolioResponse
 */
interface AccountPortfolioResponse {
  /**
   * The portfolio of this account
   *
   * @generated from protobuf field: injective_portfolio_rpc.Portfolio portfolio = 1
   */
  portfolio?: Portfolio;
}
/**
 * @generated from protobuf message injective_portfolio_rpc.Portfolio
 */
interface Portfolio {
  /**
   * The account's portfolio address
   *
   * @generated from protobuf field: string account_address = 1
   */
  accountAddress: string;
  /**
   * Account available bank balances
   *
   * @generated from protobuf field: repeated injective_portfolio_rpc.Coin bank_balances = 2
   */
  bankBalances: Coin$2[];
  /**
   * Subaccounts list
   *
   * @generated from protobuf field: repeated injective_portfolio_rpc.SubaccountBalanceV2 subaccounts = 3
   */
  subaccounts: SubaccountBalanceV2[];
  /**
   * All positions for all subaccounts, with unrealized PNL
   *
   * @generated from protobuf field: repeated injective_portfolio_rpc.PositionsWithUPNL positions_with_upnl = 4
   */
  positionsWithUpnl: PositionsWithUPNL$1[];
}
/**
 * @generated from protobuf message injective_portfolio_rpc.Coin
 */
interface Coin$2 {
  /**
   * Denom of the coin
   *
   * @generated from protobuf field: string denom = 1
   */
  denom: string;
  /**
   * @generated from protobuf field: string amount = 2
   */
  amount: string;
  /**
   * @generated from protobuf field: string usd_value = 3
   */
  usdValue: string;
}
/**
 * @generated from protobuf message injective_portfolio_rpc.SubaccountBalanceV2
 */
interface SubaccountBalanceV2 {
  /**
   * Related subaccount ID
   *
   * @generated from protobuf field: string subaccount_id = 1
   */
  subaccountId: string;
  /**
   * Coin denom on the chain.
   *
   * @generated from protobuf field: string denom = 2
   */
  denom: string;
  /**
   * @generated from protobuf field: injective_portfolio_rpc.SubaccountDeposit deposit = 3
   */
  deposit?: SubaccountDeposit$1;
}
/**
 * @generated from protobuf message injective_portfolio_rpc.SubaccountDeposit
 */
interface SubaccountDeposit$1 {
  /**
   * @generated from protobuf field: string total_balance = 1
   */
  totalBalance: string;
  /**
   * @generated from protobuf field: string available_balance = 2
   */
  availableBalance: string;
  /**
   * @generated from protobuf field: string total_balance_usd = 3
   */
  totalBalanceUsd: string;
  /**
   * @generated from protobuf field: string available_balance_usd = 4
   */
  availableBalanceUsd: string;
}
/**
 * @generated from protobuf message injective_portfolio_rpc.PositionsWithUPNL
 */
interface PositionsWithUPNL$1 {
  /**
   * @generated from protobuf field: injective_portfolio_rpc.DerivativePosition position = 1
   */
  position?: DerivativePosition;
  /**
   * Unrealized PNL
   *
   * @generated from protobuf field: string unrealized_pnl = 2
   */
  unrealizedPnl: string;
}
/**
 * @generated from protobuf message injective_portfolio_rpc.DerivativePosition
 */
interface DerivativePosition {
  /**
   * Ticker of the derivative market
   *
   * @generated from protobuf field: string ticker = 1
   */
  ticker: string;
  /**
   * Derivative Market ID
   *
   * @generated from protobuf field: string market_id = 2
   */
  marketId: string;
  /**
   * The subaccountId that the position belongs to
   *
   * @generated from protobuf field: string subaccount_id = 3
   */
  subaccountId: string;
  /**
   * Direction of the position
   *
   * @generated from protobuf field: string direction = 4
   */
  direction: string;
  /**
   * Quantity of the position
   *
   * @generated from protobuf field: string quantity = 5
   */
  quantity: string;
  /**
   * Price of the position
   *
   * @generated from protobuf field: string entry_price = 6
   */
  entryPrice: string;
  /**
   * Margin of the position
   *
   * @generated from protobuf field: string margin = 7
   */
  margin: string;
  /**
   * LiquidationPrice of the position
   *
   * @generated from protobuf field: string liquidation_price = 8
   */
  liquidationPrice: string;
  /**
   * MarkPrice of the position
   *
   * @generated from protobuf field: string mark_price = 9
   */
  markPrice: string;
  /**
   * Aggregate Quantity of the Reduce Only orders associated with the position
   *
   * @generated from protobuf field: string aggregate_reduce_only_quantity = 11
   */
  aggregateReduceOnlyQuantity: string;
  /**
   * Position updated timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 updated_at = 12
   */
  updatedAt: bigint;
  /**
   * Position created timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 created_at = 13
   */
  createdAt: bigint;
  /**
   * Last funding fees since position opened
   *
   * @generated from protobuf field: string funding_last = 14
   */
  fundingLast: string;
  /**
   * Net funding fees since position opened
   *
   * @generated from protobuf field: string funding_sum = 15
   */
  fundingSum: string;
  /**
   * Cumulative funding entry of the position
   *
   * @generated from protobuf field: string cumulative_funding_entry = 16
   */
  cumulativeFundingEntry: string;
  /**
   * Effective cumulative funding entry of the position
   *
   * @generated from protobuf field: string effective_cumulative_funding_entry = 17
   */
  effectiveCumulativeFundingEntry: string;
}
/**
 * @generated from protobuf message injective_portfolio_rpc.AccountPortfolioBalancesResponse
 */
interface AccountPortfolioBalancesResponse {
  /**
   * The portfolio balances of this account
   *
   * @generated from protobuf field: injective_portfolio_rpc.PortfolioBalances portfolio = 1
   */
  portfolio?: PortfolioBalances;
}
/**
 * @generated from protobuf message injective_portfolio_rpc.PortfolioBalances
 */
interface PortfolioBalances {
  /**
   * The account's portfolio address
   *
   * @generated from protobuf field: string account_address = 1
   */
  accountAddress: string;
  /**
   * Account available bank balances
   *
   * @generated from protobuf field: repeated injective_portfolio_rpc.Coin bank_balances = 2
   */
  bankBalances: Coin$2[];
  /**
   * Subaccounts list
   *
   * @generated from protobuf field: repeated injective_portfolio_rpc.SubaccountBalanceV2 subaccounts = 3
   */
  subaccounts: SubaccountBalanceV2[];
  /**
   * USD value of the portfolio
   *
   * @generated from protobuf field: string total_usd = 4
   */
  totalUsd: string;
}
/**
 * @generated from protobuf message injective_portfolio_rpc.StreamAccountPortfolioResponse
 */
interface StreamAccountPortfolioResponse {
  /**
   * type of portfolio entry
   *
   * @generated from protobuf field: string type = 1
   */
  type: string;
  /**
   * denom of portfolio entry
   *
   * @generated from protobuf field: string denom = 2
   */
  denom: string;
  /**
   * amount of portfolio entry
   *
   * @generated from protobuf field: string amount = 3
   */
  amount: string;
  /**
   * subaccount id of portfolio entry
   *
   * @generated from protobuf field: string subaccount_id = 4
   */
  subaccountId: string;
  /**
   * Operation timestamp in UNIX millis.
   *
   * @generated from protobuf field: sint64 timestamp = 5
   */
  timestamp: bigint;
}
/**
 * @generated MessageType for protobuf message injective_portfolio_rpc.AccountPortfolioResponse
 */
declare const AccountPortfolioResponse = new AccountPortfolioResponse$Type();
/**
 * @generated MessageType for protobuf message injective_portfolio_rpc.Portfolio
 */
declare const Portfolio = new Portfolio$Type();
/**
 * @generated MessageType for protobuf message injective_portfolio_rpc.Coin
 */
declare const Coin$2 = new Coin$Type();
/**
 * @generated MessageType for protobuf message injective_portfolio_rpc.SubaccountBalanceV2
 */
declare const SubaccountBalanceV2 = new SubaccountBalanceV2$Type();
/**
 * @generated MessageType for protobuf message injective_portfolio_rpc.SubaccountDeposit
 */
declare const SubaccountDeposit$1 = new SubaccountDeposit$Type();
/**
 * @generated MessageType for protobuf message injective_portfolio_rpc.PositionsWithUPNL
 */
declare const PositionsWithUPNL$1 = new PositionsWithUPNL$Type();
/**
 * @generated MessageType for protobuf message injective_portfolio_rpc.DerivativePosition
 */
declare const DerivativePosition = new DerivativePosition$Type();
/**
 * @generated MessageType for protobuf message injective_portfolio_rpc.AccountPortfolioBalancesResponse
 */
declare const AccountPortfolioBalancesResponse = new AccountPortfolioBalancesResponse$Type();
/**
 * @generated MessageType for protobuf message injective_portfolio_rpc.PortfolioBalances
 */
declare const PortfolioBalances = new PortfolioBalances$Type();
/**
 * @generated MessageType for protobuf message injective_portfolio_rpc.StreamAccountPortfolioResponse
 */
declare const StreamAccountPortfolioResponse = new StreamAccountPortfolioResponse$Type();
//#endregion
//#region src/client/indexer/types/account-portfolio.d.ts
interface SubaccountDepositV2 {
  totalBalance: string;
  availableBalance: string;
}
interface PortfolioSubaccountBalanceV2 {
  subaccountId: string;
  denom: string;
  deposit?: SubaccountDepositV2;
}
interface PositionsWithUPNL {
  position?: Position;
  unrealizedPnl: string;
}
interface AccountPortfolioV2 {
  accountAddress: string;
  bankBalancesList: Coin[];
  subaccountsList: PortfolioSubaccountBalanceV2[];
  positionsWithUpnlList: PositionsWithUPNL[];
}
interface AccountPortfolioBalances {
  accountAddress: string;
  bankBalancesList: Coin[];
  subaccountsList: PortfolioSubaccountBalanceV2[];
}
type GrpcPositionV2 = DerivativePosition;
type GrpcAccountPortfolioV2 = Portfolio;
type GrpcSubaccountDepositV2 = SubaccountDeposit$1;
type GrpcPositionsWithUPNL = PositionsWithUPNL$1;
type GrpcPortfolioSubaccountBalanceV2 = SubaccountBalanceV2;
//#endregion
//#region src/client/indexer/types/markets-history-rest.d.ts
type AllChronosMarketHistory = {
  marketID: string;
  resolution: string;
  t: number[];
  v: number[];
  c: number[];
  h: number[];
  l: number[];
  o: number[];
};
interface ChronosMarketHistoryResponse {
  data: AllChronosMarketHistory[];
}
//#endregion
//#region src/client/indexer/types/index.d.ts
interface StreamStatusResponse {
  details: string;
  code: number;
  metadata: any;
}
declare const IndexerModule: {
  Dmm: "dmm";
  OLP: "olp";
  Abacus: "abacus";
  Meta: "indexer-meta";
  Mito: "indexer-mito";
  Referral: "referral";
  Spot: "indexer-spot";
  Web3Gw: "web3-gateway";
  Oracle: "indexer-oracle";
  Account: "indexer-account";
  Auction: "indexer-auction";
  Trading: "indexer-trading";
  Archiver: "indexer-archiver";
  Explorer: "indexer-explorer";
  Campaign: "indexer-campaign";
  Portfolio: "indexer-portfolio";
  MegaVault: "indexer-mega-vault";
  Derivatives: "indexer-derivatives";
  Transaction: "indexer-transaction";
  ChronosSpot: "indexer-chronos-spot";
  InsuranceFund: "indexer-insurance-fund";
  ChronosMarkets: "indexer-chronos-markets";
  ChronosDerivative: "indexer-chronos-derivative";
};
//#endregion
//#region src/client/indexer/grpc/IndexerGrpcTradingApi.d.ts
/**
 * @category Indexer Grpc API
 */
declare class IndexerGrpcTradingApi extends BaseIndexerGrpcConsumer {
  protected module: string;
  private get client();
  fetchTradingStats(): Promise<GetTradingStatsResponse>;
  fetchGridStrategies({
    skip,
    state,
    limit,
    withTvl,
    endTime,
    marketId,
    startTime,
    marketType,
    strategyType,
    subaccountId,
    accountAddress,
    withPerformance,
    pendingExecution,
    lastExecutedTime,
    isTrailingStrategy
  }: {
    skip?: number;
    state?: string;
    limit?: number;
    endTime?: number;
    withTvl?: boolean;
    marketId?: string;
    startTime?: number;
    marketType?: MarketType;
    subaccountId?: string;
    strategyType?: GridStrategyType[];
    accountAddress?: string;
    withPerformance?: boolean;
    pendingExecution?: boolean;
    lastExecutedTime?: number;
    isTrailingStrategy?: boolean;
  }): Promise<ListTradingStrategiesResponse$1>;
}
//#endregion
//#region src/client/indexer/grpc/IndexerGrpcExplorerApi.d.ts
/**
 * @category Indexer Grpc API
 */
declare class IndexerGrpcExplorerApi extends BaseIndexerGrpcConsumer {
  protected module: string;
  private get client();
  fetchTxByHash(hash: string, isEvmHash?: boolean): Promise<Transaction>;
  fetchAccountTx({
    address,
    limit,
    type,
    before,
    after,
    startTime,
    endTime
  }: {
    address: string;
    limit?: number;
    type?: string;
    before?: number;
    after?: number;
    startTime?: number;
    endTime?: number;
  }): Promise<{
    txs: Transaction[];
    pagination: ExchangePagination;
  }>;
  fetchValidator(validatorAddress: string): Promise<ExplorerValidator>;
  fetchValidatorUptime(validatorAddress: string): Promise<ValidatorUptime[]>;
  fetchPeggyDepositTxs({
    sender,
    receiver,
    limit,
    skip
  }: {
    receiver?: string;
    sender?: string;
    limit?: number;
    skip?: number;
  }): Promise<PeggyDepositTx[]>;
  fetchPeggyWithdrawalTxs({
    sender,
    receiver,
    limit,
    skip
  }: {
    sender?: string;
    receiver?: string;
    limit?: number;
    skip?: number;
  }): Promise<PeggyWithdrawalTx[]>;
  fetchBlocks({
    before,
    after,
    limit,
    from,
    to
  }: {
    before?: number;
    after?: number;
    limit?: number;
    from?: number;
    to?: number;
  }): Promise<GetBlocksResponse>;
  fetchBlock(id: string): Promise<GetBlockResponse>;
  fetchTxs({
    before,
    after,
    limit,
    skip,
    type,
    chainModule,
    startTime,
    endTime
  }: {
    before?: number;
    after?: number;
    limit?: number;
    skip?: number;
    type?: string;
    startTime?: number;
    endTime?: number;
    chainModule?: string;
  }): Promise<GetTxsResponse>;
  fetchIBCTransferTxs({
    sender,
    receiver,
    srcChannel,
    srcPort,
    destChannel,
    destPort,
    limit,
    skip
  }: {
    sender?: string;
    receiver?: string;
    srcChannel?: string;
    srcPort?: string;
    destChannel?: string;
    destPort?: string;
    limit?: number;
    skip?: number;
  }): Promise<IBCTransferTx[]>;
  fetchExplorerStats(): Promise<ExplorerStats>;
  fetchTxsV2({
    type,
    token,
    status,
    perPage,
    endTime,
    startTime,
    blockNumber
  }: {
    type?: string;
    token?: string;
    status?: string;
    perPage?: number;
    endTime?: number;
    startTime?: number;
    blockNumber?: number;
  }): Promise<{
    data: ExplorerTransaction[];
    paging: Cursor | undefined;
  }>;
  fetchAccountTxsV2({
    type,
    token,
    address,
    endTime,
    perPage,
    startTime
  }: {
    type?: string;
    token?: string;
    address: string;
    endTime?: number;
    perPage?: number;
    startTime?: number;
  }): Promise<{
    data: ExplorerTransaction[];
    paging: Cursor | undefined;
  }>;
  fetchBlocksV2({
    token,
    perPage
  }: {
    token?: string;
    perPage?: number;
  }): Promise<{
    paging: Cursor | undefined;
    data: Block$1[];
  }>;
  fetchContractTxsV2({
    to,
    from,
    token,
    height,
    status,
    perPage,
    contractAddress
  }: {
    to?: number;
    from?: number;
    token?: string;
    height?: string;
    status?: string;
    perPage?: number;
    contractAddress: string;
  }): Promise<{
    data: ContractTransaction[];
    paging: Cursor | undefined;
  }>;
}
//#endregion
//#region src/client/indexer/grpc/IndexerGrpcCampaignApi.d.ts
/**
 * @category Indexer Grpc API
 */
declare class IndexerGrpcCampaignApi extends BaseIndexerGrpcConsumer {
  protected module: string;
  private get client();
  fetchCampaign({
    skip,
    limit,
    marketId,
    campaignId,
    accountAddress,
    contractAddress
  }: {
    skip?: string;
    limit?: number;
    marketId?: string;
    campaignId: string;
    accountAddress?: string;
    contractAddress?: string;
  }): Promise<{
    campaign: Campaign | undefined;
    users: CampaignUser[];
    paging: ExchangePagination;
  }>;
  fetchCampaigns({
    type,
    active,
    limit,
    cursor,
    status
  }: {
    type?: string;
    active?: boolean;
    limit?: number;
    cursor?: string;
    status?: string;
  }): Promise<{
    campaigns: CampaignV2[];
    cursor: string;
  }>;
  fetchRound({
    roundId,
    toRoundId,
    accountAddress,
    contractAddress
  }: {
    roundId?: string;
    toRoundId?: number;
    accountAddress?: string;
    contractAddress?: string;
  }): Promise<{
    campaigns: Campaign[];
    accumulatedRewards: Coin$3[];
    rewardCount: number;
  }>;
  fetchGuilds({
    skip,
    limit,
    sortBy,
    campaignContract
  }: {
    skip?: number;
    limit?: number;
    sortBy: string;
    campaignContract: string;
  }): Promise<{
    guilds: Guild[];
    paging: ExchangePagination;
    updatedAt: number;
    summary: GuildCampaignSummary | undefined;
  }>;
  fetchGuildMember({
    address,
    campaignContract
  }: {
    address: string;
    campaignContract: string;
  }): Promise<{
    info: GuildMember | undefined;
  }>;
  fetchGuildMembers({
    skip,
    limit,
    sortBy,
    guildId,
    campaignContract,
    includeGuildInfo
  }: {
    skip?: number;
    limit?: number;
    sortBy?: string;
    guildId: string;
    campaignContract: string;
    includeGuildInfo: boolean;
  }): Promise<{
    members: GuildMember[];
    paging: ExchangePagination;
    guildInfo: Guild | undefined;
  }>;
}
//#endregion
//#region src/client/indexer/grpc/IndexerGrpcArchiverApi.d.ts
/**
 * @category Indexer Grpc API
 */
declare class IndexerGrpcArchiverApi extends BaseIndexerGrpcConsumer {
  protected module: string;
  private get client();
  fetchHistoricalBalance({
    account,
    resolution
  }: {
    account: string;
    resolution: string;
  }): Promise<HistoricalBalance>;
  fetchHistoricalRpnl({
    account,
    resolution
  }: {
    account: string;
    resolution: string;
  }): Promise<HistoricalRPNL>;
  fetchHistoricalVolumes({
    account,
    resolution
  }: {
    account: string;
    resolution: string;
  }): Promise<HistoricalVolumes>;
  fetchPnlLeaderboard({
    startDate,
    endDate,
    limit,
    account
  }: {
    startDate: string;
    endDate: string;
    limit?: number;
    account?: string;
  }): Promise<PnlLeaderboard>;
  fetchVolLeaderboard({
    startDate,
    endDate,
    limit,
    account
  }: {
    startDate: string;
    endDate: string;
    limit?: number;
    account?: string;
  }): Promise<VolLeaderboard>;
  fetchPnlLeaderboardFixedResolution({
    resolution,
    limit,
    account
  }: {
    resolution: string;
    limit?: number;
    account?: string;
  }): Promise<PnlLeaderboard>;
  fetchVolLeaderboardFixedResolution({
    resolution,
    limit,
    account
  }: {
    resolution: string;
    limit?: number;
    account?: string;
  }): Promise<VolLeaderboard>;
  fetchDenomHolders({
    denom,
    token,
    limit
  }: {
    denom: string;
    token?: string;
    limit?: number;
  }): Promise<DenomHolders>;
  fetchAccountStats({
    account,
    period
  }: {
    account: string;
    period?: string;
  }): Promise<AccountStats>;
}
//#endregion
//#region src/client/indexer/grpc/IndexerGrpcReferralApi.d.ts
/**
 * @category Indexer Grpc API
 */
declare class IndexerGrpcReferralApi extends BaseIndexerGrpcConsumer {
  protected module: string;
  private get client();
  fetchReferrerDetails(address: string): Promise<ReferralDetails>;
  fetchInviteeDetails(address: string): Promise<GetInviteeDetailsResponse>;
  fetchReferrerByCode(code: string): Promise<string>;
}
//#endregion
//#region src/client/indexer/grpc/IndexerGrpcMegaVaultApi.d.ts
/**
 * @category Indexer Grpc API
 */
declare class IndexerGrpcMegaVaultApi extends BaseIndexerGrpcConsumer {
  protected module: string;
  private get client();
  fetchVault({
    vaultAddress
  }: {
    vaultAddress: string;
  }): Promise<MegaVault | undefined>;
  fetchVaultUser({
    vaultAddress,
    userAddress
  }: {
    userAddress: string;
    vaultAddress: string;
  }): Promise<MegaVaultUser | undefined>;
  fetchVaultSubscriptions({
    token,
    status,
    perPage,
    userAddress,
    vaultAddress
  }: {
    token?: string;
    status?: string;
    perPage?: number;
    userAddress: string;
    vaultAddress: string;
  }): Promise<MegaVaultSubscription[]>;
  fetchVaultRedemptions({
    token,
    status,
    perPage,
    userAddress,
    vaultAddress
  }: {
    token?: string;
    status?: string;
    perPage?: number;
    vaultAddress: string;
    userAddress: string;
  }): Promise<MegaVaultRedemption[]>;
  fetchOperatorRedemptionBuckets({
    vaultAddress,
    operatorAddress
  }: {
    vaultAddress: string;
    operatorAddress: string;
  }): Promise<MegaVaultOperatorRedemptionBucket[]>;
  fetchVaultTvlHistory({
    since,
    vaultAddress,
    maxDataPoints
  }: {
    since: number;
    vaultAddress: string;
    maxDataPoints?: number;
  }): Promise<MegaVaultHistoricalTVL[]>;
  fetchVaultPnlHistory({
    since,
    vaultAddress,
    maxDataPoints
  }: {
    since: number;
    vaultAddress: string;
    maxDataPoints?: number;
  }): Promise<MegaVaultHistoricalPnL[]>;
}
//#endregion
//#region src/client/indexer/grpc/IndexerGrpcDerivativesApi.d.ts
/**
 * @category Indexer Grpc API
 */
declare class IndexerGrpcDerivativesApi extends BaseIndexerGrpcConsumer {
  protected module: string;
  private get client();
  fetchMarkets(params?: {
    quoteDenom?: string;
    marketStatus?: string;
    marketStatuses?: string[];
  }): Promise<DerivativeMarket[]>;
  fetchMarket(marketId: string): Promise<DerivativeMarket>;
  fetchBinaryOptionsMarkets(params?: {
    marketStatus?: string;
    quoteDenom?: string;
    pagination?: PaginationOption;
  }): Promise<{
    markets: BinaryOptionsMarket[];
    pagination: ExchangePagination;
  }>;
  fetchBinaryOptionsMarket(marketId: string): Promise<BinaryOptionsMarket>;
  /** @deprecated - use fetchOrderbookV2 */
  fetchOrderbook(_marketId: string): Promise<void>;
  fetchOrders(params?: {
    cid?: string;
    tradeId?: string;
    marketId?: string;
    marketIds?: string[];
    orderSide?: OrderSide;
    pagination?: PaginationOption;
    subaccountId?: string;
    isConditional?: boolean;
  }): Promise<{
    orders: DerivativeLimitOrder[];
    pagination: ExchangePagination;
  }>;
  fetchOrderHistory(params?: {
    cid?: string;
    state?: OrderState;
    tradeId?: string;
    marketId?: string;
    marketIds?: string[];
    orderTypes?: OrderSide[];
    direction?: TradeDirection;
    pagination?: PaginationOption;
    subaccountId?: string;
    isConditional?: boolean;
    executionTypes?: TradeExecutionType[];
  }): Promise<{
    orderHistory: DerivativeOrderHistory[];
    pagination: ExchangePagination;
  }>;
  fetchPositions(params?: {
    marketId?: string;
    marketIds?: string[];
    subaccountId?: string;
    direction?: TradeDirection;
    pagination?: PaginationOption;
  }): Promise<{
    positions: Position[];
    pagination: ExchangePagination;
  }>;
  fetchPositionsV2(params?: {
    address?: string;
    marketId?: string;
    marketIds?: string[];
    subaccountId?: string;
    direction?: TradeDirection;
    pagination?: PaginationOption;
  }): Promise<{
    positions: PositionV2[];
    pagination: ExchangePagination;
  }>;
  fetchTrades(params?: {
    endTime?: number;
    tradeId?: string;
    marketId?: string;
    startTime?: number;
    marketIds?: string[];
    subaccountId?: string;
    accountAddress?: string;
    direction?: TradeDirection;
    pagination?: PaginationOption;
    executionSide?: TradeExecutionSide;
    executionTypes?: TradeExecutionType[];
    cid?: string;
  }): Promise<{
    trades: DerivativeTrade[];
    pagination: ExchangePagination;
  }>;
  fetchFundingPayments(params?: {
    marketId?: string;
    marketIds?: string[];
    subaccountId?: string;
    pagination?: PaginationOption;
  }): Promise<{
    fundingPayments: FundingPayment[];
    pagination: ExchangePagination;
  }>;
  fetchFundingRates(params?: {
    marketId?: string;
    pagination?: PaginationOption;
  }): Promise<{
    fundingRates: FundingRate[];
    pagination: ExchangePagination;
  }>;
  fetchSubaccountOrdersList(params?: {
    marketId?: string;
    subaccountId?: string;
    pagination?: PaginationOption;
  }): Promise<{
    orders: DerivativeLimitOrder[];
    pagination: ExchangePagination;
  }>;
  fetchSubaccountTradesList(params: {
    marketId?: string;
    subaccountId?: string;
    direction?: TradeDirection;
    executionType?: TradeExecutionType;
    pagination?: PaginationOption;
  }): Promise<DerivativeTrade[]>;
  /** @deprecated - use fetchOrderbooksV2 */
  fetchOrderbooks(_marketIds: string[]): Promise<void>;
  fetchOrderbooksV2(marketIds: string[]): Promise<{
    marketId: string;
    orderbook: OrderbookWithSequence;
  }[]>;
  fetchOrderbookV2(marketId: string): Promise<OrderbookWithSequence>;
}
//#endregion
//#region src/client/indexer/grpc/IndexerGrpcPortfolioApi.d.ts
/**
 * @category Indexer Grpc API
 */
declare class IndexerGrpcAccountPortfolioApi extends BaseIndexerGrpcConsumer {
  protected module: string;
  private get client();
  fetchAccountPortfolio(address: string): Promise<AccountPortfolioV2>;
  fetchAccountPortfolioBalances(address: string): Promise<AccountPortfolioBalances>;
}
//#endregion
//#region src/client/indexer/grpc/IndexerGrpcInsuranceFundApi.d.ts
/**
 * @category Indexer Grpc API
 */
declare class IndexerGrpcInsuranceFundApi extends BaseIndexerGrpcConsumer {
  protected module: string;
  private get client();
  fetchRedemptions({
    denom,
    address,
    status
  }: {
    address: string;
    denom?: string;
    status?: string;
  }): Promise<Redemption[]>;
  fetchInsuranceFunds(): Promise<IndexerInsuranceFund[]>;
}
//#endregion
//#region src/client/base/BaseRestConsumer.d.ts
/**
 * @hidden
 */
declare class BaseRestConsumer extends HttpRestClient {}
//#endregion
//#region src/client/indexer/rest/IndexerRestExplorerApi.d.ts
/**
 * @category Indexer Rest API
 */
declare class IndexerRestExplorerApi extends BaseRestConsumer {
  constructor(endpoint: string);
  fetchBlock(blockHashHeight: string): Promise<ExplorerBlockWithTxs>;
  fetchBlocks(params?: {
    before?: number;
    limit?: number;
    from?: number;
    to?: number;
  }): Promise<{
    paging: Paging;
    blocks: Block$1[];
  }>;
  fetchBlocksWithTx(params?: {
    before?: number;
    limit?: number;
    from?: number;
    to?: number;
  }): Promise<{
    paging: Paging;
    blocks: ExplorerBlockWithTxs[];
  }>;
  fetchTransactions(params?: {
    fromNumber?: number;
    limit?: number;
    before?: number;
    after?: number;
    toNumber?: number;
    skip?: number;
    startTime?: number;
    endTime?: number;
    status?: MsgStatus;
    type?: MsgType[];
  }): Promise<{
    paging: Paging;
    transactions: ExplorerTransaction[];
  }>;
  fetchAccountTransactions({
    account,
    params
  }: {
    account: string;
    params?: {
      skip?: number;
      limit?: number;
      after?: number;
      before?: number;
      type?: MsgType[];
      status?: MsgStatus;
      endTime?: number;
      toNumber?: number;
      fromNumber?: number;
      startTime?: number;
      withClaimId?: boolean;
    };
  }): Promise<{
    paging: Paging;
    transactions: ExplorerTransaction[];
  }>;
  fetchTransaction(hash: string, isEvmTx?: boolean): Promise<ExplorerTransaction>;
  fetchValidators(): Promise<Partial<ExplorerValidator>[]>;
  fetchValidatorUptime(validatorConsensusAddress: string): Promise<ExplorerValidatorUptime[]>;
  fetchContract(contractAddress: string): Promise<Contract>;
  fetchContracts(params?: {
    assetsOnly?: boolean;
    fromNumber?: number;
    codeId?: string | number;
    limit?: number;
    skip?: number;
    label?: string;
    token?: string;
    lookup?: string;
  }): Promise<{
    paging: Paging;
    contracts: Contract[];
  }>;
  fetchContractTransactions({
    contractAddress,
    params
  }: {
    contractAddress: string;
    params?: {
      fromNumber?: number;
      limit?: number;
      toNumber?: number;
      skip?: number;
    };
  }): Promise<{
    paging: Paging;
    transactions: ContractTransaction[];
  }>;
  fetchContractTransactionsWithMessages({
    contractAddress,
    params
  }: {
    contractAddress: string;
    params?: {
      fromNumber?: number;
      limit?: number;
      toNumber?: number;
      skip?: number;
    };
  }): Promise<{
    paging: Paging;
    transactions: ContractTransactionWithMessages[];
  }>;
  fetchWasmCode(codeId: number): Promise<WasmCode>;
  fetchWasmCodes(params?: {
    fromNumber?: number;
    limit?: number;
    toNumber?: number;
  }): Promise<{
    paging: Paging;
    wasmCodes: WasmCode[];
  }>;
  fetchCW20Balances(address: string): Promise<ExplorerCW20BalanceWithToken[]>;
  fetchCW20BalancesNoThrow(address: string): Promise<CW20BalanceExplorerApiResponse[]>;
  fetchBankTransfers(params: {
    limit?: number;
    skip?: number;
    startTime?: number;
    endTime?: number;
    address?: string;
    isCommunitySpendPool?: boolean;
    senders?: string;
    recipients?: string;
  }): Promise<{
    paging: Paging;
    data: BankTransfer[];
  }>;
}
//#endregion
//#region src/client/indexer/rest/IndexerRestSpotChronosApi.d.ts
/**
 * @category Indexer Chronos API
 */
declare class IndexerRestSpotChronosApi extends BaseRestConsumer {
  fetchMarketSummary(marketId: string): Promise<ChronosSpotMarketSummary>;
  fetchMarketsSummary(): Promise<AllChronosSpotMarketSummary[]>;
}
//#endregion
//#region src/client/indexer/rest/IndexerRestMarketChronosApi.d.ts
declare class IndexerRestMarketChronosApi extends BaseRestConsumer {
  fetchMarketsHistory({
    marketIds,
    resolution,
    countback
  }: {
    marketIds: string[];
    resolution: string | number;
    countback: string | number;
  }): Promise<AllChronosMarketHistory[]>;
}
//#endregion
//#region src/client/indexer/rest/IndexerRestDerivativesChronosApi.d.ts
/**
 * @category Indexer Chronos API
 */
declare class IndexerRestDerivativesChronosApi extends BaseRestConsumer {
  fetchMarketSummary(marketId: string): Promise<ChronosDerivativeMarketSummary>;
  fetchMarketsSummary(): Promise<AllChronosDerivativeMarketSummary[]>;
}
//#endregion
//#region src/client/indexer/rest/IndexerRestLeaderboardChronosApi.d.ts
/**
 * @category Indexer Chronos API
 */
declare class IndexerRestLeaderboardChronosApi extends BaseRestConsumer {
  fetchLeaderboard(resolution: string): Promise<ChronosLeaderboard>;
}
//#endregion
//#region src/client/indexer/transformers/IndexerGrpcMitoTransformer.d.ts
/**
 * @category Indexer Grpc Transformer
 */
declare class IndexerGrpcMitoTransformer {
  static grpcTokenInfoToTokenInfo(tokenInfo: TokenInfo): MitoTokenInfo;
  static mitoPaginationToPagination(pagination?: Pagination$1): MitoPagination | undefined;
  static mitoDenomBalanceToDenomBalance(denomBalance: DenomBalance$1): MitoDenomBalance;
  static changesResponseToChanges(changes?: Changes): MitoChanges | undefined;
  static mitoSubaccountInfoToSubaccountInfo(mitoSubaccountInfo?: SubaccountBalance$1): MitoSubaccountBalance | undefined;
  static mitoVaultToVault(vault: Vault$1): MitoVault;
  static mitoPriceSnapshotToPriceSnapshot(snapshot: PriceSnapshot): MitoPriceSnapshot;
  static portfolioResponseToPortfolio(portfolio: PortfolioResponse): MitoPortfolio;
  static leaderboardResponseToLeaderboard(leaderboard: LeaderboardResponse): MitoLeaderboard;
  static mitoTransferHistoryToTransferHistory(transfer: Transfer): MitoTransfer;
  static mitoLeaderboardEpochToLeaderboardEpoch(leaderboardEpoch: LeaderboardEpoch): MitoLeaderboardEpoch;
  static mitoStakingRewardToStakingReward(stakingReward: StakingReward): {
    apr: number;
    vaultName: string;
    vaultAddress: string;
    lockTimestamp: number;
    claimableRewards: Coin$8[];
    stakedAmount: Coin$8 | undefined;
    lockedAmount: Coin$8 | undefined;
  };
  static mitoGaugeToGauge(gauge: Gauge): MitoGauge;
  static mitoStakingPoolToStakingPool(stakingPool: StakingPool): MitoStakingPool;
  static mitoStakingActivityToStakingActivity(stakingActivity: StakingActivity): {
    action: string;
    txHash: string;
    staker: string;
    vaultAddress: string;
    numberByAccount: number;
    timestamp: number;
    rewardedTokens: Coin$8[];
    stakeAmount: Coin$8 | undefined;
  };
  static mitoSubscriptionToSubscription(subscription: Subscription$2): MitoSubscription;
  static mitoLpHolderToLPHolder(holder: Holders): MitoHolders;
  static mitoMissionToMission(mission: Mission): MitoMission;
  static mitoMissionLeaderboardEntryToMissionLeaderboardEntry(entry: MissionLeaderboardEntry): MitoMissionLeaderboardEntry;
  static mitoIDOProgressToIDOProgress(progress: IDOProgress): MitoIDOProgress;
  static mitoStakedToSubscriptionToStakedToSubscription(data: ArrayOfString): MitoStakeToSubscription;
  static mitoIDOToIDO(IDO: IDO): MitoIDO;
  static mitoIDOSubscriberToIDOSubscriber(IDOSubscriber: IDOSubscriber): MitoIDOSubscriber;
  static mitoIDOClaimedCoinsToIDOClaimedCoins(claimedCoins: IDOClaimedCoins): MitoIDOClaimedCoins;
  static mitoIDOSubscriptionToIDOSubscription(subscription: IDOSubscription): MitoIDOSubscription;
  static mitoIDOSubscriptionActivityToIDOSubscriptionActivity(IDOSubscriptionActivity: IDOSubscriptionActivity): MitoIDOSubscriptionActivity;
  static mitoWhitelistAccountToWhitelistAccount(account: WhitelistAccount): MitoWhitelistAccount;
  static mitoClaimReferenceToClaimReference(claimReference: ClaimReference): MitoClaimReference;
  static mitoVestingCOonfigToVestingConfig(config?: VestingConfig): MitoVestingConfig;
  static mitoIDOInitParamsToIDOVestingConfig(initParams?: InitParams): MitoVestingConfigMap | undefined;
  static vaultResponseToVault(response: GetVaultResponse$1): MitoVault;
  static vaultsResponseToVaults(response: GetVaultsResponse): {
    vaults: MitoVault[];
    pagination?: MitoPagination;
  };
  static lpTokenPriceChartResponseToLPTokenPriceChart(response: LPTokenPriceChartResponse): MitoPriceSnapshot[];
  static vaultsByHolderAddressResponseToVaultsByHolderAddress(response: VaultsByHolderAddressResponse): {
    subscriptions: MitoSubscription[];
    pagination: MitoPagination | undefined;
  };
  static lpHoldersResponseToLPHolders(response: LPHoldersResponse): {
    holders: MitoHolders[];
    pagination: MitoPagination | undefined;
  };
  static transferHistoryResponseToTransfer(response: TransfersHistoryResponse): {
    transfers: MitoTransfer[];
    pagination: MitoPagination | undefined;
  };
  static leaderboardEpochsResponseToLeaderboardEpochs(response: LeaderboardEpochsResponse): {
    epochs: MitoLeaderboardEpoch[];
    pagination: MitoPagination | undefined;
  };
  static stakingPoolsResponseToStakingPools(response: GetStakingPoolsResponse): {
    pools: MitoStakingPool[];
    pagination: MitoPagination | undefined;
  };
  static stakingRewardByAccountResponseToStakingRewardByAccount(response: StakingRewardByAccountResponse): {
    rewards: {
      apr: number;
      vaultName: string;
      vaultAddress: string;
      lockTimestamp: number;
      claimableRewards: Coin$8[];
      stakedAmount: Coin$8 | undefined;
      lockedAmount: Coin$8 | undefined;
    }[];
    pagination: MitoPagination | undefined;
  };
  static mitoStakingHistoryResponseTpStakingHistory(response: StakingHistoryResponse): {
    activities: {
      action: string;
      txHash: string;
      staker: string;
      vaultAddress: string;
      numberByAccount: number;
      timestamp: number;
      rewardedTokens: Coin$8[];
      stakeAmount: Coin$8 | undefined;
    }[];
    pagination: MitoPagination | undefined;
  };
  static mitoMissionsResponseMissions(response: MissionsResponse): MitoMission[];
  static mitoMissionLeaderboardResponseToMissionLeaderboard(response: MissionLeaderboardResponse): MitoMissionLeaderboard;
  static mitoListIDOsResponseToIDOs(response: ListIDOsResponse): {
    idos: MitoIDO[];
    pagination: MitoPagination | undefined;
  };
  static mitoIDOResponseToIDO(response: GetIDOResponse): {
    ido: MitoIDO | undefined;
  };
  static mitoIDOSubscribersResponseToIDOSubscribers(response: GetIDOSubscribersResponse): {
    marketId: string;
    quoteDenom: string;
    subscribers: MitoIDOSubscriber[];
    pagination: MitoPagination | undefined;
    tokenInfo: MitoTokenInfo | undefined;
  };
  static mitoIDOSubscriptionResponseToIDOSubscription(response: GetIDOSubscriptionResponse): {
    subscription: MitoIDOSubscription | undefined;
  };
  static mitoIDOActivitiesResponseToIDOActivities(response: GetIDOActivitiesResponse): {
    activities: MitoIDOSubscriptionActivity[];
    pagination: MitoPagination | undefined;
  };
  static mitoWhitelistAccountResponseToWhitelistAccount(response: GetWhitelistResponse): {
    idoAddress: string | undefined;
    accounts: MitoWhitelistAccount[];
    pagination: MitoPagination | undefined;
  };
  static claimReferencesResponseToClaimReferences(response: GetClaimReferencesResponse): {
    claimReferences: MitoClaimReference[];
    pagination?: MitoPagination;
  };
}
//#endregion
//#region src/client/indexer/transformers/IndexerGrpcSpotTransformer.d.ts
/**
 * @category Indexer Grpc Transformer
 */
declare class IndexerGrpcSpotTransformer {
  static grpcTokenMetaToTokenMeta(tokenMeta: GrpcTokenMeta | undefined): IndexerTokenMeta | undefined;
  static marketResponseToMarket(response: MarketResponse$1): SpotMarket;
  static marketsResponseToMarkets(response: MarketsResponse$1): SpotMarket[];
  static ordersResponseToOrders(response: OrdersResponse$1): {
    orders: SpotLimitOrder[];
    pagination: ExchangePagination;
  };
  static orderHistoryResponseToOrderHistory(response: OrdersHistoryResponse$1): {
    orderHistory: SpotOrderHistory[];
    pagination: ExchangePagination;
  };
  static tradesResponseToTrades(response: TradesResponse$1): {
    trades: SpotTrade[];
    pagination: ExchangePagination;
  };
  static subaccountTradesListResponseToTradesList(response: SubaccountTradesListResponse$1): SpotTrade[];
  static orderbookV2ResponseToOrderbookV2(response: OrderbookV2Response$1): OrderbookWithSequence;
  static orderbooksV2ResponseToOrderbooksV2(response: OrderbooksV2Response$1): {
    marketId: string;
    orderbook: OrderbookWithSequence;
  }[];
  static grpcMarketToMarket(market: GrpcSpotMarketInfo): SpotMarket;
  static grpcMarketsToMarkets(markets: GrpcSpotMarketInfo[]): SpotMarket[];
  static grpcPriceLevelToPriceLevel(priceLevel: GrpcPriceLevel): PriceLevel;
  static grpcPriceLevelsToPriceLevels(priceLevels: GrpcPriceLevel[]): PriceLevel[];
  static grpcOrderbookToOrderbook({
    buys,
    sells
  }: {
    buys: GrpcPriceLevel[];
    sells: GrpcPriceLevel[];
  }): Orderbook;
  static grpcOrderbookV2ToOrderbookV2({
    buys,
    sells,
    sequence
  }: {
    buys: GrpcPriceLevel[];
    sells: GrpcPriceLevel[];
    sequence: number;
  }): OrderbookWithSequence;
  static grpcOrderToOrder(order: GrpcSpotLimitOrder): SpotLimitOrder;
  static grpcOrdersToOrders(orders: GrpcSpotLimitOrder[]): SpotLimitOrder[];
  static grpcOrderHistoryToOrderHistory(orderHistory: GrpcSpotOrderHistory): SpotOrderHistory;
  static grpcOrderHistoryListToOrderHistoryList(orderHistory: GrpcSpotOrderHistory[]): SpotOrderHistory[];
  static grpcTradeToTrade(trade: GrpcSpotTrade): SpotTrade;
  static grpcTradesToTrades(trades: GrpcSpotTrade[]): SpotTrade[];
  static grpcAtomicSwapHistoryListToAtomicSwapHistoryList(response: AtomicSwapHistoryResponse): {
    swapHistory: AtomicSwap[];
    pagination: ExchangePagination;
  };
  static grpcAtomicSwapHistoryToAtomicSwapHistory(swapHistory: GrpcAtomicSwap): AtomicSwap;
}
//#endregion
//#region src/client/indexer/transformers/IndexerCampaignTransformer.d.ts
declare class IndexerCampaignTransformer {
  static GrpcCampaignUserToCampaignUser(campaignUser: CampaignUser$1): CampaignUser;
  static GrpcCampaignToCampaign(campaign: Campaign$1): Campaign;
  static GrpcGuildToGuild(guild: Guild$1): Guild;
  static GrpcGuildMemberToGuildMember(member: GuildMember$1): GuildMember;
  static GrpcGuildCampaignSummaryToGuildCampaignSummary(campaignSummary: CampaignSummary): GuildCampaignSummary;
  static CampaignResponseToCampaign(response: RankingResponse): {
    campaign: Campaign | undefined;
    users: CampaignUser[];
    paging: ExchangePagination;
  };
  static RoundsResponseToRounds(response: CampaignsResponse): {
    campaigns: Campaign[];
    accumulatedRewards: Coin$3[];
    rewardCount: number;
  };
  static GuildsResponseToGuilds(response: ListGuildsResponse): {
    guilds: Guild[];
    paging: ExchangePagination;
    updatedAt: number;
    summary: GuildCampaignSummary | undefined;
  };
  static GuildMemberResponseToGuildMember(response: GetGuildMemberResponse): {
    info: GuildMember | undefined;
  };
  static GuildMembersResponseToGuildMembers(response: ListGuildMembersResponse): {
    members: GuildMember[];
    paging: ExchangePagination;
    guildInfo: Guild | undefined;
  };
  static GrpcCampaignV2ToCampaignV2(campaign: CampaignV2$1): CampaignV2;
  static CampaignsV2ResponseToCampaigns(response: CampaignsV2Response): {
    campaigns: CampaignV2[];
    cursor: string;
  };
}
//#endregion
//#region src/client/indexer/transformers/IndexerGrpcOracleTransformer.d.ts
declare class IndexerGrpcOracleTransformer {
  static oraclesResponseToOracles(response: OracleListResponse): Oracle[];
  static grpcOracleToOracle(grpcOracle: GrpcOracle): Oracle;
}
//#endregion
//#region src/client/indexer/transformers/IndexerSpotStreamTransformer.d.ts
/**
 * @category Indexer Stream Transformer
 */
declare class IndexerSpotStreamTransformer {
  static tradesStreamCallback: (response: StreamTradesResponse$1) => {
    trade: SpotTrade | undefined;
    operation: StreamOperation;
    timestamp: bigint;
  };
  static ordersStreamCallback: (response: StreamOrdersResponse$1) => {
    order: SpotLimitOrder | undefined;
    operation: StreamOperation;
    timestamp: bigint;
  };
  static orderHistoryStreamCallback: (response: StreamOrdersHistoryResponse$1) => {
    order: SpotOrderHistory | undefined;
    operation: StreamOperation;
    timestamp: bigint;
  };
  static orderbookV2StreamCallback: (response: StreamOrderbookV2Response$1) => {
    orderbook: OrderbookWithSequence | undefined;
    operation: StreamOperation;
    marketId: string;
    timestamp: bigint;
  };
  static orderbookUpdateStreamCallback: (response: StreamOrderbookUpdateResponse$1) => {
    orderbook: OrderbookWithSequence | undefined;
    operation: StreamOperation;
    marketId: string;
    timestamp: bigint;
  };
}
//#endregion
//#region src/client/indexer/transformers/IndexerGrpcAccountTransformer.d.ts
/**
 * @category Indexer Grpc Transformer
 *
 */
declare class IndexerGrpcAccountTransformer {
  /**
   *
   * @deprecated - use IndexerGrpcAccountPortfolioApi.accountPortfolioResponseToAccountPortfolio
   */
  static accountPortfolioResponseToAccountPortfolio(response: PortfolioResponse$1): AccountPortfolio;
  static grpcSubaccountPortfolioToSubaccountPortfolio(subaccountPortfolio: GrpcSubaccountPortfolio): SubaccountPortfolio;
  static grpcAccountPortfolioToAccountPortfolio(portfolio: GrpcAccountPortfolio): AccountPortfolio;
  static grpcAmountToAmount(amount: GrpcCoin): Coin;
  static grpcDepositToDeposit(deposit: GrpcSubaccountDeposit): SubaccountDeposit;
  static balancesResponseToBalances(response: SubaccountBalancesListResponse): SubaccountBalance[];
  static balanceResponseToBalance(response: SubaccountBalanceEndpointResponse): SubaccountBalance;
  static grpcBalanceToBalance(balance: GrpcSubaccountBalance): SubaccountBalance;
  static grpcBalancesToBalances(balances: GrpcSubaccountBalance[]): SubaccountBalance[];
  static grpcTransferHistoryEntryToTransferHistoryEntry(transfer: GrpcSubaccountBalanceTransfer): SubaccountTransfer;
  static tradingRewardsResponseToTradingRewards(response: RewardsResponse): TradingReward[];
  static grpcTradingRewardsToTradingRewards(rewards: GrpcTradingReward[]): TradingReward[];
  static grpcTradingRewardToTradingReward(reward: GrpcTradingReward): TradingReward;
  static transferHistoryResponseToTransferHistory(response: SubaccountHistoryResponse): {
    transfers: SubaccountTransfer[];
    pagination: ExchangePagination;
  };
  static grpcTransferHistoryToTransferHistory(transfers: GrpcSubaccountBalanceTransfer[]): SubaccountTransfer[];
}
//#endregion
//#region src/client/indexer/transformers/IndexerGrpcAuctionTransformer.d.ts
/**
 * @category Indexer Grpc Transformer
 */
declare class IndexerGrpcAuctionTransformer {
  static grpcAuctionCoinToAuctionCoin(grpcCoin: GrpcAuctionCoin): AuctionCoin;
  static grpcAuctionCoinPricesToAuctionCoinPrices(grpcCoinPrices: GrpcAuctionCoinPrices): AuctionCoinPrices;
  static grpcBidToBid(grpcBid: GrpcIndexerAuctionBid): IndexerAuctionBid;
  static grpcAuctionToAuction(grpcAuction: GrpcAuction): Auction;
  static grpcAuctionV2ToAuctionV2(grpcAuction: GrpcAuctionV2): AuctionV2;
  static grpcAccountAuctionV2ToAccountAuctionV2(grpcAccountAuction: GrpcAccountAuctionV2): AccountAuctionV2;
  static auctionsResponseToAuctions(response: AuctionsResponse): Auction[];
  static auctionsHistoryV2ResponseToAuctionHistory(response: AuctionsHistoryV2Response): {
    auctions: AuctionV2[];
    next: string[];
  };
  static accountAuctionsV2ResponseToAccountAuctionsV2(response: AccountAuctionsV2Response): {
    auctions: AccountAuctionV2[];
    next: string[];
    total: bigint;
  };
  static auctionResponseToAuction(response: AuctionEndpointResponse): {
    auction: Auction;
    bids: IndexerAuctionBid[];
  };
  static auctionStatsResponseToAuctionStats(response: AuctionsStatsResponse): AuctionsStats;
  static auctionAccountStatusResponseToAuctionAccountStatus(response: AuctionAccountStatusResponse): AccountAuctionStatus;
}
//#endregion
//#region src/client/indexer/transformers/IndexerGrpcArchiverTransformer.d.ts
/**
 * @category Indexer Grpc Transformer
 */
declare class IndexerGrpcArchiverTransformer {
  static grpcHistoricalBalanceToHistoricalBalance(historicalBalance: HistoricalBalance$1): HistoricalBalance;
  static grpcHistoricalRPNLToHistoricalRPNL(historicalRPNL: HistoricalRPNL$1): HistoricalRPNL;
  static grpcHistoricalVolumesToHistoricalVolumes(historicalVolumes: HistoricalVolumes$1): HistoricalVolumes;
  static grpcLeaderboardRowToLeaderboardRow(leaderboardRow: LeaderboardRow$1): LeaderboardRow;
  static grpcHistoricalBalanceResponseToHistoricalBalances(response: BalanceResponse): HistoricalBalance;
  static grpcHistoricalRPNLResponseToHistoricalRPNL(response: RpnlResponse): HistoricalRPNL;
  static grpcHistoricalVolumesResponseToHistoricalVolumes(response: VolumesResponse): HistoricalVolumes;
  static grpcPnlLeaderboardResponseToPnlLeaderboard(response: PnlLeaderboardResponse): PnlLeaderboard;
  static grpcVolLeaderboardResponseToVolLeaderboard(response: VolLeaderboardResponse): VolLeaderboard;
  static grpcPnlLeaderboardFixedResolutionResponseToPnlLeaderboard(response: PnlLeaderboardFixedResolutionResponse): PnlLeaderboard;
  static grpcVolLeaderboardFixedResolutionResponseToVolLeaderboard(response: VolLeaderboardFixedResolutionResponse): VolLeaderboard;
  static grpcDenomHoldersResponseToDenomHolders(response: DenomHoldersResponse): DenomHolders;
  static grpcAccountStatsResponseToAccountStats(response: AccountStatsResponse): AccountStats;
  static grpcSpotAverageEntryToSpotAverageEntry(averageEntry: SpotAverageEntry$1): SpotAverageEntry;
}
//#endregion
//#region src/client/indexer/transformers/IndexerGrpcExplorerTransformer.d.ts
/**
 * @category Indexer Grpc Transformer
 */
declare class IndexerGrpcExplorerTransformer {
  static getTxByTxHashResponseToTx(tx: GetTxByTxHashResponse): Transaction;
  static getAccountTxsResponseToAccountTxs(response: GetAccountTxsResponse): {
    txs: Transaction[];
    pagination: ExchangePagination;
  };
  static getValidatorUptimeResponseToValidatorUptime(response: GetValidatorUptimeResponse): ValidatorUptime[];
  static getPeggyDepositTxsResponseToPeggyDepositTxs(response: GetPeggyDepositTxsResponse): PeggyDepositTx[];
  static getPeggyWithdrawalTxsResponseToPeggyWithdrawalTxs(response: GetPeggyWithdrawalTxsResponse): PeggyWithdrawalTx[];
  static getIBCTransferTxsResponseToIBCTransferTxs(response: GetIBCTransferTxsResponse): IBCTransferTx[];
  static validatorResponseToValidator(validator: GetValidatorResponse): ExplorerValidator;
  static streamTxResponseToTxs(response: StreamTxsResponse): IndexerStreamTransaction;
  static grpcGasFeeToGasFee(gasFee: GrpcGasFee): GasFee;
  static grpcTransactionToBankMsgSendTransaction(tx: GetTxByTxHashResponse): BankMsgSendTransaction;
  static grpcTransactionToTransaction(tx: GetTxByTxHashResponse): Transaction;
  static grpcTransactionsToTransactions(txs: Array<GetTxByTxHashResponse>): Array<Transaction>;
  static grpcTransactionToTransactionFromDetail(tx: TxDetailData): Transaction;
  static grpcTransactionsToTransactionsFromDetail(txs: TxDetailData[]): Array<Transaction>;
  static grpcBlockToBlock(block: BlockInfo): Block$1;
  static grpcBlockToBlockWithTxs(block: BlockInfo): BlockWithTxs;
  static grpcBlocksToBlocks(blocks: Array<BlockInfo>): Array<Block$1>;
  static grpcBlocksToBlocksWithTxs(blocks: Array<BlockInfo>): Array<BlockWithTxs>;
  static grpcValidatorDescriptionToValidatorDescription(validatorDescription: GrpcIndexerValidatorDescription): ExplorerValidatorDescription;
  static grpcValidatorUptimeToValidatorUptime(validatorUptime: GrpcValidatorUptime): ValidatorUptime;
  static grpcValidatorSlashingEventToValidatorSlashingEvent(validatorUptime: GrpcValidatorSlashingEvent): ValidatorSlashingEvent;
  static grpcIBCTransferTxToIBCTransferTx(grpcIBCTransferTx: GrpcIBCTransferTx): IBCTransferTx;
  static grpcPeggyDepositTx(grpcPeggyDepositTx: GrpcPeggyDepositTx): PeggyDepositTx;
  static grpcPeggyWithdrawalTx(grpcPeggyWithdrawalTx: GrpcPeggyWithdrawalTx): PeggyWithdrawalTx;
  static getExplorerStatsResponseToExplorerStats(response: GetStatsResponse): ExplorerStats;
  static getTxsV2ResponseToTxs(response: GetTxsV2Response): {
    data: ExplorerTransaction[];
    paging: Cursor | undefined;
  };
  static grpcTxV2ToTransaction(tx: TxData): ExplorerTransaction;
  static getAccountTxsV2ResponseToAccountTxs(response: GetAccountTxsV2Response): {
    data: ExplorerTransaction[];
    paging: Cursor | undefined;
  };
  static grpcAccountTxV2ToTransaction(tx: TxDetailData): ExplorerTransaction;
  static getBlocksV2ResponseToBlocks(response: GetBlocksV2Response): {
    paging: Cursor | undefined;
    data: Block$1[];
  };
  static grpcBlockV2ToBlock(block: BlockInfo): Block$1;
  static getContractTxsV2ResponseToContractTxs(response: GetContractTxsV2Response): {
    data: ContractTransaction[];
    paging: Cursor | undefined;
  };
  static grpcContractTxV2ToTransaction(tx: TxDetailData): ContractTransaction;
}
//#endregion
//#region src/client/indexer/transformers/IndexerGrpcReferralTransformer.d.ts
declare class IndexerGrpcReferralTransformer {
  static referrerDetailsResponseToReferrerDetails(address: string, response: GetReferrerDetailsResponse): ReferralDetails;
  static inviteeDetailsResponseToInviteeDetails(response: GetInviteeDetailsResponse): GetInviteeDetailsResponse;
  static referrerByCodeResponseToReferrerByCode(response: GetReferrerByCodeResponse): string;
}
//#endregion
//#region src/client/indexer/transformers/IndexerOracleStreamTransformer.d.ts
/**
 * @category Indexer Stream Transformer
 */
declare class IndexerOracleStreamTransformer {
  static pricesStreamCallback: (response: StreamPricesResponse) => {
    price: string;
    timestamp: number;
    operation: StreamOperation;
  };
  static pricesByMarketsCallback: (response: StreamPricesByMarketsResponse) => {
    price: string;
    timestamp: bigint;
    marketId: string;
  };
}
//#endregion
//#region src/client/indexer/transformers/IndexerRestExplorerTransformer.d.ts
/**
 * @category Indexer Rest Transformer
 */
declare class IndexerRestExplorerTransformer {
  static blockToBlock(block: BlockFromExplorerApiResponse): Block$1;
  static blocksToBlocks(blocks: BlockFromExplorerApiResponse[]): Block$1[];
  static transactionToTransaction(transaction: TransactionFromExplorerApiResponse): ExplorerTransaction;
  static transactionsToTransactions(transactions: TransactionFromExplorerApiResponse[]): ExplorerTransaction[];
  static blockWithTxToBlockWithTx(block: BlockFromExplorerApiResponse): ExplorerBlockWithTxs;
  static blocksWithTxsToBlocksWithTxs(blocks: BlockFromExplorerApiResponse[]): ExplorerBlockWithTxs[];
  static baseTransactionToTransaction(transaction: Transaction): ExplorerTransaction;
  static validatorExplorerToValidator(validators: any[]): Partial<ExplorerValidator>[];
  static validatorUptimeToExplorerValidatorUptime(validatorUptimeList: ValidatorUptimeFromExplorerApiResponse[]): ExplorerValidatorUptime[];
  static contractToExplorerContract(contract: ContractExplorerApiResponse): Contract;
  static contractTransactionToExplorerContractTransaction(transaction: ContractTransactionExplorerApiResponse): ContractTransaction;
  static contractTransactionToExplorerContractTransactionWithMessages(transaction: ContractTransactionExplorerApiResponse): ContractTransactionWithMessages;
  static wasmCodeToExplorerWasmCode(wasmCode: WasmCodeExplorerApiResponse): WasmCode;
  static CW20BalanceToExplorerCW20Balance(balance: CW20BalanceExplorerApiResponse): ExplorerCW20BalanceWithToken;
  static bankTransferToBankTransfer(transfer: BankTransferFromExplorerApiResponse): BankTransfer;
  static bankTransfersToBankTransfers(transfers: BankTransferFromExplorerApiResponse[]): BankTransfer[];
}
//#endregion
//#region src/client/indexer/transformers/IndexerAccountStreamTransformer.d.ts
/**
 * @category Indexer Stream Transformer
 */
declare class IndexerAccountStreamTransformer {
  static balanceStreamCallback: (response: StreamSubaccountBalanceResponse) => {
    balance: SubaccountBalance | undefined;
    operation: "update";
    timestamp: bigint;
  };
}
//#endregion
//#region src/client/indexer/transformers/IndexerAuctionStreamTransformer.d.ts
/**
 * @category Indexer Stream Transformer
 */
declare class IndexerAuctionStreamTransformer {
  static bidsStreamCallback: (response: StreamBidsResponse$1) => {
    bid: IndexerAuctionBid;
    operation: "insert";
  };
}
//#endregion
//#region src/client/indexer/transformers/IndexerGrpcMegaVaultTransformer.d.ts
declare class IndexerGrpcMegaVaultTransformer {
  static vaultResponseToVault(response: GetVaultResponse): MegaVault | undefined;
  static userResponseToUser(response: GetUserResponse): MegaVaultUser | undefined;
  static subscriptionsResponseToSubscriptions(response: ListSubscriptionsResponse): MegaVaultSubscription[];
  static redemptionsResponseToRedemptions(response: ListRedemptionsResponse): MegaVaultRedemption[];
  static operatorRedemptionBucketsResponseToOperatorRedemptionBuckets(response: GetOperatorRedemptionBucketsResponse): MegaVaultOperatorRedemptionBucket[];
  static tvlHistoryResponseToTvlHistory(response: TvlHistoryResponse): MegaVaultHistoricalTVL[];
  static pnlHistoryResponseToPnlHistory(response: PnlHistoryResponse): MegaVaultHistoricalPnL[];
  static grpcOperatorToOperator(operator: GrpcMegaVaultOperator): MegaVaultOperator;
  static grpcIncentiveToIncentive(incentive: GrpcMegaVaultIncentives): MegaVaultIncentives;
  static grpcTargetAprToTargetApr(targetApr: GrpcMegaVaultTargetApr): MegaVaultTargetApr;
  static grpcVaultStatsToVaultStats(stats: GrpcMegaVaultVaultStats): MegaVaultStats;
  static grpcPnlStatsToPnlStats(pnl: GrpcMegaVaultPnlStats): MegaVaultPnlStats;
  static grpcUnrealizedPnlToUnrealizedPnl(pnl: GrpcMegaVaultUnrealizedPnl): MegaVaultUnrealizedPnl;
  static grpcPnlToPnl(pnl: GrpcMegaVaultPnl): MegaVaultPnl;
  static grpcMaxDrawdownToMaxDrawdown(maxDrawdown: GrpcMegaVaultMaxDrawdown): MegaVaultMaxDrawdown;
  static grpcVolatilityStatsToVolatilityStats(volatility: GrpcMegaVaultVolatilityStats): MegaVaultVolatilityStats;
  static grpcVolatilityToVolatility(volatility: GrpcMegaVaultVolatility): MegaVaultVolatility;
  static grpcAprStatsToAprStats(apr: GrpcMegaVaultAprStats): MegaVaultAprStats;
  static grpcAprToApr(apr: GrpcMegaVaultApr): MegaVaultApr;
  static grpcUserStatsToUserStats(stats: GrpcMegaVaultUserStats): MegaVaultUserStats;
  static grpcSubscriptionsToSubscriptions(subscriptions: GrpcMegaVaultSubscription[]): MegaVaultSubscription[];
  static grpcSubscriptionToSubscription(subscription: GrpcMegaVaultSubscription): MegaVaultSubscription;
  static grpcRedemptionToRedemption(redemption: GrpcMegaVaultRedemption): MegaVaultRedemption;
  static grpcOperatorRedemptionBucketToOperatorRedemptionBucket(bucket: GrpcMegaVaultOperatorRedemptionBucket): MegaVaultOperatorRedemptionBucket;
  static grpcHistoricalTVLToHistoricalTVL(history: GrpcMegaVaultHistoricalTVL): MegaVaultHistoricalTVL;
  static grpcHistoricalPnLToHistoricalPnL(history: GrpcMegaVaultHistoricalPnL): MegaVaultHistoricalPnL;
  static grpcOperationStatusLogEntryToOperationStatusLogEntry(log: GrpcMegaVaultOperationStatusLogEntry): OperationStatusLogEntry;
}
//#endregion
//#region src/client/indexer/transformers/IndexerArchiverStreamTransformer.d.ts
/**
 * @category Indexer Stream Transformer
 */
declare class IndexerArchiverStreamTransformer {
  static spotAverageEntriesStreamCallback: (response: StreamSpotAverageEntriesResponse) => {
    averageEntry: SpotAverageEntry | undefined;
    operation: "update";
    timestamp: number;
  };
}
//#endregion
//#region src/client/indexer/transformers/IndexerExplorerStreamTransformer.d.ts
/**
 * @category Indexer Stream Transformer
 */
declare class ExplorerStreamTransformer {
  static blocksStreamCallback: (response: StreamBlocksResponse) => {
    block: Block$1;
    operation: "insert";
  };
  static blocksWithTxsStreamCallback: (response: StreamBlocksResponse) => {
    block: BlockWithTxs;
    operation: "insert";
  };
  static transactionsStreamCallback: (response: StreamTxsResponse) => {
    block: IndexerStreamTransaction;
    operation: "insert";
  };
}
//#endregion
//#region src/client/indexer/transformers/IndexerGrpcDerivativeTransformer.d.ts
/**
 * @category Indexer Grpc Transformer
 */
declare class IndexerGrpcDerivativeTransformer {
  static grpcTokenMetaToTokenMeta(tokenMeta: GrpcTokenMeta | undefined): IndexerTokenMeta | undefined;
  static grpcPerpetualMarketInfoToPerpetualMarketInfo(perpetualMarketInfo: GrpcPerpetualMarketInfo | undefined): PerpetualMarketInfo | undefined;
  static grpcPerpetualMarketFundingToPerpetualMarketFunding(perpetualMarketFunding: GrpcPerpetualMarketFunding | undefined): PerpetualMarketFunding | undefined;
  static grpcExpiryFuturesMarketInfoToExpiryFuturesMarketInfo(expiryFuturesMarketInfo: GrpcExpiryFuturesMarketInfo | undefined): ExpiryFuturesMarketInfo | undefined;
  static marketResponseToMarket(response: MarketResponse): DerivativeMarket;
  static marketsResponseToMarkets(response: MarketsResponse): DerivativeMarket[];
  static ordersResponseToOrders(response: OrdersResponse): {
    orders: DerivativeLimitOrder[];
    pagination: ExchangePagination;
  };
  static orderHistoryResponseToOrderHistory(response: OrdersHistoryResponse, isConditional?: boolean): {
    orderHistory: DerivativeOrderHistory[];
    pagination: ExchangePagination;
  };
  static positionsResponseToPositions(response: PositionsResponse): {
    positions: Position[];
    pagination: ExchangePagination;
  };
  static positionsV2ResponseToPositionsV2(response: PositionsV2Response): {
    positions: PositionV2[];
    pagination: ExchangePagination;
  };
  static tradesResponseToTrades(response: TradesResponse): {
    trades: DerivativeTrade[];
    pagination: ExchangePagination;
  };
  static subaccountTradesListResponseToSubaccountTradesList(response: SubaccountTradesListResponse): DerivativeTrade[];
  static fundingPaymentsResponseToFundingPayments(response: FundingPaymentsResponse): {
    fundingPayments: FundingPayment[];
    pagination: ExchangePagination;
  };
  static fundingRatesResponseToFundingRates(response: FundingRatesResponse): {
    fundingRates: FundingRate[];
    pagination: ExchangePagination;
  };
  static orderbookV2ResponseToOrderbookV2(response: OrderbookV2Response): OrderbookWithSequence;
  static orderbooksV2ResponseToOrderbooksV2(response: OrderbooksV2Response): {
    marketId: string;
    orderbook: OrderbookWithSequence;
  }[];
  static binaryOptionsMarketResponseToBinaryOptionsMarket(response: BinaryOptionsMarketResponse): BinaryOptionsMarket;
  static binaryOptionsMarketResponseWithPaginationToBinaryOptionsMarket(response: BinaryOptionsMarketsResponse): {
    markets: BinaryOptionsMarket[];
    pagination: ExchangePagination;
  };
  static binaryOptionsMarketsResponseToBinaryOptionsMarkets(response: BinaryOptionsMarketsResponse): BinaryOptionsMarket[];
  static grpcBinaryOptionsMarketToBinaryOptionsMarket(market: GrpcBinaryOptionsMarketInfo): BinaryOptionsMarket;
  static grpcBinaryOptionsMarketsToBinaryOptionsMarkets(markets: GrpcBinaryOptionsMarketInfo[]): BinaryOptionsMarket[];
  static grpcMarketToMarket(market: GrpcDerivativeMarketInfo): DerivativeMarket;
  static grpcMarketsToMarkets(markets: GrpcDerivativeMarketInfo[]): DerivativeMarket[];
  static grpcPositionDeltaToPositionDelta(positionDelta: GrpcPositionDelta): PositionDelta;
  static grpcPriceLevelToPriceLevel(priceLevel: GrpcPriceLevel): PriceLevel;
  static grpcPriceLevelsToPriceLevels(priceLevels: GrpcPriceLevel[]): PriceLevel[];
  static grpcOrderbookToOrderbook({
    buys,
    sells
  }: {
    buys: GrpcPriceLevel[];
    sells: GrpcPriceLevel[];
  }): Orderbook;
  static grpcOrderbookV2ToOrderbookV2({
    sequence,
    buys,
    sells
  }: {
    sequence: number;
    buys: GrpcPriceLevel[];
    sells: GrpcPriceLevel[];
  }): OrderbookWithSequence;
  static priceLevelsToGrpcPriceLevels(priceLevels: PriceLevel[]): GrpcPriceLevel[];
  static grpcOrderToOrder(order: GrpcDerivativeLimitOrder): DerivativeLimitOrder;
  static grpcOrdersToOrders(orders: GrpcDerivativeLimitOrder[]): DerivativeLimitOrder[];
  static grpcOrderHistoryToOrderHistory(orderHistory: GrpcDerivativeOrderHistory): DerivativeOrderHistory;
  static grpcOrderHistoryListToOrderHistoryList(orderHistory: GrpcDerivativeOrderHistory[], isConditional?: boolean): DerivativeOrderHistory[];
  static grpcPositionToPosition(position: GrpcDerivativePosition): Position;
  static grpcPositionV2ToPositionV2(position: GrpcDerivativePositionV2): PositionV2;
  static grpcPositionsToPositions(positions: GrpcDerivativePosition[]): Position[];
  static grpcPositionsV2ToPositionsV2(positions: GrpcDerivativePositionV2[]): PositionV2[];
  static grpcTradeToTrade(trade: GrpcDerivativeTrade): DerivativeTrade;
  static grpcTradesToTrades(trades: GrpcDerivativeTrade[]): DerivativeTrade[];
  static grpcFundingPaymentToFundingPayment(fundingPayment: GrpcFundingPayment): FundingPayment;
  static grpcFundingPaymentsToFundingPayments(fundingPayments: GrpcFundingPayment[]): FundingPayment[];
  static grpcFundingRateToFundingRate(fundingRate: GrpcFundingRate): FundingRate;
  static grpcFundingRatesToFundingRates(fundingRates: GrpcFundingRate[]): FundingRate[];
}
//#endregion
//#region src/client/indexer/transformers/IndexerGrpcMitoStreamTransformer.d.ts
/**
 * @category Indexer Stream Transformer
 */
declare class IndexerGrpcMitoStreamTransformer {
  static transfersStreamCallback: (response: StreamTransfersResponse) => {
    transfer: MitoTransfer | undefined;
    opType: StreamOperation;
  };
  static vaultStreamCallback: (response: StreamVaultResponse) => {
    vault: MitoVault | undefined;
    opType: StreamOperation;
  };
  static vaultHolderSubscriptionStreamCallback: (response: StreamHolderSubscriptionResponse) => {
    subscription: MitoSubscription | undefined;
    opType: StreamOperation;
  };
  static stakingRewardByAccountStreamCallback: (response: StreamStakingRewardByAccountResponse) => {
    stakingReward: {
      apr: number;
      vaultName: string;
      vaultAddress: string;
      lockTimestamp: number;
      claimableRewards: Coin$8[];
      stakedAmount: Coin$8 | undefined;
      lockedAmount: Coin$8 | undefined;
    } | undefined;
    opType: StreamOperation;
  };
  static historicalStakingStreamCallback: (response: StreamHistoricalStakingResponse) => {
    historicalStaking: {
      action: string;
      txHash: string;
      staker: string;
      vaultAddress: string;
      numberByAccount: number;
      timestamp: number;
      rewardedTokens: Coin$8[];
      stakeAmount: Coin$8 | undefined;
    } | undefined;
    opType: StreamOperation;
  };
}
//#endregion
//#region src/client/indexer/transformers/IndexerAccountPortfolioTransformer.d.ts
declare class IndexerGrpcAccountPortfolioTransformer {
  static accountPortfolioResponseToAccountPortfolio(response: AccountPortfolioResponse, address: string): AccountPortfolioV2;
  static accountPortfolioBalancesResponseToAccountPortfolioBalances(response: AccountPortfolioBalancesResponse, address: string): AccountPortfolioBalances;
  static grpcPositionWithUPNLToPositionWithUPNL(positionsWithUPNL: GrpcPositionsWithUPNL): PositionsWithUPNL;
  static grpcSubaccountDepositToSubaccountDeposit(subaccountDeposit: GrpcSubaccountDepositV2): SubaccountDepositV2;
  static grpcSubaccountBalanceToSubaccountBalance(subaccountBalance: GrpcPortfolioSubaccountBalanceV2): PortfolioSubaccountBalanceV2;
}
//#endregion
//#region src/client/indexer/transformers/IndexerDerivativeStreamTransformer.d.ts
/**
 * @category Indexer Stream Transformer
 */
declare class IndexerDerivativeStreamTransformer {
  static tradesStreamCallback: (response: StreamTradesResponse) => {
    trade: DerivativeTrade | undefined;
    operation: StreamOperation;
    timestamp: bigint;
  };
  static positionStreamCallback: (response: StreamPositionsResponse) => {
    position: Position | undefined;
    timestamp: bigint;
  };
  static ordersStreamCallback: (response: StreamOrdersResponse) => {
    order: DerivativeLimitOrder | undefined;
    operation: StreamOperation;
    timestamp: bigint;
  };
  static orderHistoryStreamCallback: (response: StreamOrdersHistoryResponse) => {
    order: DerivativeOrderHistory | undefined;
    operation: StreamOperation;
    timestamp: bigint;
  };
  static orderbookV2StreamCallback: (response: StreamOrderbookV2Response) => {
    orderbook: OrderbookWithSequence | undefined;
    operation: StreamOperation;
    marketId: string;
    timestamp: bigint;
  };
  static orderbookUpdateStreamCallback: (response: StreamOrderbookUpdateResponse) => {
    orderbook: OrderbookWithSequence | undefined;
    operation: StreamOperation;
    marketId: string;
    timestamp: bigint;
  };
  static positionV2StreamCallback: (response: StreamPositionsV2Response) => {
    position: PositionV2 | undefined;
    timestamp: bigint;
  };
}
//#endregion
//#region src/client/indexer/transformers/IndexerGrpcInsuranceFundTransformer.d.ts
/**
 * @category Indexer Grpc Transformer
 */
declare class IndexerGrpcInsuranceFundTransformer {
  static insuranceFundsResponseToInsuranceFunds(response: FundsResponse): IndexerInsuranceFund[];
  static redemptionsResponseToRedemptions(response: RedemptionsResponse): Redemption[];
  static grpcInsuranceFundToInsuranceFund(grpcInsuranceFund: GrpcIndexerInsuranceFund): IndexerInsuranceFund;
  static grpcInsuranceFundsToInsuranceFunds(grpcInsuranceFunds: GrpcIndexerInsuranceFund[]): IndexerInsuranceFund[];
  static grpcRedemptionToRedemption(redemption: GrpcIndexerRedemptionSchedule): Redemption;
  static grpcRedemptionsToRedemptions(redemptions: GrpcIndexerRedemptionSchedule[]): Redemption[];
}
//#endregion
//#region src/client/indexer/transformers/IndexerAccountPortfolioStreamTransformer.d.ts
/**
 * @category Indexer Stream Transformer
 */
declare class IndexerAccountPortfolioStreamTransformer {
  static accountPortfolioStreamCallback: (response: StreamAccountPortfolioResponse) => {
    type: string;
    denom: string;
    amount: string;
    subaccountId: string;
  };
}
//#endregion
//#region src/client/indexer/grpc_stream/stream/IndexerGrpcSpotStream.d.ts
type MarketsStreamCallback = (response: StreamMarketsResponse) => void;
type SpotOrderbookV2StreamCallback = (response: ReturnType<typeof IndexerSpotStreamTransformer.orderbookV2StreamCallback>) => void;
type SpotOrderbookUpdateStreamCallback = (response: ReturnType<typeof IndexerSpotStreamTransformer.orderbookUpdateStreamCallback>) => void;
type SpotOrdersStreamCallback = (response: ReturnType<typeof IndexerSpotStreamTransformer.ordersStreamCallback>) => void;
type SpotOrderHistoryStreamCallback = (response: ReturnType<typeof IndexerSpotStreamTransformer.orderHistoryStreamCallback>) => void;
type SpotTradesStreamCallback = (response: ReturnType<typeof IndexerSpotStreamTransformer.tradesStreamCallback>) => void;
/**
 * @category Indexer Grpc Stream
 * @description Provides streaming access to spot market data from Injective Indexer
 */
declare class IndexerGrpcSpotStream {
  private client;
  private transport;
  constructor(endpoint: string, metadata?: Record<string, string>);
  /** @deprecated - use streamOrderbookV2 */
  streamOrderbook(_args: {
    marketIds: string[];
    callback: any;
    onEndCallback?: (status?: StreamStatusResponse) => void;
    onStatusCallback?: (status: StreamStatusResponse) => void;
  }): Subscription;
  /**
   * Stream spot orders
   * @param params - Stream parameters
   * @param params.marketId - Optional market ID to filter orders
   * @param params.subaccountId - Optional subaccount ID to filter orders
   * @param params.orderSide - Optional order side to filter
   * @param params.callback - Called for each order update
   * @param params.onEndCallback - Called when stream ends normally
   * @param params.onStatusCallback - Called on stream errors
   * @returns Subscription object with unsubscribe method
   */
  streamOrders({
    marketId,
    subaccountId,
    orderSide,
    callback,
    onEndCallback,
    onStatusCallback
  }: {
    marketId?: string;
    subaccountId?: string;
    orderSide?: OrderSide;
    callback: SpotOrdersStreamCallback;
    onEndCallback?: (status?: StreamStatusResponse) => void;
    onStatusCallback?: (status: StreamStatusResponse) => void;
  }): Subscription;
  /**
   * Stream spot order history
   * @param params - Stream parameters
   * @param params.marketId - Optional market ID to filter orders
   * @param params.subaccountId - Optional subaccount ID to filter orders
   * @param params.orderTypes - Optional array of order types to filter
   * @param params.executionTypes - Optional array of execution types to filter
   * @param params.direction - Optional trade direction to filter
   * @param params.state - Optional order state to filter
   * @param params.callback - Called for each order history update
   * @param params.onEndCallback - Called when stream ends normally
   * @param params.onStatusCallback - Called on stream errors
   * @returns Subscription object with unsubscribe method
   */
  streamOrderHistory({
    marketId,
    subaccountId,
    orderTypes,
    executionTypes,
    direction,
    state,
    callback,
    onEndCallback,
    onStatusCallback
  }: {
    marketId?: string;
    subaccountId?: string;
    orderTypes?: OrderSide[];
    executionTypes?: TradeExecutionType[];
    direction?: TradeDirection;
    state?: OrderState;
    callback: SpotOrderHistoryStreamCallback;
    onEndCallback?: (status?: StreamStatusResponse) => void;
    onStatusCallback?: (status: StreamStatusResponse) => void;
  }): Subscription;
  /**
   * Stream spot trades
   * @param params - Stream parameters
   * @param params.marketIds - Optional array of market IDs to filter trades
   * @param params.marketId - Optional market ID to filter trades
   * @param params.subaccountIds - Optional array of subaccount IDs to filter trades
   * @param params.subaccountId - Optional subaccount ID to filter trades
   * @param params.pagination - Optional pagination options
   * @param params.direction - Optional trade direction to filter
   * @param params.executionSide - Optional trade execution side to filter
   * @param params.callback - Called for each trade update
   * @param params.onEndCallback - Called when stream ends normally
   * @param params.onStatusCallback - Called on stream errors
   * @returns Subscription object with unsubscribe method
   */
  streamTrades({
    marketIds,
    marketId,
    subaccountIds,
    subaccountId,
    pagination,
    direction,
    executionSide,
    callback,
    onEndCallback,
    onStatusCallback
  }: {
    marketIds?: string[];
    marketId?: string;
    subaccountIds?: string[];
    subaccountId?: string;
    pagination?: PaginationOption;
    direction?: TradeDirection;
    executionSide?: TradeExecutionSide;
    callback: SpotTradesStreamCallback;
    onEndCallback?: (status?: StreamStatusResponse) => void;
    onStatusCallback?: (status: StreamStatusResponse) => void;
  }): Subscription;
  /**
   * Stream spot market data
   * @param params - Stream parameters
   * @param params.marketIds - Optional array of market IDs to filter
   * @param params.callback - Called for each market update
   * @param params.onEndCallback - Called when stream ends normally
   * @param params.onStatusCallback - Called on stream errors
   * @returns Subscription object with unsubscribe method
   */
  streamMarkets({
    marketIds,
    callback,
    onEndCallback,
    onStatusCallback
  }: {
    marketIds?: string[];
    callback: MarketsStreamCallback;
    onEndCallback?: (status?: StreamStatusResponse) => void;
    onStatusCallback?: (status: StreamStatusResponse) => void;
  }): Subscription;
  /**
   * Stream spot orderbook V2
   * @param params - Stream parameters
   * @param params.marketIds - Array of market IDs to stream orderbook for
   * @param params.callback - Called for each orderbook update
   * @param params.onEndCallback - Called when stream ends normally
   * @param params.onStatusCallback - Called on stream errors
   * @returns Subscription object with unsubscribe method
   */
  streamOrderbooksV2({
    marketIds,
    callback,
    onEndCallback,
    onStatusCallback
  }: {
    marketIds: string[];
    callback: SpotOrderbookV2StreamCallback;
    onEndCallback?: (status?: StreamStatusResponse) => void;
    onStatusCallback?: (status: StreamStatusResponse) => void;
  }): Subscription;
  /**
   * Stream spot orderbook updates
   * @param params - Stream parameters
   * @param params.marketIds - Array of market IDs to stream orderbook updates for
   * @param params.callback - Called for each orderbook update
   * @param params.onEndCallback - Called when stream ends normally
   * @param params.onStatusCallback - Called on stream errors
   * @returns Subscription object with unsubscribe method
   */
  streamOrderbookUpdates({
    marketIds,
    callback,
    onEndCallback,
    onStatusCallback
  }: {
    marketIds: string[];
    callback: SpotOrderbookUpdateStreamCallback;
    onEndCallback?: (status?: StreamStatusResponse) => void;
    onStatusCallback?: (status: StreamStatusResponse) => void;
  }): Subscription;
}
//#endregion
//#region src/client/indexer/grpc_stream/stream/IndexerGrpcMitoStream.d.ts
type TransfersStreamCallback = (response: ReturnType<typeof IndexerGrpcMitoStreamTransformer.transfersStreamCallback>) => void;
type VaultStreamCallback = (response: ReturnType<typeof IndexerGrpcMitoStreamTransformer.vaultStreamCallback>) => void;
type VaultHolderSubscriptionStreamCallback = (response: ReturnType<typeof IndexerGrpcMitoStreamTransformer.vaultHolderSubscriptionStreamCallback>) => void;
type StakingRewardByAccountStreamCallback = (response: ReturnType<typeof IndexerGrpcMitoStreamTransformer.stakingRewardByAccountStreamCallback>) => void;
type HistoricalStakingStreamCallback = (response: ReturnType<typeof IndexerGrpcMitoStreamTransformer.historicalStakingStreamCallback>) => void;
/**
 * @category Indexer Grpc Stream
 * @description Provides streaming access to Mito vault data from Injective Indexer
 */
declare class IndexerGrpcMitoStream {
  private client;
  private transport;
  constructor(endpoint: string, metadata?: Record<string, string>);
  /**
   * Stream vault transfers
   * @param params - Stream parameters
   * @param params.vault - Optional vault address to filter
   * @param params.account - Optional account address to filter
   * @param params.callback - Called for each transfer update
   * @param params.onEndCallback - Called when stream ends normally
   * @param params.onStatusCallback - Called on stream errors
   * @returns Subscription object with unsubscribe method
   */
  streamTransfers({
    vault,
    account,
    callback,
    onEndCallback,
    onStatusCallback
  }: {
    vault?: string;
    account?: string;
    callback: TransfersStreamCallback;
    onEndCallback?: (status?: StreamStatusResponse) => void;
    onStatusCallback?: (status: StreamStatusResponse) => void;
  }): Subscription;
  /**
   * Stream vault information
   * @param params - Stream parameters
   * @param params.vault - Optional vault address to filter
   * @param params.callback - Called for each vault update
   * @param params.onEndCallback - Called when stream ends normally
   * @param params.onStatusCallback - Called on stream errors
   * @returns Subscription object with unsubscribe method
   */
  streamVault({
    vault,
    callback,
    onEndCallback,
    onStatusCallback
  }: {
    vault?: string;
    callback: VaultStreamCallback;
    onEndCallback?: (status?: StreamStatusResponse) => void;
    onStatusCallback?: (status: StreamStatusResponse) => void;
  }): Subscription;
  /**
   * Stream vault holder subscriptions
   * @param params - Stream parameters
   * @param params.holderAddress - The holder address to stream subscriptions for
   * @param params.vaultAddress - Optional vault address to filter
   * @param params.stakingContractAddress - Optional staking contract address to filter
   * @param params.callback - Called for each subscription update
   * @param params.onEndCallback - Called when stream ends normally
   * @param params.onStatusCallback - Called on stream errors
   * @returns Subscription object with unsubscribe method
   */
  streamVaultHolderSubscriptions({
    holderAddress,
    vaultAddress,
    stakingContractAddress,
    callback,
    onEndCallback,
    onStatusCallback
  }: {
    holderAddress: string;
    vaultAddress?: string;
    stakingContractAddress?: string;
    callback: VaultHolderSubscriptionStreamCallback;
    onEndCallback?: (status?: StreamStatusResponse) => void;
    onStatusCallback?: (status: StreamStatusResponse) => void;
  }): Subscription;
  /**
   * Stream staking rewards by account
   * @param params - Stream parameters
   * @param params.staker - The staker address to stream rewards for
   * @param params.stakingContractAddress - The staking contract address
   * @param params.callback - Called for each reward update
   * @param params.onEndCallback - Called when stream ends normally
   * @param params.onStatusCallback - Called on stream errors
   * @returns Subscription object with unsubscribe method
   */
  streamStakingRewardsByAccount({
    staker,
    callback,
    onEndCallback,
    onStatusCallback,
    stakingContractAddress
  }: {
    staker: string;
    stakingContractAddress: string;
    callback: StakingRewardByAccountStreamCallback;
    onEndCallback?: (status?: StreamStatusResponse) => void;
    onStatusCallback?: (status: StreamStatusResponse) => void;
  }): Subscription;
  /**
   * Stream historical staking data
   * @param params - Stream parameters
   * @param params.staker - The staker address to stream data for
   * @param params.stakingContractAddress - The staking contract address
   * @param params.callback - Called for each historical staking update
   * @param params.onEndCallback - Called when stream ends normally
   * @param params.onStatusCallback - Called on stream errors
   * @returns Subscription object with unsubscribe method
   */
  streamHistoricalStaking({
    staker,
    stakingContractAddress,
    callback,
    onEndCallback,
    onStatusCallback
  }: {
    staker: string;
    stakingContractAddress: string;
    callback: HistoricalStakingStreamCallback;
    onEndCallback?: (status?: StreamStatusResponse) => void;
    onStatusCallback?: (status: StreamStatusResponse) => void;
  }): Subscription;
}
//#endregion
//#region src/client/indexer/grpc_stream/stream/IndexerGrpcOracleStream.d.ts
type OraclePriceStreamCallback = (response: ReturnType<typeof IndexerOracleStreamTransformer.pricesStreamCallback>) => void;
type OraclePricesByMarketsStreamCallback = (response: ReturnType<typeof IndexerOracleStreamTransformer.pricesByMarketsCallback>) => void;
/**
 * @category Indexer Grpc Stream
 * @description Provides streaming access to oracle price data from Injective Indexer
 */
declare class IndexerGrpcOracleStream {
  private client;
  private transport;
  constructor(endpoint: string, metadata?: Record<string, string>);
  /**
   * Stream oracle price updates
   * @param params - Stream parameters
   * @param params.oracleType - The oracle type to stream prices for
   * @param params.baseSymbol - Optional base symbol filter
   * @param params.quoteSymbol - Optional quote symbol filter
   * @param params.callback - Called for each price update
   * @param params.onEndCallback - Called when stream ends normally
   * @param params.onStatusCallback - Called on stream errors
   * @returns Subscription object with unsubscribe method
   */
  streamOraclePrices({
    oracleType,
    baseSymbol,
    quoteSymbol,
    callback,
    onEndCallback,
    onStatusCallback
  }: {
    oracleType: string;
    baseSymbol?: string;
    quoteSymbol?: string;
    callback: OraclePriceStreamCallback;
    onEndCallback?: (status?: StreamStatusResponse) => void;
    onStatusCallback?: (status: StreamStatusResponse) => void;
  }): Subscription;
  /**
   * Stream oracle prices by markets
   * @param params - Stream parameters
   * @param params.marketIds - Optional array of market IDs to filter
   * @param params.callback - Called for each price update
   * @param params.onEndCallback - Called when stream ends normally
   * @param params.onStatusCallback - Called on stream errors
   * @returns Subscription object with unsubscribe method
   */
  streamOraclePricesByMarkets({
    marketIds,
    callback,
    onEndCallback,
    onStatusCallback
  }: {
    marketIds?: string[];
    callback: OraclePricesByMarketsStreamCallback;
    onEndCallback?: (status?: StreamStatusResponse) => void;
    onStatusCallback?: (status: StreamStatusResponse) => void;
  }): Subscription;
}
//#endregion
//#region src/client/indexer/grpc_stream/stream/IndexerGrpcAccountStream.d.ts
type BalanceStreamCallback = (response: ReturnType<typeof IndexerAccountStreamTransformer.balanceStreamCallback>) => void;
/**
 * @category Indexer Grpc Stream
 * @description Provides streaming access to account data from the Injective Indexer
 */
declare class IndexerGrpcAccountStream {
  private client;
  private transport;
  constructor(endpoint: string, metadata?: Record<string, string>);
  /**
   * Stream subaccount balance updates
   * @param params - Stream parameters
   * @param params.subaccountId - The subaccount ID to stream balance for
   * @param params.callback - Called for each balance update
   * @param params.onEndCallback - Called when stream ends normally
   * @param params.onStatusCallback - Called on stream errors
   * @returns Subscription object with unsubscribe method
   */
  streamSubaccountBalance({
    subaccountId,
    callback,
    onEndCallback,
    onStatusCallback
  }: {
    subaccountId: string;
    callback: BalanceStreamCallback;
    onEndCallback?: (status?: StreamStatusResponse) => void;
    onStatusCallback?: (status: StreamStatusResponse) => void;
  }): Subscription;
}
//#endregion
//#region src/client/indexer/grpc_stream/stream/IndexerGrpcAuctionStream.d.ts
type BidsStreamCallback = (response: ReturnType<typeof IndexerAuctionStreamTransformer.bidsStreamCallback>) => void;
/**
 * @category Indexer Grpc Stream
 * @description Provides streaming access to auction data from Injective Indexer
 */
declare class IndexerGrpcAuctionStream {
  private client;
  private transport;
  constructor(endpoint: string, metadata?: Record<string, string>);
  /**
   * Stream auction bids
   * @param params - Stream parameters
   * @param params.callback - Called for each bid update
   * @param params.onEndCallback - Called when stream ends normally
   * @param params.onStatusCallback - Called on stream errors
   * @returns Subscription object with unsubscribe method
   */
  streamBids({
    callback,
    onEndCallback,
    onStatusCallback
  }: {
    callback: BidsStreamCallback;
    onEndCallback?: (status?: StreamStatusResponse) => void;
    onStatusCallback?: (status: StreamStatusResponse) => void;
  }): Subscription;
}
//#endregion
//#region src/client/indexer/grpc_stream/stream/IndexerGrpcTradingStream.d.ts
/**
 * @category Indexer Grid Strategy Grpc Stream
 * @description Provides streaming access to grid strategy data from Injective Indexer
 */
declare class IndexerGrpcTradingStream {
  private client;
  private transport;
  constructor(endpoint: string, metadata?: Record<string, string>);
  /**
   * Stream grid strategies
   * @param params - Stream parameters
   * @param params.marketId - Optional market ID to filter strategies
   * @param params.accountAddresses - Optional array of account addresses to filter
   * @param params.callback - Called for each strategy update
   * @param params.onEndCallback - Called when stream ends normally
   * @param params.onStatusCallback - Called on stream errors
   * @returns Subscription object with unsubscribe method
   */
  streamGridStrategies({
    marketId,
    callback,
    onEndCallback,
    accountAddresses,
    onStatusCallback
  }: {
    marketId?: string;
    accountAddresses?: string[];
    onEndCallback?: (status?: StreamStatusResponse) => void;
    onStatusCallback?: (status: StreamStatusResponse) => void;
    callback: (response: StreamStrategyResponse) => void;
  }): Subscription;
}
//#endregion
//#region src/client/indexer/grpc_stream/stream/IndexerGrpcArchiverStream.d.ts
type SpotAverageEntriesStreamCallback = (response: ReturnType<typeof IndexerArchiverStreamTransformer.spotAverageEntriesStreamCallback>) => void;
/**
 * @category Indexer Grpc Stream
 * @description Provides streaming access to archiver data from Injective Indexer
 */
declare class IndexerGrpcArchiverStream {
  private client;
  private transport;
  constructor(endpoint: string, metadata?: Record<string, string>);
  /**
   * Stream spot average entries
   * @param params - Stream parameters
   * @param params.account - The account address to stream entries for
   * @param params.callback - Called for each average entry update
   * @param params.onEndCallback - Called when stream ends normally
   * @param params.onStatusCallback - Called on stream errors
   * @returns Subscription object with unsubscribe method
   */
  streamSpotAverageEntries({
    account,
    callback,
    onEndCallback,
    onStatusCallback
  }: {
    account: string;
    callback: SpotAverageEntriesStreamCallback;
    onEndCallback?: (status?: StreamStatusResponse) => void;
    onStatusCallback?: (status: StreamStatusResponse) => void;
  }): Subscription;
}
//#endregion
//#region src/client/indexer/grpc_stream/stream/IndexerGrpcExplorerStream.d.ts
type BlocksStreamCallback = (response: ReturnType<typeof ExplorerStreamTransformer.blocksStreamCallback>) => void;
type BlocksWithTxsStreamCallback = (response: ReturnType<typeof ExplorerStreamTransformer.blocksWithTxsStreamCallback>) => void;
type TransactionsStreamCallback = (response: ReturnType<typeof ExplorerStreamTransformer.transactionsStreamCallback>) => void;
/**
 * @category Indexer Grpc Stream
 * @description Provides streaming access to blockchain explorer data from Injective Indexer
 */
declare class IndexerGrpcExplorerStream {
  private client;
  private transport;
  constructor(endpoint: string, metadata?: Record<string, string>);
  /**
   * Stream block updates
   * @param params - Stream parameters
   * @param params.callback - Called for each block update
   * @param params.onEndCallback - Called when stream ends normally
   * @param params.onStatusCallback - Called on stream errors
   * @returns Subscription object with unsubscribe method
   */
  streamBlocks({
    callback,
    onEndCallback,
    onStatusCallback
  }: {
    callback: BlocksStreamCallback;
    onEndCallback?: (status?: StreamStatusResponse) => void;
    onStatusCallback?: (status: StreamStatusResponse) => void;
  }): Subscription;
  /**
   * Stream blocks with transactions
   * @param params - Stream parameters
   * @param params.callback - Called for each block with transactions update
   * @param params.onEndCallback - Called when stream ends normally
   * @param params.onStatusCallback - Called on stream errors
   * @returns Subscription object with unsubscribe method
   */
  streamBlocksWithTxs({
    callback,
    onEndCallback,
    onStatusCallback
  }: {
    callback: BlocksWithTxsStreamCallback;
    onEndCallback?: (status?: StreamStatusResponse) => void;
    onStatusCallback?: (status: StreamStatusResponse) => void;
  }): Subscription;
  /**
   * Stream transaction updates
   * @param params - Stream parameters
   * @param params.callback - Called for each transaction update
   * @param params.onEndCallback - Called when stream ends normally
   * @param params.onStatusCallback - Called on stream errors
   * @returns Subscription object with unsubscribe method
   */
  streamTransactions({
    callback,
    onEndCallback,
    onStatusCallback
  }: {
    callback: TransactionsStreamCallback;
    onEndCallback?: (status?: StreamStatusResponse) => void;
    onStatusCallback?: (status: StreamStatusResponse) => void;
  }): Subscription;
}
//#endregion
//#region src/client/indexer/grpc_stream/stream/IndexerGrpcDerivativesStream.d.ts
type DerivativeMarketStreamCallback = (response: StreamMarketResponse) => void;
type DerivativeOrdersStreamCallback = (response: ReturnType<typeof IndexerDerivativeStreamTransformer.ordersStreamCallback>) => void;
type DerivativeOrderHistoryStreamCallback = (response: ReturnType<typeof IndexerDerivativeStreamTransformer.orderHistoryStreamCallback>) => void;
type DerivativeTradesStreamCallback = (response: ReturnType<typeof IndexerDerivativeStreamTransformer.tradesStreamCallback>) => void;
type DerivativePositionsStreamCallback = (response: ReturnType<typeof IndexerDerivativeStreamTransformer.positionStreamCallback>) => void;
type DerivativePositionsV2StreamCallback = (response: ReturnType<typeof IndexerDerivativeStreamTransformer.positionV2StreamCallback>) => void;
type DerivativeOrderbookV2StreamCallback = (response: ReturnType<typeof IndexerDerivativeStreamTransformer.orderbookV2StreamCallback>) => void;
type DerivativeOrderbookUpdateStreamCallback = (response: ReturnType<typeof IndexerDerivativeStreamTransformer.orderbookUpdateStreamCallback>) => void;
/**
 * @category Indexer Grpc Stream
 * @description Provides streaming access to derivatives market data from Injective Indexer
 */
declare class IndexerGrpcDerivativesStream {
  private client;
  private transport;
  constructor(endpoint: string, metadata?: Record<string, string>);
  /**
   * Stream derivative orders
   * @param params - Stream parameters
   * @param params.marketId - Optional market ID to filter orders
   * @param params.subaccountId - Optional subaccount ID to filter orders
   * @param params.orderSide - Optional order side to filter
   * @param params.callback - Called for each order update
   * @param params.onEndCallback - Called when stream ends normally
   * @param params.onStatusCallback - Called on stream errors
   * @returns Subscription object with unsubscribe method
   */
  streamOrders({
    marketId,
    subaccountId,
    orderSide,
    callback,
    onEndCallback,
    onStatusCallback
  }: {
    marketId?: string;
    subaccountId?: string;
    orderSide?: OrderSide;
    callback: DerivativeOrdersStreamCallback;
    onEndCallback?: (status?: StreamStatusResponse) => void;
    onStatusCallback?: (status: StreamStatusResponse) => void;
  }): Subscription;
  /**
   * Stream derivative order history
   * @param params - Stream parameters
   * @param params.marketId - Optional market ID to filter orders
   * @param params.subaccountId - Optional subaccount ID to filter orders
   * @param params.orderTypes - Optional array of order types to filter
   * @param params.direction - Optional trade direction to filter
   * @param params.state - Optional order state to filter
   * @param params.executionTypes - Optional array of execution types to filter
   * @param params.callback - Called for each order history update
   * @param params.onEndCallback - Called when stream ends normally
   * @param params.onStatusCallback - Called on stream errors
   * @returns Subscription object with unsubscribe method
   */
  streamOrdersHistory({
    marketId,
    subaccountId,
    orderTypes,
    direction,
    state,
    executionTypes,
    callback,
    onEndCallback,
    onStatusCallback
  }: {
    marketId?: string;
    subaccountId?: string;
    orderTypes?: string[];
    direction?: TradeDirection;
    state?: OrderState;
    executionTypes?: TradeExecutionType[];
    callback: DerivativeOrderHistoryStreamCallback;
    onEndCallback?: (status?: StreamStatusResponse) => void;
    onStatusCallback?: (status: StreamStatusResponse) => void;
  }): Subscription;
  /**
   * Stream derivative trades
   * @param params - Stream parameters
   * @param params.marketIds - Optional array of market IDs to filter trades
   * @param params.marketId - Optional market ID to filter trades
   * @param params.subaccountIds - Optional array of subaccount IDs to filter trades
   * @param params.subaccountId - Optional subaccount ID to filter trades
   * @param params.executionSide - Optional trade execution side to filter
   * @param params.direction - Optional trade direction to filter
   * @param params.pagination - Optional pagination options
   * @param params.callback - Called for each trade update
   * @param params.onEndCallback - Called when stream ends normally
   * @param params.onStatusCallback - Called on stream errors
   * @returns Subscription object with unsubscribe method
   */
  streamTrades({
    marketIds,
    marketId,
    subaccountIds,
    subaccountId,
    executionSide,
    direction,
    pagination,
    callback,
    onEndCallback,
    onStatusCallback
  }: {
    marketIds?: string[];
    marketId?: string;
    subaccountIds?: string[];
    subaccountId?: string;
    executionSide?: TradeExecutionSide;
    direction?: TradeDirection;
    pagination?: PaginationOption;
    callback: DerivativeTradesStreamCallback;
    onEndCallback?: (status?: StreamStatusResponse) => void;
    onStatusCallback?: (status: StreamStatusResponse) => void;
  }): Subscription;
  /**
   * Stream derivative positions
   * @param params - Stream parameters
   * @param params.marketId - Optional market ID to filter positions
   * @param params.address - Optional account address to filter positions
   * @param params.subaccountId - Optional subaccount ID to filter positions
   * @param params.callback - Called for each position update
   * @param params.onEndCallback - Called when stream ends normally
   * @param params.onStatusCallback - Called on stream errors
   * @returns Subscription object with unsubscribe method
   */
  streamPositions({
    marketId,
    address,
    subaccountId,
    callback,
    onEndCallback,
    onStatusCallback
  }: {
    marketId?: string;
    address?: string;
    subaccountId?: string;
    callback: DerivativePositionsStreamCallback;
    onEndCallback?: (status?: StreamStatusResponse) => void;
    onStatusCallback?: (status: StreamStatusResponse) => void;
  }): Subscription;
  /**
   * Stream derivative markets
   * @param params - Stream parameters
   * @param params.marketIds - Optional array of market IDs to filter
   * @param params.callback - Called for each market update
   * @param params.onEndCallback - Called when stream ends normally
   * @param params.onStatusCallback - Called on stream errors
   * @returns Subscription object with unsubscribe method
   */
  streamMarkets({
    marketIds,
    callback,
    onEndCallback,
    onStatusCallback
  }: {
    marketIds?: string[];
    callback: DerivativeMarketStreamCallback;
    onEndCallback?: (status?: StreamStatusResponse) => void;
    onStatusCallback?: (status: StreamStatusResponse) => void;
  }): Subscription;
  /**
   * Stream derivative orderbooks V2
   * @param params - Stream parameters
   * @param params.marketIds - Array of market IDs to stream orderbook for
   * @param params.callback - Called for each orderbook update
   * @param params.onEndCallback - Called when stream ends normally
   * @param params.onStatusCallback - Called on stream errors
   * @returns Subscription object with unsubscribe method
   */
  streamOrderbooksV2({
    marketIds,
    callback,
    onEndCallback,
    onStatusCallback
  }: {
    marketIds: string[];
    callback: DerivativeOrderbookV2StreamCallback;
    onEndCallback?: (status?: StreamStatusResponse) => void;
    onStatusCallback?: (status: StreamStatusResponse) => void;
  }): Subscription;
  /**
   * Stream derivative orderbook updates
   * @param params - Stream parameters
   * @param params.marketIds - Array of market IDs to stream orderbook updates for
   * @param params.callback - Called for each orderbook update
   * @param params.onEndCallback - Called when stream ends normally
   * @param params.onStatusCallback - Called on stream errors
   * @returns Subscription object with unsubscribe method
   */
  streamOrderbookUpdates({
    marketIds,
    callback,
    onEndCallback,
    onStatusCallback
  }: {
    marketIds: string[];
    callback: DerivativeOrderbookUpdateStreamCallback;
    onEndCallback?: (status?: StreamStatusResponse) => void;
    onStatusCallback?: (status: StreamStatusResponse) => void;
  }): Subscription;
  /**
   * Stream derivative positions V2
   * @param params - Stream parameters
   * @param params.marketId - Optional market ID to filter positions
   * @param params.address - Optional account address to filter positions
   * @param params.subaccountId - Optional subaccount ID to filter positions
   * @param params.callback - Called for each position update
   * @param params.onEndCallback - Called when stream ends normally
   * @param params.onStatusCallback - Called on stream errors
   * @returns Subscription object with unsubscribe method
   */
  streamPositionsV2({
    marketId,
    address,
    subaccountId,
    callback,
    onEndCallback,
    onStatusCallback
  }: {
    marketId?: string;
    address?: string;
    subaccountId?: string;
    callback: DerivativePositionsV2StreamCallback;
    onEndCallback?: (status?: StreamStatusResponse) => void;
    onStatusCallback?: (status: StreamStatusResponse) => void;
  }): Subscription;
}
//#endregion
//#region src/client/indexer/grpc_stream/stream/IndexerGrpcAccountPortfolioStream.d.ts
type AccountPortfolioStreamCallback = (response: ReturnType<typeof IndexerAccountPortfolioStreamTransformer.accountPortfolioStreamCallback>) => void;
/**
 * @category Indexer Grpc Stream
 * @description Provides streaming access to account portfolio data from Injective Indexer
 */
declare class IndexerGrpcAccountPortfolioStream {
  private client;
  private transport;
  constructor(endpoint: string, metadata?: Record<string, string>);
  /**
   * Stream account portfolio updates
   * @param params - Stream parameters
   * @param params.accountAddress - The account address to stream portfolio for
   * @param params.subaccountId - Optional subaccount ID to filter
   * @param params.type - Optional portfolio type to filter
   * @param params.callback - Called for each portfolio update
   * @param params.onEndCallback - Called when stream ends normally
   * @param params.onStatusCallback - Called on stream errors
   * @returns Subscription object with unsubscribe method
   */
  streamAccountPortfolio({
    subaccountId,
    accountAddress,
    type,
    callback,
    onEndCallback,
    onStatusCallback
  }: {
    accountAddress: string;
    subaccountId?: string;
    type?: string;
    callback: AccountPortfolioStreamCallback;
    onEndCallback?: (status?: StreamStatusResponse) => void;
    onStatusCallback?: (status: StreamStatusResponse) => void;
  }): Subscription;
}
//#endregion
//#region src/client/indexer/grpc_stream/stream/streamHelpers.d.ts
/**
 * Creates a subscription wrapper for V2 streaming with proper cancellation support.
 *
 * @param stream - The ServerStreamingCall from the V2 client
 * @param handleResponse - Callback to process each stream response
 * @param onEndCallback - Optional callback when stream ends normally
 * @param onStatusCallback - Optional callback for stream errors
 * @returns Subscription object with unsubscribe method
 */
declare function createStreamSubscription<TResponse>(stream: {
  responses: AsyncIterable<TResponse>;
}, handleResponse: (response: TResponse) => void, onEndCallback?: (status?: StreamStatusResponse) => void, onStatusCallback?: (status: StreamStatusResponse) => void): Subscription;
//#endregion
//#region src/client/indexer/grpc_stream/stream/StreamManager.d.ts
/**
 * StreamManager - Simple registry for managing multiple V1 stream subscriptions by key
 *
 * This is a lightweight utility for storing and canceling multiple V1 RxJS-based streams.
 * For V2 streams with advanced lifecycle management and retry logic, use StreamManagerV2.
 */
declare class StreamManager<T> {
  private streams;
  set(stream: any, streamKey: T): void;
  get(streamKey: T): any;
  exists(streamKey: T): boolean;
  cancelAll(): void;
  cancel(streamKey: T): void;
  cancelIfExists(streamKey: T): void;
}
//#endregion
//#region src/client/indexer/grpc_stream/streamV2/IndexerGrpcSpotStreamV2.d.ts
type SpotOrderbookUpdateStreamCallbackV2 = (response: ReturnType<typeof IndexerSpotStreamTransformer.orderbookUpdateStreamCallback>) => void;
type SpotOrdersStreamCallbackV2 = (response: ReturnType<typeof IndexerSpotStreamTransformer.ordersStreamCallback>) => void;
type SpotOrderHistoryStreamCallbackV2 = (response: ReturnType<typeof IndexerSpotStreamTransformer.orderHistoryStreamCallback>) => void;
type SpotTradesStreamCallbackV2 = (response: ReturnType<typeof IndexerSpotStreamTransformer.tradesStreamCallback>) => void;
declare class IndexerGrpcSpotStreamV2 {
  private client;
  private transport;
  constructor(endpoint: string, metadata?: Record<string, string>);
  /**
   * Stream spot orderbook updates
   * @param params.marketIds - Array of market IDs to stream
   * @param params.callback - Called for each orderbook update
   * @returns StreamSubscription
   */
  streamOrderbookUpdates({
    marketIds,
    callback
  }: {
    marketIds: string[];
    callback: SpotOrderbookUpdateStreamCallbackV2;
  }): StreamSubscription;
  /**
   * Stream spot orders
   * @param params.marketId - Optional market ID to filter
   * @param params.subaccountId - Optional subaccount ID to filter
   * @param params.orderSide - Optional order side to filter
   * @param params.callback - Called for each order update
   * @returns StreamSubscription
   */
  streamOrders({
    marketId,
    subaccountId,
    orderSide,
    callback
  }: {
    marketId?: string;
    subaccountId?: string;
    orderSide?: OrderSide;
    callback: SpotOrdersStreamCallbackV2;
  }): StreamSubscription;
  /**
   * Stream spot order history
   * @param params.subaccountId - Optional subaccount ID to filter
   * @param params.marketId - Optional market ID to filter
   * @param params.orderTypes - Optional order types to filter
   * @param params.direction - Optional direction to filter
   * @param params.state - Optional state to filter
   * @param params.executionTypes - Optional execution types to filter
   * @param params.callback - Called for each order history update
   * @returns StreamSubscription
   */
  streamOrderHistory({
    subaccountId,
    marketId,
    orderTypes,
    direction,
    state,
    executionTypes,
    callback
  }: {
    subaccountId?: string;
    marketId?: string;
    orderTypes?: string[];
    direction?: string;
    state?: string;
    executionTypes?: string[];
    callback: SpotOrderHistoryStreamCallbackV2;
  }): StreamSubscription;
  /**
   * Stream spot trades
   * @param params.marketId - Optional market ID to filter
   * @param params.marketIds - Optional array of market IDs to filter
   * @param params.subaccountId - Optional subaccount ID to filter
   * @param params.subaccountIds - Optional array of subaccount IDs to filter
   * @param params.executionSide - Optional execution side to filter
   * @param params.direction - Optional direction to filter
   * @param params.executionTypes - Optional execution types to filter
   * @param params.callback - Called for each trade update
   * @returns StreamSubscription
   */
  streamTrades({
    marketId,
    marketIds,
    subaccountId,
    subaccountIds,
    executionSide,
    direction,
    executionTypes,
    callback
  }: {
    marketId?: string;
    marketIds?: string[];
    subaccountId?: string;
    subaccountIds?: string[];
    executionSide?: string;
    direction?: string;
    executionTypes?: string[];
    callback: SpotTradesStreamCallbackV2;
  }): StreamSubscription;
}
//#endregion
//#region src/client/indexer/grpc_stream/streamV2/IndexerGrpcMitoStreamV2.d.ts
type TransfersStreamCallbackV2 = (response: ReturnType<typeof IndexerGrpcMitoStreamTransformer.transfersStreamCallback>) => void;
type VaultStreamCallbackV2 = (response: ReturnType<typeof IndexerGrpcMitoStreamTransformer.vaultStreamCallback>) => void;
type VaultHolderSubscriptionStreamCallbackV2 = (response: ReturnType<typeof IndexerGrpcMitoStreamTransformer.vaultHolderSubscriptionStreamCallback>) => void;
type StakingRewardByAccountStreamCallbackV2 = (response: ReturnType<typeof IndexerGrpcMitoStreamTransformer.stakingRewardByAccountStreamCallback>) => void;
type HistoricalStakingStreamCallbackV2 = (response: ReturnType<typeof IndexerGrpcMitoStreamTransformer.historicalStakingStreamCallback>) => void;
declare class IndexerGrpcMitoStreamV2 {
  private client;
  private transport;
  constructor(endpoint: string, metadata?: Record<string, string>);
  /**
   * Stream vault transfers
   * @param params.vault - Optional vault address to filter
   * @param params.account - Optional account address to filter
   * @param params.callback - Called for each transfer update
   * @returns StreamSubscription
   */
  streamTransfers({
    vault,
    account,
    callback
  }: {
    vault?: string;
    account?: string;
    callback: TransfersStreamCallbackV2;
  }): StreamSubscription;
  /**
   * Stream vault information
   * @param params.vault - Optional vault address to filter
   * @param params.callback - Called for each vault update
   * @returns StreamSubscription
   */
  streamVault({
    vault,
    callback
  }: {
    vault?: string;
    callback: VaultStreamCallbackV2;
  }): StreamSubscription;
  /**
   * Stream vault holder subscriptions
   * @param params.holderAddress - The holder address to stream subscriptions for
   * @param params.vaultAddress - Optional vault address to filter
   * @param params.stakingContractAddress - Optional staking contract address to filter
   * @param params.callback - Called for each subscription update
   * @returns StreamSubscription
   */
  streamVaultHolderSubscriptions({
    holderAddress,
    vaultAddress,
    stakingContractAddress,
    callback
  }: {
    holderAddress: string;
    vaultAddress?: string;
    stakingContractAddress?: string;
    callback: VaultHolderSubscriptionStreamCallbackV2;
  }): StreamSubscription;
  /**
   * Stream staking rewards by account
   * @param params.staker - The staker address to stream rewards for
   * @param params.stakingContractAddress - The staking contract address
   * @param params.callback - Called for each reward update
   * @returns StreamSubscription
   */
  streamStakingRewardsByAccount({
    staker,
    stakingContractAddress,
    callback
  }: {
    staker: string;
    stakingContractAddress: string;
    callback: StakingRewardByAccountStreamCallbackV2;
  }): StreamSubscription;
  /**
   * Stream historical staking data
   * @param params.staker - The staker address to stream data for
   * @param params.stakingContractAddress - The staking contract address
   * @param params.callback - Called for each historical staking update
   * @returns StreamSubscription
   */
  streamHistoricalStaking({
    staker,
    stakingContractAddress,
    callback
  }: {
    staker: string;
    stakingContractAddress: string;
    callback: HistoricalStakingStreamCallbackV2;
  }): StreamSubscription;
}
//#endregion
//#region src/client/indexer/grpc_stream/streamV2/IndexerGrpcOracleStreamV2.d.ts
type OraclePriceStreamCallbackV2 = (response: ReturnType<typeof IndexerOracleStreamTransformer.pricesStreamCallback>) => void;
type OraclePricesByMarketsStreamCallbackV2 = (response: ReturnType<typeof IndexerOracleStreamTransformer.pricesByMarketsCallback>) => void;
declare class IndexerGrpcOracleStreamV2 {
  private client;
  private transport;
  constructor(endpoint: string, metadata?: Record<string, string>);
  /**
   * Stream oracle price updates
   * @param params.oracleType - The oracle type to stream prices for
   * @param params.baseSymbol - Optional base symbol filter
   * @param params.quoteSymbol - Optional quote symbol filter
   * @param params.callback - Called for each price update
   * @returns StreamSubscription
   */
  streamOraclePrices({
    oracleType,
    baseSymbol,
    quoteSymbol,
    callback
  }: {
    oracleType: string;
    baseSymbol?: string;
    quoteSymbol?: string;
    callback: OraclePriceStreamCallbackV2;
  }): StreamSubscription;
  /**
   * Stream oracle prices by markets
   * @param params.marketIds - Optional array of market IDs to filter
   * @param params.callback - Called for each price update
   * @returns StreamSubscription
   */
  streamOraclePricesByMarkets({
    marketIds,
    callback
  }: {
    marketIds?: string[];
    callback: OraclePricesByMarketsStreamCallbackV2;
  }): StreamSubscription;
}
//#endregion
//#region src/client/indexer/grpc_stream/streamV2/IndexerGrpcAccountStreamV2.d.ts
type BalanceStreamCallbackV2 = (response: ReturnType<typeof IndexerAccountStreamTransformer.balanceStreamCallback>) => void;
declare class IndexerGrpcAccountStreamV2 {
  private client;
  private transport;
  constructor(endpoint: string, metadata?: Record<string, string>);
  /**
   * Stream subaccount balance updates
   * @param params.subaccountId - The subaccount ID to stream balance for
   * @param params.callback - Called for each balance update
   * @returns StreamSubscription
   */
  streamSubaccountBalance({
    subaccountId,
    callback
  }: {
    subaccountId: string;
    callback: BalanceStreamCallbackV2;
  }): StreamSubscription;
}
//#endregion
//#region src/client/indexer/grpc_stream/streamV2/IndexerGrpcAuctionStreamV2.d.ts
type BidsStreamCallbackV2 = (response: ReturnType<typeof IndexerAuctionStreamTransformer.bidsStreamCallback>) => void;
declare class IndexerGrpcAuctionStreamV2 {
  private client;
  private transport;
  constructor(endpoint: string, metadata?: Record<string, string>);
  /**
   * Stream auction bids
   * @param params.callback - Called for each bid update
   * @returns StreamSubscription
   */
  streamBids({
    callback
  }: {
    callback: BidsStreamCallbackV2;
  }): StreamSubscription;
}
//#endregion
//#region src/client/indexer/grpc_stream/streamV2/IndexerGrpcTradingStreamV2.d.ts
type GridStrategyStreamCallbackV2 = (response: StreamStrategyResponse) => void;
declare class IndexerGrpcTradingStreamV2 {
  private client;
  private transport;
  constructor(endpoint: string, metadata?: Record<string, string>);
  /**
   * Stream grid strategies
   * @param params.marketId - Optional market ID to filter strategies
   * @param params.accountAddresses - Optional array of account addresses to filter
   * @param params.callback - Called for each strategy update
   * @returns StreamSubscription
   */
  streamGridStrategies({
    marketId,
    accountAddresses,
    callback
  }: {
    marketId?: string;
    accountAddresses?: string[];
    callback: GridStrategyStreamCallbackV2;
  }): StreamSubscription;
}
//#endregion
//#region src/client/indexer/grpc_stream/streamV2/IndexerGrpcArchiverStreamV2.d.ts
type SpotAverageEntriesStreamCallbackV2 = (response: ReturnType<typeof IndexerArchiverStreamTransformer.spotAverageEntriesStreamCallback>) => void;
declare class IndexerGrpcArchiverStreamV2 {
  private client;
  private transport;
  constructor(endpoint: string, metadata?: Record<string, string>);
  /**
   * Stream spot average entries
   * @param params.account - The account address to stream entries for
   * @param params.callback - Called for each average entry update
   * @returns StreamSubscription
   */
  streamSpotAverageEntries({
    account,
    callback
  }: {
    account: string;
    callback: SpotAverageEntriesStreamCallbackV2;
  }): StreamSubscription;
}
//#endregion
//#region src/client/indexer/grpc_stream/streamV2/IndexerGrpcExplorerStreamV2.d.ts
type BlocksStreamCallbackV2 = (response: ReturnType<typeof ExplorerStreamTransformer.blocksStreamCallback>) => void;
type BlocksWithTxsStreamCallbackV2 = (response: ReturnType<typeof ExplorerStreamTransformer.blocksWithTxsStreamCallback>) => void;
type TransactionsStreamCallbackV2 = (response: ReturnType<typeof ExplorerStreamTransformer.transactionsStreamCallback>) => void;
declare class IndexerGrpcExplorerStreamV2 {
  private client;
  private transport;
  constructor(endpoint: string, metadata?: Record<string, string>);
  /**
   * Stream block updates
   * @param params.callback - Called for each block update
   * @returns StreamSubscription
   */
  streamBlocks({
    callback
  }: {
    callback: BlocksStreamCallbackV2;
  }): StreamSubscription;
  /**
   * Stream blocks with transactions
   * @param params.callback - Called for each block with transactions update
   * @returns StreamSubscription
   */
  streamBlocksWithTxs({
    callback
  }: {
    callback: BlocksWithTxsStreamCallbackV2;
  }): StreamSubscription;
  /**
   * Stream transaction updates
   * @param params.callback - Called for each transaction update
   * @returns StreamSubscription
   */
  streamTransactions({
    callback
  }: {
    callback: TransactionsStreamCallbackV2;
  }): StreamSubscription;
}
//#endregion
//#region src/client/indexer/grpc_stream/streamV2/IndexerGrpcDerivativesStreamV2.d.ts
type DerivativeMarketStreamCallbackV2 = (response: StreamMarketResponse) => void;
type DerivativeOrdersStreamCallbackV2 = (response: ReturnType<typeof IndexerDerivativeStreamTransformer.ordersStreamCallback>) => void;
type DerivativeOrderHistoryStreamCallbackV2 = (response: ReturnType<typeof IndexerDerivativeStreamTransformer.orderHistoryStreamCallback>) => void;
type DerivativeTradesStreamCallbackV2 = (response: ReturnType<typeof IndexerDerivativeStreamTransformer.tradesStreamCallback>) => void;
type DerivativePositionsStreamCallbackV2 = (response: ReturnType<typeof IndexerDerivativeStreamTransformer.positionStreamCallback>) => void;
type DerivativePositionsV2StreamCallbackV2 = (response: ReturnType<typeof IndexerDerivativeStreamTransformer.positionV2StreamCallback>) => void;
type DerivativeOrderbookV2StreamCallbackV2 = (response: ReturnType<typeof IndexerDerivativeStreamTransformer.orderbookV2StreamCallback>) => void;
type DerivativeOrderbookUpdateStreamCallbackV2 = (response: ReturnType<typeof IndexerDerivativeStreamTransformer.orderbookUpdateStreamCallback>) => void;
declare class IndexerGrpcDerivativesStreamV2 {
  private client;
  private transport;
  constructor(endpoint: string, metadata?: Record<string, string>);
  /**
   * Stream derivative orders
   * @param params.marketId - Optional market ID to filter
   * @param params.subaccountId - Optional subaccount ID to filter
   * @param params.orderSide - Optional order side to filter
   * @param params.callback - Called for each order update
   * @returns StreamSubscription
   */
  streamOrders({
    marketId,
    subaccountId,
    orderSide,
    callback
  }: {
    marketId?: string;
    subaccountId?: string;
    orderSide?: OrderSide;
    callback: DerivativeOrdersStreamCallbackV2;
  }): StreamSubscription;
  /**
   * Stream derivative order history
   * @param params.subaccountId - Optional subaccount ID to filter
   * @param params.marketId - Optional market ID to filter
   * @param params.orderTypes - Optional order types to filter
   * @param params.direction - Optional direction to filter
   * @param params.state - Optional state to filter
   * @param params.executionTypes - Optional execution types to filter
   * @param params.callback - Called for each order history update
   * @returns StreamSubscription
   */
  streamOrdersHistory({
    subaccountId,
    marketId,
    orderTypes,
    direction,
    state,
    executionTypes,
    callback
  }: {
    subaccountId?: string;
    marketId?: string;
    orderTypes?: string[];
    direction?: TradeDirection;
    state?: OrderState;
    executionTypes?: TradeExecutionType[];
    callback: DerivativeOrderHistoryStreamCallbackV2;
  }): StreamSubscription;
  /**
   * Stream derivative trades
   * @param params.marketId - Optional market ID to filter
   * @param params.marketIds - Optional array of market IDs to filter
   * @param params.subaccountId - Optional subaccount ID to filter
   * @param params.subaccountIds - Optional array of subaccount IDs to filter
   * @param params.executionSide - Optional execution side to filter
   * @param params.direction - Optional direction to filter
   * @param params.pagination - Optional pagination options
   * @param params.callback - Called for each trade update
   * @returns StreamSubscription
   */
  streamTrades({
    marketIds,
    marketId,
    subaccountIds,
    subaccountId,
    executionSide,
    direction,
    pagination,
    callback
  }: {
    marketIds?: string[];
    marketId?: string;
    subaccountIds?: string[];
    subaccountId?: string;
    executionSide?: TradeExecutionSide;
    direction?: TradeDirection;
    pagination?: PaginationOption;
    callback: DerivativeTradesStreamCallbackV2;
  }): StreamSubscription;
  /**
   * Stream derivative positions
   * @param params.marketId - Optional market ID to filter
   * @param params.address - Optional address to filter
   * @param params.subaccountId - Optional subaccount ID to filter
   * @param params.callback - Called for each position update
   * @returns StreamSubscription
   */
  streamPositions({
    marketId,
    address,
    subaccountId,
    callback
  }: {
    marketId?: string;
    address?: string;
    subaccountId?: string;
    callback: DerivativePositionsStreamCallbackV2;
  }): StreamSubscription;
  /**
   * Stream derivative markets
   * @param params.marketIds - Optional array of market IDs to filter
   * @param params.callback - Called for each market update
   * @returns StreamSubscription
   */
  streamMarkets({
    marketIds,
    callback
  }: {
    marketIds?: string[];
    callback: DerivativeMarketStreamCallbackV2;
  }): StreamSubscription;
  /**
   * Stream derivative orderbooks V2
   * @param params.marketIds - Array of market IDs to stream
   * @param params.callback - Called for each orderbook update
   * @returns StreamSubscription
   */
  streamOrderbooksV2({
    marketIds,
    callback
  }: {
    marketIds: string[];
    callback: DerivativeOrderbookV2StreamCallbackV2;
  }): StreamSubscription;
  /**
   * Stream derivative orderbook updates
   * @param params.marketIds - Array of market IDs to stream
   * @param params.callback - Called for each orderbook update
   * @returns StreamSubscription
   */
  streamOrderbookUpdates({
    marketIds,
    callback
  }: {
    marketIds: string[];
    callback: DerivativeOrderbookUpdateStreamCallbackV2;
  }): StreamSubscription;
  /**
   * Stream derivative positions V2
   * @param params.marketId - Optional market ID to filter
   * @param params.address - Optional address to filter
   * @param params.subaccountId - Optional subaccount ID to filter
   * @param params.callback - Called for each position update
   * @returns StreamSubscription
   */
  streamPositionsV2({
    marketId,
    address,
    subaccountId,
    callback
  }: {
    marketId?: string;
    address?: string;
    subaccountId?: string;
    callback: DerivativePositionsV2StreamCallbackV2;
  }): StreamSubscription;
}
//#endregion
//#region src/client/indexer/grpc_stream/streamV2/IndexerGrpcAccountPortfolioStreamV2.d.ts
type AccountPortfolioStreamCallbackV2 = (response: ReturnType<typeof IndexerAccountPortfolioStreamTransformer.accountPortfolioStreamCallback>) => void;
declare class IndexerGrpcAccountPortfolioStreamV2 {
  private client;
  private transport;
  constructor(endpoint: string, metadata?: Record<string, string>);
  /**
   * Stream account portfolio updates
   * @param params.accountAddress - The account address to stream portfolio for
   * @param params.subaccountId - Optional subaccount ID to filter
   * @param params.type - Optional portfolio type to filter
   * @param params.callback - Called for each portfolio update
   * @returns StreamSubscription
   */
  streamAccountPortfolio({
    accountAddress,
    subaccountId,
    type,
    callback
  }: {
    accountAddress: string;
    subaccountId?: string;
    type?: string;
    callback: AccountPortfolioStreamCallbackV2;
  }): StreamSubscription;
}
//#endregion
//#region src/client/indexer/grpc_stream/streamV2/StreamManagerV2.d.ts
/**
 * StreamManagerV2 - Manages gRPC stream connections with automatic retry
 *
 * V2 Features:
 * - Event-based lifecycle (on/off methods)
 * - Automatic retry with exponential backoff
 * - Persistent retry mode
 * - Comprehensive gRPC error code mapping
 * - Distinguishes retryable vs non-retryable errors
 *
 */
declare class StreamManagerV2<TResponse> extends EventEmitter<StreamManagerEvents<TResponse>> {
  private config;
  private state;
  private subscription;
  private retryTimeoutId;
  private retryAttempt;
  constructor(config: StreamManagerConfig<TResponse>);
  start(): void;
  stop(): void;
  getId(): string;
  /**
   * Destroy the stream manager and clean up all resources
   * Call this when the stream manager is no longer needed
   */
  destroy(): void;
  getState(): StreamState;
  private updateState;
  private clearSubscription;
  private clearRetryTimeout;
  private calculateNextBackoff;
  private scheduleRetry;
  private handleMaxRetriesReached;
  private handleError;
  /**
   * Handles incoming data - calls user callback
   * Called automatically when user emits 'data' event from streamFactory callback
   */
  private handleData;
  private handleConnected;
  private handleDisconnect;
  private connect;
  /**
   * Extracts error message, code, and details from an error object
   */
  private extractErrorInfo;
}
//#endregion
//#region src/client/indexer/grpc_stream/streamV2/streamHelpersV2.d.ts
/**
 * Creates an event-based subscription for StreamManager V2.
 * This emits 'error' and 'complete' events instead of using callbacks.
 *
 * Error Handling:
 * - gRPC errors are extracted with full metadata and emitted as 'error' events
 * - User callback errors are caught and emitted separately to distinguish from stream errors
 * - Aborted streams don't emit any events (clean shutdown)
 *
 * @param stream - The ServerStreamingCall from the V2 client
 * @param handleResponse - Callback to process each stream response
 * @returns StreamSubscription with event emitters for error/complete
 */
declare function createStreamSubscriptionV2<TResponse>(stream: {
  responses: AsyncIterable<TResponse>;
}, handleResponse: (response: TResponse) => void): StreamSubscription;
//#endregion
//#region src/core/accounts/AccountParserNoCosmjs.d.ts
declare const accountEthParser: <T>(ethAccount: any, pubKeyTypeUrl?: string) => T;
//#endregion
//#region src/client/chain/grpc/ChainGrpcGovApi.d.ts
/**
 * @category Chain Grpc API
 */
declare class ChainGrpcGovApi extends BaseGrpcConsumer {
  protected module: string;
  private get client();
  fetchModuleParams(): Promise<GovModuleStateParams>;
  fetchProposals({
    status,
    pagination
  }: {
    status: ProposalStatus$1;
    pagination?: PaginationOption;
  }): Promise<{
    proposals: Proposal[];
    pagination: Pagination;
  }>;
  fetchProposal(proposalId: number): Promise<Proposal | undefined>;
  fetchProposalDeposits({
    proposalId,
    pagination
  }: {
    proposalId: number;
    pagination?: PaginationOption;
  }): Promise<{
    deposits: ProposalDeposit[];
    pagination: Pagination;
  }>;
  fetchProposalVotes({
    proposalId,
    pagination
  }: {
    proposalId: number;
    pagination?: PaginationOption;
  }): Promise<{
    votes: Vote[];
    pagination: Pagination;
  }>;
  fetchProposalTally(proposalId: number): Promise<TallyResult>;
}
//#endregion
//#region src/client/chain/grpc/ChainGrpcIbcApi.d.ts
/**
 * @category Chain Grpc API
 */
declare class ChainGrpcIbcApi extends BaseGrpcConsumer {
  protected module: string;
  private get client();
  fetchDenomTrace(hash: string): Promise<DenomTrace>;
  fetchDenomsTrace(pagination?: PaginationOption): Promise<DenomTrace[]>;
}
//#endregion
//#region src/client/chain/grpc/ChainGrpcEvmApi.d.ts
/**
 * @category Chain Grpc API
 */
declare class ChainGrpcEvmApi extends BaseGrpcConsumer {
  protected module: string;
  private get client();
  fetchAccount(ethAddress: string): Promise<{
    balance: string;
    codeHash: string;
    nonce: string;
  }>;
  fetchCosmosAccount(ethAddress: string): Promise<{
    sequence: string;
    cosmosAddress: string;
    accountNumber: string;
  }>;
  fetchValidatorAccount(consAddress: string): Promise<{
    sequence: string;
    accountNumber: string;
    accountAddress: string;
  }>;
  fetchBalance(ethAddress: string): Promise<string>;
  fetchStorage(ethAddress: string, key: string): Promise<string>;
  fetchCode(ethAddress: string): Promise<Uint8Array<ArrayBufferLike>>;
  fetchParams(): Promise<EvmParams | undefined>;
  fetchBaseFee(): Promise<string>;
}
//#endregion
//#region src/client/chain/grpc/ChainGrpcAuthApi.d.ts
/**
 * @category Chain Grpc API
 */
declare class ChainGrpcAuthApi extends BaseGrpcConsumer {
  protected module: string;
  private get client();
  fetchModuleParams(): Promise<AuthModuleParams>;
  fetchAccount(address: string): Promise<Account>;
  fetchAccounts(pagination?: PaginationOption): Promise<{
    pagination: Pagination;
    accounts: Account[];
  }>;
}
//#endregion
//#region src/client/chain/grpc/ChainGrpcBankApi.d.ts
/**
 * @category Chain Grpc API
 */
declare class ChainGrpcBankApi extends BaseGrpcConsumer {
  protected module: string;
  private get client();
  fetchModuleParams(): Promise<BankModuleParams>;
  fetchBalance({
    accountAddress,
    denom
  }: {
    accountAddress: string;
    denom: string;
  }): Promise<Coin$8>;
  fetchBalances(address: string, pagination?: PaginationOption): Promise<{
    balances: Coin$8[];
    pagination: Pagination;
  }>;
  fetchTotalSupply(pagination?: PaginationOption): Promise<{
    supply: TotalSupply;
    pagination: Pagination;
  }>;
  /** a way to ensure all total supply is fully fetched */
  fetchAllTotalSupply(pagination?: PaginationOption): Promise<{
    supply: TotalSupply;
    pagination: Pagination;
  }>;
  fetchSupplyOf(denom: string): Promise<Coin$8>;
  fetchDenomsMetadata(pagination?: PaginationOption): Promise<{
    metadatas: Metadata[];
    pagination: Pagination;
  }>;
  fetchDenomMetadata(denom: string): Promise<Metadata$1>;
  fetchDenomOwners(denom: string, pagination?: PaginationOption): Promise<{
    denomOwners: {
      address: string;
      balance: Coin$8 | undefined;
    }[];
    pagination: Pagination;
  }>;
}
//#endregion
//#region src/client/chain/grpc/ChainGrpcMintApi.d.ts
/**
 * @category Chain Grpc API
 */
declare class ChainGrpcMintApi extends BaseGrpcConsumer {
  protected module: string;
  private get client();
  fetchModuleParams(): Promise<MinModuleParams>;
  fetchInflation(): Promise<{
    inflation: BigNumber$1;
  }>;
  fetchAnnualProvisions(): Promise<{
    annualProvisions: any;
  }>;
}
//#endregion
//#region src/client/chain/grpc/ChainGrpcWasmApi.d.ts
/**
 * @category Chain Grpc API
 */
declare class ChainGrpcWasmApi extends BaseGrpcConsumer {
  protected module: string;
  private get client();
  fetchContractAccountsBalance({
    contractAddress,
    pagination
  }: {
    contractAddress: string;
    pagination?: PaginationOption;
  }): Promise<ContractAccountsBalanceWithPagination>;
  fetchContractState({
    contractAddress,
    pagination
  }: {
    contractAddress: string;
    pagination?: PaginationOption;
  }): Promise<ContractStateWithPagination>;
  fetchContractInfo(contractAddress: string): Promise<ContractInfo | undefined>;
  fetchContractHistory(contractAddress: string): Promise<{
    entriesList: ContractCodeHistoryEntry[];
    pagination: Pagination;
  }>;
  fetchSmartContractState(contractAddress: string, query?: string | Record<string, any>): Promise<QuerySmartContractStateResponse>;
  fetchRawContractState(contractAddress: string, query?: string): Promise<QueryRawContractStateResponse>;
  fetchContractCodes(pagination?: PaginationOption): Promise<{
    codeInfosList: CodeInfoResponse[];
    pagination: Pagination;
  }>;
  fetchContractCode(codeId: number): Promise<{
    codeInfo: CodeInfoResponse;
    data: Uint8Array<ArrayBufferLike>;
  }>;
  fetchContractCodeContracts(codeId: number, pagination?: PaginationOption): Promise<{
    contractsList: string[];
    pagination: Pagination;
  }>;
}
//#endregion
//#region src/client/chain/grpc/ChainGrpcAuthZApi.d.ts
/**
 * @category Chain Grpc API
 */
declare class ChainGrpcAuthZApi extends BaseGrpcConsumer {
  protected module: string;
  private get client();
  fetchGrants({
    pagination,
    granter,
    grantee,
    msgTypeUrl
  }: {
    pagination?: PaginationOption;
    granter: string;
    grantee: string;
    msgTypeUrl?: string;
  }): Promise<{
    pagination: Pagination;
    grants: GrantWithDecodedAuthorization[];
  }>;
  fetchGranterGrants(granter: string, pagination?: PaginationOption): Promise<{
    pagination: Pagination;
    grants: GrantAuthorizationWithDecodedAuthorization[];
  }>;
  fetchGranteeGrants(grantee: string, pagination?: PaginationOption): Promise<{
    pagination: Pagination;
    grants: GrantAuthorizationWithDecodedAuthorization[];
  }>;
}
//#endregion
//#region src/client/chain/grpc/ChainGrpcPeggyApi.d.ts
/**
 * @category Chain Grpc API
 */
declare class ChainGrpcPeggyApi extends BaseGrpcConsumer {
  protected module: string;
  private get client();
  fetchModuleParams(): Promise<PeggyModuleParams>;
}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/injective/wasmx/v1/genesis_pb.d.ts
/**
 * @generated from protobuf message injective.wasmx.v1.RegisteredContractWithAddress
 */
interface RegisteredContractWithAddress {
  /**
   * @generated from protobuf field: string address = 1
   */
  address: string;
  /**
   * @generated from protobuf field: injective.wasmx.v1.RegisteredContract registered_contract = 2
   */
  registeredContract?: RegisteredContract;
}
/**
 * GenesisState defines the wasmx module's genesis state.
 *
 * @generated from protobuf message injective.wasmx.v1.GenesisState
 */
interface GenesisState$3 {
  /**
   * params defines all the parameters of related to wasmx.
   *
   * @generated from protobuf field: injective.wasmx.v1.Params params = 1
   */
  params?: Params$14;
  /**
   * registered_contracts is an array containing the genesis registered
   * contracts
   *
   * @generated from protobuf field: repeated injective.wasmx.v1.RegisteredContractWithAddress registered_contracts = 2
   */
  registeredContracts: RegisteredContractWithAddress[];
}
/**
 * @generated MessageType for protobuf message injective.wasmx.v1.RegisteredContractWithAddress
 */
declare const RegisteredContractWithAddress = new RegisteredContractWithAddress$Type();
/**
 * @generated MessageType for protobuf message injective.wasmx.v1.GenesisState
 */
declare const GenesisState$3 = new GenesisState$Type();
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/injective/wasmx/v1/query_pb.d.ts
/**
 * QueryWasmxParamsRequest is the response type for the Query/WasmxParams RPC
 * method.
 *
 * @generated from protobuf message injective.wasmx.v1.QueryWasmxParamsResponse
 */
interface QueryWasmxParamsResponse {
  /**
   * @generated from protobuf field: injective.wasmx.v1.Params params = 1
   */
  params?: Params$14;
}
/**
 * @generated MessageType for protobuf message injective.wasmx.v1.QueryWasmxParamsResponse
 */
declare const QueryWasmxParamsResponse = new QueryWasmxParamsResponse$Type();
//#endregion
//#region src/client/chain/grpc/ChainGrpcWasmXApi.d.ts
/**
 * @category Chain Grpc API
 */
declare class ChainGrpcWasmXApi extends BaseGrpcConsumer {
  protected module: string;
  private get client();
  fetchModuleParams(): Promise<QueryWasmxParamsResponse>;
  fetchModuleState(): Promise<GenesisState$3 | undefined>;
}
//#endregion
//#region src/client/chain/grpc/ChainGrpcErc20Api.d.ts
/**
 * @category Chain Grpc API
 */
declare class ChainGrpcErc20Api extends BaseGrpcConsumer {
  protected module: string;
  private get client();
  fetchModuleParams(): Promise<Params$6>;
  fetchTokenPairs(pagination?: PaginationOption): Promise<{
    tokenPairs: {
      bankDenom: string;
      erc20Address: string;
    }[];
    pagination: Pagination;
  }>;
  fetchAllTokenPairsWithPagination(pagination?: PaginationOption): Promise<{
    tokenPairs: {
      bankDenom: string;
      erc20Address: string;
    }[];
    pagination: Pagination;
  }>;
  fetchTokenPairByDenom(denom: string): Promise<TokenPair | undefined>;
  fetchTokenPairByErc20Address(erc20Address: string): Promise<TokenPair | undefined>;
}
//#endregion
//#region src/client/chain/grpc/ChainGrpcOracleApi.d.ts
/**
 * @category Chain Grpc API
 */
declare class ChainGrpcOracleApi extends BaseGrpcConsumer {
  protected module: string;
  private get client();
  fetchModuleParams(): Promise<OracleModuleParams>;
}
//#endregion
//#region src/client/chain/grpc/ChainGrpcTxFeesApi.d.ts
/**
 * @category Chain Grpc API
 */
declare class ChainGrpcTxFeesApi extends BaseGrpcConsumer {
  protected module: string;
  private get client();
  fetchModuleParams(): Promise<TxFeesModuleStateParams>;
  fetchEipBaseFee(): Promise<TxFeesEipBaseFee>;
}
//#endregion
//#region src/client/chain/grpc/ChainGrpcAuctionApi.d.ts
/**
 * @category Chain Grpc API
 */
declare class ChainGrpcAuctionApi extends BaseGrpcConsumer {
  protected module: string;
  private get client();
  fetchModuleParams(): Promise<AuctionModuleStateParams>;
  fetchCurrentBasket(): Promise<AuctionCurrentBasket>;
  fetchModuleState(): Promise<AuctionModuleState>;
  fetchLastAuctionResult(): Promise<AuctionLastAuctionResult | undefined>;
}
//#endregion
//#region src/client/chain/grpc/ChainGrpcStakingApi.d.ts
/**
 * @category Chain Grpc API
 */
declare class ChainGrpcStakingApi extends BaseGrpcConsumer {
  protected module: string;
  private get client();
  fetchModuleParams(): Promise<StakingModuleParams>;
  fetchPool(): Promise<Pool>;
  fetchValidators(pagination?: PaginationOption): Promise<{
    validators: Validator[];
    pagination: Pagination;
  }>;
  fetchValidator(address: string): Promise<Validator>;
  fetchValidatorDelegations({
    validatorAddress,
    pagination
  }: {
    validatorAddress: string;
    pagination?: PaginationOption;
  }): Promise<{
    delegations: Delegation[];
    pagination: Pagination;
  }>;
  fetchValidatorDelegationsNoThrow({
    validatorAddress,
    pagination
  }: {
    validatorAddress: string;
    pagination?: PaginationOption;
  }): Promise<{
    delegations: Delegation[];
    pagination: Pagination;
  }>;
  fetchValidatorUnbondingDelegations({
    validatorAddress,
    pagination
  }: {
    validatorAddress: string;
    pagination?: PaginationOption;
  }): Promise<{
    unbondingDelegations: UnBondingDelegation[];
    pagination: Pagination;
  }>;
  fetchValidatorUnbondingDelegationsNoThrow({
    validatorAddress,
    pagination
  }: {
    validatorAddress: string;
    pagination?: PaginationOption;
  }): Promise<{
    unbondingDelegations: UnBondingDelegation[];
    pagination: Pagination;
  }>;
  fetchDelegation({
    injectiveAddress,
    validatorAddress
  }: {
    injectiveAddress: string;
    validatorAddress: string;
  }): Promise<Delegation>;
  fetchDelegations({
    injectiveAddress,
    pagination
  }: {
    injectiveAddress: string;
    pagination?: PaginationOption;
  }): Promise<{
    delegations: Delegation[];
    pagination: Pagination;
  }>;
  fetchDelegationsNoThrow({
    injectiveAddress,
    pagination
  }: {
    injectiveAddress: string;
    pagination?: PaginationOption;
  }): Promise<{
    delegations: Delegation[];
    pagination: Pagination;
  }>;
  fetchDelegators({
    validatorAddress,
    pagination
  }: {
    validatorAddress: string;
    pagination?: PaginationOption;
  }): Promise<{
    delegations: Delegation[];
    pagination: Pagination;
  }>;
  fetchDelegatorsNoThrow({
    validatorAddress,
    pagination
  }: {
    validatorAddress: string;
    pagination?: PaginationOption;
  }): Promise<{
    delegations: Delegation[];
    pagination: Pagination;
  }>;
  fetchUnbondingDelegations({
    injectiveAddress,
    pagination
  }: {
    injectiveAddress: string;
    pagination?: PaginationOption;
  }): Promise<{
    unbondingDelegations: UnBondingDelegation[];
    pagination: Pagination;
  }>;
  fetchUnbondingDelegationsNoThrow({
    injectiveAddress,
    pagination
  }: {
    injectiveAddress: string;
    pagination?: PaginationOption;
  }): Promise<{
    unbondingDelegations: UnBondingDelegation[];
    pagination: Pagination;
  }>;
  fetchReDelegations({
    injectiveAddress,
    pagination
  }: {
    injectiveAddress: string;
    pagination?: PaginationOption;
  }): Promise<{
    redelegations: ReDelegation[];
    pagination: Pagination;
  }>;
  fetchReDelegationsNoThrow({
    injectiveAddress,
    pagination
  }: {
    injectiveAddress: string;
    pagination?: PaginationOption;
  }): Promise<{
    redelegations: ReDelegation[];
    pagination: Pagination;
  }>;
}
//#endregion
//#region src/client/chain/grpc/ChainGrpcExchangeApi.d.ts
/**
 * @category Chain Grpc API
 */
declare class ChainGrpcExchangeApi extends BaseGrpcConsumer {
  protected module: string;
  private get client();
  fetchModuleParams(): Promise<ExchangeModuleParams>;
  fetchModuleState(): Promise<GenesisState$4>;
  fetchFeeDiscountSchedule(): Promise<FeeDiscountSchedule>;
  fetchFeeDiscountAccountInfo(injectiveAddress: string): Promise<FeeDiscountAccountInfo>;
  fetchTradingRewardsCampaign(): Promise<TradeRewardCampaign>;
  fetchTradeRewardPoints(injectiveAddresses: string[]): Promise<string[]>;
  fetchPendingTradeRewardPoints(injectiveAddresses: string[], timestamp?: number): Promise<string[]>;
  fetchPositions(): Promise<ChainDerivativePosition[]>;
  fetchSubaccountTradeNonce(subaccountId: string): Promise<QuerySubaccountTradeNonceResponse>;
  fetchIsOptedOutOfRewards(account: string): Promise<IsOptedOutOfRewards>;
  fetchActiveStakeGrant(account: string): Promise<{
    grant: ActiveGrant;
    effectiveGrant: EffectiveGrant;
  }>;
  fetchDenomDecimal(denom: string): Promise<bigint>;
  fetchDenomDecimals(): Promise<ChainDenomDecimal[]>;
  fetchDenomMinNotional(denom: string): Promise<string>;
  fetchDenomMinNotionals(): Promise<ChainDenomMinNotional[]>;
  fetchDerivativeMarkets(status?: string, marketIds?: string[]): Promise<DerivativeMarket[]>;
  fetchSpotMarkets(status?: string, marketIds?: string[]): Promise<SpotMarket[]>;
  fetchFullSpotMarkets(status?: string, marketIds?: string[]): Promise<SpotMarket[]>;
}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/cosmos/base/tendermint/v1beta1/types_pb.d.ts
/**
 * Block is tendermint type Block, with the Header proposer address
 * field converted to bech32 string.
 *
 * @generated from protobuf message cosmos.base.tendermint.v1beta1.Block
 */
interface Block {
  /**
   * @generated from protobuf field: cosmos.base.tendermint.v1beta1.Header header = 1
   */
  header?: Header;
  /**
   * @generated from protobuf field: cometbft.types.v1.Data data = 2
   */
  data?: Data;
  /**
   * @generated from protobuf field: cometbft.types.v1.EvidenceList evidence = 3
   */
  evidence?: EvidenceList;
  /**
   * @generated from protobuf field: cometbft.types.v1.Commit last_commit = 4
   */
  lastCommit?: Commit;
}
/**
 * Header defines the structure of a Tendermint block header.
 *
 * @generated from protobuf message cosmos.base.tendermint.v1beta1.Header
 */
interface Header {
  /**
   * basic block info
   *
   * @generated from protobuf field: cometbft.version.v1.Consensus version = 1
   */
  version?: Consensus;
  /**
   * @generated from protobuf field: string chain_id = 2
   */
  chainId: string;
  /**
   * @generated from protobuf field: int64 height = 3
   */
  height: bigint;
  /**
   * @generated from protobuf field: google.protobuf.Timestamp time = 4
   */
  time?: Timestamp;
  /**
   * prev block info
   *
   * @generated from protobuf field: cometbft.types.v1.BlockID last_block_id = 5
   */
  lastBlockId?: BlockID;
  /**
   * hashes of block data
   *
   * @generated from protobuf field: bytes last_commit_hash = 6
   */
  lastCommitHash: Uint8Array; // commit from validators from the last block
  /**
   * @generated from protobuf field: bytes data_hash = 7
   */
  dataHash: Uint8Array; // transactions
  /**
   * hashes from the app output from the prev block
   *
   * @generated from protobuf field: bytes validators_hash = 8
   */
  validatorsHash: Uint8Array; // validators for the current block
  /**
   * @generated from protobuf field: bytes next_validators_hash = 9
   */
  nextValidatorsHash: Uint8Array; // validators for the next block
  /**
   * @generated from protobuf field: bytes consensus_hash = 10
   */
  consensusHash: Uint8Array; // consensus params for current block
  /**
   * @generated from protobuf field: bytes app_hash = 11
   */
  appHash: Uint8Array; // state after txs from the previous block
  /**
   * @generated from protobuf field: bytes last_results_hash = 12
   */
  lastResultsHash: Uint8Array; // root hash of all results from the txs from the previous block
  /**
   * consensus info
   *
   * @generated from protobuf field: bytes evidence_hash = 13
   */
  evidenceHash: Uint8Array; // evidence included in the block
  /**
   * proposer_address is the original block proposer address, formatted as a Bech32 string.
   * In Tendermint, this type is `bytes`, but in the SDK, we convert it to a Bech32 string
   * for better UX.
   *
   * @generated from protobuf field: string proposer_address = 14
   */
  proposerAddress: string; // original proposer of the block
}
/**
 * @generated MessageType for protobuf message cosmos.base.tendermint.v1beta1.Block
 */
declare const Block = new Block$Type();
/**
 * @generated MessageType for protobuf message cosmos.base.tendermint.v1beta1.Header
 */
declare const Header = new Header$Type();
//#endregion
//#region src/client/chain/grpc/ChainGrpcTendermintApi.d.ts
/**
 * @category Chain Grpc API
 */
declare class ChainGrpcTendermintApi extends BaseGrpcConsumer {
  protected module: string;
  private get client();
  fetchLatestBlock(): Promise<Block | Block$2 | undefined>;
  fetchBlock(height: number | string): Promise<Block | Block$2 | undefined>;
}
//#endregion
//#region src/client/chain/grpc/ChainGrpcPermissionsApi.d.ts
/**
 * @category Chain Grpc API
 */
declare class ChainGrpcPermissionsApi extends BaseGrpcConsumer {
  protected module: string;
  private get client();
  fetchModuleParams(): Promise<PermissionsModuleParams>;
  fetchNamespaceDenoms(): Promise<string[]>;
  fetchNamespaces(): Promise<void[]>;
  fetchNamespace(denom: string): Promise<PermissionNamespace | undefined>;
  fetchActorsByRole({
    denom,
    role
  }: {
    denom: string;
    role: string;
  }): Promise<{
    roles: string;
  }[]>;
  fetchRolesByActor({
    actor,
    denom
  }: {
    actor: string;
    denom: string;
  }): Promise<{
    roles: string;
  }[]>;
  fetchRoleManager({
    denom,
    manager
  }: {
    denom: string;
    manager: string;
  }): Promise<PermissionRoleManager | undefined>;
  fetchRoleManagers(): Promise<PermissionRoleManager[]>;
  fetchPolicyStatuses(): Promise<PermissionPolicyStatus[]>;
  fetchPolicyManagerCapabilities(denom: string): Promise<PermissionPolicyManagerCapability[]>;
  fetchVoucher({
    denom,
    address
  }: {
    denom: string;
    address: string;
  }): Promise<Coin$8 | undefined>;
  fetchVouchers(denom: string): Promise<PermissionAddressVoucher[]>;
  fetchModuleState(): Promise<{
    params: PermissionsModuleParams;
    namespaces: PermissionNamespace[];
    vouchers: PermissionAddressVoucher[];
  } | undefined>;
}
//#endregion
//#region src/client/chain/grpc/ChainGrpcDistributionApi.d.ts
/**
 * @category Chain Grpc API
 */
declare class ChainGrpcDistributionApi extends BaseGrpcConsumer {
  protected module: string;
  private get client();
  fetchModuleParams(): Promise<DistributionModuleParams>;
  fetchDelegatorRewardsForValidator({
    delegatorAddress,
    validatorAddress
  }: {
    delegatorAddress: string;
    validatorAddress: string;
  }): Promise<Coin[]>;
  fetchDelegatorRewardsForValidatorNoThrow({
    delegatorAddress,
    validatorAddress
  }: {
    delegatorAddress: string;
    validatorAddress: string;
  }): Promise<Coin[]>;
  fetchDelegatorRewards(injectiveAddress: string): Promise<ValidatorRewards[]>;
  fetchDelegatorRewardsNoThrow(injectiveAddress: string): Promise<ValidatorRewards[]>;
}
//#endregion
//#region src/client/chain/grpc/ChainGrpcTokenFactoryApi.d.ts
/**
 * @category TokenFactory Grpc API
 */
declare class ChainGrpcTokenFactoryApi extends BaseGrpcConsumer {
  protected module: string;
  private get client();
  fetchDenomsFromCreator(creator: string): Promise<string[]>;
  fetchDenomAuthorityMetadata(creator: string, subDenom: string): Promise<AuthorityMetadata>;
  fetchModuleParams(): Promise<TokenFactoryModuleParams>;
  fetchModuleState(): Promise<TokenFactoryModuleState>;
}
//#endregion
//#region src/client/chain/grpc/ChainGrpcInsuranceFundApi.d.ts
/**
 * @category Chain Grpc API
 */
declare class ChainGrpcInsuranceFundApi extends BaseGrpcConsumer {
  protected module: string;
  private get client();
  fetchModuleParams(): Promise<InsuranceModuleParams>;
  fetchInsuranceFunds(): Promise<InsuranceFund[]>;
  fetchInsuranceFund(marketId: string): Promise<InsuranceFund>;
  fetchEstimatedRedemptions({
    marketId,
    address
  }: {
    marketId: string;
    address: string;
  }): Promise<{
    amount: string;
    denom: string;
  }[]>;
  fetchPendingRedemptions({
    marketId,
    address
  }: {
    marketId: string;
    address: string;
  }): Promise<{
    amount: string;
    denom: string;
  }[]>;
}
//#endregion
//#region src/client/chain/rest/ChainRestBankApi.d.ts
/**
 * @category Chain Rest API
 */
declare class ChainRestBankApi extends BaseRestConsumer {
  /**
   * Get address's balance
   *
   * @param address address of account to look up
   */
  fetchBalances(address: string, params?: Record<string, any>): Promise<BalancesResponse>;
  /**
   * Get address's balances
   *
   * @param address address of account to look up
   */
  fetchBalance(address: string, denom: string, params?: Record<string, any>): Promise<DenomBalance>;
  fetchDenomOwners(denom: string, params?: Record<string, any>): Promise<DenomOwnersResponse['denom_owners']>;
}
//#endregion
//#region src/client/chain/rest/ChainRestAuthApi.d.ts
/**
 * @category Chain Rest API
 */
declare class ChainRestAuthApi extends BaseRestConsumer {
  /**
   * Looks up the account information for the Injective address.
   *
   * @param address address of account to look up
   */
  fetchAccount(address: string, params?: Record<string, any>): Promise<AccountResponse>;
  /**
   * Looks up the account information for any cosmos chain address.
   *
   * @param address address of account to look up
   */
  fetchCosmosAccount(address: string, params?: Record<string, any>): Promise<BaseAccountRestResponse>;
}
//#endregion
//#region src/client/chain/rest/ChainRestWasmApi.d.ts
type SmartContractStateResponse = unknown;
/**
 * @category Chain Wasm API
 */
declare class ChainRestWasmApi extends BaseRestConsumer {
  fetchSmartContractState(contractAddress: string, query: string, params?: Record<string, any>): Promise<SmartContractStateResponse>;
}
//#endregion
//#region src/client/chain/rest/ChainRestTendermintApi.d.ts
/**
 * @category Chain Rest API
 */
declare class ChainRestTendermintApi extends BaseRestConsumer {
  fetchLatestBlock(params?: Record<string, any>): Promise<BlockLatestRestResponse['block']>;
  fetchBlock(height: number | string, params?: Record<string, any>): Promise<BlockLatestRestResponse['block']>;
  fetchNodeInfo(params?: Record<string, any>): Promise<{
    nodeInfo: NodeInfoRestResponse['default_node_info'];
    applicationVersion: NodeInfoRestResponse['application_version'];
  }>;
}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/cosmos/gov/v1/query_pb.d.ts
/**
 * QueryProposalResponse is the response type for the Query/Proposal RPC method.
 *
 * @generated from protobuf message cosmos.gov.v1.QueryProposalResponse
 */
interface QueryProposalResponse {
  /**
   * proposal is the requested governance proposal.
   *
   * @generated from protobuf field: cosmos.gov.v1.Proposal proposal = 1
   */
  proposal?: Proposal$1;
}
/**
 * QueryProposalsResponse is the response type for the Query/Proposals RPC
 * method.
 *
 * @generated from protobuf message cosmos.gov.v1.QueryProposalsResponse
 */
interface QueryProposalsResponse {
  /**
   * proposals defines all the requested governance proposals.
   *
   * @generated from protobuf field: repeated cosmos.gov.v1.Proposal proposals = 1
   */
  proposals: Proposal$1[];
  /**
   * pagination defines the pagination in the response.
   *
   * @generated from protobuf field: cosmos.base.query.v1beta1.PageResponse pagination = 2
   */
  pagination?: PageResponse;
}
/**
 * QueryVotesResponse is the response type for the Query/Votes RPC method.
 *
 * @generated from protobuf message cosmos.gov.v1.QueryVotesResponse
 */
interface QueryVotesResponse {
  /**
   * votes defines the queried votes.
   *
   * @generated from protobuf field: repeated cosmos.gov.v1.Vote votes = 1
   */
  votes: Vote$1[];
  /**
   * pagination defines the pagination in the response.
   *
   * @generated from protobuf field: cosmos.base.query.v1beta1.PageResponse pagination = 2
   */
  pagination?: PageResponse;
}
/**
 * QueryParamsResponse is the response type for the Query/Params RPC method.
 *
 * @generated from protobuf message cosmos.gov.v1.QueryParamsResponse
 */
interface QueryParamsResponse$10 {
  /**
   * Deprecated: Prefer to use `params` instead.
   * voting_params defines the parameters related to voting.
   *
   * @deprecated
   * @generated from protobuf field: cosmos.gov.v1.VotingParams voting_params = 1 [deprecated = true]
   */
  votingParams?: VotingParams;
  /**
   * Deprecated: Prefer to use `params` instead.
   * deposit_params defines the parameters related to deposit.
   *
   * @deprecated
   * @generated from protobuf field: cosmos.gov.v1.DepositParams deposit_params = 2 [deprecated = true]
   */
  depositParams?: DepositParams;
  /**
   * Deprecated: Prefer to use `params` instead.
   * tally_params defines the parameters related to tally.
   *
   * @deprecated
   * @generated from protobuf field: cosmos.gov.v1.TallyParams tally_params = 3 [deprecated = true]
   */
  tallyParams?: TallyParams;
  /**
   * params defines all the paramaters of x/gov module.
   *
   * Since: cosmos-sdk 0.47
   *
   * @generated from protobuf field: cosmos.gov.v1.Params params = 4
   */
  params?: Params$13;
}
/**
 * QueryDepositsResponse is the response type for the Query/Deposits RPC method.
 *
 * @generated from protobuf message cosmos.gov.v1.QueryDepositsResponse
 */
interface QueryDepositsResponse {
  /**
   * deposits defines the requested deposits.
   *
   * @generated from protobuf field: repeated cosmos.gov.v1.Deposit deposits = 1
   */
  deposits: Deposit[];
  /**
   * pagination defines the pagination in the response.
   *
   * @generated from protobuf field: cosmos.base.query.v1beta1.PageResponse pagination = 2
   */
  pagination?: PageResponse;
}
/**
 * QueryTallyResultResponse is the response type for the Query/Tally RPC method.
 *
 * @generated from protobuf message cosmos.gov.v1.QueryTallyResultResponse
 */
interface QueryTallyResultResponse {
  /**
   * tally defines the requested tally.
   *
   * @generated from protobuf field: cosmos.gov.v1.TallyResult tally = 1
   */
  tally?: TallyResult$1;
}
/**
 * @generated MessageType for protobuf message cosmos.gov.v1.QueryProposalResponse
 */
declare const QueryProposalResponse = new QueryProposalResponse$Type();
/**
 * @generated MessageType for protobuf message cosmos.gov.v1.QueryProposalsResponse
 */
declare const QueryProposalsResponse = new QueryProposalsResponse$Type();
/**
 * @generated MessageType for protobuf message cosmos.gov.v1.QueryVotesResponse
 */
declare const QueryVotesResponse = new QueryVotesResponse$Type();
/**
 * @generated MessageType for protobuf message cosmos.gov.v1.QueryParamsResponse
 */
declare const QueryParamsResponse$10 = new QueryParamsResponse$Type();
/**
 * @generated MessageType for protobuf message cosmos.gov.v1.QueryDepositsResponse
 */
declare const QueryDepositsResponse = new QueryDepositsResponse$Type();
/**
 * @generated MessageType for protobuf message cosmos.gov.v1.QueryTallyResultResponse
 */
declare const QueryTallyResultResponse = new QueryTallyResultResponse$Type();
//#endregion
//#region src/client/chain/transformers/ChainGrpcGovTransformer.d.ts
/**
 * @category Chain Grpc Transformer
 */
declare class ChainGrpcGovTransformer {
  static moduleParamsResponseToModuleParams(response: QueryParamsResponse$10): GovModuleStateParams;
  static moduleParamsResponseToModuleParamsByType({
    depositParams,
    votingParams,
    tallyParams
  }: {
    depositParams: GrpcGovernanceDepositParams;
    votingParams: GrpcGovernanceVotingParams;
    tallyParams: GrpcGovernanceTallyParams;
  }): GovModuleStateParams;
  static proposalResponseToProposal(response: QueryProposalResponse): Proposal | undefined;
  static proposalsResponseToProposals(response: QueryProposalsResponse): {
    proposals: Proposal[];
    pagination: Pagination;
  };
  static depositsResponseToDeposits(response: QueryDepositsResponse): {
    deposits: ProposalDeposit[];
    pagination: Pagination;
  };
  static grpcVoteToVote(vote: GrpcVote): Vote;
  static votesResponseToVotes(response: QueryVotesResponse): {
    votes: Vote[];
    pagination: Pagination;
  };
  static tallyResultResponseToTallyResult(response: QueryTallyResultResponse): TallyResult;
  static grpcTallyResultToTallyResult(result: GrpcTallyResult | undefined): TallyResult;
  static grpcProposalToProposal(proposal: GrpcProposal): Proposal | undefined;
}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/injective/evm/v1/query_pb.d.ts
/**
 * QueryAccountResponse is the response type for the Query/Account RPC method.
 *
 * @generated from protobuf message injective.evm.v1.QueryAccountResponse
 */
interface QueryAccountResponse$1 {
  /**
   * balance is the balance of the EVM denomination.
   *
   * @generated from protobuf field: string balance = 1
   */
  balance: string;
  /**
   * code_hash is the hex-formatted code bytes from the EOA.
   *
   * @generated from protobuf field: string code_hash = 2
   */
  codeHash: string;
  /**
   * nonce is the account's sequence number.
   *
   * @generated from protobuf field: uint64 nonce = 3
   */
  nonce: bigint;
}
/**
 * QueryCosmosAccountResponse is the response type for the Query/CosmosAccount
 * RPC method.
 *
 * @generated from protobuf message injective.evm.v1.QueryCosmosAccountResponse
 */
interface QueryCosmosAccountResponse {
  /**
   * cosmos_address is the cosmos address of the account.
   *
   * @generated from protobuf field: string cosmos_address = 1
   */
  cosmosAddress: string;
  /**
   * sequence is the account's sequence number.
   *
   * @generated from protobuf field: uint64 sequence = 2
   */
  sequence: bigint;
  /**
   * account_number is the account number
   *
   * @generated from protobuf field: uint64 account_number = 3
   */
  accountNumber: bigint;
}
/**
 * QueryValidatorAccountResponse is the response type for the
 * Query/ValidatorAccount RPC method.
 *
 * @generated from protobuf message injective.evm.v1.QueryValidatorAccountResponse
 */
interface QueryValidatorAccountResponse {
  /**
   * account_address is the cosmos address of the account in bech32 format.
   *
   * @generated from protobuf field: string account_address = 1
   */
  accountAddress: string;
  /**
   * sequence is the account's sequence number.
   *
   * @generated from protobuf field: uint64 sequence = 2
   */
  sequence: bigint;
  /**
   * account_number is the account number
   *
   * @generated from protobuf field: uint64 account_number = 3
   */
  accountNumber: bigint;
}
/**
 * QueryParamsResponse defines the response type for querying x/evm parameters.
 *
 * @generated from protobuf message injective.evm.v1.QueryParamsResponse
 */
interface QueryParamsResponse$9 {
  /**
   * params define the evm module parameters.
   *
   * @generated from protobuf field: injective.evm.v1.Params params = 1
   */
  params?: Params$12;
}
/**
 * @generated MessageType for protobuf message injective.evm.v1.QueryAccountResponse
 */
declare const QueryAccountResponse$1 = new QueryAccountResponse$Type();
/**
 * @generated MessageType for protobuf message injective.evm.v1.QueryCosmosAccountResponse
 */
declare const QueryCosmosAccountResponse = new QueryCosmosAccountResponse$Type();
/**
 * @generated MessageType for protobuf message injective.evm.v1.QueryValidatorAccountResponse
 */
declare const QueryValidatorAccountResponse = new QueryValidatorAccountResponse$Type();
/**
 * @generated MessageType for protobuf message injective.evm.v1.QueryParamsResponse
 */
declare const QueryParamsResponse$9 = new QueryParamsResponse$Type();
//#endregion
//#region src/client/chain/transformers/ChainGrpcEvmTransformer.d.ts
/**
 * @category Chain Grpc Transformer
 */
declare class ChainGrpcEvmTransformer {
  static grpcBlobConfigToBlobConfig(config: GrpcEvmBlobConfig): EvmBlobConfig;
  static grpcBlockScheduleConfigToBlockScheduleConfig(config: GrpcEvmBlobScheduleConfig): EvmBlobScheduleConfig;
  static grpcChainConfigToChainConfig(config: GrpcEvmChainConfig): EvmChainConfig;
  /**
   * response transformers
   * */
  static accountResponseToAccount(response: QueryAccountResponse$1): {
    balance: string;
    codeHash: string;
    nonce: string;
  };
  static cosmosAccountResponseToCosmosAccount(response: QueryCosmosAccountResponse): {
    sequence: string;
    cosmosAddress: string;
    accountNumber: string;
  };
  static validatorAccountResponseToValidatorAccount(response: QueryValidatorAccountResponse): {
    sequence: string;
    accountNumber: string;
    accountAddress: string;
  };
  static paramsResponseToParams(response: QueryParamsResponse$9): EvmParams | undefined;
}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/cosmos/auth/v1beta1/query_pb.d.ts
/**
 * QueryAccountsResponse is the response type for the Query/Accounts RPC method.
 *
 * Since: cosmos-sdk 0.43
 *
 * @generated from protobuf message cosmos.auth.v1beta1.QueryAccountsResponse
 */
interface QueryAccountsResponse {
  /**
   * accounts are the existing accounts
   *
   * @generated from protobuf field: repeated google.protobuf.Any accounts = 1
   */
  accounts: Any[];
  /**
   * pagination defines the pagination in the response.
   *
   * @generated from protobuf field: cosmos.base.query.v1beta1.PageResponse pagination = 2
   */
  pagination?: PageResponse;
}
/**
 * QueryAccountResponse is the response type for the Query/Account RPC method.
 *
 * @generated from protobuf message cosmos.auth.v1beta1.QueryAccountResponse
 */
interface QueryAccountResponse {
  /**
   * account defines the account of the corresponding address.
   *
   * @generated from protobuf field: google.protobuf.Any account = 1
   */
  account?: Any;
}
/**
 * QueryParamsResponse is the response type for the Query/Params RPC method.
 *
 * @generated from protobuf message cosmos.auth.v1beta1.QueryParamsResponse
 */
interface QueryParamsResponse$8 {
  /**
   * params defines the parameters of the module.
   *
   * @generated from protobuf field: cosmos.auth.v1beta1.Params params = 1
   */
  params?: Params$11;
}
/**
 * @generated MessageType for protobuf message cosmos.auth.v1beta1.QueryAccountsResponse
 */
declare const QueryAccountsResponse = new QueryAccountsResponse$Type();
/**
 * @generated MessageType for protobuf message cosmos.auth.v1beta1.QueryAccountResponse
 */
declare const QueryAccountResponse = new QueryAccountResponse$Type();
/**
 * @generated MessageType for protobuf message cosmos.auth.v1beta1.QueryParamsResponse
 */
declare const QueryParamsResponse$8 = new QueryParamsResponse$Type();
//#endregion
//#region src/client/chain/transformers/ChainGrpcAuthTransformer.d.ts
/**
 * @category Chain Grpc Transformer
 */
declare class ChainGrpcAuthTransformer {
  static moduleParamsResponseToModuleParams(response: QueryParamsResponse$8): AuthModuleParams;
  static grpcAccountToAccount(ethAccount: Any): Account;
  static accountResponseToAccount(response: QueryAccountResponse): Account;
  static accountsResponseToAccounts(response: QueryAccountsResponse): {
    pagination: Pagination;
    accounts: Account[];
  };
}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/cosmos/bank/v1beta1/query_pb.d.ts
/**
 * QueryBalanceResponse is the response type for the Query/Balance RPC method.
 *
 * @generated from protobuf message cosmos.bank.v1beta1.QueryBalanceResponse
 */
interface QueryBalanceResponse {
  /**
   * balance is the balance of the coin.
   *
   * @generated from protobuf field: cosmos.base.v1beta1.Coin balance = 1
   */
  balance?: Coin$1;
}
/**
 * QueryAllBalancesResponse is the response type for the Query/AllBalances RPC
 * method.
 *
 * @generated from protobuf message cosmos.bank.v1beta1.QueryAllBalancesResponse
 */
interface QueryAllBalancesResponse {
  /**
   * balances is the balances of all the coins.
   *
   * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin balances = 1
   */
  balances: Coin$1[];
  /**
   * pagination defines the pagination in the response.
   *
   * @generated from protobuf field: cosmos.base.query.v1beta1.PageResponse pagination = 2
   */
  pagination?: PageResponse;
}
/**
 * QueryTotalSupplyResponse is the response type for the Query/TotalSupply RPC
 * method
 *
 * @generated from protobuf message cosmos.bank.v1beta1.QueryTotalSupplyResponse
 */
interface QueryTotalSupplyResponse {
  /**
   * supply is the supply of the coins
   *
   * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin supply = 1
   */
  supply: Coin$1[];
  /**
   * pagination defines the pagination in the response.
   *
   * Since: cosmos-sdk 0.43
   *
   * @generated from protobuf field: cosmos.base.query.v1beta1.PageResponse pagination = 2
   */
  pagination?: PageResponse;
}
/**
 * QueryParamsResponse defines the response type for querying x/bank parameters.
 *
 * @generated from protobuf message cosmos.bank.v1beta1.QueryParamsResponse
 */
interface QueryParamsResponse$7 {
  /**
   * params provides the parameters of the bank module.
   *
   * @generated from protobuf field: cosmos.bank.v1beta1.Params params = 1
   */
  params?: Params$10;
}
/**
 * QueryDenomsMetadataResponse is the response type for the Query/DenomsMetadata RPC
 * method.
 *
 * @generated from protobuf message cosmos.bank.v1beta1.QueryDenomsMetadataResponse
 */
interface QueryDenomsMetadataResponse {
  /**
   * metadata provides the client information for all the registered tokens.
   *
   * @generated from protobuf field: repeated cosmos.bank.v1beta1.Metadata metadatas = 1
   */
  metadatas: Metadata$1[];
  /**
   * pagination defines the pagination in the response.
   *
   * @generated from protobuf field: cosmos.base.query.v1beta1.PageResponse pagination = 2
   */
  pagination?: PageResponse;
}
/**
 * DenomOwner defines structure representing an account that owns or holds a
 * particular denominated token. It contains the account address and account
 * balance of the denominated token.
 *
 * Since: cosmos-sdk 0.46
 *
 * @generated from protobuf message cosmos.bank.v1beta1.DenomOwner
 */
interface DenomOwner {
  /**
   * address defines the address that owns a particular denomination.
   *
   * @generated from protobuf field: string address = 1
   */
  address: string;
  /**
   * balance is the balance of the denominated coin for an account.
   *
   * @generated from protobuf field: cosmos.base.v1beta1.Coin balance = 2
   */
  balance?: Coin$1;
}
/**
 * QueryDenomOwnersResponse defines the RPC response of a DenomOwners RPC query.
 *
 * Since: cosmos-sdk 0.46
 *
 * @generated from protobuf message cosmos.bank.v1beta1.QueryDenomOwnersResponse
 */
interface QueryDenomOwnersResponse {
  /**
   * @generated from protobuf field: repeated cosmos.bank.v1beta1.DenomOwner denom_owners = 1
   */
  denomOwners: DenomOwner[];
  /**
   * pagination defines the pagination in the response.
   *
   * @generated from protobuf field: cosmos.base.query.v1beta1.PageResponse pagination = 2
   */
  pagination?: PageResponse;
}
/**
 * @generated MessageType for protobuf message cosmos.bank.v1beta1.QueryBalanceResponse
 */
declare const QueryBalanceResponse = new QueryBalanceResponse$Type();
/**
 * @generated MessageType for protobuf message cosmos.bank.v1beta1.QueryAllBalancesResponse
 */
declare const QueryAllBalancesResponse = new QueryAllBalancesResponse$Type();
/**
 * @generated MessageType for protobuf message cosmos.bank.v1beta1.QueryTotalSupplyResponse
 */
declare const QueryTotalSupplyResponse = new QueryTotalSupplyResponse$Type();
/**
 * @generated MessageType for protobuf message cosmos.bank.v1beta1.QueryParamsResponse
 */
declare const QueryParamsResponse$7 = new QueryParamsResponse$Type();
/**
 * @generated MessageType for protobuf message cosmos.bank.v1beta1.QueryDenomsMetadataResponse
 */
declare const QueryDenomsMetadataResponse = new QueryDenomsMetadataResponse$Type();
/**
 * @generated MessageType for protobuf message cosmos.bank.v1beta1.DenomOwner
 */
declare const DenomOwner = new DenomOwner$Type();
/**
 * @generated MessageType for protobuf message cosmos.bank.v1beta1.QueryDenomOwnersResponse
 */
declare const QueryDenomOwnersResponse = new QueryDenomOwnersResponse$Type();
//#endregion
//#region src/client/chain/transformers/ChainGrpcBankTransformer.d.ts
/**
 * @category Chain Grpc Transformer
 */
declare class ChainGrpcBankTransformer {
  static metadataToMetadata(metadata: Metadata$1): Metadata;
  static moduleParamsResponseToModuleParams(response: QueryParamsResponse$7): BankModuleParams;
  static denomOwnersResponseToDenomOwners(response: QueryDenomOwnersResponse): {
    denomOwners: {
      address: string;
      balance: Coin | undefined;
    }[];
    pagination: Pagination;
  };
  static totalSupplyResponseToTotalSupply(response: QueryTotalSupplyResponse): {
    supply: TotalSupply;
    pagination: Pagination;
  };
  static denomsMetadataResponseToDenomsMetadata(response: QueryDenomsMetadataResponse): {
    metadatas: Metadata[];
    pagination: Pagination;
  };
  static balanceResponseToBalance(response: QueryBalanceResponse): Coin;
  static balancesResponseToBalances(response: QueryAllBalancesResponse): {
    balances: Coin[];
    pagination: Pagination;
  };
}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/cosmos/mint/v1beta1/query_pb.d.ts
/**
 * QueryParamsResponse is the response type for the Query/Params RPC method.
 *
 * @generated from protobuf message cosmos.mint.v1beta1.QueryParamsResponse
 */
interface QueryParamsResponse$6 {
  /**
   * params defines the parameters of the module.
   *
   * @generated from protobuf field: cosmos.mint.v1beta1.Params params = 1
   */
  params?: Params$9;
}
/**
 * @generated MessageType for protobuf message cosmos.mint.v1beta1.QueryParamsResponse
 */
declare const QueryParamsResponse$6 = new QueryParamsResponse$Type();
//#endregion
//#region src/client/chain/transformers/ChainGrpcMintTransformer.d.ts
/**
 * @category Chain Grpc Transformer
 */
declare class ChainGrpcMintTransformer {
  static moduleParamsResponseToModuleParams(response: QueryParamsResponse$6): MinModuleParams;
}
//#endregion
//#region src/client/chain/transformers/ChainGrpcWasmTransformer.d.ts
/**
 * @category Chain Grpc Transformer
 */
declare class ChainGrpcWasmTransformer {
  static allContractStateResponseToContractAccountsBalanceWithPagination(response: QueryAllContractStateResponse): ContractAccountsBalanceWithPagination;
  static allContractStateResponseToContractState(response: QueryAllContractStateResponse): ContractStateWithPagination;
  static contactInfoResponseToContractInfo(contractInfo: grpcContractInfo): ContractInfo;
  static grpcContractCodeHistoryEntryToContractCodeHistoryEntry(entry: GrpcContractCodeHistoryEntry): ContractCodeHistoryEntry;
  static grpcCodeInfoResponseToCodeInfoResponse(info: GrpcCodeInfoResponse): CodeInfoResponse;
  static contactHistoryResponseToContractHistory(response: QueryContractHistoryResponse): {
    entriesList: ContractCodeHistoryEntry[];
    pagination: Pagination;
  };
  static contractCodesResponseToContractCodes(response: QueryCodesResponse): {
    codeInfosList: CodeInfoResponse[];
    pagination: Pagination;
  };
  static contractCodeResponseToContractCode(response: QueryCodeResponse): {
    codeInfo: CodeInfoResponse;
    data: Uint8Array<ArrayBufferLike>;
  };
  static contractByCodeResponseToContractByCode(response: QueryContractsByCodeResponse): {
    contractsList: string[];
    pagination: Pagination;
  };
}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/cosmos/authz/v1beta1/query_pb.d.ts
/**
 * QueryGrantsResponse is the response type for the Query/Authorizations RPC method.
 *
 * @generated from protobuf message cosmos.authz.v1beta1.QueryGrantsResponse
 */
interface QueryGrantsResponse {
  /**
   * authorizations is a list of grants granted for grantee by granter.
   *
   * @generated from protobuf field: repeated cosmos.authz.v1beta1.Grant grants = 1
   */
  grants: Grant[];
  /**
   * pagination defines an pagination for the response.
   *
   * @generated from protobuf field: cosmos.base.query.v1beta1.PageResponse pagination = 2
   */
  pagination?: PageResponse;
}
/**
 * QueryGranterGrantsResponse is the response type for the Query/GranterGrants RPC method.
 *
 * @generated from protobuf message cosmos.authz.v1beta1.QueryGranterGrantsResponse
 */
interface QueryGranterGrantsResponse {
  /**
   * grants is a list of grants granted by the granter.
   *
   * @generated from protobuf field: repeated cosmos.authz.v1beta1.GrantAuthorization grants = 1
   */
  grants: GrantAuthorization[];
  /**
   * pagination defines an pagination for the response.
   *
   * @generated from protobuf field: cosmos.base.query.v1beta1.PageResponse pagination = 2
   */
  pagination?: PageResponse;
}
/**
 * QueryGranteeGrantsResponse is the response type for the Query/GranteeGrants RPC method.
 *
 * @generated from protobuf message cosmos.authz.v1beta1.QueryGranteeGrantsResponse
 */
interface QueryGranteeGrantsResponse {
  /**
   * grants is a list of grants granted to the grantee.
   *
   * @generated from protobuf field: repeated cosmos.authz.v1beta1.GrantAuthorization grants = 1
   */
  grants: GrantAuthorization[];
  /**
   * pagination defines an pagination for the response.
   *
   * @generated from protobuf field: cosmos.base.query.v1beta1.PageResponse pagination = 2
   */
  pagination?: PageResponse;
}
/**
 * @generated MessageType for protobuf message cosmos.authz.v1beta1.QueryGrantsResponse
 */
declare const QueryGrantsResponse = new QueryGrantsResponse$Type();
/**
 * @generated MessageType for protobuf message cosmos.authz.v1beta1.QueryGranterGrantsResponse
 */
declare const QueryGranterGrantsResponse = new QueryGranterGrantsResponse$Type();
/**
 * @generated MessageType for protobuf message cosmos.authz.v1beta1.QueryGranteeGrantsResponse
 */
declare const QueryGranteeGrantsResponse = new QueryGranteeGrantsResponse$Type();
//#endregion
//#region src/client/chain/transformers/ChainGrpcAuthZTransformer.d.ts
/**
 * @category Chain Grpc Transformer
 */
declare class ChainGrpcAuthZTransformer {
  static grpcGrantToGrant(grant: Grant): GrantWithDecodedAuthorization;
  static grpcGrantAuthorizationToGrantAuthorization(grant: GrantAuthorization): GrantAuthorizationWithDecodedAuthorization;
  static grpcGrantsToGrants(response: QueryGrantsResponse): {
    pagination: Pagination;
    grants: GrantWithDecodedAuthorization[];
  };
  static grpcGranteeGrantsToGranteeGrants(response: QueryGranteeGrantsResponse): {
    pagination: Pagination;
    grants: GrantAuthorizationWithDecodedAuthorization[];
  };
  static grpcGranterGrantsToGranterGrants(response: QueryGranterGrantsResponse): {
    pagination: Pagination;
    grants: GrantAuthorizationWithDecodedAuthorization[];
  };
}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/injective/peggy/v1/query_pb.d.ts
/**
 * @generated from protobuf message injective.peggy.v1.QueryParamsResponse
 */
interface QueryParamsResponse$5 {
  /**
   * @generated from protobuf field: injective.peggy.v1.Params params = 1
   */
  params?: Params$8;
}
/**
 * @generated MessageType for protobuf message injective.peggy.v1.QueryParamsResponse
 */
declare const QueryParamsResponse$5 = new QueryParamsResponse$Type();
//#endregion
//#region src/client/chain/transformers/ChainGrpcPeggyTransformer.d.ts
/**
 * @category Chain Grpc Transformer
 */
declare class ChainGrpcPeggyTransformer {
  static moduleParamsResponseToModuleParams(response: QueryParamsResponse$5): PeggyModuleParams;
}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/injective/erc20/v1beta1/query_pb.d.ts
/**
 * QueryParamsResponse is the response type for the Query/Params RPC method.
 *
 * @generated from protobuf message injective.erc20.v1beta1.QueryParamsResponse
 */
interface QueryParamsResponse$4 {
  /**
   * params defines the parameters of the module.
   *
   * @generated from protobuf field: injective.erc20.v1beta1.Params params = 1
   */
  params?: Params$7;
}
/**
 * QueryAllTokenPairsResponse is the response type for the Query/AllTokenPairs
 * RPC method.
 *
 * @generated from protobuf message injective.erc20.v1beta1.QueryAllTokenPairsResponse
 */
interface QueryAllTokenPairsResponse {
  /**
   * @generated from protobuf field: repeated injective.erc20.v1beta1.TokenPair token_pairs = 1
   */
  tokenPairs: TokenPair$1[];
  /**
   * pagination defines the pagination in the response.
   *
   * @generated from protobuf field: cosmos.base.query.v1beta1.PageResponse pagination = 2
   */
  pagination?: PageResponse;
}
/**
 * @generated MessageType for protobuf message injective.erc20.v1beta1.QueryParamsResponse
 */
declare const QueryParamsResponse$4 = new QueryParamsResponse$Type();
/**
 * @generated MessageType for protobuf message injective.erc20.v1beta1.QueryAllTokenPairsResponse
 */
declare const QueryAllTokenPairsResponse = new QueryAllTokenPairsResponse$Type();
//#endregion
//#region src/client/chain/transformers/ChainGrpcErc20Transformer.d.ts
/**
 * @category Chain Grpc Transformer
 */
declare class ChainGrpcErc20Transformer {
  static grpcTokenPairToTokenPair(grpcTokenPair: GrpcTokenPair): TokenPair;
  static paramsResponseToParams(response: QueryParamsResponse$4): Params$6;
  static tokenPairsResponseToTokenPairs(response: QueryAllTokenPairsResponse): {
    tokenPairs: {
      bankDenom: string;
      erc20Address: string;
    }[];
    pagination: Pagination;
  };
}
//#endregion
//#region src/client/chain/transformers/ChainGrpcTxFeesTransformer.d.ts
/**
 * @category Chain Grpc Transformer
 */
declare class ChainGrpcTxFeesTransformer {
  static moduleParamsResponseToModuleParams(response: QueryParamsResponse$11): TxFeesModuleStateParams;
  static eipBaseFeeResponseToEipBaseFee(response: QueryEipBaseFeeResponse): TxFeesEipBaseFee;
}
//#endregion
//#region src/client/chain/transformers/ChainGrpcCommonTransformer.d.ts
declare class ChainGrpcCommonTransformer {
  static grpcCoinToCoin(coin: GrpcCoin): Coin;
  static pageRequestToGrpcPageRequestV2(pageRequest?: PaginationOption): PageRequest | undefined;
  static pageRequestToGrpcPageRequest(pageRequest?: PaginationOption): PageRequest | undefined;
  static paginationUint8ArrayToString(key: Uint8Array | string | undefined): string;
  static grpcPaginationToPagination(pagination: PageResponse | undefined): Pagination;
  static grpcPaginationToPaginationV2(pagination: PageResponse | undefined): Pagination;
}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/injective/auction/v1beta1/genesis_pb.d.ts
/**
 * GenesisState defines the auction module's genesis state.
 *
 * @generated from protobuf message injective.auction.v1beta1.GenesisState
 */
interface GenesisState$2 {
  /**
   * params defines all the parameters of related to auction.
   *
   * @generated from protobuf field: injective.auction.v1beta1.Params params = 1
   */
  params?: Params$5;
  /**
   * current auction round
   *
   * @generated from protobuf field: uint64 auction_round = 2
   */
  auctionRound: bigint;
  /**
   * current highest bid
   *
   * @generated from protobuf field: injective.auction.v1beta1.Bid highest_bid = 3
   */
  highestBid?: Bid;
  /**
   * auction ending timestamp
   *
   * @generated from protobuf field: int64 auction_ending_timestamp = 4
   */
  auctionEndingTimestamp: bigint;
  /**
   * last auction result
   *
   * @generated from protobuf field: injective.auction.v1beta1.LastAuctionResult last_auction_result = 5
   */
  lastAuctionResult?: LastAuctionResult;
}
/**
 * @generated MessageType for protobuf message injective.auction.v1beta1.GenesisState
 */
declare const GenesisState$2 = new GenesisState$Type();
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/injective/auction/v1beta1/query_pb.d.ts
/**
 * QueryAuctionParamsRequest is the response type for the Query/AuctionParams
 * RPC method.
 *
 * @generated from protobuf message injective.auction.v1beta1.QueryAuctionParamsResponse
 */
interface QueryAuctionParamsResponse {
  /**
   * @generated from protobuf field: injective.auction.v1beta1.Params params = 1
   */
  params?: Params$5;
}
/**
 * QueryCurrentAuctionBasketResponse is the response type for the
 * Query/CurrentAuctionBasket RPC method.
 *
 * @generated from protobuf message injective.auction.v1beta1.QueryCurrentAuctionBasketResponse
 */
interface QueryCurrentAuctionBasketResponse {
  /**
   * amount describes the amount put on auction
   *
   * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin amount = 1
   */
  amount: Coin$1[];
  /**
   * auctionRound describes current auction round
   *
   * @generated from protobuf field: uint64 auctionRound = 2
   */
  auctionRound: bigint;
  /**
   * auctionClosingTime describes auction close time for the round
   *
   * @generated from protobuf field: uint64 auctionClosingTime = 3
   */
  auctionClosingTime: bigint;
  /**
   * highestBidder describes highest bidder on current round
   *
   * @generated from protobuf field: string highestBidder = 4
   */
  highestBidder: string;
  /**
   * highestBidAmount describes highest bid amount on current round
   *
   * @generated from protobuf field: string highestBidAmount = 5
   */
  highestBidAmount: string;
}
/**
 * QueryModuleStateResponse is the response type for the
 * Query/AuctionModuleState RPC method.
 *
 * @generated from protobuf message injective.auction.v1beta1.QueryModuleStateResponse
 */
interface QueryModuleStateResponse$2 {
  /**
   * @generated from protobuf field: injective.auction.v1beta1.GenesisState state = 1
   */
  state?: GenesisState$2;
}
/**
 * @generated from protobuf message injective.auction.v1beta1.QueryLastAuctionResultResponse
 */
interface QueryLastAuctionResultResponse {
  /**
   * @generated from protobuf field: injective.auction.v1beta1.LastAuctionResult last_auction_result = 1
   */
  lastAuctionResult?: LastAuctionResult;
}
/**
 * @generated MessageType for protobuf message injective.auction.v1beta1.QueryAuctionParamsResponse
 */
declare const QueryAuctionParamsResponse = new QueryAuctionParamsResponse$Type();
/**
 * @generated MessageType for protobuf message injective.auction.v1beta1.QueryCurrentAuctionBasketResponse
 */
declare const QueryCurrentAuctionBasketResponse = new QueryCurrentAuctionBasketResponse$Type();
/**
 * @generated MessageType for protobuf message injective.auction.v1beta1.QueryModuleStateResponse
 */
declare const QueryModuleStateResponse$2 = new QueryModuleStateResponse$Type();
/**
 * @generated MessageType for protobuf message injective.auction.v1beta1.QueryLastAuctionResultResponse
 */
declare const QueryLastAuctionResultResponse = new QueryLastAuctionResultResponse$Type();
//#endregion
//#region src/client/chain/transformers/ChainGrpcAuctionTransformer.d.ts
/**
 * Transformer for Auction module gRPC responses
 * @category Chain Grpc Transformer
 */
declare class ChainGrpcAuctionTransformer {
  static grpcBidToBid(grpcBid: GrpcAuctionBid): AuctionBid;
  static grpcLastAuctionResultToLastAuctionResult(grpcLastAuctionResult: GrpcAuctionLastAuctionResult): AuctionLastAuctionResult;
  static moduleParamsResponseToModuleParams(response: QueryAuctionParamsResponse): AuctionModuleStateParams;
  static currentBasketResponseToCurrentBasket(response: QueryCurrentAuctionBasketResponse): AuctionCurrentBasket;
  static auctionModuleStateResponseToAuctionModuleState(response: QueryModuleStateResponse$2): AuctionModuleState;
  static lastAuctionResultResponseToLastAuctionResult(response: QueryLastAuctionResultResponse): AuctionLastAuctionResult | undefined;
}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/cosmos/staking/v1beta1/query_pb.d.ts
/**
 * QueryValidatorsResponse is response type for the Query/Validators RPC method
 *
 * @generated from protobuf message cosmos.staking.v1beta1.QueryValidatorsResponse
 */
interface QueryValidatorsResponse {
  /**
   * validators contains all the queried validators.
   *
   * @generated from protobuf field: repeated cosmos.staking.v1beta1.Validator validators = 1
   */
  validators: Validator$1[];
  /**
   * pagination defines the pagination in the response.
   *
   * @generated from protobuf field: cosmos.base.query.v1beta1.PageResponse pagination = 2
   */
  pagination?: PageResponse;
}
/**
 * QueryValidatorResponse is response type for the Query/Validator RPC method
 *
 * @generated from protobuf message cosmos.staking.v1beta1.QueryValidatorResponse
 */
interface QueryValidatorResponse {
  /**
   * validator defines the validator info.
   *
   * @generated from protobuf field: cosmos.staking.v1beta1.Validator validator = 1
   */
  validator?: Validator$1;
}
/**
 * QueryDelegationResponse is response type for the Query/Delegation RPC method.
 *
 * @generated from protobuf message cosmos.staking.v1beta1.QueryDelegationResponse
 */
interface QueryDelegationResponse {
  /**
   * delegation_responses defines the delegation info of a delegation.
   *
   * @generated from protobuf field: cosmos.staking.v1beta1.DelegationResponse delegation_response = 1
   */
  delegationResponse?: DelegationResponse;
}
/**
 * QueryDelegatorDelegationsResponse is response type for the
 * Query/DelegatorDelegations RPC method.
 *
 * @generated from protobuf message cosmos.staking.v1beta1.QueryDelegatorDelegationsResponse
 */
interface QueryDelegatorDelegationsResponse {
  /**
   * delegation_responses defines all the delegations' info of a delegator.
   *
   * @generated from protobuf field: repeated cosmos.staking.v1beta1.DelegationResponse delegation_responses = 1
   */
  delegationResponses: DelegationResponse[];
  /**
   * pagination defines the pagination in the response.
   *
   * @generated from protobuf field: cosmos.base.query.v1beta1.PageResponse pagination = 2
   */
  pagination?: PageResponse;
}
/**
 * QueryUnbondingDelegatorDelegationsResponse is response type for the
 * Query/UnbondingDelegatorDelegations RPC method.
 *
 * @generated from protobuf message cosmos.staking.v1beta1.QueryDelegatorUnbondingDelegationsResponse
 */
interface QueryDelegatorUnbondingDelegationsResponse {
  /**
   * @generated from protobuf field: repeated cosmos.staking.v1beta1.UnbondingDelegation unbonding_responses = 1
   */
  unbondingResponses: UnbondingDelegation[];
  /**
   * pagination defines the pagination in the response.
   *
   * @generated from protobuf field: cosmos.base.query.v1beta1.PageResponse pagination = 2
   */
  pagination?: PageResponse;
}
/**
 * QueryRedelegationsResponse is response type for the Query/Redelegations RPC
 * method.
 *
 * @generated from protobuf message cosmos.staking.v1beta1.QueryRedelegationsResponse
 */
interface QueryRedelegationsResponse {
  /**
   * @generated from protobuf field: repeated cosmos.staking.v1beta1.RedelegationResponse redelegation_responses = 1
   */
  redelegationResponses: RedelegationResponse[];
  /**
   * pagination defines the pagination in the response.
   *
   * @generated from protobuf field: cosmos.base.query.v1beta1.PageResponse pagination = 2
   */
  pagination?: PageResponse;
}
/**
 * QueryPoolResponse is response type for the Query/Pool RPC method.
 *
 * @generated from protobuf message cosmos.staking.v1beta1.QueryPoolResponse
 */
interface QueryPoolResponse {
  /**
   * pool defines the pool info.
   *
   * @generated from protobuf field: cosmos.staking.v1beta1.Pool pool = 1
   */
  pool?: Pool$1;
}
/**
 * QueryParamsResponse is response type for the Query/Params RPC method.
 *
 * @generated from protobuf message cosmos.staking.v1beta1.QueryParamsResponse
 */
interface QueryParamsResponse$3 {
  /**
   * params holds all the parameters of this module.
   *
   * @generated from protobuf field: cosmos.staking.v1beta1.Params params = 1
   */
  params?: Params$4;
}
/**
 * @generated MessageType for protobuf message cosmos.staking.v1beta1.QueryValidatorsResponse
 */
declare const QueryValidatorsResponse = new QueryValidatorsResponse$Type();
/**
 * @generated MessageType for protobuf message cosmos.staking.v1beta1.QueryValidatorResponse
 */
declare const QueryValidatorResponse = new QueryValidatorResponse$Type();
/**
 * @generated MessageType for protobuf message cosmos.staking.v1beta1.QueryDelegationResponse
 */
declare const QueryDelegationResponse = new QueryDelegationResponse$Type();
/**
 * @generated MessageType for protobuf message cosmos.staking.v1beta1.QueryDelegatorDelegationsResponse
 */
declare const QueryDelegatorDelegationsResponse = new QueryDelegatorDelegationsResponse$Type();
/**
 * @generated MessageType for protobuf message cosmos.staking.v1beta1.QueryDelegatorUnbondingDelegationsResponse
 */
declare const QueryDelegatorUnbondingDelegationsResponse = new QueryDelegatorUnbondingDelegationsResponse$Type();
/**
 * @generated MessageType for protobuf message cosmos.staking.v1beta1.QueryRedelegationsResponse
 */
declare const QueryRedelegationsResponse = new QueryRedelegationsResponse$Type();
/**
 * @generated MessageType for protobuf message cosmos.staking.v1beta1.QueryPoolResponse
 */
declare const QueryPoolResponse = new QueryPoolResponse$Type();
/**
 * @generated MessageType for protobuf message cosmos.staking.v1beta1.QueryParamsResponse
 */
declare const QueryParamsResponse$3 = new QueryParamsResponse$Type();
//#endregion
//#region src/client/chain/transformers/ChainGrpcStakingTransformer.d.ts
/**
 * @category Chain Grpc Transformer
 */
declare class ChainGrpcStakingTransformer {
  static moduleParamsResponseToModuleParams(response: QueryParamsResponse$3): StakingModuleParams;
  static validatorResponseToValidator(response: QueryValidatorResponse): Validator;
  static validatorsResponseToValidators(response: QueryValidatorsResponse): {
    validators: Validator[];
    pagination: Pagination;
  };
  static delegationResponseToDelegation(response: QueryDelegationResponse): Delegation;
  static delegationsResponseToDelegations(response: QueryDelegatorDelegationsResponse): {
    delegations: Delegation[];
    pagination: Pagination;
  };
  static unBondingDelegationsResponseToUnBondingDelegations(response: QueryDelegatorUnbondingDelegationsResponse): {
    unbondingDelegations: UnBondingDelegation[];
    pagination: Pagination;
  };
  static reDelegationsResponseToReDelegations(response: QueryRedelegationsResponse): {
    redelegations: ReDelegation[];
    pagination: Pagination;
  };
  static grpcValidatorToValidator(validator: GrpcValidator): Validator;
  static poolResponseToPool(response: QueryPoolResponse): Pool;
  static grpcValidatorDescriptionToDescription(description?: GrpcValidatorDescription): ValidatorDescription;
  static grpcValidatorCommissionToCommission(commission?: GrpcValidatorCommission): ValidatorCommission;
  static grpcValidatorStatusToStatus(status: number): "UnBonded" | "UnBonding" | "Bonded";
}
//#endregion
//#region src/client/chain/transformers/ChainGrpcExchangeTransformer.d.ts
/**
 * @category Chain Grpc Transformer
 */
declare class ChainGrpcExchangeTransformer {
  static moduleParamsResponseToParams(response: QueryExchangeParamsResponse): ExchangeModuleParams;
  static feeDiscountScheduleResponseToFeeDiscountSchedule(response: QueryFeeDiscountScheduleResponse): FeeDiscountSchedule;
  static tradingRewardsCampaignResponseToTradingRewardsCampaign(response: QueryTradeRewardCampaignResponse): TradeRewardCampaign;
  static feeDiscountAccountInfoResponseToFeeDiscountAccountInfo(response: QueryFeeDiscountAccountInfoResponse): FeeDiscountAccountInfo;
  static grpcFeeDiscountTierInfoToFeeDiscountTierInfo(info?: FeeDiscountTierInfo): FeeDiscountTierInfo | undefined;
  static grpcFeeDiscountTierTTLToFeeDiscountTierTTL(info?: GrpcFeeDiscountTierTTL): FeeDiscountTierTTL | undefined;
  static grpcPointsMultiplierToPointsMultiplier(point: GrpcPointsMultiplier): PointsMultiplier;
  static grpcTradingRewardCampaignBoostInfoToTradingRewardCampaignBoostInfo(info?: GrpcTradingRewardCampaignBoostInfo): TradingRewardCampaignBoostInfo | undefined;
  static grpcTradingRewardCampaignInfoToTradingRewardCampaignInfo(info?: GrpcTradingRewardCampaignInfo): TradingRewardCampaignInfo | undefined;
  static grpcCampaignRewardPoolToCampaignRewardPool(pool: GrpcCampaignRewardPool): CampaignRewardPool;
  static grpcPositionToPosition(position: GrpcChainPosition): ChainPosition;
  static positionsResponseToPositions(response: QueryPositionsResponse): ChainDerivativePosition[];
  static isOptedOutOfRewardsResponseToIsOptedOutOfRewards(response: QueryIsOptedOutOfRewardsResponse): IsOptedOutOfRewards;
  static activeStakeGrantResponseToActiveStakeGrant(response: QueryActiveStakeGrantResponse): {
    grant: ActiveGrant;
    effectiveGrant: EffectiveGrant;
  };
  static denomMinNotionalResponseToDenomMinNotional(response: QueryDenomMinNotionalResponse): string;
  static denomDecimalsResponseToDenomDecimals(response: QueryDenomDecimalsResponse): ChainDenomDecimal[];
  static denomMinNotionalsResponseToDenomMinNotionals(response: QueryDenomMinNotionalsResponse): ChainDenomMinNotional[];
  static spotMarketsResponseToSpotMarkets(response: QuerySpotMarketsResponse): SpotMarket[];
  static grpcSpotMarketToSpotMarket(market: GrpcChainSpotMarket): SpotMarket;
  static fullSpotMarketsResponseToSpotMarkets(response: QueryFullSpotMarketsResponse): SpotMarket[];
  static grpcFullSpotMarketToSpotMarket(market: GrpcChainFullSpotMarket): SpotMarket;
  static fullDerivativeMarketsResponseToDerivativeMarkets(response: QueryDerivativeMarketsResponse): DerivativeMarket[];
  static grpcFullDerivativeMarketToDerivativeMarket(market: GrpcChainFullDerivativeMarket): DerivativeMarket;
}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/injective/permissions/v1beta1/genesis_pb.d.ts
/**
 * GenesisState defines the permissions module's genesis state.
 *
 * @generated from protobuf message injective.permissions.v1beta1.GenesisState
 */
interface GenesisState$1 {
  /**
   * params defines the parameters of the module
   *
   * @generated from protobuf field: injective.permissions.v1beta1.Params params = 1
   */
  params?: Params$3;
  /**
   * namespaces defines the namespaces of the module
   *
   * @generated from protobuf field: repeated injective.permissions.v1beta1.Namespace namespaces = 2
   */
  namespaces: Namespace[];
  /**
   * vouchers defines the vouchers of the module
   *
   * @generated from protobuf field: repeated injective.permissions.v1beta1.AddressVoucher vouchers = 3
   */
  vouchers: AddressVoucher[];
}
/**
 * @generated MessageType for protobuf message injective.permissions.v1beta1.GenesisState
 */
declare const GenesisState$1 = new GenesisState$Type();
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/injective/permissions/v1beta1/query_pb.d.ts
/**
 * QueryParamsResponse is the response type for the Query/Params RPC method.
 *
 * @generated from protobuf message injective.permissions.v1beta1.QueryParamsResponse
 */
interface QueryParamsResponse$2 {
  /**
   * params defines the parameters of the module.
   *
   * @generated from protobuf field: injective.permissions.v1beta1.Params params = 1
   */
  params?: Params$3;
}
/**
 * QueryNamespaceDenomsResponse is the response type for the
 * Query/NamespaceDenoms RPC method.
 *
 * @generated from protobuf message injective.permissions.v1beta1.QueryNamespaceDenomsResponse
 */
interface QueryNamespaceDenomsResponse {
  /**
   * List of denoms
   *
   * @generated from protobuf field: repeated string denoms = 1
   */
  denoms: string[];
}
/**
 * QueryNamespacesResponse is the response type for the Query/Namespaces
 * RPC method.
 *
 * @generated from protobuf message injective.permissions.v1beta1.QueryNamespacesResponse
 */
interface QueryNamespacesResponse {
  /**
   * List of namespaces
   *
   * @generated from protobuf field: repeated injective.permissions.v1beta1.Namespace namespaces = 1
   */
  namespaces: Namespace[];
}
/**
 * QueryNamespaceResponse is the response type for the
 * Query/NamespaceByDenom RPC method.
 *
 * @generated from protobuf message injective.permissions.v1beta1.QueryNamespaceResponse
 */
interface QueryNamespaceResponse {
  /**
   * The namespace details
   *
   * @generated from protobuf field: injective.permissions.v1beta1.Namespace namespace = 1
   */
  namespace?: Namespace;
}
/**
 * QueryAddressesByRoleResponse is the response type for the
 * Query/AddressesByRole RPC method.
 *
 * @generated from protobuf message injective.permissions.v1beta1.QueryActorsByRoleResponse
 */
interface QueryActorsByRoleResponse {
  /**
   * List of actors' Injective addresses
   *
   * @generated from protobuf field: repeated string actors = 1
   */
  actors: string[];
}
/**
 * QueryRolesByActorResponse is the response type for the
 * Query/RolesByActor RPC method.
 *
 * @generated from protobuf message injective.permissions.v1beta1.QueryRolesByActorResponse
 */
interface QueryRolesByActorResponse {
  /**
   * List of roles
   *
   * @generated from protobuf field: repeated string roles = 1
   */
  roles: string[];
}
/**
 * QueryRoleManagersResponse is the response type for the
 * Query/RoleManagers RPC method.
 *
 * @generated from protobuf message injective.permissions.v1beta1.QueryRoleManagersResponse
 */
interface QueryRoleManagersResponse {
  /**
   * List of role managers
   *
   * @generated from protobuf field: repeated injective.permissions.v1beta1.RoleManager role_managers = 1
   */
  roleManagers: RoleManager[];
}
/**
 * QueryRoleManagerResponse is the response type for the
 * Query/RoleManager RPC method.
 *
 * @generated from protobuf message injective.permissions.v1beta1.QueryRoleManagerResponse
 */
interface QueryRoleManagerResponse {
  /**
   * The role manager details
   *
   * @generated from protobuf field: injective.permissions.v1beta1.RoleManager role_manager = 1
   */
  roleManager?: RoleManager;
}
/**
 * QueryRoleManagerResponse is the response type for the
 * Query/RoleManager RPC method.
 *
 * @generated from protobuf message injective.permissions.v1beta1.QueryPolicyStatusesResponse
 */
interface QueryPolicyStatusesResponse {
  /**
   * List of policy statuses
   *
   * @generated from protobuf field: repeated injective.permissions.v1beta1.PolicyStatus policy_statuses = 1
   */
  policyStatuses: PolicyStatus[];
}
/**
 * QueryPolicyManagerCapabilitiesResponse is the response type for the
 * Query/PolicyManagerCapabilities RPC method.
 *
 * @generated from protobuf message injective.permissions.v1beta1.QueryPolicyManagerCapabilitiesResponse
 */
interface QueryPolicyManagerCapabilitiesResponse {
  /**
   * List of policy manager capabilities
   *
   * @generated from protobuf field: repeated injective.permissions.v1beta1.PolicyManagerCapability policy_manager_capabilities = 1
   */
  policyManagerCapabilities: PolicyManagerCapability[];
}
/**
 * @generated from protobuf message injective.permissions.v1beta1.QueryVouchersResponse
 */
interface QueryVouchersResponse {
  /**
   * List of vouchers
   *
   * @generated from protobuf field: repeated injective.permissions.v1beta1.AddressVoucher vouchers = 1
   */
  vouchers: AddressVoucher[];
}
/**
 * @generated from protobuf message injective.permissions.v1beta1.QueryVoucherResponse
 */
interface QueryVoucherResponse {
  /**
   * The voucher amount
   *
   * @generated from protobuf field: cosmos.base.v1beta1.Coin voucher = 1
   */
  voucher?: Coin$1;
}
/**
 * QueryModuleStateResponse is the response type for the
 * Query/PermissionsModuleState RPC method.
 *
 * @generated from protobuf message injective.permissions.v1beta1.QueryModuleStateResponse
 */
interface QueryModuleStateResponse$1 {
  /**
   * The module state
   *
   * @generated from protobuf field: injective.permissions.v1beta1.GenesisState state = 1
   */
  state?: GenesisState$1;
}
/**
 * @generated MessageType for protobuf message injective.permissions.v1beta1.QueryParamsResponse
 */
declare const QueryParamsResponse$2 = new QueryParamsResponse$Type();
/**
 * @generated MessageType for protobuf message injective.permissions.v1beta1.QueryNamespaceDenomsResponse
 */
declare const QueryNamespaceDenomsResponse = new QueryNamespaceDenomsResponse$Type();
/**
 * @generated MessageType for protobuf message injective.permissions.v1beta1.QueryNamespacesResponse
 */
declare const QueryNamespacesResponse = new QueryNamespacesResponse$Type();
/**
 * @generated MessageType for protobuf message injective.permissions.v1beta1.QueryNamespaceResponse
 */
declare const QueryNamespaceResponse = new QueryNamespaceResponse$Type();
/**
 * @generated MessageType for protobuf message injective.permissions.v1beta1.QueryActorsByRoleResponse
 */
declare const QueryActorsByRoleResponse = new QueryActorsByRoleResponse$Type();
/**
 * @generated MessageType for protobuf message injective.permissions.v1beta1.QueryRolesByActorResponse
 */
declare const QueryRolesByActorResponse = new QueryRolesByActorResponse$Type();
/**
 * @generated MessageType for protobuf message injective.permissions.v1beta1.QueryRoleManagersResponse
 */
declare const QueryRoleManagersResponse = new QueryRoleManagersResponse$Type();
/**
 * @generated MessageType for protobuf message injective.permissions.v1beta1.QueryRoleManagerResponse
 */
declare const QueryRoleManagerResponse = new QueryRoleManagerResponse$Type();
/**
 * @generated MessageType for protobuf message injective.permissions.v1beta1.QueryPolicyStatusesResponse
 */
declare const QueryPolicyStatusesResponse = new QueryPolicyStatusesResponse$Type();
/**
 * @generated MessageType for protobuf message injective.permissions.v1beta1.QueryPolicyManagerCapabilitiesResponse
 */
declare const QueryPolicyManagerCapabilitiesResponse = new QueryPolicyManagerCapabilitiesResponse$Type();
/**
 * @generated MessageType for protobuf message injective.permissions.v1beta1.QueryVouchersResponse
 */
declare const QueryVouchersResponse = new QueryVouchersResponse$Type();
/**
 * @generated MessageType for protobuf message injective.permissions.v1beta1.QueryVoucherResponse
 */
declare const QueryVoucherResponse = new QueryVoucherResponse$Type();
/**
 * @generated MessageType for protobuf message injective.permissions.v1beta1.QueryModuleStateResponse
 */
declare const QueryModuleStateResponse$1 = new QueryModuleStateResponse$Type();
//#endregion
//#region src/client/chain/transformers/ChainGrpcPermissionsTransformer.d.ts
/**
 * @category Chain Grpc Transformer
 */
declare class ChainGrpcPermissionsTransformer {
  static grpcRoleToRole(grpcRole: GrpcPermissionRole): PermissionRole;
  static grpcActorRolesToActorRoles(grpcActorRoles: GrpcPermissionActorRoles): PermissionActorRoles;
  static grpcRoleManagerToRoleManager(grpcRoleManager: GrpcPermissionRoleManager): PermissionRoleManager;
  static grpcPolicyStatusToPolicyStatus(grpcPolicyStatus: GrpcPermissionPolicyStatus): PermissionPolicyStatus;
  static grpcPolicyManagerCapabilityToPolicyManagerCapability(grpcPolicyManagerCapability: GrpcPermissionPolicyStatusManagerCapability): PermissionPolicyManagerCapability;
  static grpcAddressVoucherToAddressVoucher(grpcAddressVoucher: GrpcPermissionAddressVoucher): PermissionAddressVoucher;
  static grpcNamespaceToNamespace(grpcNamespace: GrpcPermissionNamespace): PermissionNamespace;
  static moduleParamsResponseToModuleParams(response: QueryParamsResponse$2): PermissionsModuleParams;
  static nameSpaceDenomsResponseToNameSpaceDenoms(response: QueryNamespaceDenomsResponse): string[];
  static namespaceResponseToNamespaces(response: QueryNamespaceResponse): PermissionNamespace | undefined;
  static namespacesResponseToNamespaces(response: QueryNamespacesResponse): void[];
  static actorsByRoleResponseToActorsByRole(response: QueryActorsByRoleResponse): {
    roles: string;
  }[];
  static rolesByActorResponseToRolesByActor(response: QueryRolesByActorResponse): {
    roles: string;
  }[];
  static roleManagerResponseToRoleManager(response: QueryRoleManagerResponse): PermissionRoleManager | undefined;
  static roleManagersResponseToRoleManagers(response: QueryRoleManagersResponse): PermissionRoleManager[];
  static policyStatusesResponseToPolicyStatuses(response: QueryPolicyStatusesResponse): PermissionPolicyStatus[];
  static policyManagerCapabilitiesResponseToPolicyManagerCapabilities(response: QueryPolicyManagerCapabilitiesResponse): PermissionPolicyManagerCapability[];
  static voucherResponseToVoucher(response: QueryVoucherResponse): Coin$8 | undefined;
  static vouchersResponseToVouchers(response: QueryVouchersResponse): PermissionAddressVoucher[];
  static moduleStateResponseToModuleState(response: QueryModuleStateResponse$1): {
    params: PermissionsModuleParams;
    namespaces: PermissionNamespace[];
    vouchers: PermissionAddressVoucher[];
  } | undefined;
}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/cosmos/distribution/v1beta1/query_pb.d.ts
/**
 * QueryParamsResponse is the response type for the Query/Params RPC method.
 *
 * @generated from protobuf message cosmos.distribution.v1beta1.QueryParamsResponse
 */
interface QueryParamsResponse$1 {
  /**
   * params defines the parameters of the module.
   *
   * @generated from protobuf field: cosmos.distribution.v1beta1.Params params = 1
   */
  params?: Params$2;
}
/**
 * QueryDelegationRewardsResponse is the response type for the
 * Query/DelegationRewards RPC method.
 *
 * @generated from protobuf message cosmos.distribution.v1beta1.QueryDelegationRewardsResponse
 */
interface QueryDelegationRewardsResponse {
  /**
   * rewards defines the rewards accrued by a delegation.
   *
   * @generated from protobuf field: repeated cosmos.base.v1beta1.DecCoin rewards = 1
   */
  rewards: DecCoin[];
}
/**
 * QueryDelegationTotalRewardsResponse is the response type for the
 * Query/DelegationTotalRewards RPC method.
 *
 * @generated from protobuf message cosmos.distribution.v1beta1.QueryDelegationTotalRewardsResponse
 */
interface QueryDelegationTotalRewardsResponse {
  /**
   * rewards defines all the rewards accrued by a delegator.
   *
   * @generated from protobuf field: repeated cosmos.distribution.v1beta1.DelegationDelegatorReward rewards = 1
   */
  rewards: DelegationDelegatorReward[];
  /**
   * total defines the sum of all the rewards.
   *
   * @generated from protobuf field: repeated cosmos.base.v1beta1.DecCoin total = 2
   */
  total: DecCoin[];
}
/**
 * @generated MessageType for protobuf message cosmos.distribution.v1beta1.QueryParamsResponse
 */
declare const QueryParamsResponse$1 = new QueryParamsResponse$Type();
/**
 * @generated MessageType for protobuf message cosmos.distribution.v1beta1.QueryDelegationRewardsResponse
 */
declare const QueryDelegationRewardsResponse = new QueryDelegationRewardsResponse$Type();
/**
 * @generated MessageType for protobuf message cosmos.distribution.v1beta1.QueryDelegationTotalRewardsResponse
 */
declare const QueryDelegationTotalRewardsResponse = new QueryDelegationTotalRewardsResponse$Type();
//#endregion
//#region src/client/chain/transformers/ChainGrpcDistributionTransformer.d.ts
/**
 * @category Chain Grpc Transformer
 */
declare class ChainGrpcDistributionTransformer {
  static moduleParamsResponseToModuleParams(response: QueryParamsResponse$1): DistributionModuleParams;
  static delegationRewardResponseToReward(response: QueryDelegationRewardsResponse): Coin[];
  static totalDelegationRewardResponseToTotalReward(response: QueryDelegationTotalRewardsResponse): ValidatorRewards[];
}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/injective/tokenfactory/v1beta1/authorityMetadata_pb.d.ts
/**
 * DenomAuthorityMetadata specifies metadata for addresses that have specific
 * capabilities over a token factory denom. Right now there is only one Admin
 * permission, but is planned to be extended to the future.
 *
 * @generated from protobuf message injective.tokenfactory.v1beta1.DenomAuthorityMetadata
 */
interface DenomAuthorityMetadata {
  /**
   * Can be empty for no admin, or a valid injective address
   *
   * @generated from protobuf field: string admin = 1
   */
  admin: string;
  /**
   * true if the admin can burn tokens from other addresses
   *
   * @generated from protobuf field: bool admin_burn_allowed = 2
   */
  adminBurnAllowed: boolean;
}
/**
 * @generated MessageType for protobuf message injective.tokenfactory.v1beta1.DenomAuthorityMetadata
 */
declare const DenomAuthorityMetadata = new DenomAuthorityMetadata$Type();
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/injective/tokenfactory/v1beta1/genesis_pb.d.ts
/**
 * GenesisState defines the tokenfactory module's genesis state.
 *
 * @generated from protobuf message injective.tokenfactory.v1beta1.GenesisState
 */
interface GenesisState {
  /**
   * params defines the parameters of the module.
   *
   * @generated from protobuf field: injective.tokenfactory.v1beta1.Params params = 1
   */
  params?: Params$1;
  /**
   * @generated from protobuf field: repeated injective.tokenfactory.v1beta1.GenesisDenom factory_denoms = 2
   */
  factoryDenoms: GenesisDenom[];
}
/**
 * GenesisDenom defines a tokenfactory denom that is defined within genesis
 * state. The structure contains DenomAuthorityMetadata which defines the
 * denom's admin.
 *
 * @generated from protobuf message injective.tokenfactory.v1beta1.GenesisDenom
 */
interface GenesisDenom {
  /**
   * The denom
   *
   * @generated from protobuf field: string denom = 1
   */
  denom: string;
  /**
   * The authority metadata
   *
   * @generated from protobuf field: injective.tokenfactory.v1beta1.DenomAuthorityMetadata authority_metadata = 2
   */
  authorityMetadata?: DenomAuthorityMetadata;
  /**
   * The name
   *
   * @generated from protobuf field: string name = 3
   */
  name: string;
  /**
   * The symbol
   *
   * @generated from protobuf field: string symbol = 4
   */
  symbol: string;
  /**
   * The number of decimals
   *
   * @generated from protobuf field: uint32 decimals = 5
   */
  decimals: number;
}
/**
 * @generated MessageType for protobuf message injective.tokenfactory.v1beta1.GenesisState
 */
declare const GenesisState = new GenesisState$Type();
/**
 * @generated MessageType for protobuf message injective.tokenfactory.v1beta1.GenesisDenom
 */
declare const GenesisDenom = new GenesisDenom$Type();
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/injective/tokenfactory/v1beta1/query_pb.d.ts
/**
 * QueryParamsResponse is the response type for the Query/Params RPC method.
 *
 * @generated from protobuf message injective.tokenfactory.v1beta1.QueryParamsResponse
 */
interface QueryParamsResponse {
  /**
   * params defines the parameters of the module.
   *
   * @generated from protobuf field: injective.tokenfactory.v1beta1.Params params = 1
   */
  params?: Params$1;
}
/**
 * QueryDenomAuthorityMetadataResponse defines the response structure for the
 * DenomAuthorityMetadata gRPC query.
 *
 * @generated from protobuf message injective.tokenfactory.v1beta1.QueryDenomAuthorityMetadataResponse
 */
interface QueryDenomAuthorityMetadataResponse {
  /**
   * The authority metadata
   *
   * @generated from protobuf field: injective.tokenfactory.v1beta1.DenomAuthorityMetadata authority_metadata = 1
   */
  authorityMetadata?: DenomAuthorityMetadata;
}
/**
 * QueryDenomsFromCreatorRequest defines the response structure for the
 * DenomsFromCreator gRPC query.
 *
 * @generated from protobuf message injective.tokenfactory.v1beta1.QueryDenomsFromCreatorResponse
 */
interface QueryDenomsFromCreatorResponse {
  /**
   * The list of denoms
   *
   * @generated from protobuf field: repeated string denoms = 1
   */
  denoms: string[];
}
/**
 * QueryModuleStateResponse is the response type for the
 * Query/TokenfactoryModuleState RPC method.
 *
 * @generated from protobuf message injective.tokenfactory.v1beta1.QueryModuleStateResponse
 */
interface QueryModuleStateResponse {
  /**
   * The module state
   *
   * @generated from protobuf field: injective.tokenfactory.v1beta1.GenesisState state = 1
   */
  state?: GenesisState;
}
/**
 * @generated MessageType for protobuf message injective.tokenfactory.v1beta1.QueryParamsResponse
 */
declare const QueryParamsResponse = new QueryParamsResponse$Type();
/**
 * @generated MessageType for protobuf message injective.tokenfactory.v1beta1.QueryDenomAuthorityMetadataResponse
 */
declare const QueryDenomAuthorityMetadataResponse = new QueryDenomAuthorityMetadataResponse$Type();
/**
 * @generated MessageType for protobuf message injective.tokenfactory.v1beta1.QueryDenomsFromCreatorResponse
 */
declare const QueryDenomsFromCreatorResponse = new QueryDenomsFromCreatorResponse$Type();
/**
 * @generated MessageType for protobuf message injective.tokenfactory.v1beta1.QueryModuleStateResponse
 */
declare const QueryModuleStateResponse = new QueryModuleStateResponse$Type();
//#endregion
//#region src/client/chain/transformers/ChainGrpcTokenFactoryTransformer.d.ts
/**
 * @category Chain Grpc Transformer
 */
declare class ChainGrpcTokenFactoryTransformer {
  static moduleParamsResponseToModuleParams(response: QueryParamsResponse): TokenFactoryModuleParams;
  static moduleStateResponseToModuleState(response: QueryModuleStateResponse): TokenFactoryModuleState;
  static denomsCreatorResponseToDenomsString(response: QueryDenomsFromCreatorResponse): string[];
  static authorityMetadataResponseToAuthorityMetadata(response: QueryDenomAuthorityMetadataResponse): AuthorityMetadata;
}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/injective/insurance/v1beta1/query_pb.d.ts
/**
 * QueryInsuranceParamsRequest is the response type for the
 * Query/InsuranceParams RPC method.
 *
 * @generated from protobuf message injective.insurance.v1beta1.QueryInsuranceParamsResponse
 */
interface QueryInsuranceParamsResponse {
  /**
   * @generated from protobuf field: injective.insurance.v1beta1.Params params = 1
   */
  params?: Params;
}
/**
 * QueryInsuranceFundResponse is the response type for the Query/InsuranceFund
 * RPC method.
 *
 * @generated from protobuf message injective.insurance.v1beta1.QueryInsuranceFundResponse
 */
interface QueryInsuranceFundResponse {
  /**
   * @generated from protobuf field: injective.insurance.v1beta1.InsuranceFund fund = 1
   */
  fund?: InsuranceFund$1;
}
/**
 * QueryInsuranceFundsResponse is the response type for the Query/InsuranceFunds
 * RPC method.
 *
 * @generated from protobuf message injective.insurance.v1beta1.QueryInsuranceFundsResponse
 */
interface QueryInsuranceFundsResponse {
  /**
   * @generated from protobuf field: repeated injective.insurance.v1beta1.InsuranceFund funds = 1
   */
  funds: InsuranceFund$1[];
}
/**
 * QueryEstimatedRedemptionsResponse is the response type for the
 * Query/EstimatedRedemptions RPC method.
 *
 * @generated from protobuf message injective.insurance.v1beta1.QueryEstimatedRedemptionsResponse
 */
interface QueryEstimatedRedemptionsResponse {
  /**
   * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin amount = 1
   */
  amount: Coin$1[];
}
/**
 * QueryPendingRedemptionsResponse is the response type for the
 * Query/PendingRedemptions RPC method.
 *
 * @generated from protobuf message injective.insurance.v1beta1.QueryPendingRedemptionsResponse
 */
interface QueryPendingRedemptionsResponse {
  /**
   * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin amount = 1
   */
  amount: Coin$1[];
}
/**
 * @generated MessageType for protobuf message injective.insurance.v1beta1.QueryInsuranceParamsResponse
 */
declare const QueryInsuranceParamsResponse = new QueryInsuranceParamsResponse$Type();
/**
 * @generated MessageType for protobuf message injective.insurance.v1beta1.QueryInsuranceFundResponse
 */
declare const QueryInsuranceFundResponse = new QueryInsuranceFundResponse$Type();
/**
 * @generated MessageType for protobuf message injective.insurance.v1beta1.QueryInsuranceFundsResponse
 */
declare const QueryInsuranceFundsResponse = new QueryInsuranceFundsResponse$Type();
/**
 * @generated MessageType for protobuf message injective.insurance.v1beta1.QueryEstimatedRedemptionsResponse
 */
declare const QueryEstimatedRedemptionsResponse = new QueryEstimatedRedemptionsResponse$Type();
/**
 * @generated MessageType for protobuf message injective.insurance.v1beta1.QueryPendingRedemptionsResponse
 */
declare const QueryPendingRedemptionsResponse = new QueryPendingRedemptionsResponse$Type();
//#endregion
//#region src/client/chain/transformers/ChainGrpcInsuranceFundTransformer.d.ts
/**
 * @category Chain Grpc Transformer
 */
declare class ChainGrpcInsuranceFundTransformer {
  static moduleParamsResponseToModuleParams(response: QueryInsuranceParamsResponse): InsuranceModuleParams;
  static grpcInsuranceFundToInsuranceFund(grpcFund: GrpcInsuranceFund): InsuranceFund;
  static insuranceFundResponseToInsuranceFund(response: QueryInsuranceFundResponse): InsuranceFund;
  static insuranceFundsResponseToInsuranceFunds(response: QueryInsuranceFundsResponse): InsuranceFund[];
  static redemptionsResponseToRedemptions(response: QueryEstimatedRedemptionsResponse): {
    amount: string;
    denom: string;
  }[];
  static estimatedRedemptionsResponseToEstimatedRedemptions(response: QueryPendingRedemptionsResponse): {
    amount: string;
    denom: string;
  }[];
}
//#endregion
export { DerivativeOrdersStreamCallbackV2 as $, MsgLiquidatePosition as $_, GrpcAuctionContract as $a, grpcPagingToPaging as $c, SIGN_EIP712_V2 as $d, TxClientSimulateResponse as $f, ContractCodeHistoryOperationTypeMap as $g, GrpcDenomDecimals as $h, MegaVaultSubscriptionStatus as $i, derivativePriceFromChainPriceToFixed as $l, CreateSpotMarketOrderAuthz as $m, IndexerModule as $n, GrpcGasFee as $o, AuctionParams as $p, GrpcExpiryFuturesMarketInfo as $r, GrpcMitoStakingGauge as $s, IndexerGrpcAccountStream as $t, publicKeyToAddress as $u, ChainGrpcAuctionApi as A, MsgBatchCancelDerivativeOrders as A_, GrpcPnlLeaderboard as Aa, MitoStakeToSubscription as Ac, PublicKey as Ad, getTxRawFromTxRawOrDirectSignResponse as Af, GrpcReDelegation as Ag, GrpcEvmBlobScheduleConfig as Ah, GrpcMegaVaultRedemption as Ai, getEthereumAddress as Al, PermissionVoucher as Am, IndexerGrpcExplorerTransformer as An, BankTransfer as Ao, TokenFactoryModuleState as Ap, ValidatorUptimeFromExplorerApiResponse as Ar, GrpcTradingReward as As, StreamManager as At, hexToNumber as Au, MsgSubmitProposalExpiryFuturesMarketLaunch as Av, ChainGrpcAuthApi as B, MsgBatchCancelSpotOrders as B_, VolLeaderboard as Ba, MitoVestingConfigMap as Bc, getEip712FeeV2 as Bd, TxInfoResponse as Bf, Pool as Bg, ExchangeModuleParams as Bh, MegaVaultAprStats as Bi, amountToCosmosSdkDecAmount as Bl, Params$6 as Bm, IndexerRestDerivativesChronosApi as Bn, EventLogEvent as Bo, AccountsResponse as Bp, DerivativeOrderHistory as Br, GrpcMitoHolders as Bs, DerivativePositionsV2StreamCallback as Bt, sortObjectByKeysWithReduce as Bu, MsgBid as Bv, ChainGrpcInsuranceFundApi as C, Vote as C_, AccountStats as Ca, MitoLeaderboardEpoch as Cc, getGenericAuthorizationFromMessageType as Cd, createTransaction as Cf, TradingRewardCampaignBoostInfo as Cg, PubKey$1 as Ch, GrpcMegaVaultIncentives as Ci, uint8ArrayToBase64 as Cl, PermissionParams as Cm, IndexerArchiverStreamTransformer as Cn, OrderbookWithSequence as Co, ChainModule as Cp, ContractExplorerApiResponse as Cr, TradingStrategy as Cs, VaultHolderSubscriptionStreamCallbackV2 as Ct, spotQuantityToChainQuantity as Cu, MsgMultiSend as Cv, ChainGrpcTendermintApi as D, MsgCreateBinaryOptionsLimitOrder as D_, GrpcHistoricalRPNL as Da, MitoPagination as Dc, MsgBroadcasterWithPk as Dd, createTransactionFromMsg as Df, GrpcDelegation as Dg, EvmLog as Dh, GrpcMegaVaultOperatorRedemptionBucket as Di, getAddressFromInjectiveAddress as Dl, PermissionRoleActors as Dm, IndexerRestExplorerTransformer as Dn, AccessType as Do, AuthorityMetadata as Dp, ExplorerBlockApiResponse as Dr, GrpcSubaccountBalanceTransfer as Ds, SpotOrderbookUpdateStreamCallbackV2 as Dt, bigIntToString as Du, MsgExec as Dv, ChainGrpcPermissionsApi as E, WeightedVoteOption as E_, GrpcHistoricalBalance as Ea, MitoMissionLeaderboardEntry as Ec, ExecArgNeptuneDeposit as Ed, createTransactionForAddressAndMsg as Ef, Delegation as Eg, EvmChainConfig as Eh, GrpcMegaVaultOperator as Ei, addHexPrefix as El, PermissionRole as Em, IndexerAccountStreamTransformer as En, Route as Eo, NodeInfoRestResponse as Ep, ExplorerApiResponseWithPagination as Er, GrpcSubaccountBalance as Es, SpotOrderHistoryStreamCallbackV2 as Et, bigIntToNumber as Eu, MsgTransfer as Ev, ChainGrpcPeggyApi as F, MsgCancelBinaryOptionsOrder as F_, HistoricalVolumes as Fa, MitoSubscription as Fc, getDefaultEip712Types as Fd, RestTx as Ff, GrpcUnbondingDelegationEntry as Fg, ChainDenomDecimal as Fh, GrpcMegaVaultVaultStats as Fi, removeHexPrefix as Fl, GrpcTxFeesParams as Fm, IndexerGrpcOracleTransformer as Fn, ContractTransaction as Fo, ValidatorRewards as Fp, DerivativeLimitOrder as Fr, TradingReward as Fs, DerivativeOrderHistoryStreamCallback as Ft, isServerSide as Fu, MsgSubmitGenericProposal as Fv, createStreamSubscriptionV2 as G, MsgCreateInsuranceFund as G_, AuctionCoinPrices as Ga, IndexerGrpcTransactionApi as Gc, numberTypeToReflectionNumberType as Gd, CreateTransactionArgs as Gf, ValidatorCommission as Gg, FeeDiscountTierTTL as Gh, MegaVaultOperator as Gi, denomAmountToChainDenomAmount as Gl, BatchCancelSpotOrdersAuthz as Gm, IndexerGrpcAccountPortfolioApi as Gn, ExplorerTransactionV2 as Go, AuctionEventAuctionResult as Gp, FundingRate as Gr, GrpcMitoIDOSubscription as Gs, IndexerGrpcExplorerStream as Gt, decompressPubKey as Gu, ChainGrpcIbcApi as H, MsgCancelPostOnlyModeV2 as H_, AccountAuctionV2 as Ha, IndexerGrpcAuctionApi as Hc, getEipTxDetails as Hd, TxResultResponse as Hf, StakingModuleParams as Hg, FeeDiscountAccountInfo as Hh, MegaVaultHistoricalTVL as Hi, denomAmountFromChainDenomAmount as Hl, GrpcPeggyParams as Hm, IndexerRestSpotChronosApi as Hn, ExplorerCW20BalanceWithToken as Ho, CosmosAccountRestResponse as Hp, ExpiryFuturesMarket as Hr, GrpcMitoIDOClaimedCoins as Hs, IndexerGrpcDerivativesStream as Ht, TypedDataUtilsHashStruct as Hu, MsgVote as Hv, ChainGrpcAuthZApi as I, MsgInstantSpotMarketLaunch as I_, Holder as Ia, MitoTokenInfo as Ic, getDefaultEip712TypesV2 as Id, RestTxBody as If, GrpcValidator as Ig, ChainDenomMinNotional as Ih, GrpcMegaVaultVolatility as Ii, getDerivativeMarketDecimals as Il, TxFeesEipBaseFee as Im, IndexerCampaignTransformer as In, ContractTransactionWithMessages as Io, BalancesResponse as Ip, DerivativeLimitOrderParams as Ir, TransferType as Is, DerivativeOrderbookUpdateStreamCallback as It, objectToJson as Iu, MsgSubmitTextProposal as Iv, IndexerGrpcAccountPortfolioStreamV2 as J, MsgUpdateSpotMarketV2 as J_, AuctionsStats as Ja, IndexerGrpcMetaApi as Jc, stringTypeToReflectionStringType as Jd, MsgArg as Jf, CodeInfoResponse as Jg, GrpcChainDerivativePosition as Jh, MegaVaultPnlStats as Ji, derivativeMarginFromChainMargin as Jl, CancelDerivativeOrderAuthz as Jm, IndexerGrpcReferralApi as Jn, ExplorerValidatorDescription as Jo, AuctionLastAuctionResult as Jp, GrpcDerivativeMarketInfo as Jr, GrpcMitoLeaderboardEpoch as Js, SpotAverageEntriesStreamCallback as Jt, messageHash as Ju, StreamManagerV2 as K, MsgFundCommunityPool as K_, AuctionContract as Ka, IndexerGrpcOracleApi as Kc, objectKeysToEip712Types as Kd, CreateTransactionResult as Kf, ValidatorDescription as Kg, GrpcCampaignRewardPool as Kh, MegaVaultOperatorRedemptionBucket as Ki, denomAmountToChainDenomAmountToFixed as Kl, BatchCreateDerivativeLimitOrdersAuthz as Km, IndexerGrpcDerivativesApi as Kn, ExplorerTxsV2Response as Ko, AuctionEventAuctionStart as Kp, GrpcBinaryOptionsMarketInfo as Kr, GrpcMitoIDOSubscriptionActivity as Ks, TransactionsStreamCallback as Kt, domainHash as Ku, ChainGrpcWasmApi as L, MsgIncreasePositionMargin as L_, LeaderboardRow as La, MitoTransfer as Lc, getEip712Domain as Ld, RestTxLog as Lf, GrpcValidatorCommission as Lg, ChainDerivativePosition as Lh, GrpcMegaVaultVolatilityStats as Li, getDerivativeMarketTensMultiplier as Ll, TxFeesModuleStateParams as Lm, IndexerGrpcSpotTransformer as Ln, CosmWasmChecksum as Lo, DenomBalance as Lp, DerivativeMarket as Lr, GrpcMitoChanges as Ls, DerivativeOrderbookV2StreamCallback as Lt, protoObjectToJson as Lu, MsgDeposit$1 as Lv, ChainGrpcOracleApi as M, MsgWithdrawDelegatorReward as M_, GrpcVolLeaderboard as Ma, MitoStakingPool as Mc, MsgDecoder as Md, BroadcastModeKeplr as Mf, GrpcReDelegationResponse as Mg, GrpcEvmLog as Mh, GrpcMegaVaultTargetApr as Mi, getInjectiveAddressFromSubaccountId as Ml, GrpcOracleParams as Mm, IndexerGrpcAuctionTransformer as Mn, BlockWithTxs as Mo, GrpcDecCoin as Mp, BaseDerivativeMarket as Mr, SubaccountDeposit as Ms, AccountPortfolioStreamCallback as Mt, isJsonString as Mu, MsgSubmitProposalSpotMarketParamUpdate as Mv, ChainGrpcErc20Api as N, MsgCancelUnbondingDelegation as N_, HistoricalBalance as Na, MitoStakingReward as Nc, getEip712TypedData as Nd, RestAuthInfo as Nf, GrpcStakingParams as Ng, GrpcEvmParams as Nh, GrpcMegaVaultUnrealizedPnl as Ni, getSubaccountId as Nl, OracleModuleParams as Nm, IndexerGrpcAccountTransformer as Nn, CW20Message as No, GrpcDelegationDelegatorReward as Np, BatchDerivativeOrderCancelParams as Nr, SubaccountPortfolio as Ns, IndexerGrpcAccountPortfolioStream as Nt, isNode as Nu, MsgSubmitProposalPerpetualMarketLaunch as Nv, ChainGrpcExchangeApi as O, MsgWithdrawValidatorCommission as O_, GrpcHistoricalVolumes as Oa, MitoPortfolio as Oc, BaseAccount as Od, createTransactionWithSigners as Of, GrpcDelegationResponse as Og, EvmParams as Oh, GrpcMegaVaultPnl as Oi, getChecksumAddress as Ol, PermissionRoleIDs as Om, IndexerOracleStreamTransformer as On, AccessTypeCode as Oo, FactoryDenomWithMetadata as Op, ExplorerTransactionApiResponse as Or, GrpcSubaccountDeposit as Os, SpotOrdersStreamCallbackV2 as Ot, getErrorMessage as Ou, MsgSubmitProposal as Ov, ChainGrpcWasmXApi as P, MsgUpdateDerivativeMarketV2 as P_, HistoricalRPNL as Pa, MitoSubaccountBalance as Pc, getEip712TypedDataV2 as Pd, RestSignerInfo as Pf, GrpcUnbondingDelegation as Pg, CampaignRewardPool as Ph, GrpcMegaVaultUserStats as Pi, isCw20ContractAddress as Pl, GrpcTxFeesEipBaseFee as Pm, IndexerSpotStreamTransformer as Pn, Contract as Po, GrpcDistributionParams as Pp, BinaryOptionsMarket as Pr, SubaccountTransfer as Ps, DerivativeMarketStreamCallback as Pt, isReactNative as Pu, MsgSubmitProposalSpotMarketLaunch as Pv, DerivativeOrderbookV2StreamCallbackV2 as Q, MsgInstantiateContract as Q_, GrpcAuctionCoinPrices as Qa, grpcPaginationToPagination as Qc, SIGN_EIP712 as Qd, TxClientMode as Qf, ContractCodeHistoryOperationType as Qg, GrpcChainSpotMarket as Qh, MegaVaultSubscription as Qi, derivativePriceFromChainPrice as Ql, CreateSpotLimitOrderAuthz as Qm, IndexerGrpcTradingApi as Qn, GrpcExplorerStats as Qo, AuctionModuleStateResponse as Qp, GrpcDerivativeTrade as Qr, GrpcMitoPriceSnapshot as Qs, BalanceStreamCallback as Qt, privateKeyToPublicKeyBase64 as Qu, ChainGrpcMintApi as R, MsgCreateSpotMarketOrder as R_, PnlLeaderboard as Ra, MitoVault as Rc, getEip712DomainV2 as Rd, SimulationResponse as Rf, GrpcValidatorCommissionRates as Rg, ChainPosition as Rh, MegaVault as Ri, getSpotMarketDecimals as Rl, GrpcParams as Rm, IndexerGrpcMitoTransformer as Rn, CosmWasmPermission as Ro, DenomOwnersResponse as Rp, DerivativeMarketWithoutBinaryOptions as Rr, GrpcMitoClaimReference as Rs, DerivativeOrdersStreamCallback as Rt, safeBigIntStringify as Ru, MsgRevoke as Rv, ChainRestBankApi as S, TallyResult as S_, ReferralDetails as Sa, MitoLeaderboardEntry as Sc, GrantAuthorizationType as Sd, waitTxBroadcasted as Sf, TradeRewardCampaign as Sg, EthAccount as Sh, GrpcMegaVaultHistoricalTVL as Si, toUtf8 as Sl, PermissionNamespace as Sm, ExplorerStreamTransformer as Sn, Orderbook as So, MsgAdminUpdateBinaryOptionsMarket as Sp, CW20BalanceExplorerApiResponse as Sr, MarketType as Ss, TransfersStreamCallbackV2 as St, spotQuantityFromChainQuantityToFixed as Su, MsgDeposit as Sv, ChainGrpcDistributionApi as T, VoteOptionMap as T_, GrpcDenomHolders as Ta, MitoMissionLeaderboard as Tc, ExecArgNeptuneWithdraw as Td, createTransactionAndCosmosSignDocForAddressAndMsg as Tf, BondStatus as Tg, EvmBlobScheduleConfig as Th, GrpcMegaVaultOperationStatusLogEntry as Ti, uint8ArrayToString as Tl, PermissionPolicyStatus as Tm, IndexerAuctionStreamTransformer as Tn, QuantityAndFees as To, BlockLatestRestResponse as Tp, ExplorerApiResponse as Tr, GrpcAccountPortfolio as Ts, IndexerGrpcSpotStreamV2 as Tt, bigIntReplacer as Tu, MsgBurn as Tv, ChainGrpcGovApi as U, MsgCreateSpotLimitOrder as U_, Auction as Ua, IndexerGrpcAccountApi as Uc, getTypesIncludingFeePayer as Ud, TxSearchResult as Uf, UnBondingDelegation as Ug, FeeDiscountSchedule as Uh, MegaVaultIncentives as Ui, denomAmountFromChainDenomAmountToFixed as Ul, PeggyModuleParams as Um, IndexerRestExplorerApi as Un, ExplorerStats as Uo, AuctionBid as Up, ExpiryFuturesMarketInfo as Ur, GrpcMitoIDOProgress as Us, BlocksStreamCallback as Ut, TypedDataUtilsSanitizeData as Uu, GrpcWebFetchTransport as Uv, ChainGrpcEvmApi as V, MsgGrantWithAuthorization as V_, AccountAuctionStatus as Va, MitoWhitelistAccount as Vc, getEipTxContext as Vd, TxResult as Vf, ReDelegation as Vg, ExchangeParams as Vh, MegaVaultHistoricalPnL as Vi, cosmosSdkDecToBigNumber as Vl, TokenPair as Vm, IndexerRestMarketChronosApi as Vn, ExplorerBlockWithTxs as Vo, BaseAccountRestResponse as Vp, DerivativeTrade as Vr, GrpcMitoIDO as Vs, DerivativeTradesStreamCallback as Vt, SignTypedDataVersionV4 as Vu, MsgSend as Vv, accountEthParser as W, MsgAuthorizeStakeGrants as W_, AuctionCoin as Wa, IndexerGrpcWeb3GwApi as Wc, getObjectEip712PropertyType as Wd, TxSearchResultParams as Wf, Validator as Wg, FeeDiscountTierInfo as Wh, MegaVaultMaxDrawdown as Wi, denomAmountFromGrpcChainDenomAmount as Wl, BatchCancelDerivativeOrdersAuthz as Wm, IndexerGrpcInsuranceFundApi as Wn, ExplorerTransaction as Wo, AuctionCurrentBasket as Wp, FundingPayment as Wr, GrpcMitoIDOSubscriber as Ws, BlocksWithTxsStreamCallback as Wt, TypedMessageV4 as Wu, DerivativeOrderHistoryStreamCallbackV2 as X, MsgTransferDelegation as X_, GrpcAuction as Xa, recoverTypedSignaturePubKey as Xc, SIGN_AMINO as Xd, TxClientBroadcastOptions as Xf, ContractAccountsBalanceWithPagination as Xg, GrpcChainFullSpotMarket as Xh, MegaVaultRedemptionStatus as Xi, derivativeMarginToChainMargin as Xl, CreateDerivativeLimitOrderAuthz as Xm, IndexerGrpcCampaignApi as Xn, GasFee as Xo, AuctionModuleState as Xp, GrpcDerivativePosition as Xr, GrpcMitoMissionLeaderboardEntry as Xs, BidsStreamCallback as Xt, privateKeyHashToPublicKeyBase64 as Xu, DerivativeMarketStreamCallbackV2 as Y, MsgReclaimLockedFunds as Y_, GrpcAccountAuctionV2 as Ya, IndexerGrpcMitoApi as Yc, TxClient as Yd, SignerDetails as Yf, ContractAccountBalance as Yg, GrpcChainFullDerivativeMarket as Yh, MegaVaultRedemption as Yi, derivativeMarginFromChainMarginToFixed as Yl, CancelSpotOrderAuthz as Ym, IndexerGrpcArchiverApi as Yn, ExplorerValidatorUptime as Yo, AuctionModuleParams as Yp, GrpcDerivativeOrderHistory as Yr, GrpcMitoMission as Ys, IndexerGrpcTradingStream as Yt, privateKeyHashToPublicKey as Yu, DerivativeOrderbookUpdateStreamCallbackV2 as Z, MsgRequestRedemption as Z_, GrpcAuctionCoin as Za, fetchAllWithPagination as Zc, SIGN_DIRECT as Zd, TxClientBroadcastResponse as Zf, ContractCodeHistoryEntry as Zg, GrpcChainPosition as Zh, MegaVaultStats as Zi, derivativeMarginToChainMarginToFixed as Zl, CreateDerivativeMarketOrderAuthz as Zm, IndexerGrpcExplorerApi as Zn, GrpcBankMsgSendMessage as Zo, AuctionModuleStateParams as Zp, GrpcDerivativePositionV2 as Zr, GrpcMitoPagination as Zs, IndexerGrpcAuctionStream as Zt, privateKeyToPublicKey as Zu, ChainGrpcEvmTransformer as _, GrpcVote as __, GrpcGuild as _a, MitoIDOProgress as _c, OrderHashManager as _d, getPublicKey as _f, GrpcTradingRewardCampaignInfo as _g, SendEnabled as _h, IncentivesCampaign as _i, hexToBase64 as _l, PermissionActionMap as _m, IndexerGrpcInsuranceFundTransformer as _n, SpotOrderHistory as _o, TokenFactoryMsgs as _p, AllDerivativeMarketSummaryResponse as _r, ValidatorUptimeStatus as _s, OraclePriceStreamCallbackV2 as _t, spotPriceFromChainPrice as _u, MsgWithdraw as _v, ChainGrpcExchangeTransformer as a, GrpcContractCodeHistoryEntry as a_, MegaVaultVolatilityStats as aa, GrpcMitoTokenInfo as ac, getGrpcWebTransport as ad, isTxNotFoundError as af, GrpcFeeDiscountTierTTL as ag, GrpcInsuranceFund as ah, PerpetualMarket as ai, BECH32_ADDR_CONS_PREFIX as al, GrpcAuctionParams as am, StakingRewardByAccountStreamCallback as an, Oracle as ao, DistributionMsgs as ap, GrpcAccountPortfolioV2 as ar, GrpcValidatorUptime as as, BlocksWithTxsStreamCallbackV2 as at, derivativeQuantityToChainQuantityToFixed as au, MsgBeginRedelegate as av, ChainRestWasmApi as b, ProposalStatus as b_, GuildCampaignSummary as ba, MitoIDOSubscriptionActivity as bc, ContractExecutionAuthorization as bd, TxRestApi as bf, OrderTypeMap as bg, AuthBaseAccount as bh, GrpcMegaVaultAprStats as bi, stringToUint8Array as bl, PermissionAddressVoucher as bm, IndexerGrpcMitoStreamTransformer as bn, GrpcTokenMeta as bo, MsgCreateBinaryOptionsMarketOrder as bp, BankTransferFromExplorerApiResponse as br, GridStrategyType as bs, IndexerGrpcMitoStreamV2 as bt, spotPriceToChainPriceToFixed as bu, MsgSendToEth as bv, ChainGrpcCommonTransformer as c, TokenInfo$1 as c_, AllSpotMarketSummaryResponse as ca, MitoChanges as cc, makeTimeoutTimestampInNs as cd, createFee as cf, GrpcOrderInfo as cg, InsuranceFund as ch, Position as ci, BECH32_PUBKEY_CONS_PREFIX as cl, GrpcPermissionNamespace as cm, VaultStreamCallback as cn, GrpcAtomicSwap as co, ExchangeV1Msgs as cp, GrpcPositionsWithUPNL as cr, Message as cs, IndexerGrpcArchiverStreamV2 as ct, formatNumberToAllowableDecimals as cu, MsgExecuteContract as cv, ChainGrpcPeggyTransformer as d, GrpcGovernanceDepositParams as d_, Campaign as da, MitoGauge as dc, protobufTimestampToUnixSeconds as dd, createSignDocFromTransaction as df, GrpcPointsMultiplier as dg, GrpcMintParams as dh, GrpcIndexerInsuranceFund as di, base64ToUint8Array as dl, GrpcPermissionRole as dm, SpotOrderHistoryStreamCallback as dn, GrpcSpotOrderHistory as do, GovMsgs as dp, PositionsWithUPNL as dr, PeggyWithdrawalTx as ds, IndexerGrpcTradingStreamV2 as dt, formatPriceToAllowablePrice as du, MsgRewardsOptOut as dv, ContractInfo as e_, MegaVaultTargetApr as ea, GrpcMitoStakingPool as ec, ripemd160 as ed, createAny as ef, GrpcDenomMinNotional as eg, GenericAuthorization$1 as eh, GrpcFundingPayment as ei, grpcPagingToPagingV2 as el, GrpcAuctionBid as em, IndexerGrpcOracleStream as en, GrpcAuctionV2 as eo, TxConcreteApi as ep, StreamStatusResponse as er, GrpcIBCTransferTx as es, DerivativePositionsStreamCallbackV2 as et, derivativePriceToChainPrice as eu, MsgBatchUpdateOrders as ev, ChainGrpcAuthZTransformer as f, GrpcGovernanceTallyParams as f_, CampaignUser as fa, MitoGaugeStatus as fc, MsgUpdateActorRoles as fd, createSignerInfo as ff, GrpcSpotMarket as fg, MinModuleParams as fh, GrpcIndexerRedemptionSchedule as fi, base64ToUtf8 as fl, GrpcPermissionRoleActors as fm, SpotOrderbookUpdateStreamCallback as fn, GrpcSpotTrade as fo, IbcMsgs as fp, SubaccountDepositV2 as fr, Signature as fs, BidsStreamCallbackV2 as ft, getExactDecimalsFromNumber as fu, MsgPrivilegedExecuteContract as fv, ChainGrpcAuthTransformer as g, GrpcTallyResult as g_, GrpcCampaignV2 as ga, MitoIDOInitParams as gc, MsgClaimVoucher as gd, getAminoStdSignDoc as gf, GrpcTradingRewardCampaignBoostInfo as gg, Metadata as gh, RedemptionStatus as gi, fromUtf8 as gl, GrpcPermissionsParams as gm, IndexerAccountPortfolioStreamTransformer as gn, SpotOrderCancelParams as go, StakingMsgs as gp, AllChronosDerivativeMarketSummary as gr, ValidatorUptime as gs, IndexerGrpcOracleStreamV2 as gt, numberToCosmosSdkDecString as gu, MsgUpdateAdmin as gv, ChainGrpcBankTransformer as h, GrpcProposalDeposit as h_, GrpcCampaignUser as ha, MitoIDOClaimedCoins as hc, MsgUpdateParams as hd, createWeb3Extension as hf, GrpcTradeRewardCampaign as hg, GrpcSupply as hh, Redemption as hi, fromBase64 as hl, GrpcPermissionsNamespace as hm, SpotTradesStreamCallback as hn, SpotMarket as ho, PeggyMsgs as hp, ChronosLeaderboardResponse as hr, ValidatorSlashingEvent as hs, IndexerGrpcAccountStreamV2 as ht, isNumber as hu, MsgUndelegate as hv, ChainGrpcPermissionsTransformer as i, GrpcCodeInfoResponse as i_, MegaVaultVolatility as ia, GrpcMitoSubscription as ic, ofacList as id, errorToErrorMessage as if, GrpcFeeDiscountTierInfo as ig, GrantWithDecodedAuthorization as ih, GrpcPositionDelta as ii, BECH32_ADDR_ACC_PREFIX as il, GrpcAuctionLastAuctionResult as im, IndexerGrpcMitoStream as in, GrpcOracle as io, BankMsgs as ip, AccountPortfolioV2 as ir, GrpcValidatorSlashingEvent as is, BlocksStreamCallbackV2 as it, derivativeQuantityToChainQuantity as iu, MsgCreateValidator as iv, ChainGrpcTxFeesApi as j, MsgCreateDerivativeLimitOrder as j_, GrpcSpotAverageEntry as ja, MitoStakingActivity as jc, Address as jd, BroadcastMode as jf, GrpcReDelegationEntryResponse as jg, GrpcEvmChainConfig as jh, GrpcMegaVaultSubscription as ji, getInjectiveAddress as jl, PermissionsModuleParams as jm, IndexerGrpcArchiverTransformer as jn, Block$1 as jo, DistributionModuleParams as jp, WasmCodeExplorerApiResponse as jr, SubaccountBalance as js, createStreamSubscription as jt, isBrowser as ju, MsgSubmitProposalPerpetualMarketLaunchV2 as jv, ChainGrpcStakingApi as k, MsgCreateDerivativeMarketOrder as k_, GrpcLeaderboardRow as ka, MitoPriceSnapshot as kc, PrivateKey as kd, createTxRawFromSigResponse as kf, GrpcPool as kg, GrpcEvmBlobConfig as kh, GrpcMegaVaultPnlStats as ki, getDefaultSubaccountId as kl, PermissionRoleManager as km, IndexerGrpcReferralTransformer as kn, BankMsgSendTransaction as ko, TokenFactoryModuleParams as kp, TransactionFromExplorerApiResponse as kr, GrpcSubaccountPortfolio as ks, SpotTradesStreamCallbackV2 as kt, grpcCoinToUiCoin as ku, ProposalDecomposer as kv, ChainGrpcTxFeesTransformer as l, grpcContractInfo as l_, ChronosSpotMarketSummary as la, MitoClaimReference as lc, protobufTimestampToDate as ld, createNonCriticalExtensionFromObject as lf, GrpcOrderType as lg, InsuranceModuleParams as lh, PositionDelta as li, BECH32_PUBKEY_VAL_PREFIX as ll, GrpcPermissionPolicyStatus as lm, IndexerGrpcSpotStream as ln, GrpcSpotLimitOrder as lo, ExchangeV2Msgs as lp, GrpcSubaccountDepositV2 as lr, Paging as ls, SpotAverageEntriesStreamCallbackV2 as lt, formatNumberToAllowableTensMultiplier as lu, MsgCreateDenom as lv, ChainGrpcMintTransformer as m, GrpcProposal as m_, GrpcCampaign as ma, MitoIDO as mc, MsgCreateNamespace as md, createTxRawEIP712 as mf, GrpcSpotOrder as mg, GrpcBankParams as mh, InsuranceFundCreateParams as mi, concatUint8Arrays as ml, GrpcPermissionRoleManager as mm, SpotOrdersStreamCallback as mn, SpotLimitOrderParams as mo, Msgs as mp, ChronosLeaderboardEntry as mr, TxMessage as ms, BalanceStreamCallbackV2 as mt, getTensMultiplier as mu, MsgUnderwrite as mv, ChainGrpcTokenFactoryTransformer as n, GoogleProtoBufAny as n_, MegaVaultUser as na, GrpcMitoStakingStakingReward as nc, sha256 as nd, getEthereumSignerAddress as nf, GrpcFeeDiscountAccountInfo as ng, GrantAuthorization$1 as nh, GrpcPerpetualMarketFunding as ni, paginationRequestFromPagination as nl, GrpcAuctionEventAuctionStart as nm, OraclePricesByMarketsStreamCallback as nn, IndexerAuctionBid as no, AuctionMsgs as np, ChronosMarketHistoryResponse as nr, GrpcPeggyDepositTx as ns, DerivativeTradesStreamCallbackV2 as nt, derivativeQuantityFromChainQuantity as nu, MsgRevokeAllowance as nv, ChainGrpcStakingTransformer as o, GrpcContractInfo as o_, OperationStatusLogEntry as oa, GrpcMitoVault as oc, getGasPriceBasedOnMessage as od, createAuthInfo as of, GrpcMarketStatus as og, GrpcInsuranceParams as oh, PerpetualMarketFunding as oi, BECH32_ADDR_VAL_PREFIX as ol, GrpcPermissionActorRoles as om, TransfersStreamCallback as on, AtomicSwap as oo, Erc20Msgs as op, GrpcPortfolioSubaccountBalanceV2 as or, IBCTransferTx as os, IndexerGrpcExplorerStreamV2 as ot, formatAmountToAllowableAmount as ou, MsgGrantAllowance as ov, ChainGrpcWasmTransformer as p, GrpcGovernanceVotingParams as p_, CampaignV2 as pa, MitoHolders as pc, MsgUpdateNamespace as pd, createSigners as pf, GrpcSpotMarketOrder as pg, BankModuleParams as ph, IndexerInsuranceFund as pi, binaryToBase64 as pl, GrpcPermissionRoleIDs as pm, SpotOrderbookV2StreamCallback as pn, SpotLimitOrder as po, InsuranceMsgs as pp, ChronosLeaderboard as pr, Transaction as ps, IndexerGrpcAuctionStreamV2 as pt, getSignificantDecimalsFromNumber as pu, MsgEditValidator as pv, AccountPortfolioStreamCallbackV2 as q, MsgSetDenomMetadata as q_, AuctionV2 as qa, IndexerGrpcSpotApi as qc, protoTypeToAminoType as qd, CreateTransactionWithSignersArgs as qf, AbsoluteTxPosition as qg, GrpcChainDerivativeMarket as qh, MegaVaultPnl as qi, denomAmountToGrpcChainDenomAmount as ql, BatchCreateSpotLimitOrdersAuthz as qm, IndexerGrpcMegaVaultApi as qn, ExplorerValidator as qo, AuctionEventBid as qp, GrpcDerivativeLimitOrder as qr, GrpcMitoLeaderboardEntry as qs, IndexerGrpcArchiverStream as qt, hashToHex as qu, ChainGrpcDistributionTransformer as r, GrpcAbsoluteTxPosition as r_, MegaVaultUserStats as ra, GrpcMitoSubaccountBalance as rc, parseCoins as rd, getInjectiveSignerAddress as rf, GrpcFeeDiscountSchedule as rg, GrantAuthorizationWithDecodedAuthorization as rh, GrpcPerpetualMarketInfo as ri, paginationUint8ArrayToString as rl, GrpcAuctionEventBid as rm, HistoricalStakingStreamCallback as rn, StreamBidsResponse as ro, AuthzMsgs as rp, AccountPortfolioBalances as rr, GrpcPeggyWithdrawalTx as rs, IndexerGrpcDerivativesStreamV2 as rt, derivativeQuantityFromChainQuantityToFixed as ru, MsgCancelSpotOrder as rv, ChainGrpcAuctionTransformer as s, MarketingInfo as s_, AllChronosSpotMarketSummary as sa, GrpcMitoWhitelistAccount as sc, makeTimeoutTimestamp as sd, createBody as sf, GrpcMarketStatusMap as sg, GrpcRedemptionSchedule as sh, PerpetualMarketInfo as si, BECH32_PUBKEY_ACC_PREFIX as sl, GrpcPermissionAddressVoucher as sm, VaultHolderSubscriptionStreamCallback as sn, BatchSpotOrderCancelParams as so, ExchangeMsgs as sp, GrpcPositionV2 as sr, IndexerStreamTransaction as ss, TransactionsStreamCallbackV2 as st, formatAmountToAllowableDecimals as su, MsgMigrateContract as sv, ChainGrpcInsuranceFundTransformer as t, ContractStateWithPagination as t_, MegaVaultUnrealizedPnl as ta, GrpcMitoStakingStakingActivity as tc, sanitizeTypedData as td, createAnyMessage as tf, GrpcExchangeParams as tg, Grant$1 as th, GrpcFundingRate as ti, pageRequestToGrpcPageRequestV2 as tl, GrpcAuctionEventAuctionResult as tm, OraclePriceStreamCallback as tn, GrpcIndexerAuctionBid as to, TxResponse as tp, AllChronosMarketHistory as tr, GrpcIndexerValidatorDescription as ts, DerivativePositionsV2StreamCallbackV2 as tt, derivativePriceToChainPriceToFixed as tu, MsgExternalTransfer as tv, ChainGrpcErc20Transformer as u, GovModuleStateParams as u_, ChronosSpotMarketSummaryResponse as ua, MitoDenomBalance as uc, protobufTimestampToUnixMs as ud, createSignDoc as uf, GrpcOrderTypeMap as ug, OracleTypeMap as uh, PositionV2 as ui, DEFAULT_DERIVATION_PATH as ul, GrpcPermissionPolicyStatusManagerCapability as um, MarketsStreamCallback as un, GrpcSpotMarketInfo as uo, FeegrantMsgs as up, PortfolioSubaccountBalanceV2 as ur, PeggyDepositTx as us, GridStrategyStreamCallbackV2 as ut, formatPriceToAllowableDecimals as uu, MsgChangeAdmin as uv, ChainGrpcGovTransformer as v, Proposal as v_, GrpcGuildMember as va, MitoIDOSubscriber as vc, MsgInstantBinaryOptionsMarketLaunch as vd, getTransactionPartsFromTxRaw as vf, IsOptedOutOfRewards as vg, TotalSupply as vh, IncentivesRound as vi, hexToBuff as vl, PermissionActorRoles as vm, IndexerDerivativeStreamTransformer as vn, SpotTrade as vo, WasmMsgs as vp, ChronosDerivativeMarketSummary as vr, WasmCode as vs, OraclePricesByMarketsStreamCallbackV2 as vt, spotPriceFromChainPriceToFixed as vu, MsgSignData as vv, ChainGrpcTokenFactoryApi as w, VoteOption as w_, DenomHolders as wa, MitoMission as wc, msgsOrMsgExecMsgs as wd, createTransactionAndCosmosSignDoc as wf, TradingRewardCampaignInfo as wg, EvmBlobConfig as wh, GrpcMegaVaultMaxDrawdown as wi, uint8ArrayToHex as wl, PermissionPolicyManagerCapability as wm, IndexerGrpcMegaVaultTransformer as wn, PriceLevel as wo, RestApiResponse as wp, ContractTransactionExplorerApiResponse as wr, AccountPortfolio as ws, VaultStreamCallbackV2 as wt, spotQuantityToChainQuantityToFixed as wu, MsgMint as wv, ChainRestAuthApi as x, ProposalStatusMap as x_, GuildMember as xa, MitoLeaderboard as xc, GenericAuthorization as xd, TxGrpcApi as xf, PointsMultiplier as xg, AuthModuleParams as xh, GrpcMegaVaultHistoricalPnL as xi, toBase64 as xl, PermissionGenesisState as xm, IndexerGrpcDerivativeTransformer as xn, IndexerTokenMeta as xo, MsgBatchCancelBinaryOptionsOrders as xp, BlockFromExplorerApiResponse as xr, ListTradingStrategiesResponse as xs, StakingRewardByAccountStreamCallbackV2 as xt, spotQuantityFromChainQuantity as xu, MsgStoreCode as xv, ChainRestTendermintApi as y, ProposalDeposit as y_, Guild as ya, MitoIDOSubscription as yc, ContractExecutionCompatAuthorization as yd, generateArbitrarySignDoc as yf, OrderType as yg, Account as yh, GrpcMegaVaultApr as yi, hexToUint8Array as yl, PermissionAddressRoles as ym, IndexerGrpcAccountPortfolioTransformer as yn, GrpcPriceLevel as yo, MsgSetDelegationTransferReceivers as yp, ChronosDerivativeMarketSummaryResponse as yr, GridStrategyStreamResponse as ys, HistoricalStakingStreamCallbackV2 as yt, spotPriceToChainPrice as yu, MsgDelegate as yv, ChainGrpcBankApi as z, MsgCancelDerivativeOrder as z_, SpotAverageEntry as za, MitoVestingConfig as zc, getEip712Fee as zd, TxInfo as zf, GrpcValidatorDescription as zg, DepositProposalParams as zh, MegaVaultApr as zi, getSpotMarketTensMultiplier as zl, GrpcTokenPair as zm, IndexerRestLeaderboardChronosApi as zn, EventLog as zo, AccountResponse as zp, DerivativeOrderCancelParams as zr, GrpcMitoDenomBalance as zs, DerivativePositionsStreamCallback as zt, sortObjectByKeys as zu, MsgGrant as zv };