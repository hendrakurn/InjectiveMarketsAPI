const require_chunk = require('./chunk-CbDLau6x.cjs');
const require_utils = require('./utils-D3XFGv8y.cjs');
const require_defineProperty = require('./defineProperty-dyr5BsvG.cjs');
const require_accounts = require('./accounts-HFzAaFRB.cjs');
let __injectivelabs_core_proto_ts_v2_generated_cosmos_base_v1beta1_coin_pb = require("@injectivelabs/core-proto-ts-v2/generated/cosmos/base/v1beta1/coin_pb");
__injectivelabs_core_proto_ts_v2_generated_cosmos_base_v1beta1_coin_pb = require_chunk.__toESM(__injectivelabs_core_proto_ts_v2_generated_cosmos_base_v1beta1_coin_pb);
let __injectivelabs_core_proto_ts_v2_generated_injective_types_v1beta1_account_pb = require("@injectivelabs/core-proto-ts-v2/generated/injective/types/v1beta1/account_pb");
__injectivelabs_core_proto_ts_v2_generated_injective_types_v1beta1_account_pb = require_chunk.__toESM(__injectivelabs_core_proto_ts_v2_generated_injective_types_v1beta1_account_pb);
let __injectivelabs_core_proto_ts_v2_generated_ibc_core_client_v1_client_pb = require("@injectivelabs/core-proto-ts-v2/generated/ibc/core/client/v1/client_pb");
__injectivelabs_core_proto_ts_v2_generated_ibc_core_client_v1_client_pb = require_chunk.__toESM(__injectivelabs_core_proto_ts_v2_generated_ibc_core_client_v1_client_pb);
let __injectivelabs_core_proto_ts_v2_generated_ibc_applications_transfer_v1_tx_pb = require("@injectivelabs/core-proto-ts-v2/generated/ibc/applications/transfer/v1/tx_pb");
__injectivelabs_core_proto_ts_v2_generated_ibc_applications_transfer_v1_tx_pb = require_chunk.__toESM(__injectivelabs_core_proto_ts_v2_generated_ibc_applications_transfer_v1_tx_pb);
let cosmjs_types_ibc_applications_transfer_v1_tx = require("cosmjs-types/ibc/applications/transfer/v1/tx");
let __cosmjs_stargate = require("@cosmjs/stargate");
let __cosmjs_math = require("@cosmjs/math");
let __cosmjs_utils = require("@cosmjs/utils");
let cosmjs_types_cosmos_tx_v1beta1_tx = require("cosmjs-types/cosmos/tx/v1beta1/tx");
let __cosmjs_tendermint_rpc = require("@cosmjs/tendermint-rpc");
let cosmjs_types_cosmos_tx_signing_v1beta1_signing = require("cosmjs-types/cosmos/tx/signing/v1beta1/signing");
let cosmjs_types_cosmos_distribution_v1beta1_tx = require("cosmjs-types/cosmos/distribution/v1beta1/tx");
let cosmjs_types_cosmos_staking_v1beta1_tx = require("cosmjs-types/cosmos/staking/v1beta1/tx");
let __cosmjs_amino = require("@cosmjs/amino");
let __cosmjs_proto_signing = require("@cosmjs/proto-signing");

//#region src/core/modules/ibc/msgs/MsgTransferCosmjs.ts
/**
* @category Messages
*
* @deprecated use MsgTransfer with SIGN_DIRECT and a Cosmos wallet
*/
var MsgTransferCosmjs = class MsgTransferCosmjs {
	constructor(params) {
		require_defineProperty._defineProperty(this, "params", void 0);
		this.params = params;
	}
	static fromJSON(params) {
		return new MsgTransferCosmjs(params);
	}
	toProto() {
		const { params } = this;
		const token = __injectivelabs_core_proto_ts_v2_generated_cosmos_base_v1beta1_coin_pb.Coin.create({
			denom: params.amount.denom,
			amount: params.amount.amount
		});
		const message = __injectivelabs_core_proto_ts_v2_generated_ibc_applications_transfer_v1_tx_pb.MsgTransfer.create({
			sourcePort: params.port,
			sourceChannel: params.channelId,
			token,
			sender: params.sender,
			receiver: params.receiver
		});
		if (params.height) message.timeoutHeight = __injectivelabs_core_proto_ts_v2_generated_ibc_core_client_v1_client_pb.Height.create({
			revisionHeight: BigInt(params.height.revisionHeight),
			revisionNumber: BigInt(params.height.revisionNumber)
		});
		if (params.timeout) message.timeoutTimestamp = BigInt(params.timeout);
		return cosmjs_types_ibc_applications_transfer_v1_tx.MsgTransfer.fromPartial({
			sourcePort: message.sourcePort,
			sourceChannel: message.sourceChannel,
			token: message.token,
			sender: message.sender,
			receiver: message.receiver,
			timeoutHeight: message.timeoutHeight ? {
				revisionHeight: message.timeoutHeight.revisionHeight,
				revisionNumber: message.timeoutHeight.revisionNumber
			} : void 0,
			timeoutTimestamp: message.timeoutTimestamp
		});
	}
	toData() {
		throw new Error("Method not implemented.");
	}
	toAmino() {
		const { params } = this;
		const message = cosmjs_types_ibc_applications_transfer_v1_tx.MsgTransfer.fromPartial({
			sourcePort: params.port,
			sourceChannel: params.channelId,
			sender: params.sender,
			receiver: params.receiver,
			token: params.amount,
			timeoutHeight: params.height ? {
				revisionHeight: BigInt(params.height.revisionHeight),
				revisionNumber: BigInt(params.height.revisionNumber)
			} : void 0,
			timeoutTimestamp: params.timeout ? BigInt(params.timeout) : void 0
		});
		return {
			type: "/ibc.applications.transfer.v1.MsgTransfer",
			value: {
				...message,
				timeoutHeight: message.timeoutHeight ? {
					revisionHeight: message.timeoutHeight.revisionHeight.toString(),
					revisionNumber: message.timeoutHeight.revisionNumber.toString()
				} : void 0,
				timeoutTimestamp: message.timeoutTimestamp ? message.timeoutTimestamp.toString() : void 0
			}
		};
	}
	toWeb3Gw() {
		const { value } = this.toAmino();
		return {
			"@type": "/ibc.applications.transfer.v1.MsgTransfer",
			...value
		};
	}
	toDirectSign() {
		return {
			type: "/ibc.applications.transfer.v1.MsgTransfer",
			message: this.toProto()
		};
	}
	toBinary() {
		return cosmjs_types_ibc_applications_transfer_v1_tx.MsgTransfer.encode(this.toProto()).finish();
	}
};

//#endregion
//#region src/core/accounts/AccountParser.ts
const accountParser = (ethAccount) => {
	const baseAccount = __injectivelabs_core_proto_ts_v2_generated_injective_types_v1beta1_account_pb.EthAccount.fromBinary(ethAccount.value).baseAccount;
	const pubKey = baseAccount.pubKey;
	return {
		address: baseAccount.address,
		pubkey: pubKey ? {
			type: "/injective.crypto.v1beta1.ethsecp256k1.PubKey",
			value: require_utils.uint8ArrayToBase64(pubKey.value)
		} : null,
		accountNumber: parseInt(baseAccount.accountNumber.toString(), 10),
		sequence: parseInt(baseAccount.sequence.toString(), 10)
	};
};

//#endregion
//#region src/core/stargate/StargateClient.ts
var StargateClient = class extends __cosmjs_stargate.StargateClient {
	async getAccount(searchAddress) {
		try {
			const isInjective = (await this.getChainId()).startsWith("injective");
			const account = await this.forceGetQueryClient().auth.account(searchAddress);
			if (!account) return null;
			if (isInjective) return accountParser(account);
			return (0, __cosmjs_stargate.accountFromAny)(account);
		} catch (error) {
			if (/rpc error: code = NotFound/i.test(error.toString())) return null;
			throw error;
		}
	}
};

//#endregion
//#region src/core/stargate/SigningStargateClient.ts
function createDefaultAminoConverters() {
	return {
		...(0, __cosmjs_stargate.createAuthzAminoConverters)(),
		...(0, __cosmjs_stargate.createBankAminoConverters)(),
		...(0, __cosmjs_stargate.createDistributionAminoConverters)(),
		...(0, __cosmjs_stargate.createGovAminoConverters)(),
		...(0, __cosmjs_stargate.createStakingAminoConverters)(),
		...(0, __cosmjs_stargate.createIbcAminoConverters)(),
		...(0, __cosmjs_stargate.createFeegrantAminoConverters)(),
		...(0, __cosmjs_stargate.createVestingAminoConverters)()
	};
}
var SigningStargateClient = class SigningStargateClient extends StargateClient {
	/**
	* Creates an instance by connecting to the given Tendermint RPC endpoint.
	*
	* For now this uses the Tendermint 0.34 client. If you need Tendermint 0.37
	* support, see `createWithSigner`.
	*/
	static async connectWithSigner(endpoint, signer, options = {}) {
		const tmClient = await __cosmjs_tendermint_rpc.Tendermint37Client.connect(endpoint);
		return SigningStargateClient.createWithSigner(tmClient, signer, options);
	}
	/**
	* Creates an instance from a manually created Tendermint client.
	* Use this to use `Tendermint37Client` instead of `Tendermint37Client`.
	*/
	static async createWithSigner(tmClient, signer, options = {}) {
		return new SigningStargateClient(tmClient, signer, options);
	}
	/**
	* Creates a client in offline mode.
	*
	* This should only be used in niche cases where you know exactly what you're doing,
	* e.g. when building an offline signing application.
	*
	* When you try to use online functionality with such a signer, an
	* exception will be raised.
	*/
	static async offline(signer, options = {}) {
		return new SigningStargateClient(void 0, signer, options);
	}
	constructor(tmClient, signer, options) {
		super(tmClient, options);
		require_defineProperty._defineProperty(this, "registry", void 0);
		require_defineProperty._defineProperty(this, "broadcastTimeoutMs", void 0);
		require_defineProperty._defineProperty(this, "broadcastPollIntervalMs", void 0);
		require_defineProperty._defineProperty(this, "signer", void 0);
		require_defineProperty._defineProperty(this, "aminoTypes", void 0);
		require_defineProperty._defineProperty(this, "gasPrice", void 0);
		const { registry = new __cosmjs_proto_signing.Registry(__cosmjs_stargate.defaultRegistryTypes), aminoTypes = new __cosmjs_stargate.AminoTypes(createDefaultAminoConverters()) } = options;
		this.registry = registry;
		this.aminoTypes = aminoTypes;
		this.signer = signer;
		this.broadcastTimeoutMs = options.broadcastTimeoutMs;
		this.broadcastPollIntervalMs = options.broadcastPollIntervalMs;
		this.gasPrice = options.gasPrice;
	}
	async simulate(signerAddress, messages, memo) {
		const anyMsgs = messages.map((m) => this.registry.encodeAsAny(m));
		const accountFromSigner = (await this.signer.getAccounts()).find((account) => account.address === signerAddress);
		if (!accountFromSigner) throw new Error("Failed to retrieve account from signer");
		const pubkey = (0, __cosmjs_amino.encodeSecp256k1Pubkey)(accountFromSigner.pubkey);
		const { sequence } = await this.getSequence(signerAddress);
		const { gasInfo } = await this.forceGetQueryClient().tx.simulate(anyMsgs, memo, pubkey, sequence);
		(0, __cosmjs_utils.assertDefined)(gasInfo);
		return __cosmjs_math.Uint53.fromString(gasInfo.gasUsed.toString()).toNumber();
	}
	async sendTokens(senderAddress, recipientAddress, amount, fee, memo = "") {
		const sendMsg = {
			typeUrl: "/cosmos.bank.v1beta1.MsgSend",
			value: {
				fromAddress: senderAddress,
				toAddress: recipientAddress,
				amount: [...amount]
			}
		};
		return this.signAndBroadcast(senderAddress, [sendMsg], fee, memo);
	}
	async delegateTokens(delegatorAddress, validatorAddress, amount, fee, memo = "") {
		const delegateMsg = {
			typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
			value: cosmjs_types_cosmos_staking_v1beta1_tx.MsgDelegate.fromPartial({
				delegatorAddress,
				validatorAddress,
				amount
			})
		};
		return this.signAndBroadcast(delegatorAddress, [delegateMsg], fee, memo);
	}
	async undelegateTokens(delegatorAddress, validatorAddress, amount, fee, memo = "") {
		const undelegateMsg = {
			typeUrl: "/cosmos.staking.v1beta1.MsgUndelegate",
			value: cosmjs_types_cosmos_staking_v1beta1_tx.MsgUndelegate.fromPartial({
				delegatorAddress,
				validatorAddress,
				amount
			})
		};
		return this.signAndBroadcast(delegatorAddress, [undelegateMsg], fee, memo);
	}
	async withdrawRewards(delegatorAddress, validatorAddress, fee, memo = "") {
		const withdrawMsg = {
			typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
			value: cosmjs_types_cosmos_distribution_v1beta1_tx.MsgWithdrawDelegatorReward.fromPartial({
				delegatorAddress,
				validatorAddress
			})
		};
		return this.signAndBroadcast(delegatorAddress, [withdrawMsg], fee, memo);
	}
	async sendIbcTokens(senderAddress, recipientAddress, transferAmount, sourcePort, sourceChannel, timeoutHeight, timeoutTimestamp, fee, memo = "") {
		const timeoutTimestampNanoseconds = timeoutTimestamp ? BigInt(timeoutTimestamp) * BigInt(1e9) : void 0;
		const transferMsg = {
			typeUrl: "/ibc.applications.transfer.v1.MsgTransfer",
			value: cosmjs_types_ibc_applications_transfer_v1_tx.MsgTransfer.fromPartial({
				sourcePort,
				sourceChannel,
				sender: senderAddress,
				receiver: recipientAddress,
				token: transferAmount,
				timeoutHeight,
				timeoutTimestamp: timeoutTimestampNanoseconds
			})
		};
		return this.signAndBroadcast(senderAddress, [transferMsg], fee, memo);
	}
	async signAndBroadcast(signerAddress, messages, fee, memo = "") {
		let usedFee;
		if (fee == "auto" || typeof fee === "number") {
			(0, __cosmjs_utils.assertDefined)(this.gasPrice, "Gas price must be set in the client options when auto gas is used.");
			const gasEstimation = await this.simulate(signerAddress, messages, memo);
			const multiplier = typeof fee === "number" ? fee : 1.3;
			usedFee = (0, __cosmjs_stargate.calculateFee)(Math.round(gasEstimation * multiplier), this.gasPrice);
		} else usedFee = fee;
		const txRaw = await this.sign(signerAddress, messages, usedFee, memo);
		const txBytes = cosmjs_types_cosmos_tx_v1beta1_tx.TxRaw.encode(txRaw).finish();
		return this.broadcastTx(txBytes, this.broadcastTimeoutMs, this.broadcastPollIntervalMs);
	}
	/**
	* Gets account number and sequence from the API, creates a sign doc,
	* creates a single signature and assembles the signed transaction.
	*
	* The sign mode (SIGN_MODE_DIRECT or SIGN_MODE_LEGACY_AMINO_JSON) is determined by this client's signer.
	*
	* You can pass signer data (account number, sequence and chain ID) explicitly instead of querying them
	* from the chain. This is needed when signing for a multisig account, but it also allows for offline signing
	* (See the SigningStargateClient.offline constructor).
	*/
	async sign(signerAddress, messages, fee, memo, explicitSignerData) {
		let signerData;
		if (explicitSignerData) signerData = explicitSignerData;
		else {
			const { accountNumber, sequence } = await this.getSequence(signerAddress);
			signerData = {
				accountNumber,
				sequence,
				chainId: await this.getChainId()
			};
		}
		return (0, __cosmjs_proto_signing.isOfflineDirectSigner)(this.signer) ? this.signDirect(signerAddress, messages, fee, memo, signerData) : this.signAmino(signerAddress, messages, fee, memo, signerData);
	}
	async signAmino(signerAddress, messages, fee, memo, { accountNumber, sequence, chainId }) {
		(0, __cosmjs_utils.assert)(!(0, __cosmjs_proto_signing.isOfflineDirectSigner)(this.signer));
		const accountFromSigner = (await this.signer.getAccounts()).find((account) => account.address === signerAddress);
		if (!accountFromSigner) throw new Error("Failed to retrieve account from signer");
		const pubkey = chainId.startsWith("injective") ? require_accounts.getPublicKey({
			chainId,
			key: require_utils.uint8ArrayToBase64(accountFromSigner.pubkey)
		}) : (0, __cosmjs_proto_signing.encodePubkey)((0, __cosmjs_amino.encodeSecp256k1Pubkey)(accountFromSigner.pubkey));
		const signMode = cosmjs_types_cosmos_tx_signing_v1beta1_signing.SignMode.SIGN_MODE_LEGACY_AMINO_JSON;
		const signDoc = (0, __cosmjs_amino.makeSignDoc)(messages.map((msg) => this.aminoTypes.toAmino(msg)), fee, chainId, memo, accountNumber, sequence);
		const { signature, signed } = await this.signer.signAmino(signerAddress, signDoc);
		const signedTxBodyEncodeObject = {
			typeUrl: "/cosmos.tx.v1beta1.TxBody",
			value: {
				messages: signed.msgs.map((msg) => this.aminoTypes.fromAmino(msg)),
				memo: signed.memo
			}
		};
		const signedTxBodyBytes = this.registry.encode(signedTxBodyEncodeObject);
		const signedGasLimit = __cosmjs_math.Int53.fromString(signed.fee.gas).toNumber();
		const signedAuthInfoBytes = (0, __cosmjs_proto_signing.makeAuthInfoBytes)([{
			pubkey,
			sequence: __cosmjs_math.Int53.fromString(signed.sequence).toNumber()
		}], signed.fee.amount, signedGasLimit, signed.fee.granter, signed.fee.payer, signMode);
		return cosmjs_types_cosmos_tx_v1beta1_tx.TxRaw.fromPartial({
			bodyBytes: signedTxBodyBytes,
			authInfoBytes: signedAuthInfoBytes,
			signatures: [require_utils.base64ToUint8Array(signature.signature)]
		});
	}
	async signDirect(signerAddress, messages, fee, memo, { accountNumber, sequence, chainId }) {
		(0, __cosmjs_utils.assert)((0, __cosmjs_proto_signing.isOfflineDirectSigner)(this.signer));
		const accountFromSigner = (await this.signer.getAccounts()).find((account) => account.address === signerAddress);
		if (!accountFromSigner) throw new Error("Failed to retrieve account from signer");
		const pubkey = chainId.startsWith("injective") ? require_accounts.getPublicKey({
			chainId,
			key: require_utils.uint8ArrayToBase64(accountFromSigner.pubkey)
		}) : (0, __cosmjs_proto_signing.encodePubkey)((0, __cosmjs_amino.encodeSecp256k1Pubkey)(accountFromSigner.pubkey));
		const txBodyEncodeObject = {
			typeUrl: "/cosmos.tx.v1beta1.TxBody",
			value: {
				messages,
				memo
			}
		};
		const txBodyBytes = this.registry.encode(txBodyEncodeObject);
		const gasLimit = __cosmjs_math.Int53.fromString(fee.gas).toNumber();
		const signDoc = (0, __cosmjs_proto_signing.makeSignDoc)(txBodyBytes, (0, __cosmjs_proto_signing.makeAuthInfoBytes)([{
			pubkey,
			sequence
		}], fee.amount, gasLimit, fee.granter, fee.payer), chainId, accountNumber);
		const { signature, signed } = await this.signer.signDirect(signerAddress, signDoc);
		return cosmjs_types_cosmos_tx_v1beta1_tx.TxRaw.fromPartial({
			bodyBytes: signed.bodyBytes,
			authInfoBytes: signed.authInfoBytes,
			signatures: [require_utils.base64ToUint8Array(signature.signature)]
		});
	}
};

//#endregion
//#region src/core/accounts/signers/EthSecp256k1Wallet.ts
var EthSecp256k1Wallet = class EthSecp256k1Wallet {
	/**
	* Creates a EthSecp256k1Wallet from the given private key
	*
	* @param privKey The private key.
	* @param prefix The bech32 address prefix (human readable part). Defaults to "inj".
	*/
	static async fromKey(privKey, prefix = "inj") {
		return new EthSecp256k1Wallet(privKey, require_accounts.PrivateKey.fromHex(require_utils.uint8ArrayToHex(privKey)).toPublicKey().toPubKeyBytes(), prefix);
	}
	constructor(privKey, pubKey, prefix) {
		require_defineProperty._defineProperty(this, "privateKey", void 0);
		require_defineProperty._defineProperty(this, "publicKey", void 0);
		require_defineProperty._defineProperty(this, "prefix", void 0);
		this.privateKey = require_accounts.PrivateKey.fromHex(require_utils.uint8ArrayToHex(privKey));
		this.publicKey = require_accounts.PublicKey.fromBytes(pubKey);
		this.prefix = prefix;
	}
	get address() {
		return this.publicKey.toAddress().toBech32(this.prefix);
	}
	async getAccounts() {
		return [{
			algo: "eth_secp256k1",
			address: this.address,
			pubkey: this.publicKey.toPubKeyBytes()
		}];
	}
	async signAmino(signerAddress, signDoc) {
		if (signerAddress !== this.address) throw new Error(`Address ${signerAddress} not found in wallet`);
		const messageBytes = (0, __cosmjs_amino.serializeSignDoc)(signDoc);
		const signature = await this.privateKey.sign(messageBytes);
		return {
			signed: signDoc,
			signature: {
				pub_key: {
					type: "tendermint/PubKeyEthSecp256k1",
					value: this.publicKey.toBase64()
				},
				signature: require_utils.uint8ArrayToBase64(signature)
			}
		};
	}
};

//#endregion
//#region src/core/accounts/signers/DirectEthSecp256k1Wallet.ts
var DirectEthSecp256k1Wallet = class DirectEthSecp256k1Wallet {
	/**
	* Creates a DirectEthSecp256k1Wallet from the given private key
	*
	* @param privKey The private key.
	* @param prefix The bech32 address prefix (human readable part). Defaults to "inj".
	*/
	static async fromKey(privKey, prefix = "inj") {
		return new DirectEthSecp256k1Wallet(privKey, require_accounts.PrivateKey.fromHex(require_utils.uint8ArrayToHex(privKey)).toPublicKey().toPubKeyBytes(), prefix);
	}
	constructor(privKey, pubKey, prefix) {
		require_defineProperty._defineProperty(this, "privateKey", void 0);
		require_defineProperty._defineProperty(this, "publicKey", void 0);
		require_defineProperty._defineProperty(this, "prefix", void 0);
		this.privateKey = require_accounts.PrivateKey.fromHex(require_utils.uint8ArrayToHex(privKey));
		this.publicKey = require_accounts.PublicKey.fromBytes(pubKey);
		this.prefix = prefix;
	}
	get address() {
		return this.publicKey.toAddress().toBech32(this.prefix);
	}
	async getAccounts() {
		return [{
			algo: "eth_secp256k1",
			address: this.address,
			pubkey: this.publicKey.toPubKeyBytes()
		}];
	}
	async signDirect(address, signDoc) {
		const signBytes = (0, __cosmjs_proto_signing.makeSignBytes)(signDoc);
		if (address !== this.address) throw new Error(`Address ${address} not found in wallet`);
		const signature = await this.privateKey.sign(signBytes);
		return {
			signed: signDoc,
			signature: {
				pub_key: {
					type: "tendermint/PubKeyEthSecp256k1",
					value: this.publicKey.toBase64()
				},
				signature: require_utils.uint8ArrayToBase64(signature)
			}
		};
	}
};

//#endregion
Object.defineProperty(exports, 'DirectEthSecp256k1Wallet', {
  enumerable: true,
  get: function () {
    return DirectEthSecp256k1Wallet;
  }
});
Object.defineProperty(exports, 'EthSecp256k1Wallet', {
  enumerable: true,
  get: function () {
    return EthSecp256k1Wallet;
  }
});
Object.defineProperty(exports, 'MsgTransferCosmjs', {
  enumerable: true,
  get: function () {
    return MsgTransferCosmjs;
  }
});
Object.defineProperty(exports, 'SigningStargateClient', {
  enumerable: true,
  get: function () {
    return SigningStargateClient;
  }
});
Object.defineProperty(exports, 'StargateClient', {
  enumerable: true,
  get: function () {
    return StargateClient;
  }
});
Object.defineProperty(exports, 'accountParser', {
  enumerable: true,
  get: function () {
    return accountParser;
  }
});