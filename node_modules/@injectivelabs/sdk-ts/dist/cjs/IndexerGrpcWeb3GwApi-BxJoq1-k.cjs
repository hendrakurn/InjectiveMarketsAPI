const require_chunk = require('./chunk-CbDLau6x.cjs');
const require_utils = require('./utils-D3XFGv8y.cjs');
const require_defineProperty = require('./defineProperty-dyr5BsvG.cjs');
const require_BaseIndexerGrpcConsumer = require('./BaseIndexerGrpcConsumer-BBXxg_BR.cjs');
let __injectivelabs_core_proto_ts_v2_generated_cosmos_tx_v1beta1_tx_pb = require("@injectivelabs/core-proto-ts-v2/generated/cosmos/tx/v1beta1/tx_pb");
__injectivelabs_core_proto_ts_v2_generated_cosmos_tx_v1beta1_tx_pb = require_chunk.__toESM(__injectivelabs_core_proto_ts_v2_generated_cosmos_tx_v1beta1_tx_pb);
let __injectivelabs_utils = require("@injectivelabs/utils");
let __injectivelabs_exceptions = require("@injectivelabs/exceptions");
let __injectivelabs_core_proto_ts_v2_generated_cosmos_base_v1beta1_coin_pb = require("@injectivelabs/core-proto-ts-v2/generated/cosmos/base/v1beta1/coin_pb");
__injectivelabs_core_proto_ts_v2_generated_cosmos_base_v1beta1_coin_pb = require_chunk.__toESM(__injectivelabs_core_proto_ts_v2_generated_cosmos_base_v1beta1_coin_pb);
let __injectivelabs_indexer_proto_ts_v2_generated_injective_exchange_rpc_pb = require("@injectivelabs/indexer-proto-ts-v2/generated/injective_exchange_rpc_pb");
__injectivelabs_indexer_proto_ts_v2_generated_injective_exchange_rpc_pb = require_chunk.__toESM(__injectivelabs_indexer_proto_ts_v2_generated_injective_exchange_rpc_pb);
let __injectivelabs_indexer_proto_ts_v2_generated_injective_exchange_rpc_pb_client = require("@injectivelabs/indexer-proto-ts-v2/generated/injective_exchange_rpc_pb.client");

//#region src/client/indexer/types/mito.ts
const MitoGaugeStatus = {
	Active: "active",
	Live: "live"
};

//#endregion
//#region src/client/indexer/types/account.ts
const TransferType = {
	Internal: "internal",
	External: "external",
	Withdraw: "withdraw",
	Deposit: "deposit"
};

//#endregion
//#region src/client/indexer/types/trading.ts
const MarketType = {
	Spot: "spot",
	Derivative: "derivative"
};
const GridStrategyType = {
	Geometric: "geometric",
	Arithmetic: "arithmetic",
	Perpetual: "perpetual"
};

//#endregion
//#region src/client/indexer/types/explorer.ts
const AccessTypeCode = {
	AccessTypeUnspecified: 0,
	AccessTypeNobody: 1,
	AccessTypeOnlyAddress: 2,
	AccessTypeEverybody: 3,
	AccessTypeAnyOfAddresses: 4
};
const AccessType = {
	AccessTypeUnspecified: "Unspecified",
	AccessTypeNobody: "Nobody",
	AccessTypeOnlyAddress: "Only Address",
	AccessTypeEverybody: "Everybody",
	AccessTypeAnyOfAddresses: "Any of Addresses"
};
const ValidatorUptimeStatus = {
	Proposed: "proposed",
	Signed: "signed",
	Missed: "missed"
};

//#endregion
//#region src/client/indexer/types/insurance-funds.ts
const RedemptionStatus = {
	Pending: "pending",
	Disbursed: "disbursed"
};

//#endregion
//#region src/client/indexer/types/index.ts
const IndexerModule = { ...__injectivelabs_exceptions.IndexerErrorModule };

//#endregion
//#region src/client/indexer/grpc/IndexerGrpcTransactionApi.ts
/**
* @category Indexer Grpc API
* @deprecated use IndexerGrpcWeb3GwApi
*/
var IndexerGrpcTransactionApi = class extends require_BaseIndexerGrpcConsumer.BaseIndexerGrpcConsumer {
	constructor(..._args) {
		super(..._args);
		require_defineProperty._defineProperty(this, "module", IndexerModule.Transaction);
	}
	get client() {
		return this.initClient(__injectivelabs_indexer_proto_ts_v2_generated_injective_exchange_rpc_pb_client.InjectiveExchangeRPCClient);
	}
	async prepareTxRequest(args) {
		const { address, chainId, message, memo, estimateGas = true, gasLimit = __injectivelabs_utils.DEFAULT_GAS_LIMIT, feeDenom = __injectivelabs_utils.DEFAULT_BRIDGE_FEE_DENOM, feePrice = __injectivelabs_utils.DEFAULT_BRIDGE_FEE_PRICE, timeoutHeight } = args;
		const txFeeAmount = __injectivelabs_core_proto_ts_v2_generated_cosmos_base_v1beta1_coin_pb.Coin.create();
		txFeeAmount.denom = feeDenom;
		txFeeAmount.amount = feePrice;
		const cosmosTxFee = __injectivelabs_indexer_proto_ts_v2_generated_injective_exchange_rpc_pb.CosmosTxFee.create();
		cosmosTxFee.price = [txFeeAmount];
		if (!estimateGas) cosmosTxFee.gas = BigInt(gasLimit);
		const prepareTxRequest = __injectivelabs_indexer_proto_ts_v2_generated_injective_exchange_rpc_pb.PrepareTxRequest.create();
		prepareTxRequest.chainId = BigInt(chainId);
		prepareTxRequest.signerAddress = address;
		prepareTxRequest.fee = cosmosTxFee;
		prepareTxRequest.msgs = (Array.isArray(message) ? message : [message]).map((message$1) => require_utils.stringToUint8Array(require_utils.safeBigIntStringify(message$1)));
		if (timeoutHeight !== void 0) prepareTxRequest.timeoutHeight = BigInt(timeoutHeight);
		if (memo) prepareTxRequest.memo = typeof memo === "number" ? memo.toString() : memo;
		return await this.executeGrpcCall(prepareTxRequest, this.client.prepareTx.bind(this.client));
	}
	async prepareExchangeTxRequest(args) {
		return this.prepareTxRequest({
			...args,
			gasLimit: args.gasLimit || __injectivelabs_utils.DEFAULT_EXCHANGE_LIMIT
		});
	}
	async prepareCosmosTxRequest({ memo, address, message, estimateGas = true, gasLimit = __injectivelabs_utils.DEFAULT_GAS_LIMIT, feeDenom = __injectivelabs_utils.DEFAULT_BRIDGE_FEE_DENOM, feePrice = __injectivelabs_utils.DEFAULT_BRIDGE_FEE_PRICE, timeoutHeight }) {
		const txFeeAmount = __injectivelabs_core_proto_ts_v2_generated_cosmos_base_v1beta1_coin_pb.Coin.create();
		txFeeAmount.denom = feeDenom;
		txFeeAmount.amount = feePrice;
		const cosmosTxFee = __injectivelabs_indexer_proto_ts_v2_generated_injective_exchange_rpc_pb.CosmosTxFee.create();
		cosmosTxFee.price = [txFeeAmount];
		if (!estimateGas) cosmosTxFee.gas = BigInt(gasLimit);
		const prepareTxRequest = __injectivelabs_indexer_proto_ts_v2_generated_injective_exchange_rpc_pb.PrepareCosmosTxRequest.create();
		prepareTxRequest.fee = cosmosTxFee;
		prepareTxRequest.senderAddress = address;
		prepareTxRequest.msgs = (Array.isArray(message) ? message : [message]).map((message$1) => require_utils.stringToUint8Array(require_utils.safeBigIntStringify(message$1)));
		if (timeoutHeight !== void 0) prepareTxRequest.timeoutHeight = BigInt(timeoutHeight);
		if (memo) prepareTxRequest.memo = typeof memo === "number" ? memo.toString() : memo;
		return await this.executeGrpcCall(prepareTxRequest, this.client.prepareCosmosTx.bind(this.client));
	}
	/**
	* Keep in mind that the transaction is just added
	* to the mempool, we need to query the transaction hash
	* if we want to ensure that the transaction is included
	* in the block
	*/
	async broadcastTxRequest({ signature, chainId, message, txResponse }) {
		const parsedTypedData = JSON.parse(txResponse.data);
		let publicKeyHex;
		try {
			publicKeyHex = await require_utils.recoverTypedSignaturePubKey(parsedTypedData, signature);
		} catch (e) {
			throw new __injectivelabs_exceptions.TransactionException(e, {
				code: __injectivelabs_exceptions.UnspecifiedErrorCode,
				context: "Web3Gateway.RecoverTypedSignaturePubKey",
				type: __injectivelabs_exceptions.ErrorType.Web3Gateway
			});
		}
		const cosmosPubKey = __injectivelabs_indexer_proto_ts_v2_generated_injective_exchange_rpc_pb.CosmosPubKey.create();
		cosmosPubKey.type = txResponse.pubKeyType;
		cosmosPubKey.key = publicKeyHex;
		parsedTypedData.message.msgs = null;
		const broadcastTxRequest = __injectivelabs_indexer_proto_ts_v2_generated_injective_exchange_rpc_pb.BroadcastTxRequest.create();
		broadcastTxRequest.mode = "sync";
		broadcastTxRequest.chainId = BigInt(chainId);
		broadcastTxRequest.pubKey = cosmosPubKey;
		broadcastTxRequest.signature = signature;
		broadcastTxRequest.tx = require_utils.stringToUint8Array(require_utils.safeBigIntStringify(parsedTypedData.message));
		broadcastTxRequest.feePayer = txResponse.feePayer;
		broadcastTxRequest.feePayerSig = txResponse.feePayerSig;
		broadcastTxRequest.msgs = (Array.isArray(message) ? message : [message]).map((message$1) => require_utils.stringToUint8Array(require_utils.safeBigIntStringify(message$1)));
		return await this.executeGrpcCall(broadcastTxRequest, this.client.broadcastTx.bind(this.client));
	}
	/**
	* Keep in mind that the transaction is just added
	* to the mempool, we need to query the transaction hash
	* if we want to ensure that the transaction is included
	* in the block
	*/
	async broadcastCosmosTxRequest({ address, signature, txRaw, pubKey }) {
		const pubKeyInHex = require_utils.uint8ArrayToHex(require_utils.base64ToUint8Array(pubKey.value));
		const signatureInHex = require_utils.uint8ArrayToHex(require_utils.base64ToUint8Array(signature));
		const cosmosPubKey = __injectivelabs_indexer_proto_ts_v2_generated_injective_exchange_rpc_pb.CosmosPubKey.create();
		cosmosPubKey.type = pubKey.type;
		cosmosPubKey.key = `0x${pubKeyInHex}`;
		txRaw.signatures = [];
		const broadcastTxRequest = __injectivelabs_indexer_proto_ts_v2_generated_injective_exchange_rpc_pb.BroadcastCosmosTxRequest.create();
		broadcastTxRequest.senderAddress = address;
		broadcastTxRequest.pubKey = cosmosPubKey;
		broadcastTxRequest.signature = `0x${signatureInHex}`;
		broadcastTxRequest.tx = __injectivelabs_core_proto_ts_v2_generated_cosmos_tx_v1beta1_tx_pb.TxRaw.toBinary(txRaw);
		return await this.executeGrpcCall(broadcastTxRequest, this.client.broadcastCosmosTx.bind(this.client));
	}
	async fetchFeePayer() {
		const request = __injectivelabs_indexer_proto_ts_v2_generated_injective_exchange_rpc_pb.GetFeePayerRequest.create();
		return await this.executeGrpcCall(request, this.client.getFeePayer.bind(this.client));
	}
};

//#endregion
//#region src/client/indexer/grpc/IndexerGrpcWeb3GwApi.ts
/**
* @category Indexer Grpc API
*/
var IndexerGrpcWeb3GwApi = class extends IndexerGrpcTransactionApi {
	constructor(..._args) {
		super(..._args);
		require_defineProperty._defineProperty(this, "module", IndexerModule.Web3Gw);
	}
	async prepareEip712Request({ address, chainId, message, memo, sequence, accountNumber, estimateGas = false, gasLimit = __injectivelabs_utils.DEFAULT_GAS_LIMIT, feeDenom = __injectivelabs_utils.DEFAULT_BRIDGE_FEE_DENOM, feePrice = __injectivelabs_utils.DEFAULT_BRIDGE_FEE_PRICE, timeoutHeight, eip712Version = "v1" }) {
		const txFeeAmount = __injectivelabs_core_proto_ts_v2_generated_cosmos_base_v1beta1_coin_pb.Coin.create({
			denom: feeDenom,
			amount: feePrice
		});
		const cosmosTxFee = __injectivelabs_indexer_proto_ts_v2_generated_injective_exchange_rpc_pb.CosmosTxFee.create();
		cosmosTxFee.price = [txFeeAmount];
		if (!estimateGas) cosmosTxFee.gas = BigInt(gasLimit);
		const prepareTxRequest = __injectivelabs_indexer_proto_ts_v2_generated_injective_exchange_rpc_pb.PrepareEip712Request.create();
		prepareTxRequest.chainId = BigInt(chainId);
		prepareTxRequest.signerAddress = address;
		prepareTxRequest.fee = cosmosTxFee;
		prepareTxRequest.msgs = (Array.isArray(message) ? message : [message]).map((message$1) => require_utils.stringToUint8Array(require_utils.safeBigIntStringify(message$1)));
		if (timeoutHeight !== void 0) prepareTxRequest.timeoutHeight = BigInt(timeoutHeight);
		if (memo) prepareTxRequest.memo = typeof memo === "number" ? memo.toString() : memo;
		if (eip712Version) prepareTxRequest.eip712Wrapper = eip712Version;
		if (accountNumber) prepareTxRequest.accountNumber = BigInt(accountNumber);
		if (sequence) prepareTxRequest.sequence = BigInt(sequence);
		return await this.executeGrpcCall(prepareTxRequest, this.client.prepareEip712.bind(this.client));
	}
};

//#endregion
Object.defineProperty(exports, 'AccessType', {
  enumerable: true,
  get: function () {
    return AccessType;
  }
});
Object.defineProperty(exports, 'AccessTypeCode', {
  enumerable: true,
  get: function () {
    return AccessTypeCode;
  }
});
Object.defineProperty(exports, 'GridStrategyType', {
  enumerable: true,
  get: function () {
    return GridStrategyType;
  }
});
Object.defineProperty(exports, 'IndexerGrpcTransactionApi', {
  enumerable: true,
  get: function () {
    return IndexerGrpcTransactionApi;
  }
});
Object.defineProperty(exports, 'IndexerGrpcWeb3GwApi', {
  enumerable: true,
  get: function () {
    return IndexerGrpcWeb3GwApi;
  }
});
Object.defineProperty(exports, 'IndexerModule', {
  enumerable: true,
  get: function () {
    return IndexerModule;
  }
});
Object.defineProperty(exports, 'MarketType', {
  enumerable: true,
  get: function () {
    return MarketType;
  }
});
Object.defineProperty(exports, 'MitoGaugeStatus', {
  enumerable: true,
  get: function () {
    return MitoGaugeStatus;
  }
});
Object.defineProperty(exports, 'RedemptionStatus', {
  enumerable: true,
  get: function () {
    return RedemptionStatus;
  }
});
Object.defineProperty(exports, 'TransferType', {
  enumerable: true,
  get: function () {
    return TransferType;
  }
});
Object.defineProperty(exports, 'ValidatorUptimeStatus', {
  enumerable: true,
  get: function () {
    return ValidatorUptimeStatus;
  }
});