const require_chunk = require('./chunk-CbDLau6x.cjs');
const require_utils = require('./utils-D3XFGv8y.cjs');
const require_defineProperty = require('./defineProperty-dyr5BsvG.cjs');
const require_accounts = require('./accounts-HFzAaFRB.cjs');
const require_ChainRestTendermintApi = require('./ChainRestTendermintApi-CyeoAmer.cjs');
const require_BaseGrpcConsumer = require('./BaseGrpcConsumer-Db3sCC6b.cjs');
const require_IndexerGrpcWeb3GwApi = require('./IndexerGrpcWeb3GwApi-BxJoq1-k.cjs');
let __injectivelabs_core_proto_ts_v2_generated_cosmos_tx_v1beta1_tx_pb = require("@injectivelabs/core-proto-ts-v2/generated/cosmos/tx/v1beta1/tx_pb");
__injectivelabs_core_proto_ts_v2_generated_cosmos_tx_v1beta1_tx_pb = require_chunk.__toESM(__injectivelabs_core_proto_ts_v2_generated_cosmos_tx_v1beta1_tx_pb);
let viem = require("viem");
let __injectivelabs_utils = require("@injectivelabs/utils");
let __injectivelabs_exceptions = require("@injectivelabs/exceptions");
let __injectivelabs_networks = require("@injectivelabs/networks");
let http_status_codes = require("http-status-codes");
let __injectivelabs_core_proto_ts_v2_generated_cosmos_tx_signing_v1beta1_signing_pb = require("@injectivelabs/core-proto-ts-v2/generated/cosmos/tx/signing/v1beta1/signing_pb");
__injectivelabs_core_proto_ts_v2_generated_cosmos_tx_signing_v1beta1_signing_pb = require_chunk.__toESM(__injectivelabs_core_proto_ts_v2_generated_cosmos_tx_signing_v1beta1_signing_pb);
let __injectivelabs_core_proto_ts_v2_generated_cosmos_tx_v1beta1_service_pb = require("@injectivelabs/core-proto-ts-v2/generated/cosmos/tx/v1beta1/service_pb");
__injectivelabs_core_proto_ts_v2_generated_cosmos_tx_v1beta1_service_pb = require_chunk.__toESM(__injectivelabs_core_proto_ts_v2_generated_cosmos_tx_v1beta1_service_pb);
let __injectivelabs_core_proto_ts_v2_generated_cosmos_tx_v1beta1_service_pb_client = require("@injectivelabs/core-proto-ts-v2/generated/cosmos/tx/v1beta1/service_pb.client");
let axios = require("axios");
axios = require_chunk.__toESM(axios);

//#region src/core/tx/utils/api.ts
const isTxNotFoundError = (error) => {
	if (!error.response) {
		const errorToString = error.toString();
		return [
			"404",
			"not found",
			"timeout"
		].some((code) => errorToString.includes(code));
	}
	const message = error.response.data ? error.response.data.message : error.toString();
	if (message.includes("404")) return true;
	if (message.includes("not found")) return true;
	return false;
};
const errorToErrorMessage = (error) => {
	if (!error.response) return error.toString();
	return error.response.data ? error.response.data.message : error.toString();
};

//#endregion
//#region src/core/tx/utils/constants.ts
const SIGN_DIRECT = __injectivelabs_core_proto_ts_v2_generated_cosmos_tx_signing_v1beta1_signing_pb.SignMode.DIRECT;
const SIGN_AMINO = __injectivelabs_core_proto_ts_v2_generated_cosmos_tx_signing_v1beta1_signing_pb.SignMode.LEGACY_AMINO_JSON;
const SIGN_EIP712 = __injectivelabs_core_proto_ts_v2_generated_cosmos_tx_signing_v1beta1_signing_pb.SignMode.LEGACY_AMINO_JSON;
const SIGN_EIP712_V2 = __injectivelabs_core_proto_ts_v2_generated_cosmos_tx_signing_v1beta1_signing_pb.SignMode.EIP712_V2;

//#endregion
//#region src/core/tx/utils/classes/TxClient.ts
var TxClient = class TxClient {
	/**
	* Encode a transaction to base64-encoded protobuf
	* @param tx transaction to encode
	*/
	static encode(tx) {
		return require_utils.uint8ArrayToBase64(__injectivelabs_core_proto_ts_v2_generated_cosmos_tx_v1beta1_tx_pb.TxRaw.toBinary(tx));
	}
	/**
	* Decode a transaction from base64-encoded protobuf
	* @param tx transaction string to decode
	*/
	static decode(encodedTx) {
		return __injectivelabs_core_proto_ts_v2_generated_cosmos_tx_v1beta1_tx_pb.TxRaw.fromBinary(require_utils.base64ToUint8Array(encodedTx));
	}
	/**
	* Get the transaction's hash
	* @param tx transaction to hash
	*/
	static hash(tx) {
		return require_utils.hashToHex(TxClient.encode(tx));
	}
};

//#endregion
//#region src/core/tx/tx.ts
/**
* @typedef {Object} CreateTransactionWithSignersArgs
* @param {CreateTransactionWithSignersArgs} params
* @property {Msg | Msg[]} message - the Cosmos messages to wrap them in a transaction
* @property {string} memo - the memo to attach to the transaction
* @property {StdFee} fee - the fee to attach to the transaction
* @property {SignerDetails} signers - the signers of the transaction
* @property {number} number - the account number to attach to the transaction
* @property {number} chainId - the chain-id to attach to the transaction
* @property {string} pubKey - the account pubKey to attach to the transaction (in base64)
*
* @typedef {Object} CreateTransactionResult
* @property {TxRaw} txRaw  - the Tx raw that was created
* @property {SignDoc} signDoc  - the SignDoc that was created - used for signing of the transaction
* @property {SignerDetails} signers  - the signers of the transaction
* @property {Uint8Array} bodyBytes  - the body bytes of the transaction
* @property {Uint8Array} authInfoBytes  - the auth info bytes of the transaction
* @property {Uint8Array} signBytes  - the sign bytes of the transaction (SignDoc serialized to binary)
* @property {Uint8Array} signHashedBytes  - the sign bytes of the transaction (SignDoc serialized to binary) and hashed using keccak256
* @returns {CreateTransactionResult} result
*/
const createTransactionWithSigners = ({ signers, chainId, message, timeoutHeight, memo = "", fee = (0, __injectivelabs_utils.getDefaultStdFee)(), signMode = SIGN_DIRECT }) => {
	const actualSigners = Array.isArray(signers) ? signers : [signers];
	const [signer] = actualSigners;
	const body = require_accounts.createBody({
		message,
		memo,
		timeoutHeight
	});
	const actualFee = typeof fee === "string" ? (0, __injectivelabs_utils.getStdFeeFromString)(fee) : fee;
	const feeMessage = require_accounts.createFee({
		fee: actualFee.amount[0],
		payer: actualFee.payer,
		granter: actualFee.granter,
		gasLimit: parseInt(actualFee.gas, 10)
	});
	const authInfo = require_accounts.createAuthInfo({
		signerInfo: require_accounts.createSigners({
			chainId,
			mode: signMode,
			signers: actualSigners
		}),
		fee: feeMessage
	});
	const bodyBytes = __injectivelabs_core_proto_ts_v2_generated_cosmos_tx_v1beta1_tx_pb.TxBody.toBinary(body);
	const authInfoBytes = __injectivelabs_core_proto_ts_v2_generated_cosmos_tx_v1beta1_tx_pb.AuthInfo.toBinary(authInfo);
	const signDoc = require_accounts.createSignDoc({
		chainId,
		bodyBytes,
		authInfoBytes,
		accountNumber: signer.accountNumber
	});
	const signDocBytes = __injectivelabs_core_proto_ts_v2_generated_cosmos_tx_v1beta1_tx_pb.SignDoc.toBinary(signDoc);
	const toSignBytes = signDocBytes;
	const toSignHash = (0, viem.keccak256)(signDocBytes, "bytes");
	const txRaw = __injectivelabs_core_proto_ts_v2_generated_cosmos_tx_v1beta1_tx_pb.TxRaw.create();
	txRaw.authInfoBytes = authInfoBytes;
	txRaw.bodyBytes = bodyBytes;
	return {
		txRaw,
		signDoc,
		signers,
		signer,
		signBytes: toSignBytes,
		signHashedBytes: toSignHash,
		bodyBytes,
		authInfoBytes
	};
};
/**
* @typedef {Object} CreateTransactionArgs
* @param {CreateTransactionArgs} params
* @property {MsgArg | MsgArg[]} message - the Cosmos messages to wrap them in a transaction
* @property {string} memo - the memo to attach to the transaction
* @property {StdFee} fee - the fee to attach to the transaction
* @property {string} sequence - the account sequence to attach to the transaction
* @property {number} number - the account number to attach to the transaction
* @property {number} chainId - the chain-id to attach to the transaction
* @property {string} pubKey - the account pubKey to attach to the transaction (in base64)
*
* @typedef {Object} CreateTransactionResult
* @property {TxRaw} txRaw  // the Tx raw that was created
* @property {SignDoc} signDoc  // the SignDoc that was created - used for signing of the transaction
* @property {number} accountNumber  // the account number of the signer of the transaction
* @property {Uint8Array} bodyBytes  // the body bytes of the transaction
* @property {Uint8Array} authInfoBytes  // the auth info bytes of the transaction
* @property {Uint8Array} signBytes  // the sign bytes of the transaction (SignDoc serialized to binary)
* @property {Uint8Array} signHashedBytes  // the sign bytes of the transaction (SignDoc serialized to binary) and hashed using keccak256
* @returns {CreateTransactionResult} result
*/
const createTransaction = (args) => {
	return createTransactionWithSigners({
		...args,
		signers: {
			pubKey: args.pubKey,
			accountNumber: args.accountNumber,
			sequence: args.sequence
		}
	});
};
/**
* Used when we want to pass a Msg class instead of the {type, message}
* object of the Message (using the toDirectSign() method)
* @returns
*/
const createTransactionFromMsg = (params) => {
	const messages = Array.isArray(params.message) ? params.message : [params.message];
	return createTransaction({
		...params,
		message: messages
	});
};
/**
* Used when we get a DirectSignResponse from
* Cosmos native wallets like Keplr, Leap, etc after
* the TxRaw has been signed.
*
* The reason why we need to create a new TxRaw and
* not use the one that we passed to signing is that the users
* can change the gas fees and that will alter the original
* TxRaw which will cause signature miss match if we broadcast
* that transaction on chain
* @returns TxRaw
*/
const createTxRawFromSigResponse = (response) => {
	if (response.signed === void 0) return response;
	const directSignResponse = response;
	const txRaw = __injectivelabs_core_proto_ts_v2_generated_cosmos_tx_v1beta1_tx_pb.TxRaw.create();
	txRaw.authInfoBytes = directSignResponse.signed.authInfoBytes;
	txRaw.bodyBytes = directSignResponse.signed.bodyBytes;
	txRaw.signatures = [require_utils.base64ToUint8Array(directSignResponse.signature.signature)];
	return txRaw;
};
/**
* Used when we don't have account details and block details
* and we pass the message and the user's address only
* @returns
*/
const createTransactionForAddressAndMsg = async (params) => {
	const messages = Array.isArray(params.message) ? params.message : [params.message];
	const chainRestAuthApi = new require_ChainRestTendermintApi.ChainRestAuthApi(params.endpoint);
	const tendermintRestApi = new require_ChainRestTendermintApi.ChainRestTendermintApi(params.endpoint);
	/** Account Details * */
	const accountDetails = await chainRestAuthApi.fetchCosmosAccount(params.address);
	const baseAccount = require_accounts.BaseAccount.fromRestCosmosApi(accountDetails);
	const latestHeight = (await tendermintRestApi.fetchLatestBlock()).header.height;
	const timeoutHeight = (0, __injectivelabs_utils.toBigNumber)(latestHeight).plus(__injectivelabs_utils.DEFAULT_BLOCK_TIMEOUT_HEIGHT);
	if (!(params.pubKey || baseAccount.pubKey.key)) throw new __injectivelabs_exceptions.GeneralException(/* @__PURE__ */ new Error(`The pubKey for ${params.address} is missing.`));
	return createTransaction({
		...params,
		pubKey: params.pubKey || baseAccount.pubKey.key,
		sequence: Number(baseAccount.sequence),
		accountNumber: Number(baseAccount.accountNumber),
		timeoutHeight: timeoutHeight.toNumber(),
		message: messages
	});
};
const createTransactionAndCosmosSignDoc = (args) => {
	const result = createTransaction(args);
	const [signer] = Array.isArray(result.signers) ? result.signers : [result.signers];
	return {
		...result,
		cosmosSignDoc: __injectivelabs_core_proto_ts_v2_generated_cosmos_tx_v1beta1_tx_pb.SignDoc.create({
			bodyBytes: result.bodyBytes,
			authInfoBytes: result.authInfoBytes,
			accountNumber: BigInt(signer.accountNumber),
			chainId: args.chainId
		})
	};
};
const createTransactionAndCosmosSignDocForAddressAndMsg = async (params) => {
	const result = await createTransactionForAddressAndMsg(params);
	const [signer] = Array.isArray(result.signers) ? result.signers : [result.signers];
	return {
		...result,
		cosmosSignDoc: __injectivelabs_core_proto_ts_v2_generated_cosmos_tx_v1beta1_tx_pb.SignDoc.create({
			bodyBytes: result.bodyBytes,
			authInfoBytes: result.authInfoBytes,
			accountNumber: BigInt(signer.accountNumber),
			chainId: params.chainId
		})
	};
};
const getTxRawFromTxRawOrDirectSignResponse = (txRawOrDirectSignResponse) => {
	return txRawOrDirectSignResponse.signed === void 0 ? txRawOrDirectSignResponse : createTxRawFromSigResponse(txRawOrDirectSignResponse);
};

//#endregion
//#region src/core/tx/api/TxGrpcApi.ts
var TxGrpcApi = class extends require_BaseGrpcConsumer.BaseGrpcConsumer {
	constructor(..._args) {
		super(..._args);
		require_defineProperty._defineProperty(this, "module", "TxGrpcApi");
	}
	get client() {
		return this.initClient(__injectivelabs_core_proto_ts_v2_generated_cosmos_tx_v1beta1_service_pb_client.ServiceClient);
	}
	async fetchTx(hash) {
		const request = __injectivelabs_core_proto_ts_v2_generated_cosmos_tx_v1beta1_service_pb.GetTxRequest.create();
		request.hash = hash;
		try {
			const txResponse = (await this.executeGrpcCall(request, this.client.getTx.bind(this.client))).txResponse;
			if (!txResponse) throw new __injectivelabs_exceptions.GrpcUnaryRequestException(/* @__PURE__ */ new Error(`The transaction with ${hash} is not found`), {
				context: "TxGrpcApi",
				contextModule: "fetch-tx"
			});
			if (txResponse.code !== 0) throw new __injectivelabs_exceptions.TransactionException(new Error(txResponse.rawLog), {
				contextCode: Number(txResponse.code),
				contextModule: txResponse.codespace
			});
			return {
				...txResponse,
				height: Number(txResponse.height),
				gasWanted: Number(txResponse.gasWanted),
				gasUsed: Number(txResponse.gasUsed),
				txHash: txResponse.txhash
			};
		} catch (e) {
			if (e instanceof __injectivelabs_exceptions.TransactionException) throw e;
			if (e instanceof __injectivelabs_exceptions.GrpcUnaryRequestException) throw e;
			throw new __injectivelabs_exceptions.GrpcUnaryRequestException(/* @__PURE__ */ new Error("There was an issue while fetching transaction details"), {
				context: "TxGrpcApi",
				contextModule: "fetch-tx"
			});
		}
	}
	async fetchTxPoll(txHash, timeout = __injectivelabs_utils.DEFAULT_TX_BLOCK_INCLUSION_TIMEOUT_IN_MS) {
		const POLL_INTERVAL = __injectivelabs_utils.DEFAULT_BLOCK_TIME_IN_SECONDS * 1e3;
		for (let i = 0; i <= timeout / POLL_INTERVAL; i += 1) {
			try {
				const txResponse = await this.fetchTx(txHash);
				if (txResponse) return txResponse;
			} catch (e) {
				if (e instanceof __injectivelabs_exceptions.TransactionException) throw e;
			}
			await new Promise((resolve) => setTimeout(resolve, POLL_INTERVAL));
		}
		throw new __injectivelabs_exceptions.GrpcUnaryRequestException(/* @__PURE__ */ new Error(`Transaction was not included in a block before timeout of ${timeout}ms`), {
			context: "TxGrpcApi",
			contextModule: "fetch-tx-poll"
		});
	}
	async simulate(txRaw) {
		const txRawClone = __injectivelabs_core_proto_ts_v2_generated_cosmos_tx_v1beta1_tx_pb.TxRaw.create({ ...txRaw });
		const simulateRequest = __injectivelabs_core_proto_ts_v2_generated_cosmos_tx_v1beta1_service_pb.SimulateRequest.create();
		if (txRawClone.signatures.length === 0) txRawClone.signatures = [new Uint8Array(0)];
		simulateRequest.txBytes = __injectivelabs_core_proto_ts_v2_generated_cosmos_tx_v1beta1_tx_pb.TxRaw.toBinary(txRawClone);
		try {
			var _response$result, _response$result2, _response$result3;
			const response = await this.executeGrpcCall(simulateRequest, this.client.simulate.bind(this.client));
			return {
				result: {
					...response.result,
					data: ((_response$result = response.result) === null || _response$result === void 0 ? void 0 : _response$result.data) || "",
					log: ((_response$result2 = response.result) === null || _response$result2 === void 0 ? void 0 : _response$result2.log) || "",
					eventsList: ((_response$result3 = response.result) === null || _response$result3 === void 0 ? void 0 : _response$result3.events) || []
				},
				gasInfo: {
					...response.gasInfo,
					gasWanted: response.gasInfo ? Number(response.gasInfo.gasWanted) : 0,
					gasUsed: response.gasInfo ? Number(response.gasInfo.gasUsed) : 0
				}
			};
		} catch (e) {
			throw new __injectivelabs_exceptions.TransactionException(e, {
				context: "TxGrpcApi.simulate",
				skipParsing: true
			});
		}
	}
	async broadcast(txRaw, options) {
		const mode = (options === null || options === void 0 ? void 0 : options.mode) || __injectivelabs_core_proto_ts_v2_generated_cosmos_tx_v1beta1_service_pb.BroadcastMode.SYNC;
		const timeout = (options === null || options === void 0 ? void 0 : options.timeout) || (0, __injectivelabs_utils.toBigNumber)((options === null || options === void 0 ? void 0 : options.txTimeout) || __injectivelabs_utils.DEFAULT_BLOCK_TIMEOUT_HEIGHT).times(__injectivelabs_utils.DEFAULT_BLOCK_TIME_IN_SECONDS * 1e3).toNumber();
		const broadcastTxRequest = __injectivelabs_core_proto_ts_v2_generated_cosmos_tx_v1beta1_service_pb.BroadcastTxRequest.create();
		broadcastTxRequest.txBytes = __injectivelabs_core_proto_ts_v2_generated_cosmos_tx_v1beta1_tx_pb.TxRaw.toBinary(txRaw);
		broadcastTxRequest.mode = mode;
		try {
			const txResponse = (await this.executeGrpcCall(broadcastTxRequest, this.client.broadcastTx.bind(this.client))).txResponse;
			if (!txResponse) throw new __injectivelabs_exceptions.GrpcUnaryRequestException(/* @__PURE__ */ new Error(`The transaction has failed to be broadcasted`), {
				context: "TxGrpcApi.broadcast",
				contextModule: "broadcast"
			});
			if (txResponse.code !== 0) throw new __injectivelabs_exceptions.TransactionException(new Error(txResponse.rawLog), {
				contextCode: Number(txResponse.code),
				contextModule: txResponse.codespace
			});
			return await this.fetchTxPoll(txResponse.txhash, timeout);
		} catch (e) {
			if (e instanceof __injectivelabs_exceptions.TransactionException) throw e;
			if (e instanceof __injectivelabs_exceptions.GrpcUnaryRequestException) throw e;
			throw new __injectivelabs_exceptions.TransactionException(new Error(e));
		}
	}
	/** @deprecated - the BLOCK mode broadcasting is deprecated now, use either sync or async */
	async broadcastBlock(txRaw) {
		const broadcastTxRequest = __injectivelabs_core_proto_ts_v2_generated_cosmos_tx_v1beta1_service_pb.BroadcastTxRequest.create();
		broadcastTxRequest.txBytes = __injectivelabs_core_proto_ts_v2_generated_cosmos_tx_v1beta1_tx_pb.TxRaw.toBinary(txRaw);
		broadcastTxRequest.mode = __injectivelabs_core_proto_ts_v2_generated_cosmos_tx_v1beta1_service_pb.BroadcastMode.BLOCK;
		try {
			const txResponse = (await this.executeGrpcCall(broadcastTxRequest, this.client.broadcastTx.bind(this.client))).txResponse;
			if (!txResponse) throw new __injectivelabs_exceptions.GeneralException(/* @__PURE__ */ new Error("There was an issue broadcasting the transaction"));
			const result = {
				...txResponse,
				height: Number(txResponse.height),
				gasWanted: Number(txResponse.gasWanted),
				gasUsed: Number(txResponse.gasUsed),
				txHash: txResponse.txhash
			};
			if (result.code !== 0) throw new __injectivelabs_exceptions.TransactionException(new Error(result.rawLog), {
				contextCode: result.code,
				contextModule: result.codespace
			});
			return result;
		} catch (e) {
			if (e instanceof __injectivelabs_exceptions.TransactionException) throw e;
			throw new __injectivelabs_exceptions.TransactionException(new Error(e));
		}
	}
};

//#endregion
//#region src/core/tx/types/tx-rest-client.ts
const BroadcastMode = {
	Sync: "BROADCAST_MODE_SYNC",
	Async: "BROADCAST_MODE_ASYNC",
	Block: "BROADCAST_MODE_BLOCK"
};
const BroadcastModeKeplr = {
	Sync: "sync",
	Async: "async",
	Block: "block"
};

//#endregion
//#region src/core/tx/api/TxRestApi.ts
/**
* It is recommended to use TxGrpcClient instead of TxRestApi
*/
var TxRestApi = class {
	constructor(endpoint, options) {
		require_defineProperty._defineProperty(this, "httpClient", void 0);
		this.httpClient = new __injectivelabs_utils.HttpClient(endpoint, {
			headers: { Accept: "application/json" },
			timeout: (options === null || options === void 0 ? void 0 : options.timeout) || 15e3
		});
	}
	async fetchTx(txHash, params = {}) {
		try {
			const { tx_response: txResponse } = await this.getRaw(`/cosmos/tx/v1beta1/txs/${txHash}`, params);
			if (!txResponse) throw new __injectivelabs_exceptions.HttpRequestException(/* @__PURE__ */ new Error(`The transaction with ${txHash} is not found`), {
				context: `/cosmos/tx/v1beta1/txs/${txHash}`,
				contextModule: "TxRestApi.fetch-tx"
			});
			if (parseInt(txResponse.code.toString(), 10) !== 0) throw new __injectivelabs_exceptions.TransactionException(new Error(txResponse.raw_log), {
				contextCode: txResponse.code,
				contextModule: txResponse.codespace
			});
			return {
				...txResponse,
				rawLog: txResponse.raw_log,
				gasWanted: parseInt(txResponse.gas_wanted, 10),
				gasUsed: parseInt(txResponse.gas_used, 10),
				height: parseInt(txResponse.height, 10),
				txHash: txResponse.txhash
			};
		} catch (e) {
			if (e instanceof __injectivelabs_exceptions.TransactionException) throw e;
			if (e instanceof __injectivelabs_exceptions.HttpRequestException) throw e;
			throw new __injectivelabs_exceptions.HttpRequestException(/* @__PURE__ */ new Error("There was an issue while fetching transaction details"), {
				context: `/cosmos/tx/v1beta1/txs/${txHash}`,
				contextModule: "TxRestApi.fetch-tx"
			});
		}
	}
	async fetchTxPoll(txHash, timeout = __injectivelabs_utils.DEFAULT_TX_BLOCK_INCLUSION_TIMEOUT_IN_MS || 6e4) {
		const POLL_INTERVAL = __injectivelabs_utils.DEFAULT_BLOCK_TIME_IN_SECONDS * 1e3;
		for (let i = 0; i <= timeout / POLL_INTERVAL; i += 1) {
			try {
				const txResponse = await this.fetchTx(txHash);
				if (txResponse) return txResponse;
			} catch (e) {
				if (e instanceof __injectivelabs_exceptions.TransactionException) throw e;
			}
			await new Promise((resolve) => setTimeout(resolve, POLL_INTERVAL));
		}
		throw new __injectivelabs_exceptions.HttpRequestException(/* @__PURE__ */ new Error(`Transaction was not included in a block before timeout of ${timeout}ms`), {
			context: `/cosmos/tx/v1beta1/txs/${txHash}`,
			contextModule: "TxRestApi.fetch-tx-poll"
		});
	}
	async simulate(txRaw) {
		const txRawClone = __injectivelabs_core_proto_ts_v2_generated_cosmos_tx_v1beta1_tx_pb.TxRaw.create({ ...txRaw });
		if (txRawClone.signatures.length === 0) txRawClone.signatures = [new Uint8Array(0)];
		try {
			const response = await this.postRaw("/cosmos/tx/v1beta1/simulate", { tx_bytes: TxClient.encode(txRawClone) });
			return {
				result: {
					data: response.result.data,
					log: response.result.log,
					eventsList: response.result.events
				},
				gasInfo: {
					gasWanted: parseInt(response.gas_info.gas_wanted, 10),
					gasUsed: parseInt(response.gas_info.gas_used, 10)
				}
			};
		} catch (e) {
			throw new __injectivelabs_exceptions.TransactionException(new Error(e));
		}
	}
	async broadcast(tx, options) {
		const timeout = (options === null || options === void 0 ? void 0 : options.timeout) || (0, __injectivelabs_utils.toBigNumber)((options === null || options === void 0 ? void 0 : options.txTimeout) || __injectivelabs_utils.DEFAULT_BLOCK_TIMEOUT_HEIGHT).times(__injectivelabs_utils.DEFAULT_BLOCK_TIME_IN_SECONDS * 1e3).toNumber();
		try {
			const { tx_response: txResponse } = await this.broadcastTx(tx, BroadcastMode.Sync);
			if (!txResponse) throw new __injectivelabs_exceptions.HttpRequestException(/* @__PURE__ */ new Error("The transaction has failed to be broadcasted"), {
				context: "TxRestApi.broadcast",
				contextModule: "broadcast"
			});
			if (txResponse.code !== 0) throw new __injectivelabs_exceptions.TransactionException(new Error(txResponse.raw_log), {
				contextCode: txResponse.code,
				contextModule: txResponse.codespace
			});
			return this.fetchTxPoll(txResponse.txhash, timeout);
		} catch (e) {
			if (e instanceof __injectivelabs_exceptions.HttpRequestException) {
				if (e.code !== http_status_codes.StatusCodes.OK) throw e;
			}
			throw e;
		}
	}
	/**
	* Broadcast the transaction using the "block" mode, waiting for its inclusion in the blockchain.
	* @param tx transaction to broadcast
	*
	* @deprecated - the BLOCk mode broadcasting is deprecated now, use either sync or async
	*/
	async broadcastBlock(tx) {
		const response = await this.broadcastTx(tx, BroadcastMode.Block);
		try {
			const { tx_response: txResponse } = response;
			if (txResponse.code !== 0) throw new __injectivelabs_exceptions.TransactionException(new Error(txResponse.raw_log), {
				contextCode: txResponse.code,
				contextModule: txResponse.codespace
			});
			return {
				txHash: txResponse.txhash,
				rawLog: txResponse.raw_log,
				gasWanted: parseInt(txResponse.gas_wanted || "0", 10),
				gasUsed: parseInt(txResponse.gas_used || "0", 10),
				height: parseInt(txResponse.height || "0", 10),
				logs: txResponse.logs || [],
				code: txResponse.code,
				codespace: txResponse.codespace,
				data: txResponse.data,
				info: txResponse.info,
				timestamp: txResponse.timestamp || "0"
			};
		} catch (e) {
			if (e instanceof __injectivelabs_exceptions.TransactionException) throw e;
			throw new __injectivelabs_exceptions.TransactionException(new Error(e));
		}
	}
	async broadcastTx(txRaw, mode = BroadcastMode.Sync) {
		return await this.postRaw("cosmos/tx/v1beta1/txs", {
			tx_bytes: TxClient.encode(txRaw),
			mode
		});
	}
	async getRaw(endpoint, params = {}) {
		try {
			return await this.httpClient.get(endpoint, params).then((d) => d.data);
		} catch (e) {
			const error = e;
			if (axios.default.isAxiosError(error)) {
				if (error.code === "ECONNABORTED") throw new __injectivelabs_exceptions.HttpRequestException(new Error(error.message), {
					code: http_status_codes.StatusCodes.REQUEST_TOO_LONG,
					context: endpoint
				});
				const message = require_utils.getErrorMessage(error, endpoint);
				throw new __injectivelabs_exceptions.HttpRequestException(new Error(message), {
					context: endpoint,
					code: error.response ? error.response.status : http_status_codes.StatusCodes.BAD_REQUEST
				});
			}
			throw new __injectivelabs_exceptions.HttpRequestException(new Error(error.message), {
				context: endpoint,
				code: __injectivelabs_exceptions.UnspecifiedErrorCode
			});
		}
	}
	async postRaw(endpoint, params = {}) {
		try {
			return await this.httpClient.post(endpoint, params).then((d) => d.data);
		} catch (e) {
			const error = e;
			if (axios.default.isAxiosError(error)) {
				const message = require_utils.getErrorMessage(error, endpoint);
				throw new __injectivelabs_exceptions.HttpRequestException(new Error(message), {
					code: error.response ? error.response.status : http_status_codes.StatusCodes.BAD_REQUEST,
					context: endpoint,
					contextModule: __injectivelabs_exceptions.HttpRequestMethod.Post
				});
			}
			throw new __injectivelabs_exceptions.HttpRequestException(new Error(error.message), {
				code: __injectivelabs_exceptions.UnspecifiedErrorCode,
				context: endpoint,
				contextModule: __injectivelabs_exceptions.HttpRequestMethod.Post
			});
		}
	}
};

//#endregion
//#region src/core/tx/api/utils.ts
const waitTxBroadcasted = (txHash, options) => {
	const timeout = (0, __injectivelabs_utils.toBigNumber)((options === null || options === void 0 ? void 0 : options.txTimeout) || __injectivelabs_utils.DEFAULT_BLOCK_TIMEOUT_HEIGHT).times(__injectivelabs_utils.DEFAULT_BLOCK_TIME_IN_SECONDS * 1e3).toNumber();
	return options.endpoints.grpc ? new TxGrpcApi(options.endpoints.grpc).fetchTxPoll(txHash, timeout) : new TxRestApi(options.endpoints.rest).fetchTxPoll(txHash, timeout);
};

//#endregion
//#region src/core/tx/arbitrary.ts
const generateArbitrarySignDoc = (message, signer) => {
	const signDoc = {
		account_number: "0",
		chain_id: "",
		fee: {
			amount: [],
			gas: "0"
		},
		memo: "",
		msgs: [{
			type: "sign/MsgSignData",
			value: {
				data: require_utils.uint8ArrayToBase64(require_utils.stringToUint8Array(require_utils.toUtf8(message))),
				signer
			}
		}],
		sequence: "0"
	};
	const stringified = require_utils.toUtf8(JSON.stringify(require_utils.sortObjectByKeys(signDoc)));
	return {
		signDoc,
		signDocBuff: require_utils.stringToUint8Array(stringified),
		stringifiedSignDoc: stringified
	};
};

//#endregion
//#region src/core/tx/types/tx.ts
const TxClientMode = {
	gRpc: "grpc",
	rest: "rest"
};

//#endregion
//#region src/core/tx/broadcaster/MsgBroadcasterWithPk.ts
/**
* This class is used to broadcast transactions
* using a privateKey as a signer
* for the transactions and broadcasting
* the transactions directly to the node
*
* Mainly used for working in a Node Environment
*/
var MsgBroadcasterWithPk = class {
	constructor(options) {
		require_defineProperty._defineProperty(this, "endpoints", void 0);
		require_defineProperty._defineProperty(this, "chainId", void 0);
		require_defineProperty._defineProperty(this, "evmChainId", void 0);
		require_defineProperty._defineProperty(this, "privateKey", void 0);
		require_defineProperty._defineProperty(this, "simulateTx", false);
		require_defineProperty._defineProperty(this, "txTimeoutOnFeeDelegation", false);
		require_defineProperty._defineProperty(this, "useRest", false);
		require_defineProperty._defineProperty(this, "gasBufferCoefficient", 1.1);
		require_defineProperty._defineProperty(this, "txTimeout", __injectivelabs_utils.DEFAULT_BLOCK_TIMEOUT_HEIGHT);
		const network = options.network || __injectivelabs_networks.Network.MainnetSentry;
		const networkInfo = (0, __injectivelabs_networks.getNetworkInfo)(network);
		const endpoints = (0, __injectivelabs_networks.getNetworkEndpoints)(network);
		this.useRest = options.useRest || false;
		this.gasBufferCoefficient = options.gasBufferCoefficient || 1.1;
		this.simulateTx = options.simulateTx || false;
		this.chainId = options.chainId || networkInfo.chainId;
		this.txTimeout = options.txTimeout || __injectivelabs_utils.DEFAULT_BLOCK_TIMEOUT_HEIGHT;
		this.evmChainId = options.evmChainId || networkInfo.evmChainId;
		this.endpoints = {
			...endpoints,
			...options.endpoints || {}
		};
		this.privateKey = options.privateKey instanceof require_accounts.PrivateKey ? options.privateKey : require_accounts.PrivateKey.fromHex(options.privateKey);
		this.txTimeoutOnFeeDelegation = options.txTimeoutOnFeeDelegation || this.txTimeoutOnFeeDelegation;
	}
	/**
	* Broadcasting the transaction using the client
	*
	* @param tx
	* @returns {string} transaction hash
	*/
	async broadcast(transaction, accountDetails) {
		const { privateKey } = this;
		if (require_utils.ofacList.includes(privateKey.toHex())) throw new __injectivelabs_exceptions.GeneralException(/* @__PURE__ */ new Error("You cannot execute this transaction"));
		const { txRaw } = await this.prepareTxForBroadcast(transaction, accountDetails);
		return await this.broadcastTxRaw(txRaw);
	}
	/**
	* Broadcasting the transaction with fee delegation services
	*
	* @param tx
	* @returns {string} transaction hash
	*/
	async broadcastWithFeeDelegation(transaction) {
		const { endpoints, txTimeout, simulateTx, privateKey, evmChainId, txTimeoutOnFeeDelegation } = this;
		const ethereumWallet = this.privateKey.toHex();
		if (require_utils.ofacList.includes(ethereumWallet)) throw new __injectivelabs_exceptions.GeneralException(/* @__PURE__ */ new Error("You cannot execute this transaction"));
		const msgs = Array.isArray(transaction.msgs) ? transaction.msgs : [transaction.msgs];
		const tx = {
			...transaction,
			msgs,
			ethereumAddress: ethereumWallet
		};
		const web3Msgs = msgs.map((msg) => msg.toWeb3());
		if (!evmChainId) throw new __injectivelabs_exceptions.GeneralException(/* @__PURE__ */ new Error("Please provide ethereumChainId"));
		let timeoutHeight = void 0;
		if (txTimeoutOnFeeDelegation) {
			const latestHeight = (await new require_ChainRestTendermintApi.ChainGrpcTendermintApi(endpoints.grpc).fetchLatestBlock()).header.height;
			timeoutHeight = (0, __injectivelabs_utils.toBigNumber)(latestHeight.toString()).plus(txTimeout).toNumber();
		}
		const transactionApi = new require_IndexerGrpcWeb3GwApi.IndexerGrpcWeb3GwApi(endpoints.web3gw || endpoints.indexer);
		const txResponse = await transactionApi.prepareTxRequest({
			memo: tx.memo,
			message: web3Msgs,
			address: tx.ethereumAddress,
			chainId: evmChainId,
			gasLimit: require_utils.getGasPriceBasedOnMessage(msgs),
			estimateGas: simulateTx || false,
			timeoutHeight
		});
		const signature = await privateKey.signTypedData(JSON.parse(txResponse.data));
		const response = await transactionApi.broadcastTxRequest({
			txResponse,
			message: web3Msgs,
			chainId: evmChainId,
			signature: `0x${require_utils.uint8ArrayToHex(signature)}`
		});
		return await new TxGrpcApi(endpoints.grpc).fetchTxPoll(response.txHash);
	}
	/**
	* Broadcasting the transaction using the client
	*
	* @param tx
	* @returns {string} transaction hash
	*/
	async simulate(transaction, accountDetails) {
		const { privateKey, endpoints, chainId } = this;
		const ethereumWallet = this.privateKey.toHex();
		if (require_utils.ofacList.includes(ethereumWallet)) throw new __injectivelabs_exceptions.GeneralException(/* @__PURE__ */ new Error("You cannot execute this transaction"));
		const tx = {
			...transaction,
			msgs: Array.isArray(transaction.msgs) ? transaction.msgs : [transaction.msgs]
		};
		/** Account Details * */
		const publicKey = privateKey.toPublicKey();
		const actualAccountDetails = await this.getAccountDetails(accountDetails);
		/** Block Details */
		const timeoutHeight = await this.getTimeoutHeight();
		/** Prepare the Transaction * */
		const { txRaw } = createTransaction({
			memo: tx.memo || "",
			fee: (0, __injectivelabs_utils.getDefaultStdFee)(),
			message: tx.msgs,
			timeoutHeight: timeoutHeight.toNumber(),
			pubKey: publicKey.toBase64(),
			sequence: actualAccountDetails.sequence,
			accountNumber: actualAccountDetails.accountNumber,
			chainId
		});
		/** Append Blank Signatures */
		txRaw.signatures = [new Uint8Array(0)];
		return await new TxGrpcApi(endpoints.grpc).simulate(txRaw);
	}
	/**
	* In case we don't want to simulate the transaction
	* we get the gas limit based on the message type.
	*
	* If we want to simulate the transaction we set the
	* gas limit based on the simulation and add a small multiplier
	* to be safe (factor of 1.1 (or user specified))
	*/
	async getTxWithStdFee(args) {
		var _result$gasInfo;
		const { simulateTx, gasBufferCoefficient } = this;
		if (!simulateTx) return createTransaction(args);
		const result = await this.simulateTxRaw(args);
		if (!((_result$gasInfo = result.gasInfo) === null || _result$gasInfo === void 0 ? void 0 : _result$gasInfo.gasUsed)) return createTransaction(args);
		const stdGasFee = (0, __injectivelabs_utils.getStdFee)({
			...args.fee,
			gas: (0, __injectivelabs_utils.toBigNumber)(result.gasInfo.gasUsed).times(gasBufferCoefficient).toFixed()
		});
		return createTransaction({
			...args,
			fee: stdGasFee
		});
	}
	/**
	* Create TxRaw and simulate it
	*/
	async simulateTxRaw(args) {
		const { endpoints } = this;
		const { txRaw } = createTransaction(args);
		txRaw.signatures = [new Uint8Array(0)];
		return await new TxGrpcApi(endpoints.grpc).simulate(txRaw);
	}
	async prepareTxForBroadcast(transaction, accountDetails) {
		var _transaction$gas;
		const { chainId, privateKey } = this;
		const msgs = Array.isArray(transaction.msgs) ? transaction.msgs : [transaction.msgs];
		const tx = {
			...transaction,
			msgs
		};
		/** Account Details * */
		const publicKey = privateKey.toPublicKey();
		const actualAccountDetails = await this.getAccountDetails(accountDetails);
		/** Block Details */
		const timeoutHeight = await this.getTimeoutHeight();
		const gas = (((_transaction$gas = transaction.gas) === null || _transaction$gas === void 0 ? void 0 : _transaction$gas.gas) || require_utils.getGasPriceBasedOnMessage(msgs)).toString();
		/** Prepare the Transaction * */
		const { signBytes, txRaw } = await this.getTxWithStdFee({
			memo: tx.memo || "",
			message: msgs,
			fee: (0, __injectivelabs_utils.getStdFee)({
				...tx.gas,
				gas
			}),
			timeoutHeight: timeoutHeight.toNumber(),
			pubKey: publicKey.toBase64(),
			sequence: actualAccountDetails.sequence,
			accountNumber: actualAccountDetails.accountNumber,
			chainId
		});
		/** Append Signatures */
		txRaw.signatures = [await privateKey.sign(signBytes)];
		return {
			txRaw,
			accountDetails: actualAccountDetails
		};
	}
	async getAccountDetails(accountDetails) {
		const { useRest } = this;
		if (accountDetails) return accountDetails;
		if (useRest) {
			const { privateKey: privateKey$1, endpoints: endpoints$1 } = this;
			const baseAccount$1 = (await new require_ChainRestTendermintApi.ChainRestAuthApi(endpoints$1.grpc).fetchAccount(privateKey$1.toBech32())).account.base_account;
			return {
				accountNumber: parseInt(baseAccount$1.account_number),
				sequence: parseInt(baseAccount$1.sequence),
				address: baseAccount$1.address,
				pubKey: baseAccount$1.pub_key ? {
					key: baseAccount$1.pub_key.key,
					type: baseAccount$1.pub_key["@type"]
				} : {
					key: "",
					type: ""
				}
			};
		}
		const { privateKey, endpoints } = this;
		const baseAccount = (await new require_ChainRestTendermintApi.ChainGrpcAuthApi(endpoints.grpc).fetchAccount(privateKey.toBech32())).baseAccount;
		return {
			accountNumber: baseAccount.accountNumber,
			sequence: baseAccount.sequence,
			address: baseAccount.address,
			pubKey: baseAccount.pubKey ? {
				key: baseAccount.pubKey.key,
				type: baseAccount.pubKey.typeUrl
			} : {
				key: "",
				type: ""
			}
		};
	}
	async getTimeoutHeight() {
		const { useRest, endpoints, txTimeout } = this;
		if (useRest) {
			const latestHeight$1 = (await new require_ChainRestTendermintApi.ChainRestTendermintApi(endpoints.grpc).fetchLatestBlock()).header.height;
			return (0, __injectivelabs_utils.toBigNumber)(latestHeight$1).plus(txTimeout);
		}
		const latestHeight = (await new require_ChainRestTendermintApi.ChainGrpcTendermintApi(endpoints.grpc).fetchLatestBlock()).header.height;
		return (0, __injectivelabs_utils.toBigNumber)(latestHeight.toString()).plus(txTimeout);
	}
	async broadcastTxRaw(txRaw) {
		const { endpoints, txTimeout } = this;
		const txResponse = await new TxGrpcApi(endpoints.grpc).broadcast(txRaw, { txTimeout });
		if (txResponse.code !== 0) throw new __injectivelabs_exceptions.GeneralException(/* @__PURE__ */ new Error(`Transaction failed to be broadcasted - ${txResponse.rawLog} - ${txResponse.txHash}`));
		return txResponse;
	}
};

//#endregion
Object.defineProperty(exports, 'BroadcastMode', {
  enumerable: true,
  get: function () {
    return BroadcastMode;
  }
});
Object.defineProperty(exports, 'BroadcastModeKeplr', {
  enumerable: true,
  get: function () {
    return BroadcastModeKeplr;
  }
});
Object.defineProperty(exports, 'MsgBroadcasterWithPk', {
  enumerable: true,
  get: function () {
    return MsgBroadcasterWithPk;
  }
});
Object.defineProperty(exports, 'SIGN_AMINO', {
  enumerable: true,
  get: function () {
    return SIGN_AMINO;
  }
});
Object.defineProperty(exports, 'SIGN_DIRECT', {
  enumerable: true,
  get: function () {
    return SIGN_DIRECT;
  }
});
Object.defineProperty(exports, 'SIGN_EIP712', {
  enumerable: true,
  get: function () {
    return SIGN_EIP712;
  }
});
Object.defineProperty(exports, 'SIGN_EIP712_V2', {
  enumerable: true,
  get: function () {
    return SIGN_EIP712_V2;
  }
});
Object.defineProperty(exports, 'TxClient', {
  enumerable: true,
  get: function () {
    return TxClient;
  }
});
Object.defineProperty(exports, 'TxClientMode', {
  enumerable: true,
  get: function () {
    return TxClientMode;
  }
});
Object.defineProperty(exports, 'TxGrpcApi', {
  enumerable: true,
  get: function () {
    return TxGrpcApi;
  }
});
Object.defineProperty(exports, 'TxRestApi', {
  enumerable: true,
  get: function () {
    return TxRestApi;
  }
});
Object.defineProperty(exports, 'createTransaction', {
  enumerable: true,
  get: function () {
    return createTransaction;
  }
});
Object.defineProperty(exports, 'createTransactionAndCosmosSignDoc', {
  enumerable: true,
  get: function () {
    return createTransactionAndCosmosSignDoc;
  }
});
Object.defineProperty(exports, 'createTransactionAndCosmosSignDocForAddressAndMsg', {
  enumerable: true,
  get: function () {
    return createTransactionAndCosmosSignDocForAddressAndMsg;
  }
});
Object.defineProperty(exports, 'createTransactionForAddressAndMsg', {
  enumerable: true,
  get: function () {
    return createTransactionForAddressAndMsg;
  }
});
Object.defineProperty(exports, 'createTransactionFromMsg', {
  enumerable: true,
  get: function () {
    return createTransactionFromMsg;
  }
});
Object.defineProperty(exports, 'createTransactionWithSigners', {
  enumerable: true,
  get: function () {
    return createTransactionWithSigners;
  }
});
Object.defineProperty(exports, 'createTxRawFromSigResponse', {
  enumerable: true,
  get: function () {
    return createTxRawFromSigResponse;
  }
});
Object.defineProperty(exports, 'errorToErrorMessage', {
  enumerable: true,
  get: function () {
    return errorToErrorMessage;
  }
});
Object.defineProperty(exports, 'generateArbitrarySignDoc', {
  enumerable: true,
  get: function () {
    return generateArbitrarySignDoc;
  }
});
Object.defineProperty(exports, 'getTxRawFromTxRawOrDirectSignResponse', {
  enumerable: true,
  get: function () {
    return getTxRawFromTxRawOrDirectSignResponse;
  }
});
Object.defineProperty(exports, 'isTxNotFoundError', {
  enumerable: true,
  get: function () {
    return isTxNotFoundError;
  }
});
Object.defineProperty(exports, 'waitTxBroadcasted', {
  enumerable: true,
  get: function () {
    return waitTxBroadcasted;
  }
});