const require_chunk = require('./chunk-CbDLau6x.cjs');
const require_utils = require('./utils-D3XFGv8y.cjs');
const require_defineProperty = require('./defineProperty-dyr5BsvG.cjs');
const require_chain = require('./chain-CPs0kwL0.cjs');
const require_ExecArgNeptuneWithdraw = require('./ExecArgNeptuneWithdraw-4esQ6Su-.cjs');
let __injectivelabs_exceptions = require("@injectivelabs/exceptions");
let __injectivelabs_networks = require("@injectivelabs/networks");

//#region src/client/wasm/swap/transformer.ts
var SwapQueryTransformer = class {
	static contractRouteResponseToContractRoute(response) {
		const data = JSON.parse(require_utils.toUtf8(response.data));
		return {
			steps: data.steps,
			sourceDenom: data.source_denom,
			targetDenom: data.target_denom
		};
	}
	static contractAllRoutesResponseToContractAllRoutes(response) {
		return JSON.parse(require_utils.toUtf8(response.data)).map((route) => ({
			steps: route.steps,
			sourceDenom: route.source_denom,
			targetDenom: route.target_denom
		}));
	}
	static contractQuantityResponseToContractQuantity(response) {
		const data = JSON.parse(require_utils.toUtf8(response.data));
		return {
			expectedFees: data.expected_fees,
			resultQuantity: data.result_quantity
		};
	}
};

//#endregion
//#region src/client/wasm/BaseWasmQuery.ts
var BaseWasmQuery = class {
	constructor(params) {
		require_defineProperty._defineProperty(this, "params", void 0);
		this.params = params;
	}
};

//#endregion
//#region src/client/wasm/swap/queries/QueryRoute.ts
var QueryRoute = class extends BaseWasmQuery {
	toPayload() {
		return require_utils.toBase64({ get_route: {
			source_denom: this.params.sourceDenom,
			target_denom: this.params.targetDenom
		} });
	}
};

//#endregion
//#region src/client/wasm/swap/queries/QueryAllRoutes.ts
var QueryAllRoutes = class extends BaseWasmQuery {
	toPayload() {
		return require_utils.toBase64({ get_all_routes: {} });
	}
};

//#endregion
//#region src/client/wasm/swap/queries/QueryInputQuantity.ts
var QueryInputQuantity = class extends BaseWasmQuery {
	toPayload() {
		return require_utils.toBase64({ get_input_quantity: {
			to_quantity: this.params.toQuantity,
			source_denom: this.params.sourceDenom,
			target_denom: this.params.targetDenom
		} });
	}
};

//#endregion
//#region src/client/wasm/swap/queries/QueryOutputQuantity.ts
var QueryOutputQuantity = class extends BaseWasmQuery {
	toPayload() {
		return require_utils.toBase64({ get_output_quantity: {
			from_quantity: this.params.fromQuantity,
			source_denom: this.params.sourceDenom,
			target_denom: this.params.targetDenom
		} });
	}
};

//#endregion
//#region src/client/wasm/neptune/types.ts
const NEPTUNE_USDT_CW20_CONTRACT = "inj1cy9hes20vww2yr6crvs75gxy5hpycya2hmjg9s";

//#endregion
//#region src/client/wasm/neptune/helper.ts
function getDenom(assetInfo) {
	if ("native_token" in assetInfo) return assetInfo.native_token.denom;
	return assetInfo.token.contract_addr;
}

//#endregion
//#region src/client/wasm/neptune/transformer.ts
var NeptuneQueryTransformer = class {
	static contractPricesResponseToPrices(response) {
		return JSON.parse(require_utils.toUtf8(response.data)).map(([assetInfo, priceInfo]) => ({
			assetInfo,
			price: priceInfo.price
		}));
	}
	static contractLendingRatesResponseToLendingRates(response) {
		return JSON.parse(require_utils.toUtf8(response.data)).map(([assetInfo, lendingRate]) => ({
			assetInfo,
			lendingRate
		}));
	}
};

//#endregion
//#region src/client/wasm/neptune/queries/QueryGetPrices.ts
var QueryGetPrices = class extends BaseWasmQuery {
	toPayload() {
		return require_utils.toBase64({ get_prices: { assets: this.params.assets } });
	}
};

//#endregion
//#region src/client/wasm/neptune/queries/QueryLendingRates.ts
var QueryGetAllLendingRates = class extends BaseWasmQuery {
	toPayload() {
		return require_utils.toBase64({ get_all_lending_rates: {
			...this.params.limit !== void 0 ? { limit: this.params.limit } : {},
			...this.params.startAfter ? { start_after: this.params.startAfter } : {}
		} });
	}
};

//#endregion
//#region src/client/wasm/neptune/service.ts
const NEPTUNE_USDT_MARKET_CONTRACT = "inj1nc7gjkf2mhp34a6gquhurg8qahnw5kxs5u3s4u";
const NEPTUNE_INTEREST_CONTRACT = "inj1ftech0pdjrjawltgejlmpx57cyhsz6frdx2dhq";
var NeptuneService = class {
	/**
	* Constructs a new NeptuneService instan ce.
	* @param network The network to use (default: Mainnet).
	* @param endpoints Optional custom network endpoints.
	*/
	constructor(network = __injectivelabs_networks.Network.MainnetSentry, endpoints, options) {
		require_defineProperty._defineProperty(this, "client", void 0);
		require_defineProperty._defineProperty(this, "priceOracleContract", void 0);
		if (!(0, __injectivelabs_networks.isMainnet)(network)) throw new __injectivelabs_exceptions.GeneralException(/* @__PURE__ */ new Error("Please switch to mainnet network"));
		this.client = new require_chain.ChainGrpcWasmApi((endpoints || (0, __injectivelabs_networks.getNetworkEndpoints)(network)).grpc, options);
		this.priceOracleContract = NEPTUNE_PRICE_CONTRACT;
	}
	/**
	* Fetch prices for given assets from the Neptune Price Oracle contract.
	* @param assets Array of AssetInfo objects.
	* @returns Array of Price objects.
	*/
	async fetchPrices(assets) {
		const queryGetPricesPayload = new QueryGetPrices({ assets }).toPayload();
		try {
			const response = await this.client.fetchSmartContractState(this.priceOracleContract, queryGetPricesPayload);
			return NeptuneQueryTransformer.contractPricesResponseToPrices(response);
		} catch (error) {
			console.error("Error fetching prices:", error);
			throw new __injectivelabs_exceptions.GeneralException(/* @__PURE__ */ new Error("Failed to fetch prices"));
		}
	}
	/**
	* Fetch the redemption ratio based on CW20 and native asset prices.
	* @param cw20Asset AssetInfo for the CW20 token.
	* @param nativeAsset AssetInfo for the native token.
	* @returns Redemption ratio as a number.
	*/
	async fetchRedemptionRatio({ cw20Asset, nativeAsset }) {
		const prices = await this.fetchPrices([cw20Asset, nativeAsset]);
		const [cw20Price] = prices;
		const [nativePrice] = prices.reverse();
		if (!cw20Price || !nativePrice) throw new __injectivelabs_exceptions.GeneralException(/* @__PURE__ */ new Error("Failed to compute redemption ratio"));
		return Number(cw20Price.price) / Number(nativePrice.price);
	}
	/**
	* Convert CW20 nUSDT to bank nUSDT using the redemption ratio.
	* @param amountCW20 Amount in CW20 nUSDT.
	* @param redemptionRatio Redemption ratio.
	* @returns Amount in bank nUSDT.
	*/
	calculateBankAmount(amountCW20, redemptionRatio) {
		return amountCW20 * redemptionRatio;
	}
	/**
	* Convert bank nUSDT to CW20 nUSDT using the redemption ratio.
	* @param amountBank Amount in bank nUSDT.
	* @param redemptionRatio Redemption ratio.
	* @returns Amount in CW20 nUSDT.
	*/
	calculateCw20Amount(amountBank, redemptionRatio) {
		return amountBank / redemptionRatio;
	}
	/**
	* Create a deposit message.
	* @param sender Sender's Injective address.
	* @param contractAddress USDT market contract address.
	* @param denom Denomination of the asset.
	* @param amount Amount to deposit as a string.
	* @returns MsgExecuteContractCompat message.
	*/
	createDepositMsg({ denom, amount, sender, contractAddress = NEPTUNE_USDT_MARKET_CONTRACT }) {
		return require_ExecArgNeptuneWithdraw.MsgExecuteContractCompat.fromJSON({
			sender,
			contractAddress,
			execArgs: require_ExecArgNeptuneWithdraw.ExecArgNeptuneDeposit.fromJSON({}),
			funds: {
				denom,
				amount
			}
		});
	}
	/**
	* Create a withdraw message.
	* @param sender Sender's Injective address.
	* @param contractAddress nUSDT contract address.
	* @param amount Amount to withdraw as a string.
	* @returns MsgExecuteContractCompat message.
	*/
	createWithdrawMsg({ amount, sender, cw20ContractAddress = NEPTUNE_USDT_CW20_CONTRACT, marketContractAddress = NEPTUNE_USDT_MARKET_CONTRACT }) {
		return require_ExecArgNeptuneWithdraw.MsgExecuteContractCompat.fromJSON({
			sender,
			contractAddress: cw20ContractAddress,
			execArgs: require_ExecArgNeptuneWithdraw.ExecArgNeptuneWithdraw.fromJSON({
				amount,
				contract: marketContractAddress
			})
		});
	}
	/**
	* Fetch lending rates with optional pagination parameters.
	* @param limit Maximum number of lending rates to fetch.
	* @param startAfter AssetInfo to start after for pagination.
	* @returns Array of [AssetInfo, Decimal256] tuples.
	*/
	async getLendingRates({ limit, startAfter, contractAddress = NEPTUNE_INTEREST_CONTRACT }) {
		const payload = new QueryGetAllLendingRates({
			limit,
			startAfter
		}).toPayload();
		try {
			const response = await this.client.fetchSmartContractState(contractAddress, payload);
			return NeptuneQueryTransformer.contractLendingRatesResponseToLendingRates(response);
		} catch (_unused) {
			throw new __injectivelabs_exceptions.GeneralException(/* @__PURE__ */ new Error("Failed to fetch lending rates"));
		}
	}
	/**
	* Fetch the lending rate for a specific denom by querying the smart contract with pagination.
	* @param denom The denomination string of the asset to find the lending rate for.
	* @returns Lending rate as a string.
	*/
	async getLendingRateByDenom({ denom, contractAddress = NEPTUNE_INTEREST_CONTRACT }) {
		const limit = 10;
		let startAfter = void 0;
		while (true) {
			const lendingRates = await this.getLendingRates({
				limit,
				startAfter,
				contractAddress
			});
			if (lendingRates.length === 0) return;
			for (const { assetInfo, lendingRate } of lendingRates) if (getDenom(assetInfo) === denom) return lendingRate;
			if (lendingRates.length < limit) return;
			startAfter = lendingRates[lendingRates.length - 1].assetInfo;
		}
	}
	/**
	* Calculates APY from APR and compounding frequency.
	*
	* @param apr - The annual percentage rate as a decimal (e.g., 0.10 for 10%)
	* @param compoundingFrequency - Number of times interest is compounded per year
	* @returns The annual percentage yield as a decimal
	*/
	calculateAPY(apr) {
		return Math.exp(apr) - 1;
	}
};

//#endregion
//#region src/client/wasm/neptune/index.ts
const NEPTUNE_PRICE_CONTRACT = "inj1u6cclz0qh5tep9m2qayry9k97dm46pnlqf8nre";

//#endregion
//#region src/client/wasm/incentives/transformer.ts
var IncentivesQueryTransformer = class {
	static contractRoundResponseToContractRound(response) {
		return JSON.parse(require_utils.toUtf8(response.data)).map((round) => ({
			id: round.id,
			name: round.name,
			endDate: round.end_date,
			campaigns: round.campaigns,
			startDate: round.start_date
		}));
	}
	static contractCampaignResponseToContractCampaign(response) {
		return JSON.parse(require_utils.toUtf8(response.data)).map((campaign) => ({
			id: campaign.id,
			name: campaign.name,
			rewards: campaign.rewards,
			inRound: campaign.in_round,
			marketId: campaign.market_id,
			isFunded: campaign.is_funded,
			description: campaign.description,
			isFinalized: campaign.is_finalized,
			totalRewards: campaign.total_rewards,
			subaccountIdSuffix: campaign.subaccount_id_suffix
		}));
	}
};

//#endregion
//#region src/client/wasm/incentives/queries/QueryAllRounds.ts
var QueryAllRounds = class extends BaseWasmQuery {
	toPayload() {
		return require_utils.toBase64({ all_rounds: {
			...this.params.limit ? { limit: this.params.limit } : {},
			...this.params.startAfter ? { start_after: this.params.startAfter } : {}
		} });
	}
};

//#endregion
//#region src/client/wasm/incentives/queries/QueryGetCampaigns.ts
var QueryGetCampaigns = class extends BaseWasmQuery {
	toPayload() {
		return require_utils.toBase64({ get_campaigns: { campaigns: this.params.campaigns } });
	}
};

//#endregion
//#region src/client/wasm/nameservice/transformer.ts
var InjNameServiceQueryTransformer = class {
	static resolverAddressResponseToResolverAddress(response) {
		return require_utils.fromBase64(require_utils.binaryToBase64(response.data)).resolver || "";
	}
	static injectiveAddressResponseToInjectiveAddress(response) {
		return require_utils.fromBase64(require_utils.binaryToBase64(response.data)).address || "";
	}
	static injectiveNameResponseToInjectiveName(response) {
		return require_utils.fromBase64(require_utils.binaryToBase64(response.data)).name || "";
	}
};

//#endregion
//#region src/client/wasm/nameservice/queries/QueryInjName.ts
var QueryInjName = class extends BaseWasmQuery {
	toPayload() {
		return require_utils.toBase64({ name: { address: this.params.address } });
	}
};

//#endregion
//#region src/client/wasm/nameservice/queries/QueryResolverAddress.ts
var QueryResolverAddress = class extends BaseWasmQuery {
	toPayload() {
		return require_utils.toBase64({ resolver: { node: this.params.node } });
	}
};

//#endregion
//#region src/client/wasm/nameservice/queries/QueryInjectiveAddress.ts
var QueryInjectiveAddress = class extends BaseWasmQuery {
	toPayload() {
		return require_utils.toBase64({ address: { node: this.params.node } });
	}
};

//#endregion
//#region src/client/wasm/trading_strategies/queries/QueryTradingStrategyContractConfig.ts
var QueryTradingStrategyContractConfig = class extends BaseWasmQuery {
	toPayload() {
		return require_utils.toBase64({ config: {} });
	}
};

//#endregion
//#region src/client/wasm/trading_strategies/queries/QueryTradingStrategyContractAllStrategies.ts
var QueryTradingStrategyContractAllStrategies = class extends BaseWasmQuery {
	toPayload() {
		return require_utils.toBase64({ all_strategies: {
			start_after: this.params.startAfter,
			limit: this.params.limit
		} });
	}
};

//#endregion
//#region src/client/wasm/trading_strategies/queries/QueryTradingStrategyContractUserStrategies.ts
var QueryTradingStrategyContractUserStrategies = class extends BaseWasmQuery {
	toPayload() {
		return require_utils.toBase64({ user_strategy: { user: this.params.user } });
	}
};

//#endregion
//#region src/client/wasm/trading_strategies/queries/QueryTradingStrategyContractTotalStrategies.ts
var QueryTradingStrategyContractTotalStrategies = class extends BaseWasmQuery {
	toPayload() {
		return require_utils.toBase64({ total_strategies: {} });
	}
};

//#endregion
Object.defineProperty(exports, 'IncentivesQueryTransformer', {
  enumerable: true,
  get: function () {
    return IncentivesQueryTransformer;
  }
});
Object.defineProperty(exports, 'InjNameServiceQueryTransformer', {
  enumerable: true,
  get: function () {
    return InjNameServiceQueryTransformer;
  }
});
Object.defineProperty(exports, 'NEPTUNE_PRICE_CONTRACT', {
  enumerable: true,
  get: function () {
    return NEPTUNE_PRICE_CONTRACT;
  }
});
Object.defineProperty(exports, 'NEPTUNE_USDT_CW20_CONTRACT', {
  enumerable: true,
  get: function () {
    return NEPTUNE_USDT_CW20_CONTRACT;
  }
});
Object.defineProperty(exports, 'NeptuneQueryTransformer', {
  enumerable: true,
  get: function () {
    return NeptuneQueryTransformer;
  }
});
Object.defineProperty(exports, 'NeptuneService', {
  enumerable: true,
  get: function () {
    return NeptuneService;
  }
});
Object.defineProperty(exports, 'QueryAllRounds', {
  enumerable: true,
  get: function () {
    return QueryAllRounds;
  }
});
Object.defineProperty(exports, 'QueryAllRoutes', {
  enumerable: true,
  get: function () {
    return QueryAllRoutes;
  }
});
Object.defineProperty(exports, 'QueryGetAllLendingRates', {
  enumerable: true,
  get: function () {
    return QueryGetAllLendingRates;
  }
});
Object.defineProperty(exports, 'QueryGetCampaigns', {
  enumerable: true,
  get: function () {
    return QueryGetCampaigns;
  }
});
Object.defineProperty(exports, 'QueryGetPrices', {
  enumerable: true,
  get: function () {
    return QueryGetPrices;
  }
});
Object.defineProperty(exports, 'QueryInjName', {
  enumerable: true,
  get: function () {
    return QueryInjName;
  }
});
Object.defineProperty(exports, 'QueryInjectiveAddress', {
  enumerable: true,
  get: function () {
    return QueryInjectiveAddress;
  }
});
Object.defineProperty(exports, 'QueryInputQuantity', {
  enumerable: true,
  get: function () {
    return QueryInputQuantity;
  }
});
Object.defineProperty(exports, 'QueryOutputQuantity', {
  enumerable: true,
  get: function () {
    return QueryOutputQuantity;
  }
});
Object.defineProperty(exports, 'QueryResolverAddress', {
  enumerable: true,
  get: function () {
    return QueryResolverAddress;
  }
});
Object.defineProperty(exports, 'QueryRoute', {
  enumerable: true,
  get: function () {
    return QueryRoute;
  }
});
Object.defineProperty(exports, 'QueryTradingStrategyContractAllStrategies', {
  enumerable: true,
  get: function () {
    return QueryTradingStrategyContractAllStrategies;
  }
});
Object.defineProperty(exports, 'QueryTradingStrategyContractConfig', {
  enumerable: true,
  get: function () {
    return QueryTradingStrategyContractConfig;
  }
});
Object.defineProperty(exports, 'QueryTradingStrategyContractTotalStrategies', {
  enumerable: true,
  get: function () {
    return QueryTradingStrategyContractTotalStrategies;
  }
});
Object.defineProperty(exports, 'QueryTradingStrategyContractUserStrategies', {
  enumerable: true,
  get: function () {
    return QueryTradingStrategyContractUserStrategies;
  }
});
Object.defineProperty(exports, 'SwapQueryTransformer', {
  enumerable: true,
  get: function () {
    return SwapQueryTransformer;
  }
});