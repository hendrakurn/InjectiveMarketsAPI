const require_chunk = require('./chunk-CbDLau6x.cjs');
const require_defineProperty = require('./defineProperty-dyr5BsvG.cjs');
const require_grpc = require('./grpc-FG2z-ICE.cjs');
let __injectivelabs_exceptions = require("@injectivelabs/exceptions");
let __protobuf_ts_runtime_rpc = require("@protobuf-ts/runtime-rpc");

//#region src/client/base/GrpcWebRpcTransport.ts
/**
* GrpcWebRpcTransport provides a simple wrapper around GrpcWebFetchTransport
* from @protobuf-ts/grpcweb-transport for use with protobuf-ts generated clients.
*
* This transport works in browser, Node.js, and React Native environments.
*/
var GrpcWebRpcTransport = class {
	constructor(baseUrl, options) {
		require_defineProperty._defineProperty(this, "transport", void 0);
		this.transport = require_grpc.getGrpcWebTransport(baseUrl, options);
	}
	mergeOptions(options) {
		return this.transport.mergeOptions(options);
	}
	unary(method, input, options) {
		return this.transport.unary(method, input, options);
	}
	serverStreaming(method, input, options) {
		return this.transport.serverStreaming(method, input, options);
	}
	clientStreaming(method, options) {
		return this.transport.clientStreaming(method, options);
	}
	duplex(method, options) {
		return this.transport.duplex(method, options);
	}
};

//#endregion
//#region src/client/base/BaseGrpcConsumer.ts
/**
* BaseGrpcConsumer provides base functionality for all gRPC consumers.
* It uses the GrpcWebRpcTransport with GrpcWebFetchTransport from @protobuf-ts/grpcweb-transport.
*/
var BaseGrpcConsumer = class {
	constructor(endpoint, options) {
		require_defineProperty._defineProperty(this, "_client", void 0);
		require_defineProperty._defineProperty(this, "endpoint", void 0);
		require_defineProperty._defineProperty(this, "module", "");
		require_defineProperty._defineProperty(this, "transport", void 0);
		require_defineProperty._defineProperty(this, "metadata", void 0);
		require_defineProperty._defineProperty(this, "options", void 0);
		this.options = options;
		this.endpoint = endpoint;
		this.transport = new GrpcWebRpcTransport(endpoint, options);
	}
	/**
	* @deprecated Pass options into the constructor instead
	*/
	setMetadata(map) {
		this.metadata = map;
		this.transport = new GrpcWebRpcTransport(this.endpoint, {
			...this.options,
			meta: this.metadata
		});
		this._client = void 0;
		return this;
	}
	/**
	* @deprecated Manage options within the constructor instead
	*/
	clearMetadata() {
		this.metadata = void 0;
		this.transport = new GrpcWebRpcTransport(this.endpoint, this.options);
		this._client = void 0;
	}
	getTransport() {
		return this.transport;
	}
	/**
	* Lazily initializes and returns the gRPC client.
	* Call this from a getter in subclasses to avoid constructor boilerplate.
	*
	* @example
	* private get client() {
	*   return this.initClient(MyGrpcClient)
	* }
	*/
	initClient(ClientClass) {
		if (!this._client) this._client = new ClientClass(this.transport);
		return this._client;
	}
	/**
	* Builds RpcOptions with metadata
	* @deprecated Options should be managed externally and passed into the constructor instead
	*/
	getRpcOptions() {
		return { meta: this.metadata || {} };
	}
	/**
	* Retry a gRPC call with exponential backoff
	*/
	retry(grpcCall, retries = 3, delay = 1e3) {
		const retryGrpcCall = async (attempt = 1) => {
			try {
				return await grpcCall();
			} catch (e) {
				if (attempt >= retries) throw e;
				return new Promise((resolve) => setTimeout(() => resolve(retryGrpcCall(attempt + 1)), delay * attempt));
			}
		};
		return retryGrpcCall();
	}
	/**
	* Extracts the ABCI error code from a gRPC error message.
	* Chain errors contain patterns like: {key:"ABCICode" value:"100"}
	*/
	getABCICodeFromMessage(message) {
		const ABCICode = /{key:"ABCICode"[ \t]+value:"(.*?)"}/g.exec(message);
		if (!ABCICode || ABCICode.length < 2) return;
		return Number(ABCICode[1]);
	}
	/**
	* Extracts the codespace/module from a gRPC error message.
	* Chain errors contain patterns like: {key:"Codespace" value:"exchange"}
	*/
	getCodespaceFromMessage(message) {
		const codespace = /{key:"Codespace"[ \t]+value:"(.*?)"}/g.exec(message);
		if (!codespace || codespace.length < 2) return;
		return codespace[1];
	}
	/**
	* Centralized error handler for gRPC calls.
	* When the error contains chain error details (ABCI code and codespace),
	* throws a TransactionException which will map the error to a user-friendly message.
	* Otherwise throws a GrpcUnaryRequestException for generic gRPC errors.
	*/
	handleGrpcError(e, context) {
		if (e instanceof __protobuf_ts_runtime_rpc.RpcError) {
			const message$1 = e.message;
			const abciCode$1 = this.getABCICodeFromMessage(message$1);
			const codespace$1 = this.getCodespaceFromMessage(message$1);
			if (abciCode$1 && codespace$1) throw new __injectivelabs_exceptions.TransactionException(new Error(message$1), {
				code: (0, __injectivelabs_exceptions.grpcErrorCodeToErrorCode)(Number(e.code)),
				context,
				contextModule: codespace$1,
				contextCode: abciCode$1
			});
			throw new __injectivelabs_exceptions.GrpcUnaryRequestException(new Error(message$1), {
				code: (0, __injectivelabs_exceptions.grpcErrorCodeToErrorCode)(Number(e.code)),
				context,
				contextModule: this.module
			});
		}
		const error = e;
		const message = (error === null || error === void 0 ? void 0 : error.message) || "";
		const abciCode = this.getABCICodeFromMessage(message);
		const codespace = this.getCodespaceFromMessage(message);
		if (abciCode && codespace) throw new __injectivelabs_exceptions.TransactionException(error, {
			code: __injectivelabs_exceptions.UnspecifiedErrorCode,
			context,
			contextModule: codespace,
			contextCode: abciCode
		});
		throw new __injectivelabs_exceptions.GrpcUnaryRequestException(error, {
			code: __injectivelabs_exceptions.UnspecifiedErrorCode,
			context,
			contextModule: this.module
		});
	}
	/**
	* Generic wrapper for gRPC calls with retry and error handling
	* Simplifies the common pattern of: retry -> await response -> handle errors
	*
	* Usage with explicit type parameter:
	* ```typescript
	* const response = await this.executeGrpcCall<QueryParamsRequest, QueryParamsResponse>(
	*   request,
	*   this.client.params.bind(this.client),
	* )
	* ```
	* @template TRequest - The request message type
	* @template TResponse - The response message type
	*/
	async executeGrpcCall(request, clientMethod) {
		try {
			return await this.retry(async () => {
				return await clientMethod(request, this.getRpcOptions()).response;
			});
		} catch (e) {
			const errorContext = clientMethod.name || "UnknownMethod";
			this.handleGrpcError(e, errorContext);
		}
	}
};

//#endregion
Object.defineProperty(exports, 'BaseGrpcConsumer', {
  enumerable: true,
  get: function () {
    return BaseGrpcConsumer;
  }
});
Object.defineProperty(exports, 'GrpcWebRpcTransport', {
  enumerable: true,
  get: function () {
    return GrpcWebRpcTransport;
  }
});