import { i as SignDoc } from "./tx_pb-DiV92WM9.js";
import { Account, AminoTypes, DeliverTxResponse, GasPrice, StargateClient, StargateClientOptions } from "@cosmjs/stargate";
import { CometClient, HttpEndpoint } from "@cosmjs/tendermint-rpc";
import { AccountData, Algo, AminoSignResponse, OfflineAminoSigner, StdFee, StdSignDoc } from "@cosmjs/amino";
import { AccountData as AccountData$1, Algo as Algo$1, DirectSignResponse, EncodeObject, OfflineDirectSigner, OfflineSigner, Registry } from "@cosmjs/proto-signing";

//#region ../../node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/binary.d.ts
/**
 * This file and any referenced files were automatically generated by @cosmology/telescope@1.0.7
 * DO NOT MODIFY BY HAND. Instead, download the latest proto files for your chain
 * and run the transpile command or yarn proto command to regenerate this bundle.
 */
declare enum WireType {
  Varint = 0,
  Fixed64 = 1,
  Bytes = 2,
  Fixed32 = 5,
}
interface IBinaryReader {
  buf: Uint8Array;
  pos: number;
  type: number;
  len: number;
  tag(): [number, WireType, number];
  skip(length?: number): this;
  skipType(wireType: number): this;
  uint32(): number;
  int32(): number;
  sint32(): number;
  fixed32(): number;
  sfixed32(): number;
  int64(): bigint;
  uint64(): bigint;
  sint64(): bigint;
  fixed64(): bigint;
  sfixed64(): bigint;
  float(): number;
  double(): number;
  bool(): boolean;
  bytes(): Uint8Array;
  string(): string;
}
declare class BinaryReader implements IBinaryReader {
  buf: Uint8Array;
  pos: number;
  type: number;
  len: number;
  assertBounds(): void;
  constructor(buf?: ArrayLike<number>);
  tag(): [number, WireType, number];
  skip(length?: number): this;
  skipType(wireType: number): this;
  uint32(): number;
  int32(): number;
  sint32(): number;
  fixed32(): number;
  sfixed32(): number;
  int64(): bigint;
  uint64(): bigint;
  sint64(): bigint;
  fixed64(): bigint;
  sfixed64(): bigint;
  float(): number;
  double(): number;
  bool(): boolean;
  bytes(): Uint8Array;
  string(): string;
}
interface IBinaryWriter {
  len: number;
  head: IOp;
  tail: IOp;
  states: State | null;
  finish(): Uint8Array;
  fork(): IBinaryWriter;
  reset(): IBinaryWriter;
  ldelim(): IBinaryWriter;
  tag(fieldNo: number, type: WireType): IBinaryWriter;
  uint32(value: number): IBinaryWriter;
  int32(value: number): IBinaryWriter;
  sint32(value: number): IBinaryWriter;
  int64(value: string | number | bigint): IBinaryWriter;
  uint64: (value: string | number | bigint) => IBinaryWriter;
  sint64(value: string | number | bigint): IBinaryWriter;
  fixed64(value: string | number | bigint): IBinaryWriter;
  sfixed64: (value: string | number | bigint) => IBinaryWriter;
  bool(value: boolean): IBinaryWriter;
  fixed32(value: number): IBinaryWriter;
  sfixed32: (value: number) => IBinaryWriter;
  float(value: number): IBinaryWriter;
  double(value: number): IBinaryWriter;
  bytes(value: Uint8Array): IBinaryWriter;
  string(value: string): IBinaryWriter;
}
interface IOp {
  len: number;
  next?: IOp;
  proceed(buf: Uint8Array | number[], pos: number): void;
}
declare class State {
  head: IOp;
  tail: IOp;
  len: number;
  next: State | null;
  constructor(writer: BinaryWriter);
}
declare class BinaryWriter implements IBinaryWriter {
  len: number;
  head: IOp;
  tail: IOp;
  states: State | null;
  constructor();
  static create(): BinaryWriter;
  static alloc(size: number): Uint8Array | number[];
  private _push;
  finish(): Uint8Array;
  fork(): BinaryWriter;
  reset(): BinaryWriter;
  ldelim(): BinaryWriter;
  tag(fieldNo: number, type: WireType): BinaryWriter;
  uint32(value: number): BinaryWriter;
  int32(value: number): BinaryWriter;
  sint32(value: number): BinaryWriter;
  int64(value: string | number | bigint): BinaryWriter;
  uint64: (value: string | number | bigint) => BinaryWriter;
  sint64(value: string | number | bigint): BinaryWriter;
  fixed64(value: string | number | bigint): BinaryWriter;
  sfixed64: (value: string | number | bigint) => BinaryWriter;
  bool(value: boolean): BinaryWriter;
  fixed32(value: number): BinaryWriter;
  sfixed32: (value: number) => BinaryWriter;
  float(value: number): BinaryWriter;
  double(value: number): BinaryWriter;
  bytes(value: Uint8Array): BinaryWriter;
  string(value: string): BinaryWriter;
}
//#endregion
//#region ../../node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/cosmos/base/v1beta1/coin.d.ts
/**
 * Coin defines a token with a denomination and an amount.
 *
 * NOTE: The amount field is an Int which implements the custom method
 * signatures required by gogoproto.
 */
interface Coin {
  denom: string;
  amount: string;
}
declare const Coin: {
  typeUrl: string;
  encode(message: Coin, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): Coin;
  fromJSON(object: any): Coin;
  toJSON(message: Coin): unknown;
  fromPartial<I extends {
    denom?: string | undefined;
    amount?: string | undefined;
  } & {
    denom?: string | undefined;
    amount?: string | undefined;
  } & Record<Exclude<keyof I, keyof Coin>, never>>(object: I): Coin;
};
//#endregion
//#region ../../node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/ibc/core/client/v1/client.d.ts
/**
 * Height is a monotonically increasing data type
 * that can be compared against another Height for the purposes of updating and
 * freezing clients
 *
 * Normally the RevisionHeight is incremented at each height while keeping
 * RevisionNumber the same. However some consensus algorithms may choose to
 * reset the height in certain conditions e.g. hard forks, state-machine
 * breaking changes In these cases, the RevisionNumber is incremented so that
 * height continues to be monitonically increasing even as the RevisionHeight
 * gets reset
 */
interface Height {
  /** the revision that the client is currently on */
  revisionNumber: bigint;
  /** the height within the given revision */
  revisionHeight: bigint;
}
declare const Height: {
  typeUrl: string;
  encode(message: Height, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): Height;
  fromJSON(object: any): Height;
  toJSON(message: Height): unknown;
  fromPartial<I extends {
    revisionNumber?: bigint | undefined;
    revisionHeight?: bigint | undefined;
  } & {
    revisionNumber?: bigint | undefined;
    revisionHeight?: bigint | undefined;
  } & Record<Exclude<keyof I, keyof Height>, never>>(object: I): Height;
};
//#endregion
//#region ../../node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/ibc/applications/transfer/v1/tx.d.ts
/**
 * MsgTransfer defines a msg to transfer fungible tokens (i.e Coins) between
 * ICS20 enabled chains. See ICS Spec here:
 * https://github.com/cosmos/ibc/tree/master/spec/app/ics-020-fungible-token-transfer#data-structures
 */
interface MsgTransfer {
  /** the port on which the packet will be sent */
  sourcePort: string;
  /** the channel by which the packet will be sent */
  sourceChannel: string;
  /** the tokens to be transferred */
  token: Coin;
  /** the sender address */
  sender: string;
  /** the recipient address on the destination chain */
  receiver: string;
  /**
   * Timeout height relative to the current block height.
   * The timeout is disabled when set to 0.
   */
  timeoutHeight: Height;
  /**
   * Timeout timestamp in absolute nanoseconds since unix epoch.
   * The timeout is disabled when set to 0.
   */
  timeoutTimestamp: bigint;
  /** optional memo */
  memo: string;
}
declare const MsgTransfer: {
  typeUrl: string;
  encode(message: MsgTransfer, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): MsgTransfer;
  fromJSON(object: any): MsgTransfer;
  toJSON(message: MsgTransfer): unknown;
  fromPartial<I extends {
    sourcePort?: string | undefined;
    sourceChannel?: string | undefined;
    token?: {
      denom?: string | undefined;
      amount?: string | undefined;
    } | undefined;
    sender?: string | undefined;
    receiver?: string | undefined;
    timeoutHeight?: {
      revisionNumber?: bigint | undefined;
      revisionHeight?: bigint | undefined;
    } | undefined;
    timeoutTimestamp?: bigint | undefined;
    memo?: string | undefined;
  } & {
    sourcePort?: string | undefined;
    sourceChannel?: string | undefined;
    token?: ({
      denom?: string | undefined;
      amount?: string | undefined;
    } & {
      denom?: string | undefined;
      amount?: string | undefined;
    } & Record<Exclude<keyof I["token"], keyof Coin>, never>) | undefined;
    sender?: string | undefined;
    receiver?: string | undefined;
    timeoutHeight?: ({
      revisionNumber?: bigint | undefined;
      revisionHeight?: bigint | undefined;
    } & {
      revisionNumber?: bigint | undefined;
      revisionHeight?: bigint | undefined;
    } & Record<Exclude<keyof I["timeoutHeight"], keyof Height>, never>) | undefined;
    timeoutTimestamp?: bigint | undefined;
    memo?: string | undefined;
  } & Record<Exclude<keyof I, keyof MsgTransfer>, never>>(object: I): MsgTransfer;
};
//#endregion
//#region src/core/modules/ibc/msgs/MsgTransferCosmjs.d.ts
declare namespace MsgTransferCosmjs {
  interface Params {
    amount: {
      denom: string;
      amount: string;
    };
    sender: string;
    port: string;
    receiver: string;
    channelId: string;
    timeout?: number;
    height?: {
      revisionHeight: number;
      revisionNumber: number;
    };
  }
  type Proto = MsgTransfer;
}
/**
 * @category Messages
 *
 * @deprecated use MsgTransfer with SIGN_DIRECT and a Cosmos wallet
 */
declare class MsgTransferCosmjs {
  params: MsgTransferCosmjs.Params;
  constructor(params: MsgTransferCosmjs.Params);
  static fromJSON(params: MsgTransferCosmjs.Params): MsgTransferCosmjs;
  toProto(): MsgTransfer;
  toData(): void;
  toAmino(): {
    type: string;
    value: {
      timeoutHeight: {
        revisionHeight: string;
        revisionNumber: string;
      } | undefined;
      timeoutTimestamp: string | undefined;
      sourcePort: string;
      sourceChannel: string;
      token: Coin;
      sender: string;
      receiver: string;
      memo: string;
    };
  };
  toWeb3Gw(): {
    timeoutHeight: {
      revisionHeight: string;
      revisionNumber: string;
    } | undefined;
    timeoutTimestamp: string | undefined;
    sourcePort: string;
    sourceChannel: string;
    token: Coin;
    sender: string;
    receiver: string;
    memo: string;
    '@type': string;
  };
  toDirectSign(): {
    type: string;
    message: MsgTransfer;
  };
  toBinary(): Uint8Array;
}
//#endregion
//#region src/core/accounts/AccountParser.d.ts
declare const accountParser: (ethAccount: any) => Account;
//#endregion
//#region src/core/stargate/StargateClient.d.ts
declare class StargateClient$1 extends StargateClient {
  getAccount(searchAddress: string): Promise<Account | null>;
}
//#endregion
//#region ../../node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/cosmos/tx/v1beta1/tx.d.ts
/**
 * TxRaw is a variant of Tx that pins the signer's exact binary representation
 * of body and auth_info. This is used for signing, broadcasting and
 * verification. The binary `serialize(tx: TxRaw)` is stored in Tendermint and
 * the hash `sha256(serialize(tx: TxRaw))` becomes the "txhash", commonly used
 * as the transaction ID.
 */
interface TxRaw {
  /**
   * body_bytes is a protobuf serialization of a TxBody that matches the
   * representation in SignDoc.
   */
  bodyBytes: Uint8Array;
  /**
   * auth_info_bytes is a protobuf serialization of an AuthInfo that matches the
   * representation in SignDoc.
   */
  authInfoBytes: Uint8Array;
  /**
   * signatures is a list of signatures that matches the length and order of
   * AuthInfo's signer_infos to allow connecting signature meta information like
   * public key and signing mode by position.
   */
  signatures: Uint8Array[];
}
declare const TxRaw: {
  typeUrl: string;
  encode(message: TxRaw, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): TxRaw;
  fromJSON(object: any): TxRaw;
  toJSON(message: TxRaw): unknown;
  fromPartial<I extends {
    bodyBytes?: Uint8Array | undefined;
    authInfoBytes?: Uint8Array | undefined;
    signatures?: Uint8Array[] | undefined;
  } & {
    bodyBytes?: Uint8Array | undefined;
    authInfoBytes?: Uint8Array | undefined;
    signatures?: (Uint8Array[] & Uint8Array[] & Record<Exclude<keyof I["signatures"], keyof Uint8Array[]>, never>) | undefined;
  } & Record<Exclude<keyof I, keyof TxRaw>, never>>(object: I): TxRaw;
};
//#endregion
//#region src/core/stargate/SigningStargateClient.d.ts
/**
 * Signing information for a single signer that is not included in the transaction.
 *
 * @see https://github.com/cosmos/cosmos-sdk/blob/v0.42.2/x/auth/signing/sign_mode_handler.go#L23-L37
 */
interface SignerData {
  readonly accountNumber: number;
  readonly sequence: number;
  readonly chainId: string;
}
interface SigningStargateClientOptions extends StargateClientOptions {
  readonly registry?: Registry;
  readonly aminoTypes?: AminoTypes;
  readonly broadcastTimeoutMs?: number;
  readonly broadcastPollIntervalMs?: number;
  readonly gasPrice?: GasPrice;
}
declare class SigningStargateClient extends StargateClient$1 {
  readonly registry: Registry;
  readonly broadcastTimeoutMs: number | undefined;
  readonly broadcastPollIntervalMs: number | undefined;
  protected readonly signer: OfflineSigner;
  protected readonly aminoTypes: AminoTypes;
  protected readonly gasPrice: GasPrice | undefined;
  /**
   * Creates an instance by connecting to the given Tendermint RPC endpoint.
   *
   * For now this uses the Tendermint 0.34 client. If you need Tendermint 0.37
   * support, see `createWithSigner`.
   */
  static connectWithSigner(endpoint: string | HttpEndpoint, signer: OfflineSigner, options?: SigningStargateClientOptions): Promise<SigningStargateClient>;
  /**
   * Creates an instance from a manually created Tendermint client.
   * Use this to use `Tendermint37Client` instead of `Tendermint37Client`.
   */
  static createWithSigner(tmClient: CometClient, signer: OfflineSigner, options?: SigningStargateClientOptions): Promise<SigningStargateClient>;
  /**
   * Creates a client in offline mode.
   *
   * This should only be used in niche cases where you know exactly what you're doing,
   * e.g. when building an offline signing application.
   *
   * When you try to use online functionality with such a signer, an
   * exception will be raised.
   */
  static offline(signer: OfflineSigner, options?: SigningStargateClientOptions): Promise<SigningStargateClient>;
  protected constructor(tmClient: CometClient | undefined, signer: OfflineSigner, options: SigningStargateClientOptions);
  simulate(signerAddress: string, messages: readonly EncodeObject[], memo: string | undefined): Promise<number>;
  sendTokens(senderAddress: string, recipientAddress: string, amount: readonly Coin[], fee: StdFee | 'auto' | number, memo?: string): Promise<DeliverTxResponse>;
  delegateTokens(delegatorAddress: string, validatorAddress: string, amount: Coin, fee: StdFee | 'auto' | number, memo?: string): Promise<DeliverTxResponse>;
  undelegateTokens(delegatorAddress: string, validatorAddress: string, amount: Coin, fee: StdFee | 'auto' | number, memo?: string): Promise<DeliverTxResponse>;
  withdrawRewards(delegatorAddress: string, validatorAddress: string, fee: StdFee | 'auto' | number, memo?: string): Promise<DeliverTxResponse>;
  sendIbcTokens(senderAddress: string, recipientAddress: string, transferAmount: Coin, sourcePort: string, sourceChannel: string, timeoutHeight: Height | undefined, /** timeout in seconds */
  timeoutTimestamp: number | undefined, fee: StdFee | 'auto' | number, memo?: string): Promise<DeliverTxResponse>;
  signAndBroadcast(signerAddress: string, messages: readonly EncodeObject[], fee: StdFee | 'auto' | number, memo?: string): Promise<DeliverTxResponse>;
  /**
   * Gets account number and sequence from the API, creates a sign doc,
   * creates a single signature and assembles the signed transaction.
   *
   * The sign mode (SIGN_MODE_DIRECT or SIGN_MODE_LEGACY_AMINO_JSON) is determined by this client's signer.
   *
   * You can pass signer data (account number, sequence and chain ID) explicitly instead of querying them
   * from the chain. This is needed when signing for a multisig account, but it also allows for offline signing
   * (See the SigningStargateClient.offline constructor).
   */
  sign(signerAddress: string, messages: readonly EncodeObject[], fee: StdFee, memo: string, explicitSignerData?: SignerData): Promise<TxRaw>;
  protected signAmino(signerAddress: string, messages: readonly EncodeObject[], fee: StdFee, memo: string, {
    accountNumber,
    sequence,
    chainId
  }: SignerData): Promise<TxRaw>;
  protected signDirect(signerAddress: string, messages: readonly EncodeObject[], fee: StdFee, memo: string, {
    accountNumber,
    sequence,
    chainId
  }: SignerData): Promise<TxRaw>;
}
//#endregion
//#region src/core/accounts/signers/types/amino-signer.d.ts
type Algo$3 = Algo | 'eth_secp256k1';
interface AccountData$3 extends Omit<AccountData, 'algo'> {
  algo: Algo$3;
}
interface OfflineAminoSigner$1 extends Omit<OfflineAminoSigner, 'getAccounts'> {
  readonly getAccounts: () => Promise<readonly AccountData$3[]>;
}
//#endregion
//#region src/core/accounts/signers/EthSecp256k1Wallet.d.ts
declare class EthSecp256k1Wallet implements OfflineAminoSigner$1 {
  /**
   * Creates a EthSecp256k1Wallet from the given private key
   *
   * @param privKey The private key.
   * @param prefix The bech32 address prefix (human readable part). Defaults to "inj".
   */
  static fromKey(privKey: Uint8Array, prefix?: string): Promise<EthSecp256k1Wallet>;
  private readonly privateKey;
  private readonly publicKey;
  private readonly prefix;
  private constructor();
  private get address();
  getAccounts(): Promise<readonly AccountData$3[]>;
  signAmino(signerAddress: string, signDoc: StdSignDoc): Promise<AminoSignResponse>;
}
//#endregion
//#region src/core/accounts/signers/types/proto-signer.d.ts
type Algo$2 = Algo$1 | 'eth_secp256k1';
interface AccountData$2 extends Omit<AccountData$1, 'algo'> {
  algo: Algo$2;
}
interface OfflineDirectSigner$1 extends Omit<OfflineDirectSigner, 'getAccounts'> {
  readonly getAccounts: () => Promise<readonly AccountData$2[]>;
}
//#endregion
//#region src/core/accounts/signers/DirectEthSecp256k1Wallet.d.ts
declare class DirectEthSecp256k1Wallet implements OfflineDirectSigner$1 {
  /**
   * Creates a DirectEthSecp256k1Wallet from the given private key
   *
   * @param privKey The private key.
   * @param prefix The bech32 address prefix (human readable part). Defaults to "inj".
   */
  static fromKey(privKey: Uint8Array, prefix?: string): Promise<DirectEthSecp256k1Wallet>;
  private readonly privateKey;
  private readonly publicKey;
  private readonly prefix;
  private constructor();
  private get address();
  getAccounts(): Promise<readonly AccountData$2[]>;
  signDirect(address: string, signDoc: Omit<SignDoc, 'accountNumber'> & {
    accountNumber: bigint;
  }): Promise<DirectSignResponse>;
}
//#endregion
export { accountParser as a, StargateClient$1 as i, EthSecp256k1Wallet as n, MsgTransferCosmjs as o, SigningStargateClient as r, DirectEthSecp256k1Wallet as t };