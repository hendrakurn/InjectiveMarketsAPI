import { $t as uint8ArrayToString, Zt as uint8ArrayToBase64, l as ChainGrpcCommonTransformer } from "./utils-CewUFGKA.js";
import { t as _defineProperty } from "./defineProperty-Bq6QU9Te.js";
import { t as BaseGrpcConsumer } from "./BaseGrpcConsumer-a7fB9A_e.js";
import { t as BaseRestConsumer } from "./BaseRestConsumer-DTvorEHL.js";
import { ChainErrorModule, HttpRequestException, UnspecifiedErrorCode } from "@injectivelabs/exceptions";
import * as InjectiveCryptoV1Beta1Ethsecp256k1KeysPb from "@injectivelabs/core-proto-ts-v2/generated/injective/crypto/v1beta1/ethsecp256k1/keys_pb";
import * as ExchangePb from "@injectivelabs/core-proto-ts-v2/generated/injective/exchange/v1beta1/exchange_pb";
import { OracleType } from "@injectivelabs/core-proto-ts-v2/generated/injective/oracle/v1beta1/oracle_pb";
import * as CosmosGovV1GovPb from "@injectivelabs/core-proto-ts-v2/generated/cosmos/gov/v1/gov_pb";
import * as CosmwasmWasmV1TypesPb from "@injectivelabs/core-proto-ts-v2/generated/cosmwasm/wasm/v1/types_pb";
import * as InjectivePermissionsV1Beta1PermissionsPb from "@injectivelabs/core-proto-ts-v2/generated/injective/permissions/v1beta1/permissions_pb";
import * as InjectiveTypesV1Beta1AccountPb from "@injectivelabs/core-proto-ts-v2/generated/injective/types/v1beta1/account_pb";
import * as CosmosAuthV1Beta1QueryPb from "@injectivelabs/core-proto-ts-v2/generated/cosmos/auth/v1beta1/query_pb";
import { QueryClient } from "@injectivelabs/core-proto-ts-v2/generated/cosmos/auth/v1beta1/query_pb.client";
import * as CosmosBaseTendermintV1Beta1QueryPb from "@injectivelabs/core-proto-ts-v2/generated/cosmos/base/tendermint/v1beta1/query_pb";
import { ServiceClient } from "@injectivelabs/core-proto-ts-v2/generated/cosmos/base/tendermint/v1beta1/query_pb.client";

//#region src/client/chain/types/gov.ts
const VoteOptionMap = CosmosGovV1GovPb.VoteOption;
const ProposalStatusMap = CosmosGovV1GovPb.ProposalStatus;

//#endregion
//#region src/client/chain/types/wasm.ts
const ContractCodeHistoryOperationTypeMap = CosmwasmWasmV1TypesPb.ContractCodeHistoryOperationType;

//#endregion
//#region src/client/chain/types/staking.ts
const BondStatus = {
	UnBonded: "UnBonded",
	UnBonding: "UnBonding",
	Bonded: "Bonded"
};

//#endregion
//#region src/client/chain/types/exchange.ts
const GrpcOrderTypeMap = ExchangePb.OrderType;
const OrderTypeMap = ExchangePb.OrderType;
const GrpcMarketStatusMap = ExchangePb.MarketStatus;

//#endregion
//#region src/client/chain/types/insurance.ts
const OracleTypeMap = OracleType;

//#endregion
//#region src/client/chain/types/permissions.ts
const PermissionActionMap = InjectivePermissionsV1Beta1PermissionsPb.Action;

//#endregion
//#region src/client/chain/types/index.ts
const ChainModule = { ...ChainErrorModule };

//#endregion
//#region src/client/chain/transformers/ChainGrpcAuthTransformer.ts
/**
* @category Chain Grpc Transformer
*/
var ChainGrpcAuthTransformer = class ChainGrpcAuthTransformer {
	static moduleParamsResponseToModuleParams(response) {
		const params = response.params;
		return {
			maxMemoCharacters: Number(params.maxMemoCharacters),
			txSigLimit: Number(params.txSigLimit),
			txSizeCostPerByte: Number(params.txSizeCostPerByte),
			sigVerifyCostEd25519: Number(params.sigVerifyCostEd25519),
			sigVerifyCostSecp256k1: Number(params.sigVerifyCostSecp256K1)
		};
	}
	static grpcAccountToAccount(ethAccount) {
		const account = InjectiveTypesV1Beta1AccountPb.EthAccount.fromBinary(ethAccount.value);
		const baseAccount = account.baseAccount;
		const pubKey = baseAccount.pubKey;
		return {
			codeHash: uint8ArrayToString(account.codeHash),
			baseAccount: {
				address: baseAccount.address,
				pubKey: pubKey ? {
					key: uint8ArrayToBase64(InjectiveCryptoV1Beta1Ethsecp256k1KeysPb.PubKey.fromBinary(pubKey.value).key),
					typeUrl: pubKey.typeUrl
				} : void 0,
				accountNumber: Number(baseAccount.accountNumber),
				sequence: Number(baseAccount.sequence)
			}
		};
	}
	static accountResponseToAccount(response) {
		return ChainGrpcAuthTransformer.grpcAccountToAccount(response.account);
	}
	static accountsResponseToAccounts(response) {
		return {
			pagination: ChainGrpcCommonTransformer.grpcPaginationToPaginationV2(response.pagination),
			accounts: response.accounts.map(ChainGrpcAuthTransformer.grpcAccountToAccount)
		};
	}
};

//#endregion
//#region src/client/chain/grpc/ChainGrpcAuthApi.ts
/**
* @category Chain Grpc API
*/
var ChainGrpcAuthApi = class extends BaseGrpcConsumer {
	constructor(..._args) {
		super(..._args);
		_defineProperty(this, "module", ChainModule.Auth);
	}
	get client() {
		return this.initClient(QueryClient);
	}
	async fetchModuleParams() {
		const request = CosmosAuthV1Beta1QueryPb.QueryParamsRequest.create();
		const response = await this.executeGrpcCall(request, this.client.params.bind(this.client));
		return ChainGrpcAuthTransformer.moduleParamsResponseToModuleParams(response);
	}
	async fetchAccount(address) {
		const request = CosmosAuthV1Beta1QueryPb.QueryAccountRequest.create();
		request.address = address;
		const response = await this.executeGrpcCall(request, this.client.account.bind(this.client));
		return ChainGrpcAuthTransformer.accountResponseToAccount(response);
	}
	async fetchAccounts(pagination) {
		const request = CosmosAuthV1Beta1QueryPb.QueryAccountsRequest.create();
		const paginationForRequest = ChainGrpcCommonTransformer.pageRequestToGrpcPageRequestV2(pagination);
		if (paginationForRequest) request.pagination = paginationForRequest;
		const response = await this.executeGrpcCall(request, this.client.accounts.bind(this.client));
		return ChainGrpcAuthTransformer.accountsResponseToAccounts(response);
	}
};

//#endregion
//#region src/client/chain/grpc/ChainGrpcTendermintApi.ts
/**
* @category Chain Grpc API
*/
var ChainGrpcTendermintApi = class extends BaseGrpcConsumer {
	constructor(..._args) {
		super(..._args);
		_defineProperty(this, "module", ChainModule.Tendermint);
	}
	get client() {
		return this.initClient(ServiceClient);
	}
	async fetchLatestBlock() {
		const request = CosmosBaseTendermintV1Beta1QueryPb.GetLatestBlockRequest.create();
		const response = await this.executeGrpcCall(request, this.client.getLatestBlock.bind(this.client));
		return response.sdkBlock || response.block;
	}
	async fetchBlock(height) {
		const request = CosmosBaseTendermintV1Beta1QueryPb.GetBlockByHeightRequest.create();
		request.height = BigInt(height.toString());
		const response = await this.executeGrpcCall(request, this.client.getBlockByHeight.bind(this.client));
		return response.sdkBlock || response.block;
	}
};

//#endregion
//#region src/client/chain/rest/ChainRestAuthApi.ts
/**
* @category Chain Rest API
*/
var ChainRestAuthApi = class extends BaseRestConsumer {
	/**
	* Looks up the account information for the Injective address.
	*
	* @param address address of account to look up
	*/
	async fetchAccount(address, params = {}) {
		const endpoint = `cosmos/auth/v1beta1/accounts/${address}`;
		try {
			return (await this.retry(() => this.get(endpoint, params))).data;
		} catch (e) {
			if (e instanceof HttpRequestException) throw e;
			throw new HttpRequestException(new Error(e), {
				code: UnspecifiedErrorCode,
				context: `${this.endpoint}/${endpoint}`,
				contextModule: ChainModule.Auth
			});
		}
	}
	/**
	* Looks up the account information for any cosmos chain address.
	*
	* @param address address of account to look up
	*/
	async fetchCosmosAccount(address, params = {}) {
		const endpoint = `cosmos/auth/v1beta1/accounts/${address}`;
		try {
			const isInjectiveAddress = address.startsWith("inj") || address.startsWith("evmos");
			const response = await this.retry(() => this.get(endpoint, params));
			return isInjectiveAddress ? response.data.account.base_account : response.data.account;
		} catch (e) {
			if (e instanceof HttpRequestException) throw e;
			throw new HttpRequestException(new Error(e), {
				code: UnspecifiedErrorCode,
				context: `${this.endpoint}/${endpoint}`,
				contextModule: ChainModule.Auth
			});
		}
	}
};

//#endregion
//#region src/client/chain/rest/ChainRestTendermintApi.ts
/**
* @category Chain Rest API
*/
var ChainRestTendermintApi = class extends BaseRestConsumer {
	async fetchLatestBlock(params = {}) {
		const endpoint = `cosmos/base/tendermint/v1beta1/blocks/latest`;
		try {
			const response = await this.retry(() => this.get(endpoint, params));
			return response.data.sdk_block || response.data.block;
		} catch (e) {
			if (e instanceof HttpRequestException) throw e;
			throw new HttpRequestException(new Error(e), {
				code: UnspecifiedErrorCode,
				context: `${this.endpoint}/${endpoint}`,
				contextModule: ChainModule.Tendermint
			});
		}
	}
	async fetchBlock(height, params = {}) {
		const endpoint = `cosmos/base/tendermint/v1beta1/blocks/${height}`;
		try {
			const response = await this.retry(() => this.get(endpoint, params));
			return response.data.sdk_block || response.data.block;
		} catch (e) {
			if (e instanceof HttpRequestException) throw e;
			throw new HttpRequestException(new Error(e), {
				code: UnspecifiedErrorCode,
				context: `${this.endpoint}/${endpoint}`,
				contextModule: ChainModule.Tendermint
			});
		}
	}
	async fetchNodeInfo(params = {}) {
		const endpoint = `cosmos/base/tendermint/v1beta1/node_info`;
		try {
			const response = await this.retry(() => this.get(endpoint, params));
			return {
				nodeInfo: response.data.default_node_info,
				applicationVersion: response.data.application_version
			};
		} catch (e) {
			if (e instanceof HttpRequestException) throw e;
			throw new HttpRequestException(new Error(e), {
				code: UnspecifiedErrorCode,
				context: `${this.endpoint}/${endpoint}`,
				contextModule: ChainModule.Tendermint
			});
		}
	}
};

//#endregion
export { ChainGrpcAuthTransformer as a, OracleType as c, GrpcOrderTypeMap as d, OrderTypeMap as f, VoteOptionMap as g, ProposalStatusMap as h, ChainGrpcAuthApi as i, OracleTypeMap as l, ContractCodeHistoryOperationTypeMap as m, ChainRestAuthApi as n, ChainModule as o, BondStatus as p, ChainGrpcTendermintApi as r, PermissionActionMap as s, ChainRestTendermintApi as t, GrpcMarketStatusMap as u };