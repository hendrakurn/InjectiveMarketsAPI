import { Ft as BECH32_PUBKEY_ACC_PREFIX, Jt as stringToUint8Array, Mt as BECH32_ADDR_ACC_PREFIX, Nt as BECH32_ADDR_CONS_PREFIX, Pt as BECH32_ADDR_VAL_PREFIX, Qt as uint8ArrayToHex, Rt as DEFAULT_DERIVATION_PATH, Xt as toUtf8, Zt as uint8ArrayToBase64, dt as TypedDataUtilsSanitizeData, et as numberToCosmosSdkDecString, ft as decompressPubKey, h as getInjectiveAddress, m as getEthereumAddress, pn as safeBigIntStringify, qt as hexToUint8Array, t as recoverTypedSignaturePubKey, zt as base64ToUint8Array } from "./utils-CewUFGKA.js";
import { t as _defineProperty } from "./defineProperty-Bq6QU9Te.js";
import { t as MsgBase } from "./MsgBase-D4pO6org.js";
import * as CosmosTxV1Beta1TxPb from "@injectivelabs/core-proto-ts-v2/generated/cosmos/tx/v1beta1/tx_pb";
import { hashTypedData, keccak256, toBytes } from "viem";
import { DEFAULT_GAS_LIMIT, getDefaultStdFee, getStdFee, toBigNumber, toChainFormat } from "@injectivelabs/utils";
import { ErrorType, GeneralException } from "@injectivelabs/exceptions";
import { bech32 } from "@scure/base";
import { secp256k1 } from "@noble/curves/secp256k1";
import * as GoogleProtobufAnyPb from "@injectivelabs/core-proto-ts-v2/generated/google/protobuf/any_pb";
import * as InjectiveCryptoV1Beta1Ethsecp256k1KeysPb from "@injectivelabs/core-proto-ts-v2/generated/injective/crypto/v1beta1/ethsecp256k1/keys_pb";
import { generateMnemonic } from "@scure/bip39";
import { wordlist } from "@scure/bip39/wordlists/english";
import { ChainId, EvmChainId } from "@injectivelabs/ts-types";
import { HDNodeWallet, Signature, Wallet, concat, getBytes } from "ethers";
import * as InjectiveTypesV1Beta1TxExtPb from "@injectivelabs/core-proto-ts-v2/generated/injective/types/v1beta1/tx_ext_pb";
import * as CosmosBaseV1Beta1CoinPb from "@injectivelabs/core-proto-ts-v2/generated/cosmos/base/v1beta1/coin_pb";
import * as CosmosCryptoSecp256k1KeysPb from "@injectivelabs/core-proto-ts-v2/generated/cosmos/crypto/secp256k1/keys_pb";
import * as InjectiveExchangeV1Beta1TxPb from "@injectivelabs/core-proto-ts-v2/generated/injective/exchange/v1beta1/tx_pb";

//#region src/core/accounts/Address.ts
/**
* @category Utility Classes
*/
var Address = class Address {
	constructor(bech32Address) {
		_defineProperty(this, "bech32Address", void 0);
		this.bech32Address = bech32Address;
	}
	compare(address) {
		return this.bech32Address === address.bech32Address;
	}
	get address() {
		return this.bech32Address;
	}
	/**
	* Create an address instance from a bech32-encoded address and a prefix
	* @param {string} bech32 bech32-encoded address
	* @param {string} prefix
	* @return {Address}
	* @throws {Error} if bech is not a valid bech32-encoded address
	*/
	static fromBech32(bech, prefix = BECH32_ADDR_ACC_PREFIX) {
		try {
			const address = uint8ArrayToHex(bech32.fromWords(bech32.decode(bech).words));
			const addressBuffer = toBytes((address.startsWith("0x") ? address : `0x${address}`).toString());
			return new Address(bech32.encode(prefix, bech32.toWords(addressBuffer)));
		} catch (e) {
			throw new GeneralException(new Error(e), { type: ErrorType.ValidationError });
		}
	}
	/**
	* Create an address instance from an ethereum address
	* @param {string} hex Ethereum address
	* @param {string} prefix
	* @return {Address}
	* @throws {Error} if bech is not a valid bech32-encoded address
	*/
	static fromHex(hex, prefix = BECH32_ADDR_ACC_PREFIX) {
		const addressBuffer = toBytes((hex.startsWith("0x") ? hex : `0x${hex}`).toString());
		return new Address(bech32.encode(prefix, bech32.toWords(addressBuffer)));
	}
	/**
	* Convert an address instance to a bech32-encoded account address
	* @param {string} prefix
	* @returns {string}
	*/
	toBech32(prefix = BECH32_ADDR_ACC_PREFIX) {
		const address = this.toHex();
		const addressBuffer = toBytes(address.startsWith("0x") ? address : `0x${address}`);
		return bech32.encode(prefix, bech32.toWords(addressBuffer));
	}
	/**
	* Return a bech32-encoded account address
	* @return {string}
	* @throws {Error} if this address is not a valid account address
	* */
	toAccountAddress() {
		return this.toBech32(BECH32_ADDR_ACC_PREFIX);
	}
	/**
	* Return a bech32-encoded validator address
	* @return {string}
	* @throws {Error} if this address is not a valid validator address
	* */
	toValidatorAddress() {
		return this.toBech32(BECH32_ADDR_VAL_PREFIX);
	}
	/**
	* Return a bech32-encoded consensus address
	* @return {string}
	* @throws {Error} if this address is not a valid consensus address
	* */
	toConsensusAddress() {
		return this.toBech32(BECH32_ADDR_CONS_PREFIX);
	}
	/**
	* Return a hex representation of address
	* @return {string}
	* @throws {Error} if this address is not a valid account address
	* */
	toHex() {
		const { bech32Address } = this;
		const address = uint8ArrayToHex(bech32.fromWords(bech32.decode(bech32Address).words));
		return address.startsWith("0x") ? address : `0x${address}`;
	}
	/**
	* Return a subaccount address from the given bech32 encoded address
	* @param {number} index the subaccount index
	* @return {string}
	* @throws {Error} if this address is not a valid account address
	* */
	getSubaccountId(index = 0) {
		const suffix = "0".repeat(23) + index;
		return `${this.toHex()}${suffix}`;
	}
	/**
	* Return a ethereum address from the given bech32 encoded address
	* @return {string}
	* @throws {Error} if this address is not a valid account address
	* */
	getEthereumAddress() {
		return this.toHex();
	}
};

//#endregion
//#region src/core/accounts/PublicKey.ts
/**
* @category Crypto Utility Classes
*/
var PublicKey = class PublicKey {
	constructor(key, type) {
		_defineProperty(this, "type", void 0);
		_defineProperty(this, "key", void 0);
		this.key = key;
		this.type = type || "/injective.crypto.v1beta1.ethsecp256k1.PubKey";
	}
	static fromBase64(publicKey) {
		return new PublicKey(base64ToUint8Array(publicKey));
	}
	static fromBytes(publicKey) {
		return new PublicKey(publicKey);
	}
	static fromHex(pubKey) {
		return new PublicKey(hexToUint8Array((pubKey.startsWith("0x") ? pubKey.slice(2) : pubKey).toString()));
	}
	static fromPrivateKeyHex(privateKey) {
		const isString = typeof privateKey === "string";
		const privateKeyHex = isString && privateKey.startsWith("0x") ? privateKey.slice(2) : privateKey;
		const privateKeyBuff = isString ? hexToUint8Array(privateKeyHex.toString()) : privateKey;
		return new PublicKey(secp256k1.getPublicKey(privateKeyBuff, true), "/injective.crypto.v1beta1.ethsecp256k1.PubKey");
	}
	toPubKeyBytes() {
		return this.key;
	}
	toBase64() {
		return uint8ArrayToBase64(this.toPubKeyBytes());
	}
	toHex() {
		return uint8ArrayToHex(this.toPubKeyBytes());
	}
	/**
	* Convert the public key to a pubkey in bech32 format.
	* Note: this does not convert the public key to an address.
	*/
	toBech32() {
		return bech32.encode(BECH32_PUBKEY_ACC_PREFIX, bech32.toWords(hexToUint8Array(this.toHex())));
	}
	toAddress() {
		const decompressedPublicKey = decompressPubKey(this.toHex());
		const addressBuffer = keccak256(toBytes(decompressedPublicKey.startsWith("0x") ? decompressedPublicKey : "0x" + decompressedPublicKey), "bytes").subarray(-20);
		return Address.fromHex(uint8ArrayToHex(addressBuffer).toLowerCase());
	}
	toProto() {
		const proto = InjectiveCryptoV1Beta1Ethsecp256k1KeysPb.PubKey.create();
		proto.key = this.key;
		return proto;
	}
	toAny() {
		const proto = this.toProto();
		const message = GoogleProtobufAnyPb.Any.create();
		message.typeUrl = this.type;
		message.value = InjectiveCryptoV1Beta1Ethsecp256k1KeysPb.PubKey.toBinary(proto);
		return message;
	}
};

//#endregion
//#region src/core/tx/utils/helpers.ts
const createAnyMessage = (msg) => {
	const message = GoogleProtobufAnyPb.Any.create();
	message.typeUrl = `${msg.type.startsWith("/") ? "" : "/"}${msg.type}`;
	message.value = msg.value;
	return message;
};
const createAny = (value, type) => {
	const message = GoogleProtobufAnyPb.Any.create();
	message.typeUrl = type;
	message.value = value;
	return message;
};
const getInjectiveSignerAddress = (address) => {
	if (!address) return "";
	if (address.startsWith("inj")) return address;
	if (address.startsWith("0x")) return getInjectiveAddress(address);
	return address;
};
const getEthereumSignerAddress = (address) => {
	if (!address) return "";
	if (address.startsWith("0x")) return address;
	if (address.startsWith("inj")) return getEthereumAddress(address);
	return `0x${address}`;
};

//#endregion
//#region src/core/tx/utils/tx.ts
const getPublicKey = ({ chainId, key }) => {
	if (typeof key !== "string") return key;
	let proto;
	let path;
	let baseProto;
	if (chainId.startsWith("injective")) {
		proto = CosmosCryptoSecp256k1KeysPb.PubKey.create();
		baseProto = CosmosCryptoSecp256k1KeysPb.PubKey;
		path = "/injective.crypto.v1beta1.ethsecp256k1.PubKey";
	} else if (chainId.startsWith("evmos")) {
		proto = CosmosCryptoSecp256k1KeysPb.PubKey.create();
		baseProto = CosmosCryptoSecp256k1KeysPb.PubKey;
		path = "/ethermint.crypto.v1.ethsecp256k1.PubKey";
	} else {
		proto = CosmosCryptoSecp256k1KeysPb.PubKey.create();
		baseProto = CosmosCryptoSecp256k1KeysPb.PubKey;
		path = "/cosmos.crypto.secp256k1.PubKey";
	}
	proto.key = base64ToUint8Array(key);
	return createAny(baseProto.toBinary(proto), path);
};
const createBody = ({ message, memo = "", timeoutHeight }) => {
	const messages = Array.isArray(message) ? message : [message];
	const txBody = CosmosTxV1Beta1TxPb.TxBody.create();
	txBody.messages = messages.map((message$1) => createAnyMessage({
		value: message$1.toBinary(),
		type: message$1.toDirectSign().type
	}));
	txBody.memo = memo;
	if (timeoutHeight) txBody.timeoutHeight = BigInt(timeoutHeight);
	return txBody;
};
const createFee = ({ fee, payer, granter, gasLimit }) => {
	const feeAmount = CosmosBaseV1Beta1CoinPb.Coin.create();
	feeAmount.amount = fee.amount;
	feeAmount.denom = fee.denom;
	const feeProto = CosmosTxV1Beta1TxPb.Fee.create();
	feeProto.gasLimit = BigInt(gasLimit);
	feeProto.amount = [feeAmount];
	if (payer) feeProto.payer = payer;
	if (granter) feeProto.granter = granter;
	return feeProto;
};
const createSigners = ({ chainId, mode, signers }) => {
	return signers.map((s) => createSignerInfo({
		mode,
		chainId,
		publicKey: s.pubKey,
		sequence: s.sequence
	}));
};
const createSignerInfo = ({ chainId, publicKey, sequence, mode }) => {
	const pubKey = getPublicKey({
		chainId,
		key: publicKey
	});
	const single = CosmosTxV1Beta1TxPb.ModeInfo_Single.create();
	single.mode = mode;
	const modeInfo = CosmosTxV1Beta1TxPb.ModeInfo.create();
	modeInfo.sum = {
		oneofKind: "single",
		single
	};
	const signerInfo = CosmosTxV1Beta1TxPb.SignerInfo.create();
	signerInfo.publicKey = pubKey;
	signerInfo.sequence = BigInt(sequence);
	signerInfo.modeInfo = modeInfo;
	return signerInfo;
};
const createAuthInfo = ({ signerInfo, fee }) => {
	const authInfo = CosmosTxV1Beta1TxPb.AuthInfo.create();
	authInfo.signerInfos = signerInfo;
	authInfo.fee = fee;
	return authInfo;
};
const createSignDoc = ({ bodyBytes, authInfoBytes, chainId, accountNumber }) => {
	const signDoc = CosmosTxV1Beta1TxPb.SignDoc.create();
	signDoc.accountNumber = BigInt(accountNumber);
	signDoc.chainId = chainId;
	signDoc.bodyBytes = bodyBytes;
	signDoc.authInfoBytes = authInfoBytes;
	return signDoc;
};
const createSignDocFromTransaction = (args) => {
	return CosmosTxV1Beta1TxPb.SignDoc.create({
		bodyBytes: args.txRaw.bodyBytes,
		authInfoBytes: args.txRaw.authInfoBytes,
		accountNumber: BigInt(args.accountNumber),
		chainId: args.chainId
	});
};
const createTxRawEIP712 = (txRaw, extension, nonCriticalExtension) => {
	const body = CosmosTxV1Beta1TxPb.TxBody.fromBinary(txRaw.bodyBytes);
	body.extensionOptions = [createAny(InjectiveTypesV1Beta1TxExtPb.ExtensionOptionsWeb3Tx.toBinary(extension), "/injective.types.v1beta1.ExtensionOptionsWeb3Tx")];
	if (nonCriticalExtension) body.nonCriticalExtensionOptions = Array.isArray(nonCriticalExtension) ? nonCriticalExtension : [nonCriticalExtension];
	txRaw.bodyBytes = CosmosTxV1Beta1TxPb.TxBody.toBinary(body);
	return txRaw;
};
const createWeb3Extension = ({ evmChainId, feePayer, feePayerSig }) => {
	const web3Extension = InjectiveTypesV1Beta1TxExtPb.ExtensionOptionsWeb3Tx.create();
	web3Extension.typedDataChainID = BigInt(evmChainId);
	if (feePayer) web3Extension.feePayer = feePayer;
	if (feePayerSig) web3Extension.feePayerSig = feePayerSig;
	return web3Extension;
};
const createNonCriticalExtensionFromObject = (object) => {
	return createAny(new TextEncoder().encode(safeBigIntStringify(object)), "/google.protobuf.Struct");
};
const getTransactionPartsFromTxRaw = (txRaw) => {
	const authInfo = CosmosTxV1Beta1TxPb.AuthInfo.fromBinary(txRaw.authInfoBytes);
	return {
		body: CosmosTxV1Beta1TxPb.TxBody.fromBinary(txRaw.bodyBytes),
		authInfo,
		signatures: txRaw.signatures
	};
};
const getAminoStdSignDoc = ({ memo, chainId, accountNumber, timeoutHeight, sequence, gas, msgs }) => ({
	chain_id: chainId,
	timeout_height: timeoutHeight || "",
	account_number: accountNumber.toString(),
	sequence: sequence.toString(),
	fee: getStdFee({ gas }),
	msgs: msgs.map((m) => m.toAmino()),
	memo: memo || ""
});

//#endregion
//#region src/core/tx/eip712/utils.ts
const getEip712Domain = (evmChainId) => {
	return { domain: {
		name: "Injective Web3",
		version: "1.0.0",
		chainId: "0x" + toBigNumber(evmChainId).toString(16),
		salt: "0",
		verifyingContract: "cosmos"
	} };
};
const getEip712DomainV2 = (evmChainId) => {
	return { domain: {
		name: "Injective Web3",
		version: "1.0.0",
		chainId: "0x" + toBigNumber(evmChainId).toString(16),
		verifyingContract: "0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC",
		salt: "0"
	} };
};
const getDefaultEip712Types = () => {
	return { types: {
		EIP712Domain: [
			{
				name: "name",
				type: "string"
			},
			{
				name: "version",
				type: "string"
			},
			{
				name: "chainId",
				type: "uint256"
			},
			{
				name: "verifyingContract",
				type: "string"
			},
			{
				name: "salt",
				type: "string"
			}
		],
		Tx: [
			{
				name: "account_number",
				type: "string"
			},
			{
				name: "chain_id",
				type: "string"
			},
			{
				name: "fee",
				type: "Fee"
			},
			{
				name: "memo",
				type: "string"
			},
			{
				name: "msgs",
				type: "Msg[]"
			},
			{
				name: "sequence",
				type: "string"
			},
			{
				name: "timeout_height",
				type: "string"
			}
		],
		Fee: [{
			name: "amount",
			type: "Coin[]"
		}, {
			name: "gas",
			type: "string"
		}],
		Coin: [{
			name: "denom",
			type: "string"
		}, {
			name: "amount",
			type: "string"
		}],
		Msg: [{
			name: "type",
			type: "string"
		}, {
			name: "value",
			type: "MsgValue"
		}]
	} };
};
const getDefaultEip712TypesV2 = () => {
	return { types: {
		EIP712Domain: [
			{
				name: "name",
				type: "string"
			},
			{
				name: "version",
				type: "string"
			},
			{
				name: "chainId",
				type: "uint256"
			},
			{
				name: "verifyingContract",
				type: "address"
			},
			{
				name: "salt",
				type: "string"
			}
		],
		Tx: [{
			name: "context",
			type: "string"
		}, {
			name: "msgs",
			type: "string"
		}]
	} };
};
const getEip712Fee = (params) => {
	const defaultStdFee = getDefaultStdFee();
	if (!params) return { fee: defaultStdFee };
	const { amount, gas, feePayer } = {
		amount: params.amount || defaultStdFee.amount,
		gas: params.gas || DEFAULT_GAS_LIMIT.toFixed(),
		feePayer: params.feePayer
	};
	return { fee: {
		...feePayer && { feePayer },
		gas,
		amount
	} };
};
const getEip712FeeV2 = (params) => {
	const defaultStdFee = getDefaultStdFee();
	if (!params) return { fee: {
		amount: [{
			denom: defaultStdFee.amount[0].denom,
			amount: defaultStdFee.amount[0].amount
		}],
		gas: Number(defaultStdFee.gas)
	} };
	const amountFromParams = (params.amount || defaultStdFee.amount)[0];
	const { amount, gas, payer } = {
		amount: [{
			denom: amountFromParams.denom,
			amount: amountFromParams.amount
		}],
		gas: Number(params.gas || DEFAULT_GAS_LIMIT.toFixed()),
		payer: params.feePayer
	};
	return { fee: {
		amount,
		gas,
		...payer && { payer }
	} };
};
const getTypesIncludingFeePayer = ({ fee, types }) => {
	if (!fee) return types;
	if (!fee.feePayer) return types;
	types.types["Fee"].unshift({
		name: "feePayer",
		type: "string"
	});
	return types;
};
const getEipTxDetails = ({ accountNumber, sequence, timeoutHeight, chainId, memo }) => {
	return {
		account_number: accountNumber,
		chain_id: chainId,
		timeout_height: timeoutHeight,
		memo: memo || "",
		sequence
	};
};
const getEipTxContext = ({ accountNumber, sequence, fee, timeoutHeight, chainId, memo }) => {
	return {
		account_number: Number(accountNumber),
		chain_id: chainId,
		...getEip712FeeV2(fee),
		memo: memo || "",
		sequence: Number(sequence),
		timeout_height: Number(timeoutHeight)
	};
};

//#endregion
//#region src/core/tx/eip712/eip712.ts
const getEip712TypedData = ({ msgs, tx, fee, evmChainId }) => {
	const messages = Array.isArray(msgs) ? msgs : [msgs];
	const eip712Msgs = messages.map((m) => m.toEip712());
	const eip712MessageTypes = messages[0].toEip712Types();
	return {
		...getTypesIncludingFeePayer({
			fee,
			types: { types: {
				...getDefaultEip712Types().types,
				...Object.fromEntries(eip712MessageTypes)
			} }
		}),
		primaryType: "Tx",
		...getEip712Domain(evmChainId),
		message: {
			...getEipTxDetails(tx),
			...getEip712Fee(fee),
			msgs: eip712Msgs
		}
	};
};
const getEip712TypedDataV2 = ({ msgs, tx, fee, evmChainId }) => {
	const eip712Msgs = (Array.isArray(msgs) ? msgs : [msgs]).map((m) => m.toEip712V2());
	return {
		...getDefaultEip712TypesV2(),
		primaryType: "Tx",
		...getEip712DomainV2(evmChainId),
		message: {
			context: safeBigIntStringify(getEipTxContext({
				...tx,
				fee
			})),
			msgs: safeBigIntStringify(eip712Msgs)
		}
	};
};

//#endregion
//#region src/core/modules/exchange/msgs/MsgSignData.ts
/**
* @category Messages
*/
var MsgSignData = class MsgSignData extends MsgBase {
	static fromJSON(params) {
		return new MsgSignData(params);
	}
	toProto() {
		const { params } = this;
		return InjectiveExchangeV1Beta1TxPb.MsgSignData.create({
			signer: hexToUint8Array(getEthereumAddress(params.sender)),
			data: stringToUint8Array(toUtf8(params.data))
		});
	}
	toData() {
		const proto = this.toProto();
		return {
			"@type": "/injective.exchange.v1beta1.MsgSignData",
			...proto
		};
	}
	toAmino() {
		const proto = this.toProto();
		return {
			type: "sign/MsgSignData",
			value: {
				signer: uint8ArrayToHex(proto.signer),
				data: toUtf8(proto.data)
			}
		};
	}
	toWeb3Gw() {
		const { value } = this.toAmino();
		return {
			"@type": "/injective.exchange.v1beta1.MsgSignData",
			...value
		};
	}
	toDirectSign() {
		return {
			type: "/injective.exchange.v1beta1.MsgSignData",
			message: this.toProto()
		};
	}
	toBinary() {
		return InjectiveExchangeV1Beta1TxPb.MsgSignData.toBinary(this.toProto());
	}
};

//#endregion
//#region src/core/modules/exchange/msgs/MsgIncreasePositionMargin.ts
const createMessage = (params) => {
	return InjectiveExchangeV1Beta1TxPb.MsgIncreasePositionMargin.create({
		sender: params.injectiveAddress,
		sourceSubaccountId: params.srcSubaccountId,
		destinationSubaccountId: params.dstSubaccountId,
		marketId: params.marketId,
		amount: params.amount
	});
};
/**
* @category Messages
*/
var MsgIncreasePositionMargin = class MsgIncreasePositionMargin extends MsgBase {
	static fromJSON(params) {
		return new MsgIncreasePositionMargin(params);
	}
	toProto() {
		const { params: initialParams } = this;
		return createMessage({
			...initialParams,
			amount: toChainFormat(initialParams.amount).toFixed()
		});
	}
	toData() {
		const proto = this.toProto();
		return {
			"@type": "/injective.exchange.v1beta1.MsgIncreasePositionMargin",
			...proto
		};
	}
	toAmino() {
		const { params } = this;
		return {
			type: "exchange/MsgIncreasePositionMargin",
			value: {
				sender: params.injectiveAddress,
				source_subaccount_id: params.srcSubaccountId,
				destination_subaccount_id: params.dstSubaccountId,
				market_id: params.marketId,
				amount: params.amount
			}
		};
	}
	toWeb3Gw() {
		const { value } = this.toAmino();
		return {
			"@type": "/injective.exchange.v1beta1.MsgIncreasePositionMargin",
			...value
		};
	}
	toEip712() {
		const { type, value } = this.toAmino();
		return {
			type,
			value: {
				...value,
				amount: toChainFormat(value.amount).toFixed()
			}
		};
	}
	toEip712V2() {
		const { params } = this;
		return {
			...this.toWeb3Gw(),
			amount: numberToCosmosSdkDecString(params.amount)
		};
	}
	toDirectSign() {
		return {
			type: "/injective.exchange.v1beta1.MsgIncreasePositionMargin",
			message: this.toProto()
		};
	}
	toBinary() {
		return InjectiveExchangeV1Beta1TxPb.MsgIncreasePositionMargin.toBinary(this.toProto());
	}
};

//#endregion
//#region src/core/tx/eip712/MsgDecoder.ts
var MsgDecoder = class {
	static decode(message) {
		const type = message.typeUrl;
		switch (true) {
			case type.includes("MsgIncreasePositionMargin"): {
				const msg = InjectiveExchangeV1Beta1TxPb.MsgIncreasePositionMargin.fromBinary(message.value);
				return MsgIncreasePositionMargin.fromJSON({
					marketId: msg.marketId,
					injectiveAddress: msg.sender,
					srcSubaccountId: msg.sourceSubaccountId,
					dstSubaccountId: msg.destinationSubaccountId,
					amount: msg.amount
				});
			}
			case type.includes("MsgSignData"): {
				const msg = InjectiveExchangeV1Beta1TxPb.MsgSignData.fromBinary(message.value);
				return MsgSignData.fromJSON({
					data: toUtf8(msg.data),
					sender: getInjectiveAddress(uint8ArrayToHex(msg.signer))
				});
			}
			default: throw new Error("Unknown message type");
		}
	}
};

//#endregion
//#region src/core/accounts/PrivateKey.ts
/**
* Class for wrapping SigningKey that is used for signature creation and public key derivation.
*
* @category Crypto Utility Classes
*/
var PrivateKey = class PrivateKey {
	constructor(wallet) {
		_defineProperty(this, "wallet", void 0);
		this.wallet = wallet;
	}
	/**
	* Generate new private key with random mnemonic phrase
	* @returns { privateKey: PrivateKey, mnemonic: string }
	*/
	static generate() {
		const mnemonic = generateMnemonic(wordlist);
		return {
			privateKey: PrivateKey.fromMnemonic(mnemonic),
			mnemonic
		};
	}
	/**
	* Create a PrivateKey instance from a given mnemonic phrase and a HD derivation path.
	* If path is not given, default to Band's HD prefix 494 and all other indexes being zeroes.
	* @param {string} words the mnemonic phrase
	* @param {string|undefined} path the HD path that follows the BIP32 standard (optional)
	* @returns {PrivateKey} Initialized PrivateKey object
	*/
	static fromMnemonic(words, path = DEFAULT_DERIVATION_PATH) {
		return new PrivateKey(new Wallet(HDNodeWallet.fromPhrase(words, void 0, path).privateKey));
	}
	/**
	* Create a PrivateKey instance from a given private key and a HD derivation path.
	* If path is not given, default to Band's HD prefix 494 and all other indexes being zeroes.
	* @param {string} privateKey  the private key
	* @returns {PrivateKey} Initialized PrivateKey object
	*
	* @deprecated - use fromHex instead
	*/
	static fromPrivateKey(privateKey) {
		return new PrivateKey(new Wallet(privateKey));
	}
	/**
	* Create a PrivateKey instance from a given private key and a HD derivation path.
	* If path is not given, default to Band's HD prefix 494 and all other indexes being zeroes.
	* @param {string} privateKey  the private key
	* @returns {PrivateKey} Initialized PrivateKey object
	*/
	static fromHex(privateKey) {
		const isString = typeof privateKey === "string";
		const privateKeyHex = isString && privateKey.startsWith("0x") ? privateKey.slice(2) : privateKey;
		return new PrivateKey(new Wallet(uint8ArrayToHex(isString ? hexToUint8Array(privateKeyHex.toString()) : privateKey)));
	}
	/**
	* Return the private key in hex
	* @returns {string}
	**/
	toPrivateKeyHex() {
		return this.wallet.privateKey.startsWith("0x") ? this.wallet.privateKey : `0x${this.wallet.privateKey}`;
	}
	/**
	* Return the PublicKey associated with this private key.
	* @returns {PublicKey} a Public key that can be used to verify the signatures made with this PrivateKey
	**/
	toPublicKey() {
		return PublicKey.fromPrivateKeyHex(this.wallet.privateKey);
	}
	/**
	* Return the hex address associated with this private key.
	* @returns {string}
	*/
	toHex() {
		return this.wallet.address.startsWith("0x") ? this.wallet.address : `0x${this.wallet.address}`;
	}
	/**
	* Return the Address associated with this private key.
	* @returns {Address}
	**/
	toAddress() {
		return Address.fromHex(this.toHex());
	}
	/**
	* Return the Bech32 address associated with this private key.
	* @returns {string}
	**/
	toBech32() {
		return Address.fromHex(this.toHex()).toBech32();
	}
	/**
	* Sign the given message using the wallet's _signingKey function.
	* @param {string} messageBytes: the message that will be hashed and signed, a Buffer made of bytes
	* @returns {Uint8Array} a signature of this private key over the given message
	*/
	sign(messageBytes) {
		const { wallet } = this;
		const msgHash = keccak256(messageBytes);
		const signature = wallet.signingKey.sign(msgHash);
		const splittedSignature = Signature.from(signature);
		return getBytes(concat([splittedSignature.r, splittedSignature.s]));
	}
	/**
	* Sign the given message using the edcsa sign_deterministic function.
	* @param {Buffer} messageBytes: the message that will be hashed and signed, a Buffer made of bytes
	* @returns {Uint8Array} a signature of this private key over the given message
	*/
	signEcda(messageBytes) {
		const { wallet } = this;
		const msgHash = keccak256(messageBytes);
		const privateKey = hexToUint8Array(wallet.privateKey.startsWith("0x") ? wallet.privateKey.slice(2) : wallet.privateKey);
		return secp256k1.sign(toBytes(msgHash), privateKey).toCompactRawBytes();
	}
	/**
	* Sign the given message using the wallet's _signingKey function.
	* @param {string} messageHashedBytes: the message that will be signed, a Buffer made of bytes
	* @returns {Uint8Array} a signature of this private key over the given message
	*/
	signHashed(messageHashedBytes) {
		const { wallet } = this;
		const signature = wallet.signingKey.sign(messageHashedBytes);
		const splittedSignature = Signature.from(signature);
		return getBytes(concat([splittedSignature.r, splittedSignature.s]));
	}
	/**
	* Sign the given message using the edcsa sign_deterministic function.
	* @param {Buffer} messageHashedBytes: the message that will be signed, a Buffer made of bytes
	* @returns {Uint8Array} a signature of this private key over the given message
	*/
	signHashedEcda(messageHashedBytes) {
		const { wallet } = this;
		const privateKey = hexToUint8Array(wallet.privateKey.startsWith("0x") ? wallet.privateKey.slice(2) : wallet.privateKey);
		return secp256k1.sign(messageHashedBytes, privateKey).toCompactRawBytes();
	}
	/**
	* Sign the given typed data using the edcsa sign_deterministic function.
	* @param {TypedDataDefinition | any} eip712Data: the typed data that will be hashed and signed
	* @returns {Uint8Array} a signature of this private key over the given message
	*/
	async signTypedData(eip712Data) {
		const { wallet } = this;
		const privateKeyHex = wallet.privateKey.startsWith("0x") ? wallet.privateKey.slice(2) : wallet.privateKey;
		const msgHashBytes = hashTypedData(TypedDataUtilsSanitizeData(eip712Data));
		const privateKey = hexToUint8Array(privateKeyHex);
		const sig = secp256k1.sign(toBytes(msgHashBytes), privateKey);
		const signature = sig.toCompactRawBytes();
		const signatureWithRecovery = new Uint8Array(signature.length + 1);
		signatureWithRecovery.set(signature);
		signatureWithRecovery[signature.length] = sig.recovery + 27;
		return signatureWithRecovery;
	}
	/**
	* Sign the given typed data using the edcsa sign_deterministic function.
	* @param {Buffer} eip712Data: the typed data that will be signed, a Buffer made of bytes
	* @returns {Uint8Array} a signature of this private key over the given message
	*/
	signHashedTypedData(eip712Data) {
		const { wallet } = this;
		const privateKey = hexToUint8Array(wallet.privateKey.startsWith("0x") ? wallet.privateKey.slice(2) : wallet.privateKey);
		return secp256k1.sign(eip712Data, privateKey).toCompactRawBytes();
	}
	/**
	* Verify signature using EIP712 typed data
	* and the publicKey
	*
	* (params are passed as an object)
	*
	* @param {string} signature: the signature to verify in hex
	* @param {any} eip712: the EIP712 typed data to verify against
	* @param {string} publicKey: the public key to verify against in hex
	* */
	static async verifySignature({ signature, eip712, publicKey }) {
		const publicKeyInHex = publicKey.startsWith("0x") ? publicKey : `0x${publicKey}`;
		const recoveredPubKey = await recoverTypedSignaturePubKey(eip712, signature);
		const recoveredPubKeyInHex = recoveredPubKey.startsWith("0x") ? recoveredPubKey : `0x${recoveredPubKey}`;
		/** uncompressed/compressed key */
		if (publicKeyInHex.length !== recoveredPubKeyInHex.length) return recoveredPubKeyInHex.substring(0, publicKeyInHex.length) === publicKeyInHex;
		return publicKeyInHex === recoveredPubKeyInHex;
	}
	/**
	* Verify signature using EIP712 typed data
	* and the publicKey
	*
	* (params are passed as an object)
	*
	* @param {string} signature: the signature to verify in hex
	* @param {any} eip712: the EIP712 typed data to verify against
	* @param {string} publicKey: the public key to verify against in hex
	* */
	async verifyThisPkSignature({ signature, eip712 }) {
		const publicKeyInHex = `0x${this.toPublicKey().toHex()}`;
		const recoveredPubKey = await recoverTypedSignaturePubKey(eip712, signature);
		const recoveredPubKeyInHex = recoveredPubKey.startsWith("0x") ? recoveredPubKey : `0x${recoveredPubKey}`;
		/** uncompressed/compressed key */
		if (publicKeyInHex.length !== recoveredPubKeyInHex.length) return recoveredPubKeyInHex.substring(0, publicKeyInHex.length) === publicKeyInHex;
		return publicKeyInHex === recoveredPubKeyInHex;
	}
	/**
	* Verify cosmos signature EIP712 typed
	* data from the TxRaw and verify the signature
	* that's included in the TxRaw
	*
	* (params are passed as an object)
	*
	* @param {CosmosTxV1Beta1TxPb.TxRaw} txRaw: the signature to verify in hex
	* @param {object} signer: the public key and the account number to verify against
	**/
	static async verifyCosmosSignature({ txRaw, signer }) {
		const { body, authInfo, signatures } = getTransactionPartsFromTxRaw(txRaw);
		if (authInfo.signerInfos.length > 1 || signatures.length > 1) throw new GeneralException(/* @__PURE__ */ new Error("Validation of multiple signers is not supported"));
		if (body.messages.length > 1) throw new GeneralException(/* @__PURE__ */ new Error("Validation of multiple messages is not supported"));
		const getChainIds = () => {
			if (!body.extensionOptions.length) return {
				chainId: ChainId.Mainnet,
				EvmChainId: EvmChainId.Mainnet
			};
			const extension = body.extensionOptions.find((extension$1) => extension$1.typeUrl.includes("ExtensionOptionsWeb3Tx"));
			if (!extension) return {
				chainId: ChainId.Mainnet,
				EvmChainId: EvmChainId.Mainnet
			};
			const decodedExtension = InjectiveTypesV1Beta1TxExtPb.ExtensionOptionsWeb3Tx.fromBinary(extension.value);
			const evmChainId$1 = Number(decodedExtension.typedDataChainID);
			return {
				evmChainId: EvmChainId,
				chainId: [
					EvmChainId.Kovan,
					EvmChainId.Goerli,
					EvmChainId.Sepolia
				].includes(evmChainId$1) ? ChainId.Testnet : ChainId.Mainnet
			};
		};
		const { evmChainId, chainId } = getChainIds();
		const [signerInfo] = authInfo.signerInfos;
		const [signature] = signatures;
		const [msg] = body.messages;
		const eip712TypedData = getEip712TypedData({
			msgs: [MsgDecoder.decode(msg)],
			fee: authInfo.fee,
			tx: {
				memo: body.memo,
				accountNumber: signer.accountNumber.toString(),
				sequence: signerInfo.sequence.toString(),
				timeoutHeight: body.timeoutHeight.toString(),
				chainId
			},
			evmChainId
		});
		return await this.verifySignature({
			eip712: eip712TypedData,
			signature: uint8ArrayToHex(signature),
			publicKey: uint8ArrayToHex(base64ToUint8Array(signer.publicKey))
		});
	}
	/**
	* Verify signature using ADR-36 sign doc
	* and the publicKey
	*
	* (params are passed as an object)
	*
	* @param {string} signature: the signature to verify in hex
	* @param {any} signDoc: the signDoc to verify against
	* @param {string} publicKey:the public key to verify against in hex
	* */
	static verifyArbitrarySignature({ signature, signDoc, publicKey }) {
		const sigHex = signature.startsWith("0x") ? signature : `0x${signature}`;
		const pubHex = publicKey.startsWith("0x") ? publicKey : `0x${publicKey}`;
		return secp256k1.verify(toBytes(sigHex), toBytes(keccak256(signDoc)), toBytes(pubHex));
	}
};

//#endregion
//#region src/core/accounts/BaseAccount.ts
/**
* @category Utility Classes
*/
var BaseAccount = class BaseAccount extends Address {
	constructor({ address, accountNumber, sequence, pubKey }) {
		super(address);
		_defineProperty(this, "accountNumber", void 0);
		_defineProperty(this, "sequence", void 0);
		_defineProperty(this, "pubKey", void 0);
		this.accountNumber = accountNumber;
		this.sequence = sequence;
		this.pubKey = pubKey;
	}
	static fromRestApi(accountResponse) {
		const { base_account: baseAccount } = accountResponse.account;
		return new BaseAccount({
			address: baseAccount.address,
			accountNumber: baseAccount.account_number ? parseInt(baseAccount.account_number, 10) : 0,
			sequence: baseAccount.sequence ? parseInt(baseAccount.sequence, 10) : 0,
			pubKey: baseAccount.pub_key ? {
				type: baseAccount.pub_key["@type"],
				key: baseAccount.pub_key.key
			} : {
				type: "",
				key: ""
			}
		});
	}
	static fromRestCosmosApi(accountResponse) {
		return new BaseAccount({
			address: accountResponse.address,
			accountNumber: accountResponse.account_number ? parseInt(accountResponse.account_number, 10) : 0,
			sequence: accountResponse.sequence ? parseInt(accountResponse.sequence, 10) : 0,
			pubKey: accountResponse.pub_key ? {
				type: accountResponse.pub_key["@type"],
				key: accountResponse.pub_key.key
			} : {
				type: "",
				key: ""
			}
		});
	}
	incrementSequence() {
		this.sequence += 1;
		return this;
	}
	toAccountDetails() {
		return {
			pubKey: this.pubKey,
			sequence: this.sequence,
			address: this.bech32Address,
			accountNumber: this.accountNumber
		};
	}
};

//#endregion
export { createAny as A, createSignerInfo as C, getAminoStdSignDoc as D, createWeb3Extension as E, Address as F, getEthereumSignerAddress as M, getInjectiveSignerAddress as N, getPublicKey as O, PublicKey as P, createSignDocFromTransaction as S, createTxRawEIP712 as T, createAuthInfo as _, MsgSignData as a, createNonCriticalExtensionFromObject as b, getDefaultEip712Types as c, getEip712DomainV2 as d, getEip712Fee as f, getTypesIncludingFeePayer as g, getEipTxDetails as h, MsgIncreasePositionMargin as i, createAnyMessage as j, getTransactionPartsFromTxRaw as k, getDefaultEip712TypesV2 as l, getEipTxContext as m, PrivateKey as n, getEip712TypedData as o, getEip712FeeV2 as p, MsgDecoder as r, getEip712TypedDataV2 as s, BaseAccount as t, getEip712Domain as u, createBody as v, createSigners as w, createSignDoc as x, createFee as y };