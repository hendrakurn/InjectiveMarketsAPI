import { Qt as uint8ArrayToHex, Zt as uint8ArrayToBase64, zt as base64ToUint8Array } from "./utils-CewUFGKA.js";
import { t as _defineProperty } from "./defineProperty-Bq6QU9Te.js";
import { O as getPublicKey, P as PublicKey, n as PrivateKey } from "./accounts-CP_DVUou.js";
import * as CosmosBaseV1Beta1CoinPb from "@injectivelabs/core-proto-ts-v2/generated/cosmos/base/v1beta1/coin_pb";
import * as InjectiveTypesV1Beta1AccountPb from "@injectivelabs/core-proto-ts-v2/generated/injective/types/v1beta1/account_pb";
import * as IbcCoreClientV1ClientPb from "@injectivelabs/core-proto-ts-v2/generated/ibc/core/client/v1/client_pb";
import * as IbcApplicationsTransferV1TxPb from "@injectivelabs/core-proto-ts-v2/generated/ibc/applications/transfer/v1/tx_pb";
import { MsgTransfer } from "cosmjs-types/ibc/applications/transfer/v1/tx";
import { AminoTypes, StargateClient, accountFromAny, calculateFee, createAuthzAminoConverters, createBankAminoConverters, createDistributionAminoConverters, createFeegrantAminoConverters, createGovAminoConverters, createIbcAminoConverters, createStakingAminoConverters, createVestingAminoConverters, defaultRegistryTypes } from "@cosmjs/stargate";
import { Int53, Uint53 } from "@cosmjs/math";
import { assert, assertDefined } from "@cosmjs/utils";
import { TxRaw } from "cosmjs-types/cosmos/tx/v1beta1/tx";
import { Tendermint37Client } from "@cosmjs/tendermint-rpc";
import { SignMode } from "cosmjs-types/cosmos/tx/signing/v1beta1/signing";
import { MsgWithdrawDelegatorReward } from "cosmjs-types/cosmos/distribution/v1beta1/tx";
import { MsgDelegate, MsgUndelegate } from "cosmjs-types/cosmos/staking/v1beta1/tx";
import { encodeSecp256k1Pubkey, makeSignDoc, serializeSignDoc } from "@cosmjs/amino";
import { Registry, encodePubkey, isOfflineDirectSigner, makeAuthInfoBytes, makeSignBytes, makeSignDoc as makeSignDoc$1 } from "@cosmjs/proto-signing";

//#region src/core/modules/ibc/msgs/MsgTransferCosmjs.ts
/**
* @category Messages
*
* @deprecated use MsgTransfer with SIGN_DIRECT and a Cosmos wallet
*/
var MsgTransferCosmjs = class MsgTransferCosmjs {
	constructor(params) {
		_defineProperty(this, "params", void 0);
		this.params = params;
	}
	static fromJSON(params) {
		return new MsgTransferCosmjs(params);
	}
	toProto() {
		const { params } = this;
		const token = CosmosBaseV1Beta1CoinPb.Coin.create({
			denom: params.amount.denom,
			amount: params.amount.amount
		});
		const message = IbcApplicationsTransferV1TxPb.MsgTransfer.create({
			sourcePort: params.port,
			sourceChannel: params.channelId,
			token,
			sender: params.sender,
			receiver: params.receiver
		});
		if (params.height) message.timeoutHeight = IbcCoreClientV1ClientPb.Height.create({
			revisionHeight: BigInt(params.height.revisionHeight),
			revisionNumber: BigInt(params.height.revisionNumber)
		});
		if (params.timeout) message.timeoutTimestamp = BigInt(params.timeout);
		return MsgTransfer.fromPartial({
			sourcePort: message.sourcePort,
			sourceChannel: message.sourceChannel,
			token: message.token,
			sender: message.sender,
			receiver: message.receiver,
			timeoutHeight: message.timeoutHeight ? {
				revisionHeight: message.timeoutHeight.revisionHeight,
				revisionNumber: message.timeoutHeight.revisionNumber
			} : void 0,
			timeoutTimestamp: message.timeoutTimestamp
		});
	}
	toData() {
		throw new Error("Method not implemented.");
	}
	toAmino() {
		const { params } = this;
		const message = MsgTransfer.fromPartial({
			sourcePort: params.port,
			sourceChannel: params.channelId,
			sender: params.sender,
			receiver: params.receiver,
			token: params.amount,
			timeoutHeight: params.height ? {
				revisionHeight: BigInt(params.height.revisionHeight),
				revisionNumber: BigInt(params.height.revisionNumber)
			} : void 0,
			timeoutTimestamp: params.timeout ? BigInt(params.timeout) : void 0
		});
		return {
			type: "/ibc.applications.transfer.v1.MsgTransfer",
			value: {
				...message,
				timeoutHeight: message.timeoutHeight ? {
					revisionHeight: message.timeoutHeight.revisionHeight.toString(),
					revisionNumber: message.timeoutHeight.revisionNumber.toString()
				} : void 0,
				timeoutTimestamp: message.timeoutTimestamp ? message.timeoutTimestamp.toString() : void 0
			}
		};
	}
	toWeb3Gw() {
		const { value } = this.toAmino();
		return {
			"@type": "/ibc.applications.transfer.v1.MsgTransfer",
			...value
		};
	}
	toDirectSign() {
		return {
			type: "/ibc.applications.transfer.v1.MsgTransfer",
			message: this.toProto()
		};
	}
	toBinary() {
		return MsgTransfer.encode(this.toProto()).finish();
	}
};

//#endregion
//#region src/core/accounts/AccountParser.ts
const accountParser = (ethAccount) => {
	const baseAccount = InjectiveTypesV1Beta1AccountPb.EthAccount.fromBinary(ethAccount.value).baseAccount;
	const pubKey = baseAccount.pubKey;
	return {
		address: baseAccount.address,
		pubkey: pubKey ? {
			type: "/injective.crypto.v1beta1.ethsecp256k1.PubKey",
			value: uint8ArrayToBase64(pubKey.value)
		} : null,
		accountNumber: parseInt(baseAccount.accountNumber.toString(), 10),
		sequence: parseInt(baseAccount.sequence.toString(), 10)
	};
};

//#endregion
//#region src/core/stargate/StargateClient.ts
var StargateClient$1 = class extends StargateClient {
	async getAccount(searchAddress) {
		try {
			const isInjective = (await this.getChainId()).startsWith("injective");
			const account = await this.forceGetQueryClient().auth.account(searchAddress);
			if (!account) return null;
			if (isInjective) return accountParser(account);
			return accountFromAny(account);
		} catch (error) {
			if (/rpc error: code = NotFound/i.test(error.toString())) return null;
			throw error;
		}
	}
};

//#endregion
//#region src/core/stargate/SigningStargateClient.ts
function createDefaultAminoConverters() {
	return {
		...createAuthzAminoConverters(),
		...createBankAminoConverters(),
		...createDistributionAminoConverters(),
		...createGovAminoConverters(),
		...createStakingAminoConverters(),
		...createIbcAminoConverters(),
		...createFeegrantAminoConverters(),
		...createVestingAminoConverters()
	};
}
var SigningStargateClient = class SigningStargateClient extends StargateClient$1 {
	/**
	* Creates an instance by connecting to the given Tendermint RPC endpoint.
	*
	* For now this uses the Tendermint 0.34 client. If you need Tendermint 0.37
	* support, see `createWithSigner`.
	*/
	static async connectWithSigner(endpoint, signer, options = {}) {
		const tmClient = await Tendermint37Client.connect(endpoint);
		return SigningStargateClient.createWithSigner(tmClient, signer, options);
	}
	/**
	* Creates an instance from a manually created Tendermint client.
	* Use this to use `Tendermint37Client` instead of `Tendermint37Client`.
	*/
	static async createWithSigner(tmClient, signer, options = {}) {
		return new SigningStargateClient(tmClient, signer, options);
	}
	/**
	* Creates a client in offline mode.
	*
	* This should only be used in niche cases where you know exactly what you're doing,
	* e.g. when building an offline signing application.
	*
	* When you try to use online functionality with such a signer, an
	* exception will be raised.
	*/
	static async offline(signer, options = {}) {
		return new SigningStargateClient(void 0, signer, options);
	}
	constructor(tmClient, signer, options) {
		super(tmClient, options);
		_defineProperty(this, "registry", void 0);
		_defineProperty(this, "broadcastTimeoutMs", void 0);
		_defineProperty(this, "broadcastPollIntervalMs", void 0);
		_defineProperty(this, "signer", void 0);
		_defineProperty(this, "aminoTypes", void 0);
		_defineProperty(this, "gasPrice", void 0);
		const { registry = new Registry(defaultRegistryTypes), aminoTypes = new AminoTypes(createDefaultAminoConverters()) } = options;
		this.registry = registry;
		this.aminoTypes = aminoTypes;
		this.signer = signer;
		this.broadcastTimeoutMs = options.broadcastTimeoutMs;
		this.broadcastPollIntervalMs = options.broadcastPollIntervalMs;
		this.gasPrice = options.gasPrice;
	}
	async simulate(signerAddress, messages, memo) {
		const anyMsgs = messages.map((m) => this.registry.encodeAsAny(m));
		const accountFromSigner = (await this.signer.getAccounts()).find((account) => account.address === signerAddress);
		if (!accountFromSigner) throw new Error("Failed to retrieve account from signer");
		const pubkey = encodeSecp256k1Pubkey(accountFromSigner.pubkey);
		const { sequence } = await this.getSequence(signerAddress);
		const { gasInfo } = await this.forceGetQueryClient().tx.simulate(anyMsgs, memo, pubkey, sequence);
		assertDefined(gasInfo);
		return Uint53.fromString(gasInfo.gasUsed.toString()).toNumber();
	}
	async sendTokens(senderAddress, recipientAddress, amount, fee, memo = "") {
		const sendMsg = {
			typeUrl: "/cosmos.bank.v1beta1.MsgSend",
			value: {
				fromAddress: senderAddress,
				toAddress: recipientAddress,
				amount: [...amount]
			}
		};
		return this.signAndBroadcast(senderAddress, [sendMsg], fee, memo);
	}
	async delegateTokens(delegatorAddress, validatorAddress, amount, fee, memo = "") {
		const delegateMsg = {
			typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
			value: MsgDelegate.fromPartial({
				delegatorAddress,
				validatorAddress,
				amount
			})
		};
		return this.signAndBroadcast(delegatorAddress, [delegateMsg], fee, memo);
	}
	async undelegateTokens(delegatorAddress, validatorAddress, amount, fee, memo = "") {
		const undelegateMsg = {
			typeUrl: "/cosmos.staking.v1beta1.MsgUndelegate",
			value: MsgUndelegate.fromPartial({
				delegatorAddress,
				validatorAddress,
				amount
			})
		};
		return this.signAndBroadcast(delegatorAddress, [undelegateMsg], fee, memo);
	}
	async withdrawRewards(delegatorAddress, validatorAddress, fee, memo = "") {
		const withdrawMsg = {
			typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
			value: MsgWithdrawDelegatorReward.fromPartial({
				delegatorAddress,
				validatorAddress
			})
		};
		return this.signAndBroadcast(delegatorAddress, [withdrawMsg], fee, memo);
	}
	async sendIbcTokens(senderAddress, recipientAddress, transferAmount, sourcePort, sourceChannel, timeoutHeight, timeoutTimestamp, fee, memo = "") {
		const timeoutTimestampNanoseconds = timeoutTimestamp ? BigInt(timeoutTimestamp) * BigInt(1e9) : void 0;
		const transferMsg = {
			typeUrl: "/ibc.applications.transfer.v1.MsgTransfer",
			value: MsgTransfer.fromPartial({
				sourcePort,
				sourceChannel,
				sender: senderAddress,
				receiver: recipientAddress,
				token: transferAmount,
				timeoutHeight,
				timeoutTimestamp: timeoutTimestampNanoseconds
			})
		};
		return this.signAndBroadcast(senderAddress, [transferMsg], fee, memo);
	}
	async signAndBroadcast(signerAddress, messages, fee, memo = "") {
		let usedFee;
		if (fee == "auto" || typeof fee === "number") {
			assertDefined(this.gasPrice, "Gas price must be set in the client options when auto gas is used.");
			const gasEstimation = await this.simulate(signerAddress, messages, memo);
			const multiplier = typeof fee === "number" ? fee : 1.3;
			usedFee = calculateFee(Math.round(gasEstimation * multiplier), this.gasPrice);
		} else usedFee = fee;
		const txRaw = await this.sign(signerAddress, messages, usedFee, memo);
		const txBytes = TxRaw.encode(txRaw).finish();
		return this.broadcastTx(txBytes, this.broadcastTimeoutMs, this.broadcastPollIntervalMs);
	}
	/**
	* Gets account number and sequence from the API, creates a sign doc,
	* creates a single signature and assembles the signed transaction.
	*
	* The sign mode (SIGN_MODE_DIRECT or SIGN_MODE_LEGACY_AMINO_JSON) is determined by this client's signer.
	*
	* You can pass signer data (account number, sequence and chain ID) explicitly instead of querying them
	* from the chain. This is needed when signing for a multisig account, but it also allows for offline signing
	* (See the SigningStargateClient.offline constructor).
	*/
	async sign(signerAddress, messages, fee, memo, explicitSignerData) {
		let signerData;
		if (explicitSignerData) signerData = explicitSignerData;
		else {
			const { accountNumber, sequence } = await this.getSequence(signerAddress);
			signerData = {
				accountNumber,
				sequence,
				chainId: await this.getChainId()
			};
		}
		return isOfflineDirectSigner(this.signer) ? this.signDirect(signerAddress, messages, fee, memo, signerData) : this.signAmino(signerAddress, messages, fee, memo, signerData);
	}
	async signAmino(signerAddress, messages, fee, memo, { accountNumber, sequence, chainId }) {
		assert(!isOfflineDirectSigner(this.signer));
		const accountFromSigner = (await this.signer.getAccounts()).find((account) => account.address === signerAddress);
		if (!accountFromSigner) throw new Error("Failed to retrieve account from signer");
		const pubkey = chainId.startsWith("injective") ? getPublicKey({
			chainId,
			key: uint8ArrayToBase64(accountFromSigner.pubkey)
		}) : encodePubkey(encodeSecp256k1Pubkey(accountFromSigner.pubkey));
		const signMode = SignMode.SIGN_MODE_LEGACY_AMINO_JSON;
		const signDoc = makeSignDoc(messages.map((msg) => this.aminoTypes.toAmino(msg)), fee, chainId, memo, accountNumber, sequence);
		const { signature, signed } = await this.signer.signAmino(signerAddress, signDoc);
		const signedTxBodyEncodeObject = {
			typeUrl: "/cosmos.tx.v1beta1.TxBody",
			value: {
				messages: signed.msgs.map((msg) => this.aminoTypes.fromAmino(msg)),
				memo: signed.memo
			}
		};
		const signedTxBodyBytes = this.registry.encode(signedTxBodyEncodeObject);
		const signedGasLimit = Int53.fromString(signed.fee.gas).toNumber();
		const signedAuthInfoBytes = makeAuthInfoBytes([{
			pubkey,
			sequence: Int53.fromString(signed.sequence).toNumber()
		}], signed.fee.amount, signedGasLimit, signed.fee.granter, signed.fee.payer, signMode);
		return TxRaw.fromPartial({
			bodyBytes: signedTxBodyBytes,
			authInfoBytes: signedAuthInfoBytes,
			signatures: [base64ToUint8Array(signature.signature)]
		});
	}
	async signDirect(signerAddress, messages, fee, memo, { accountNumber, sequence, chainId }) {
		assert(isOfflineDirectSigner(this.signer));
		const accountFromSigner = (await this.signer.getAccounts()).find((account) => account.address === signerAddress);
		if (!accountFromSigner) throw new Error("Failed to retrieve account from signer");
		const pubkey = chainId.startsWith("injective") ? getPublicKey({
			chainId,
			key: uint8ArrayToBase64(accountFromSigner.pubkey)
		}) : encodePubkey(encodeSecp256k1Pubkey(accountFromSigner.pubkey));
		const txBodyEncodeObject = {
			typeUrl: "/cosmos.tx.v1beta1.TxBody",
			value: {
				messages,
				memo
			}
		};
		const txBodyBytes = this.registry.encode(txBodyEncodeObject);
		const gasLimit = Int53.fromString(fee.gas).toNumber();
		const signDoc = makeSignDoc$1(txBodyBytes, makeAuthInfoBytes([{
			pubkey,
			sequence
		}], fee.amount, gasLimit, fee.granter, fee.payer), chainId, accountNumber);
		const { signature, signed } = await this.signer.signDirect(signerAddress, signDoc);
		return TxRaw.fromPartial({
			bodyBytes: signed.bodyBytes,
			authInfoBytes: signed.authInfoBytes,
			signatures: [base64ToUint8Array(signature.signature)]
		});
	}
};

//#endregion
//#region src/core/accounts/signers/EthSecp256k1Wallet.ts
var EthSecp256k1Wallet = class EthSecp256k1Wallet {
	/**
	* Creates a EthSecp256k1Wallet from the given private key
	*
	* @param privKey The private key.
	* @param prefix The bech32 address prefix (human readable part). Defaults to "inj".
	*/
	static async fromKey(privKey, prefix = "inj") {
		return new EthSecp256k1Wallet(privKey, PrivateKey.fromHex(uint8ArrayToHex(privKey)).toPublicKey().toPubKeyBytes(), prefix);
	}
	constructor(privKey, pubKey, prefix) {
		_defineProperty(this, "privateKey", void 0);
		_defineProperty(this, "publicKey", void 0);
		_defineProperty(this, "prefix", void 0);
		this.privateKey = PrivateKey.fromHex(uint8ArrayToHex(privKey));
		this.publicKey = PublicKey.fromBytes(pubKey);
		this.prefix = prefix;
	}
	get address() {
		return this.publicKey.toAddress().toBech32(this.prefix);
	}
	async getAccounts() {
		return [{
			algo: "eth_secp256k1",
			address: this.address,
			pubkey: this.publicKey.toPubKeyBytes()
		}];
	}
	async signAmino(signerAddress, signDoc) {
		if (signerAddress !== this.address) throw new Error(`Address ${signerAddress} not found in wallet`);
		const messageBytes = serializeSignDoc(signDoc);
		const signature = await this.privateKey.sign(messageBytes);
		return {
			signed: signDoc,
			signature: {
				pub_key: {
					type: "tendermint/PubKeyEthSecp256k1",
					value: this.publicKey.toBase64()
				},
				signature: uint8ArrayToBase64(signature)
			}
		};
	}
};

//#endregion
//#region src/core/accounts/signers/DirectEthSecp256k1Wallet.ts
var DirectEthSecp256k1Wallet = class DirectEthSecp256k1Wallet {
	/**
	* Creates a DirectEthSecp256k1Wallet from the given private key
	*
	* @param privKey The private key.
	* @param prefix The bech32 address prefix (human readable part). Defaults to "inj".
	*/
	static async fromKey(privKey, prefix = "inj") {
		return new DirectEthSecp256k1Wallet(privKey, PrivateKey.fromHex(uint8ArrayToHex(privKey)).toPublicKey().toPubKeyBytes(), prefix);
	}
	constructor(privKey, pubKey, prefix) {
		_defineProperty(this, "privateKey", void 0);
		_defineProperty(this, "publicKey", void 0);
		_defineProperty(this, "prefix", void 0);
		this.privateKey = PrivateKey.fromHex(uint8ArrayToHex(privKey));
		this.publicKey = PublicKey.fromBytes(pubKey);
		this.prefix = prefix;
	}
	get address() {
		return this.publicKey.toAddress().toBech32(this.prefix);
	}
	async getAccounts() {
		return [{
			algo: "eth_secp256k1",
			address: this.address,
			pubkey: this.publicKey.toPubKeyBytes()
		}];
	}
	async signDirect(address, signDoc) {
		const signBytes = makeSignBytes(signDoc);
		if (address !== this.address) throw new Error(`Address ${address} not found in wallet`);
		const signature = await this.privateKey.sign(signBytes);
		return {
			signed: signDoc,
			signature: {
				pub_key: {
					type: "tendermint/PubKeyEthSecp256k1",
					value: this.publicKey.toBase64()
				},
				signature: uint8ArrayToBase64(signature)
			}
		};
	}
};

//#endregion
export { accountParser as a, StargateClient$1 as i, EthSecp256k1Wallet as n, MsgTransferCosmjs as o, SigningStargateClient as r, DirectEthSecp256k1Wallet as t };