import { Et as getGasPriceBasedOnMessage, Jt as stringToUint8Array, Qt as uint8ArrayToHex, Tt as ofacList, Xt as toUtf8, Zt as uint8ArrayToBase64, mn as sortObjectByKeys, mt as hashToHex, rn as getErrorMessage, zt as base64ToUint8Array } from "./utils-CewUFGKA.js";
import { t as _defineProperty } from "./defineProperty-Bq6QU9Te.js";
import { _ as createAuthInfo, n as PrivateKey, t as BaseAccount, v as createBody, w as createSigners, x as createSignDoc, y as createFee } from "./accounts-CP_DVUou.js";
import { i as ChainGrpcAuthApi, n as ChainRestAuthApi, r as ChainGrpcTendermintApi, t as ChainRestTendermintApi } from "./ChainRestTendermintApi-BUV-cxVj.js";
import { t as BaseGrpcConsumer } from "./BaseGrpcConsumer-a7fB9A_e.js";
import { t as IndexerGrpcWeb3GwApi } from "./IndexerGrpcWeb3GwApi-CX4ohUOk.js";
import * as CosmosTxV1Beta1TxPb from "@injectivelabs/core-proto-ts-v2/generated/cosmos/tx/v1beta1/tx_pb";
import { keccak256 } from "viem";
import { DEFAULT_BLOCK_TIMEOUT_HEIGHT, DEFAULT_BLOCK_TIME_IN_SECONDS, DEFAULT_TX_BLOCK_INCLUSION_TIMEOUT_IN_MS, HttpClient, getDefaultStdFee, getStdFee, getStdFeeFromString, toBigNumber } from "@injectivelabs/utils";
import { GeneralException, GrpcUnaryRequestException, HttpRequestException, HttpRequestMethod, TransactionException, UnspecifiedErrorCode } from "@injectivelabs/exceptions";
import { Network, getNetworkEndpoints, getNetworkInfo } from "@injectivelabs/networks";
import { StatusCodes } from "http-status-codes";
import * as CosmosTxSigningV1Beta1SigningPb from "@injectivelabs/core-proto-ts-v2/generated/cosmos/tx/signing/v1beta1/signing_pb";
import * as CosmosTxV1Beta1ServicePb from "@injectivelabs/core-proto-ts-v2/generated/cosmos/tx/v1beta1/service_pb";
import { ServiceClient } from "@injectivelabs/core-proto-ts-v2/generated/cosmos/tx/v1beta1/service_pb.client";
import axios from "axios";

//#region src/core/tx/utils/api.ts
const isTxNotFoundError = (error) => {
	if (!error.response) {
		const errorToString = error.toString();
		return [
			"404",
			"not found",
			"timeout"
		].some((code) => errorToString.includes(code));
	}
	const message = error.response.data ? error.response.data.message : error.toString();
	if (message.includes("404")) return true;
	if (message.includes("not found")) return true;
	return false;
};
const errorToErrorMessage = (error) => {
	if (!error.response) return error.toString();
	return error.response.data ? error.response.data.message : error.toString();
};

//#endregion
//#region src/core/tx/utils/constants.ts
const SIGN_DIRECT = CosmosTxSigningV1Beta1SigningPb.SignMode.DIRECT;
const SIGN_AMINO = CosmosTxSigningV1Beta1SigningPb.SignMode.LEGACY_AMINO_JSON;
const SIGN_EIP712 = CosmosTxSigningV1Beta1SigningPb.SignMode.LEGACY_AMINO_JSON;
const SIGN_EIP712_V2 = CosmosTxSigningV1Beta1SigningPb.SignMode.EIP712_V2;

//#endregion
//#region src/core/tx/utils/classes/TxClient.ts
var TxClient = class TxClient {
	/**
	* Encode a transaction to base64-encoded protobuf
	* @param tx transaction to encode
	*/
	static encode(tx) {
		return uint8ArrayToBase64(CosmosTxV1Beta1TxPb.TxRaw.toBinary(tx));
	}
	/**
	* Decode a transaction from base64-encoded protobuf
	* @param tx transaction string to decode
	*/
	static decode(encodedTx) {
		return CosmosTxV1Beta1TxPb.TxRaw.fromBinary(base64ToUint8Array(encodedTx));
	}
	/**
	* Get the transaction's hash
	* @param tx transaction to hash
	*/
	static hash(tx) {
		return hashToHex(TxClient.encode(tx));
	}
};

//#endregion
//#region src/core/tx/tx.ts
/**
* @typedef {Object} CreateTransactionWithSignersArgs
* @param {CreateTransactionWithSignersArgs} params
* @property {Msg | Msg[]} message - the Cosmos messages to wrap them in a transaction
* @property {string} memo - the memo to attach to the transaction
* @property {StdFee} fee - the fee to attach to the transaction
* @property {SignerDetails} signers - the signers of the transaction
* @property {number} number - the account number to attach to the transaction
* @property {number} chainId - the chain-id to attach to the transaction
* @property {string} pubKey - the account pubKey to attach to the transaction (in base64)
*
* @typedef {Object} CreateTransactionResult
* @property {TxRaw} txRaw  - the Tx raw that was created
* @property {SignDoc} signDoc  - the SignDoc that was created - used for signing of the transaction
* @property {SignerDetails} signers  - the signers of the transaction
* @property {Uint8Array} bodyBytes  - the body bytes of the transaction
* @property {Uint8Array} authInfoBytes  - the auth info bytes of the transaction
* @property {Uint8Array} signBytes  - the sign bytes of the transaction (SignDoc serialized to binary)
* @property {Uint8Array} signHashedBytes  - the sign bytes of the transaction (SignDoc serialized to binary) and hashed using keccak256
* @returns {CreateTransactionResult} result
*/
const createTransactionWithSigners = ({ signers, chainId, message, timeoutHeight, memo = "", fee = getDefaultStdFee(), signMode = SIGN_DIRECT }) => {
	const actualSigners = Array.isArray(signers) ? signers : [signers];
	const [signer] = actualSigners;
	const body = createBody({
		message,
		memo,
		timeoutHeight
	});
	const actualFee = typeof fee === "string" ? getStdFeeFromString(fee) : fee;
	const feeMessage = createFee({
		fee: actualFee.amount[0],
		payer: actualFee.payer,
		granter: actualFee.granter,
		gasLimit: parseInt(actualFee.gas, 10)
	});
	const authInfo = createAuthInfo({
		signerInfo: createSigners({
			chainId,
			mode: signMode,
			signers: actualSigners
		}),
		fee: feeMessage
	});
	const bodyBytes = CosmosTxV1Beta1TxPb.TxBody.toBinary(body);
	const authInfoBytes = CosmosTxV1Beta1TxPb.AuthInfo.toBinary(authInfo);
	const signDoc = createSignDoc({
		chainId,
		bodyBytes,
		authInfoBytes,
		accountNumber: signer.accountNumber
	});
	const signDocBytes = CosmosTxV1Beta1TxPb.SignDoc.toBinary(signDoc);
	const toSignBytes = signDocBytes;
	const toSignHash = keccak256(signDocBytes, "bytes");
	const txRaw = CosmosTxV1Beta1TxPb.TxRaw.create();
	txRaw.authInfoBytes = authInfoBytes;
	txRaw.bodyBytes = bodyBytes;
	return {
		txRaw,
		signDoc,
		signers,
		signer,
		signBytes: toSignBytes,
		signHashedBytes: toSignHash,
		bodyBytes,
		authInfoBytes
	};
};
/**
* @typedef {Object} CreateTransactionArgs
* @param {CreateTransactionArgs} params
* @property {MsgArg | MsgArg[]} message - the Cosmos messages to wrap them in a transaction
* @property {string} memo - the memo to attach to the transaction
* @property {StdFee} fee - the fee to attach to the transaction
* @property {string} sequence - the account sequence to attach to the transaction
* @property {number} number - the account number to attach to the transaction
* @property {number} chainId - the chain-id to attach to the transaction
* @property {string} pubKey - the account pubKey to attach to the transaction (in base64)
*
* @typedef {Object} CreateTransactionResult
* @property {TxRaw} txRaw  // the Tx raw that was created
* @property {SignDoc} signDoc  // the SignDoc that was created - used for signing of the transaction
* @property {number} accountNumber  // the account number of the signer of the transaction
* @property {Uint8Array} bodyBytes  // the body bytes of the transaction
* @property {Uint8Array} authInfoBytes  // the auth info bytes of the transaction
* @property {Uint8Array} signBytes  // the sign bytes of the transaction (SignDoc serialized to binary)
* @property {Uint8Array} signHashedBytes  // the sign bytes of the transaction (SignDoc serialized to binary) and hashed using keccak256
* @returns {CreateTransactionResult} result
*/
const createTransaction = (args) => {
	return createTransactionWithSigners({
		...args,
		signers: {
			pubKey: args.pubKey,
			accountNumber: args.accountNumber,
			sequence: args.sequence
		}
	});
};
/**
* Used when we want to pass a Msg class instead of the {type, message}
* object of the Message (using the toDirectSign() method)
* @returns
*/
const createTransactionFromMsg = (params) => {
	const messages = Array.isArray(params.message) ? params.message : [params.message];
	return createTransaction({
		...params,
		message: messages
	});
};
/**
* Used when we get a DirectSignResponse from
* Cosmos native wallets like Keplr, Leap, etc after
* the TxRaw has been signed.
*
* The reason why we need to create a new TxRaw and
* not use the one that we passed to signing is that the users
* can change the gas fees and that will alter the original
* TxRaw which will cause signature miss match if we broadcast
* that transaction on chain
* @returns TxRaw
*/
const createTxRawFromSigResponse = (response) => {
	if (response.signed === void 0) return response;
	const directSignResponse = response;
	const txRaw = CosmosTxV1Beta1TxPb.TxRaw.create();
	txRaw.authInfoBytes = directSignResponse.signed.authInfoBytes;
	txRaw.bodyBytes = directSignResponse.signed.bodyBytes;
	txRaw.signatures = [base64ToUint8Array(directSignResponse.signature.signature)];
	return txRaw;
};
/**
* Used when we don't have account details and block details
* and we pass the message and the user's address only
* @returns
*/
const createTransactionForAddressAndMsg = async (params) => {
	const messages = Array.isArray(params.message) ? params.message : [params.message];
	const chainRestAuthApi = new ChainRestAuthApi(params.endpoint);
	const tendermintRestApi = new ChainRestTendermintApi(params.endpoint);
	/** Account Details * */
	const accountDetails = await chainRestAuthApi.fetchCosmosAccount(params.address);
	const baseAccount = BaseAccount.fromRestCosmosApi(accountDetails);
	const latestHeight = (await tendermintRestApi.fetchLatestBlock()).header.height;
	const timeoutHeight = toBigNumber(latestHeight).plus(DEFAULT_BLOCK_TIMEOUT_HEIGHT);
	if (!(params.pubKey || baseAccount.pubKey.key)) throw new GeneralException(/* @__PURE__ */ new Error(`The pubKey for ${params.address} is missing.`));
	return createTransaction({
		...params,
		pubKey: params.pubKey || baseAccount.pubKey.key,
		sequence: Number(baseAccount.sequence),
		accountNumber: Number(baseAccount.accountNumber),
		timeoutHeight: timeoutHeight.toNumber(),
		message: messages
	});
};
const createTransactionAndCosmosSignDoc = (args) => {
	const result = createTransaction(args);
	const [signer] = Array.isArray(result.signers) ? result.signers : [result.signers];
	return {
		...result,
		cosmosSignDoc: CosmosTxV1Beta1TxPb.SignDoc.create({
			bodyBytes: result.bodyBytes,
			authInfoBytes: result.authInfoBytes,
			accountNumber: BigInt(signer.accountNumber),
			chainId: args.chainId
		})
	};
};
const createTransactionAndCosmosSignDocForAddressAndMsg = async (params) => {
	const result = await createTransactionForAddressAndMsg(params);
	const [signer] = Array.isArray(result.signers) ? result.signers : [result.signers];
	return {
		...result,
		cosmosSignDoc: CosmosTxV1Beta1TxPb.SignDoc.create({
			bodyBytes: result.bodyBytes,
			authInfoBytes: result.authInfoBytes,
			accountNumber: BigInt(signer.accountNumber),
			chainId: params.chainId
		})
	};
};
const getTxRawFromTxRawOrDirectSignResponse = (txRawOrDirectSignResponse) => {
	return txRawOrDirectSignResponse.signed === void 0 ? txRawOrDirectSignResponse : createTxRawFromSigResponse(txRawOrDirectSignResponse);
};

//#endregion
//#region src/core/tx/api/TxGrpcApi.ts
var TxGrpcApi = class extends BaseGrpcConsumer {
	constructor(..._args) {
		super(..._args);
		_defineProperty(this, "module", "TxGrpcApi");
	}
	get client() {
		return this.initClient(ServiceClient);
	}
	async fetchTx(hash) {
		const request = CosmosTxV1Beta1ServicePb.GetTxRequest.create();
		request.hash = hash;
		try {
			const txResponse = (await this.executeGrpcCall(request, this.client.getTx.bind(this.client))).txResponse;
			if (!txResponse) throw new GrpcUnaryRequestException(/* @__PURE__ */ new Error(`The transaction with ${hash} is not found`), {
				context: "TxGrpcApi",
				contextModule: "fetch-tx"
			});
			if (txResponse.code !== 0) throw new TransactionException(new Error(txResponse.rawLog), {
				contextCode: Number(txResponse.code),
				contextModule: txResponse.codespace
			});
			return {
				...txResponse,
				height: Number(txResponse.height),
				gasWanted: Number(txResponse.gasWanted),
				gasUsed: Number(txResponse.gasUsed),
				txHash: txResponse.txhash
			};
		} catch (e) {
			if (e instanceof TransactionException) throw e;
			if (e instanceof GrpcUnaryRequestException) throw e;
			throw new GrpcUnaryRequestException(/* @__PURE__ */ new Error("There was an issue while fetching transaction details"), {
				context: "TxGrpcApi",
				contextModule: "fetch-tx"
			});
		}
	}
	async fetchTxPoll(txHash, timeout = DEFAULT_TX_BLOCK_INCLUSION_TIMEOUT_IN_MS) {
		const POLL_INTERVAL = DEFAULT_BLOCK_TIME_IN_SECONDS * 1e3;
		for (let i = 0; i <= timeout / POLL_INTERVAL; i += 1) {
			try {
				const txResponse = await this.fetchTx(txHash);
				if (txResponse) return txResponse;
			} catch (e) {
				if (e instanceof TransactionException) throw e;
			}
			await new Promise((resolve) => setTimeout(resolve, POLL_INTERVAL));
		}
		throw new GrpcUnaryRequestException(/* @__PURE__ */ new Error(`Transaction was not included in a block before timeout of ${timeout}ms`), {
			context: "TxGrpcApi",
			contextModule: "fetch-tx-poll"
		});
	}
	async simulate(txRaw) {
		const txRawClone = CosmosTxV1Beta1TxPb.TxRaw.create({ ...txRaw });
		const simulateRequest = CosmosTxV1Beta1ServicePb.SimulateRequest.create();
		if (txRawClone.signatures.length === 0) txRawClone.signatures = [new Uint8Array(0)];
		simulateRequest.txBytes = CosmosTxV1Beta1TxPb.TxRaw.toBinary(txRawClone);
		try {
			var _response$result, _response$result2, _response$result3;
			const response = await this.executeGrpcCall(simulateRequest, this.client.simulate.bind(this.client));
			return {
				result: {
					...response.result,
					data: ((_response$result = response.result) === null || _response$result === void 0 ? void 0 : _response$result.data) || "",
					log: ((_response$result2 = response.result) === null || _response$result2 === void 0 ? void 0 : _response$result2.log) || "",
					eventsList: ((_response$result3 = response.result) === null || _response$result3 === void 0 ? void 0 : _response$result3.events) || []
				},
				gasInfo: {
					...response.gasInfo,
					gasWanted: response.gasInfo ? Number(response.gasInfo.gasWanted) : 0,
					gasUsed: response.gasInfo ? Number(response.gasInfo.gasUsed) : 0
				}
			};
		} catch (e) {
			throw new TransactionException(e, {
				context: "TxGrpcApi.simulate",
				skipParsing: true
			});
		}
	}
	async broadcast(txRaw, options) {
		const mode = (options === null || options === void 0 ? void 0 : options.mode) || CosmosTxV1Beta1ServicePb.BroadcastMode.SYNC;
		const timeout = (options === null || options === void 0 ? void 0 : options.timeout) || toBigNumber((options === null || options === void 0 ? void 0 : options.txTimeout) || DEFAULT_BLOCK_TIMEOUT_HEIGHT).times(DEFAULT_BLOCK_TIME_IN_SECONDS * 1e3).toNumber();
		const broadcastTxRequest = CosmosTxV1Beta1ServicePb.BroadcastTxRequest.create();
		broadcastTxRequest.txBytes = CosmosTxV1Beta1TxPb.TxRaw.toBinary(txRaw);
		broadcastTxRequest.mode = mode;
		try {
			const txResponse = (await this.executeGrpcCall(broadcastTxRequest, this.client.broadcastTx.bind(this.client))).txResponse;
			if (!txResponse) throw new GrpcUnaryRequestException(/* @__PURE__ */ new Error(`The transaction has failed to be broadcasted`), {
				context: "TxGrpcApi.broadcast",
				contextModule: "broadcast"
			});
			if (txResponse.code !== 0) throw new TransactionException(new Error(txResponse.rawLog), {
				contextCode: Number(txResponse.code),
				contextModule: txResponse.codespace
			});
			return await this.fetchTxPoll(txResponse.txhash, timeout);
		} catch (e) {
			if (e instanceof TransactionException) throw e;
			if (e instanceof GrpcUnaryRequestException) throw e;
			throw new TransactionException(new Error(e));
		}
	}
	/** @deprecated - the BLOCK mode broadcasting is deprecated now, use either sync or async */
	async broadcastBlock(txRaw) {
		const broadcastTxRequest = CosmosTxV1Beta1ServicePb.BroadcastTxRequest.create();
		broadcastTxRequest.txBytes = CosmosTxV1Beta1TxPb.TxRaw.toBinary(txRaw);
		broadcastTxRequest.mode = CosmosTxV1Beta1ServicePb.BroadcastMode.BLOCK;
		try {
			const txResponse = (await this.executeGrpcCall(broadcastTxRequest, this.client.broadcastTx.bind(this.client))).txResponse;
			if (!txResponse) throw new GeneralException(/* @__PURE__ */ new Error("There was an issue broadcasting the transaction"));
			const result = {
				...txResponse,
				height: Number(txResponse.height),
				gasWanted: Number(txResponse.gasWanted),
				gasUsed: Number(txResponse.gasUsed),
				txHash: txResponse.txhash
			};
			if (result.code !== 0) throw new TransactionException(new Error(result.rawLog), {
				contextCode: result.code,
				contextModule: result.codespace
			});
			return result;
		} catch (e) {
			if (e instanceof TransactionException) throw e;
			throw new TransactionException(new Error(e));
		}
	}
};

//#endregion
//#region src/core/tx/types/tx-rest-client.ts
const BroadcastMode = {
	Sync: "BROADCAST_MODE_SYNC",
	Async: "BROADCAST_MODE_ASYNC",
	Block: "BROADCAST_MODE_BLOCK"
};
const BroadcastModeKeplr = {
	Sync: "sync",
	Async: "async",
	Block: "block"
};

//#endregion
//#region src/core/tx/api/TxRestApi.ts
/**
* It is recommended to use TxGrpcClient instead of TxRestApi
*/
var TxRestApi = class {
	constructor(endpoint, options) {
		_defineProperty(this, "httpClient", void 0);
		this.httpClient = new HttpClient(endpoint, {
			headers: { Accept: "application/json" },
			timeout: (options === null || options === void 0 ? void 0 : options.timeout) || 15e3
		});
	}
	async fetchTx(txHash, params = {}) {
		try {
			const { tx_response: txResponse } = await this.getRaw(`/cosmos/tx/v1beta1/txs/${txHash}`, params);
			if (!txResponse) throw new HttpRequestException(/* @__PURE__ */ new Error(`The transaction with ${txHash} is not found`), {
				context: `/cosmos/tx/v1beta1/txs/${txHash}`,
				contextModule: "TxRestApi.fetch-tx"
			});
			if (parseInt(txResponse.code.toString(), 10) !== 0) throw new TransactionException(new Error(txResponse.raw_log), {
				contextCode: txResponse.code,
				contextModule: txResponse.codespace
			});
			return {
				...txResponse,
				rawLog: txResponse.raw_log,
				gasWanted: parseInt(txResponse.gas_wanted, 10),
				gasUsed: parseInt(txResponse.gas_used, 10),
				height: parseInt(txResponse.height, 10),
				txHash: txResponse.txhash
			};
		} catch (e) {
			if (e instanceof TransactionException) throw e;
			if (e instanceof HttpRequestException) throw e;
			throw new HttpRequestException(/* @__PURE__ */ new Error("There was an issue while fetching transaction details"), {
				context: `/cosmos/tx/v1beta1/txs/${txHash}`,
				contextModule: "TxRestApi.fetch-tx"
			});
		}
	}
	async fetchTxPoll(txHash, timeout = DEFAULT_TX_BLOCK_INCLUSION_TIMEOUT_IN_MS || 6e4) {
		const POLL_INTERVAL = DEFAULT_BLOCK_TIME_IN_SECONDS * 1e3;
		for (let i = 0; i <= timeout / POLL_INTERVAL; i += 1) {
			try {
				const txResponse = await this.fetchTx(txHash);
				if (txResponse) return txResponse;
			} catch (e) {
				if (e instanceof TransactionException) throw e;
			}
			await new Promise((resolve) => setTimeout(resolve, POLL_INTERVAL));
		}
		throw new HttpRequestException(/* @__PURE__ */ new Error(`Transaction was not included in a block before timeout of ${timeout}ms`), {
			context: `/cosmos/tx/v1beta1/txs/${txHash}`,
			contextModule: "TxRestApi.fetch-tx-poll"
		});
	}
	async simulate(txRaw) {
		const txRawClone = CosmosTxV1Beta1TxPb.TxRaw.create({ ...txRaw });
		if (txRawClone.signatures.length === 0) txRawClone.signatures = [new Uint8Array(0)];
		try {
			const response = await this.postRaw("/cosmos/tx/v1beta1/simulate", { tx_bytes: TxClient.encode(txRawClone) });
			return {
				result: {
					data: response.result.data,
					log: response.result.log,
					eventsList: response.result.events
				},
				gasInfo: {
					gasWanted: parseInt(response.gas_info.gas_wanted, 10),
					gasUsed: parseInt(response.gas_info.gas_used, 10)
				}
			};
		} catch (e) {
			throw new TransactionException(new Error(e));
		}
	}
	async broadcast(tx, options) {
		const timeout = (options === null || options === void 0 ? void 0 : options.timeout) || toBigNumber((options === null || options === void 0 ? void 0 : options.txTimeout) || DEFAULT_BLOCK_TIMEOUT_HEIGHT).times(DEFAULT_BLOCK_TIME_IN_SECONDS * 1e3).toNumber();
		try {
			const { tx_response: txResponse } = await this.broadcastTx(tx, BroadcastMode.Sync);
			if (!txResponse) throw new HttpRequestException(/* @__PURE__ */ new Error("The transaction has failed to be broadcasted"), {
				context: "TxRestApi.broadcast",
				contextModule: "broadcast"
			});
			if (txResponse.code !== 0) throw new TransactionException(new Error(txResponse.raw_log), {
				contextCode: txResponse.code,
				contextModule: txResponse.codespace
			});
			return this.fetchTxPoll(txResponse.txhash, timeout);
		} catch (e) {
			if (e instanceof HttpRequestException) {
				if (e.code !== StatusCodes.OK) throw e;
			}
			throw e;
		}
	}
	/**
	* Broadcast the transaction using the "block" mode, waiting for its inclusion in the blockchain.
	* @param tx transaction to broadcast
	*
	* @deprecated - the BLOCk mode broadcasting is deprecated now, use either sync or async
	*/
	async broadcastBlock(tx) {
		const response = await this.broadcastTx(tx, BroadcastMode.Block);
		try {
			const { tx_response: txResponse } = response;
			if (txResponse.code !== 0) throw new TransactionException(new Error(txResponse.raw_log), {
				contextCode: txResponse.code,
				contextModule: txResponse.codespace
			});
			return {
				txHash: txResponse.txhash,
				rawLog: txResponse.raw_log,
				gasWanted: parseInt(txResponse.gas_wanted || "0", 10),
				gasUsed: parseInt(txResponse.gas_used || "0", 10),
				height: parseInt(txResponse.height || "0", 10),
				logs: txResponse.logs || [],
				code: txResponse.code,
				codespace: txResponse.codespace,
				data: txResponse.data,
				info: txResponse.info,
				timestamp: txResponse.timestamp || "0"
			};
		} catch (e) {
			if (e instanceof TransactionException) throw e;
			throw new TransactionException(new Error(e));
		}
	}
	async broadcastTx(txRaw, mode = BroadcastMode.Sync) {
		return await this.postRaw("cosmos/tx/v1beta1/txs", {
			tx_bytes: TxClient.encode(txRaw),
			mode
		});
	}
	async getRaw(endpoint, params = {}) {
		try {
			return await this.httpClient.get(endpoint, params).then((d) => d.data);
		} catch (e) {
			const error = e;
			if (axios.isAxiosError(error)) {
				if (error.code === "ECONNABORTED") throw new HttpRequestException(new Error(error.message), {
					code: StatusCodes.REQUEST_TOO_LONG,
					context: endpoint
				});
				const message = getErrorMessage(error, endpoint);
				throw new HttpRequestException(new Error(message), {
					context: endpoint,
					code: error.response ? error.response.status : StatusCodes.BAD_REQUEST
				});
			}
			throw new HttpRequestException(new Error(error.message), {
				context: endpoint,
				code: UnspecifiedErrorCode
			});
		}
	}
	async postRaw(endpoint, params = {}) {
		try {
			return await this.httpClient.post(endpoint, params).then((d) => d.data);
		} catch (e) {
			const error = e;
			if (axios.isAxiosError(error)) {
				const message = getErrorMessage(error, endpoint);
				throw new HttpRequestException(new Error(message), {
					code: error.response ? error.response.status : StatusCodes.BAD_REQUEST,
					context: endpoint,
					contextModule: HttpRequestMethod.Post
				});
			}
			throw new HttpRequestException(new Error(error.message), {
				code: UnspecifiedErrorCode,
				context: endpoint,
				contextModule: HttpRequestMethod.Post
			});
		}
	}
};

//#endregion
//#region src/core/tx/api/utils.ts
const waitTxBroadcasted = (txHash, options) => {
	const timeout = toBigNumber((options === null || options === void 0 ? void 0 : options.txTimeout) || DEFAULT_BLOCK_TIMEOUT_HEIGHT).times(DEFAULT_BLOCK_TIME_IN_SECONDS * 1e3).toNumber();
	return options.endpoints.grpc ? new TxGrpcApi(options.endpoints.grpc).fetchTxPoll(txHash, timeout) : new TxRestApi(options.endpoints.rest).fetchTxPoll(txHash, timeout);
};

//#endregion
//#region src/core/tx/arbitrary.ts
const generateArbitrarySignDoc = (message, signer) => {
	const signDoc = {
		account_number: "0",
		chain_id: "",
		fee: {
			amount: [],
			gas: "0"
		},
		memo: "",
		msgs: [{
			type: "sign/MsgSignData",
			value: {
				data: uint8ArrayToBase64(stringToUint8Array(toUtf8(message))),
				signer
			}
		}],
		sequence: "0"
	};
	const stringified = toUtf8(JSON.stringify(sortObjectByKeys(signDoc)));
	return {
		signDoc,
		signDocBuff: stringToUint8Array(stringified),
		stringifiedSignDoc: stringified
	};
};

//#endregion
//#region src/core/tx/types/tx.ts
const TxClientMode = {
	gRpc: "grpc",
	rest: "rest"
};

//#endregion
//#region src/core/tx/broadcaster/MsgBroadcasterWithPk.ts
/**
* This class is used to broadcast transactions
* using a privateKey as a signer
* for the transactions and broadcasting
* the transactions directly to the node
*
* Mainly used for working in a Node Environment
*/
var MsgBroadcasterWithPk = class {
	constructor(options) {
		_defineProperty(this, "endpoints", void 0);
		_defineProperty(this, "chainId", void 0);
		_defineProperty(this, "evmChainId", void 0);
		_defineProperty(this, "privateKey", void 0);
		_defineProperty(this, "simulateTx", false);
		_defineProperty(this, "txTimeoutOnFeeDelegation", false);
		_defineProperty(this, "useRest", false);
		_defineProperty(this, "gasBufferCoefficient", 1.1);
		_defineProperty(this, "txTimeout", DEFAULT_BLOCK_TIMEOUT_HEIGHT);
		const network = options.network || Network.MainnetSentry;
		const networkInfo = getNetworkInfo(network);
		const endpoints = getNetworkEndpoints(network);
		this.useRest = options.useRest || false;
		this.gasBufferCoefficient = options.gasBufferCoefficient || 1.1;
		this.simulateTx = options.simulateTx || false;
		this.chainId = options.chainId || networkInfo.chainId;
		this.txTimeout = options.txTimeout || DEFAULT_BLOCK_TIMEOUT_HEIGHT;
		this.evmChainId = options.evmChainId || networkInfo.evmChainId;
		this.endpoints = {
			...endpoints,
			...options.endpoints || {}
		};
		this.privateKey = options.privateKey instanceof PrivateKey ? options.privateKey : PrivateKey.fromHex(options.privateKey);
		this.txTimeoutOnFeeDelegation = options.txTimeoutOnFeeDelegation || this.txTimeoutOnFeeDelegation;
	}
	/**
	* Broadcasting the transaction using the client
	*
	* @param tx
	* @returns {string} transaction hash
	*/
	async broadcast(transaction, accountDetails) {
		const { privateKey } = this;
		if (ofacList.includes(privateKey.toHex())) throw new GeneralException(/* @__PURE__ */ new Error("You cannot execute this transaction"));
		const { txRaw } = await this.prepareTxForBroadcast(transaction, accountDetails);
		return await this.broadcastTxRaw(txRaw);
	}
	/**
	* Broadcasting the transaction with fee delegation services
	*
	* @param tx
	* @returns {string} transaction hash
	*/
	async broadcastWithFeeDelegation(transaction) {
		const { endpoints, txTimeout, simulateTx, privateKey, evmChainId, txTimeoutOnFeeDelegation } = this;
		const ethereumWallet = this.privateKey.toHex();
		if (ofacList.includes(ethereumWallet)) throw new GeneralException(/* @__PURE__ */ new Error("You cannot execute this transaction"));
		const msgs = Array.isArray(transaction.msgs) ? transaction.msgs : [transaction.msgs];
		const tx = {
			...transaction,
			msgs,
			ethereumAddress: ethereumWallet
		};
		const web3Msgs = msgs.map((msg) => msg.toWeb3());
		if (!evmChainId) throw new GeneralException(/* @__PURE__ */ new Error("Please provide ethereumChainId"));
		let timeoutHeight = void 0;
		if (txTimeoutOnFeeDelegation) {
			const latestHeight = (await new ChainGrpcTendermintApi(endpoints.grpc).fetchLatestBlock()).header.height;
			timeoutHeight = toBigNumber(latestHeight.toString()).plus(txTimeout).toNumber();
		}
		const transactionApi = new IndexerGrpcWeb3GwApi(endpoints.web3gw || endpoints.indexer);
		const txResponse = await transactionApi.prepareTxRequest({
			memo: tx.memo,
			message: web3Msgs,
			address: tx.ethereumAddress,
			chainId: evmChainId,
			gasLimit: getGasPriceBasedOnMessage(msgs),
			estimateGas: simulateTx || false,
			timeoutHeight
		});
		const signature = await privateKey.signTypedData(JSON.parse(txResponse.data));
		const response = await transactionApi.broadcastTxRequest({
			txResponse,
			message: web3Msgs,
			chainId: evmChainId,
			signature: `0x${uint8ArrayToHex(signature)}`
		});
		return await new TxGrpcApi(endpoints.grpc).fetchTxPoll(response.txHash);
	}
	/**
	* Broadcasting the transaction using the client
	*
	* @param tx
	* @returns {string} transaction hash
	*/
	async simulate(transaction, accountDetails) {
		const { privateKey, endpoints, chainId } = this;
		const ethereumWallet = this.privateKey.toHex();
		if (ofacList.includes(ethereumWallet)) throw new GeneralException(/* @__PURE__ */ new Error("You cannot execute this transaction"));
		const tx = {
			...transaction,
			msgs: Array.isArray(transaction.msgs) ? transaction.msgs : [transaction.msgs]
		};
		/** Account Details * */
		const publicKey = privateKey.toPublicKey();
		const actualAccountDetails = await this.getAccountDetails(accountDetails);
		/** Block Details */
		const timeoutHeight = await this.getTimeoutHeight();
		/** Prepare the Transaction * */
		const { txRaw } = createTransaction({
			memo: tx.memo || "",
			fee: getDefaultStdFee(),
			message: tx.msgs,
			timeoutHeight: timeoutHeight.toNumber(),
			pubKey: publicKey.toBase64(),
			sequence: actualAccountDetails.sequence,
			accountNumber: actualAccountDetails.accountNumber,
			chainId
		});
		/** Append Blank Signatures */
		txRaw.signatures = [new Uint8Array(0)];
		return await new TxGrpcApi(endpoints.grpc).simulate(txRaw);
	}
	/**
	* In case we don't want to simulate the transaction
	* we get the gas limit based on the message type.
	*
	* If we want to simulate the transaction we set the
	* gas limit based on the simulation and add a small multiplier
	* to be safe (factor of 1.1 (or user specified))
	*/
	async getTxWithStdFee(args) {
		var _result$gasInfo;
		const { simulateTx, gasBufferCoefficient } = this;
		if (!simulateTx) return createTransaction(args);
		const result = await this.simulateTxRaw(args);
		if (!((_result$gasInfo = result.gasInfo) === null || _result$gasInfo === void 0 ? void 0 : _result$gasInfo.gasUsed)) return createTransaction(args);
		const stdGasFee = getStdFee({
			...args.fee,
			gas: toBigNumber(result.gasInfo.gasUsed).times(gasBufferCoefficient).toFixed()
		});
		return createTransaction({
			...args,
			fee: stdGasFee
		});
	}
	/**
	* Create TxRaw and simulate it
	*/
	async simulateTxRaw(args) {
		const { endpoints } = this;
		const { txRaw } = createTransaction(args);
		txRaw.signatures = [new Uint8Array(0)];
		return await new TxGrpcApi(endpoints.grpc).simulate(txRaw);
	}
	async prepareTxForBroadcast(transaction, accountDetails) {
		var _transaction$gas;
		const { chainId, privateKey } = this;
		const msgs = Array.isArray(transaction.msgs) ? transaction.msgs : [transaction.msgs];
		const tx = {
			...transaction,
			msgs
		};
		/** Account Details * */
		const publicKey = privateKey.toPublicKey();
		const actualAccountDetails = await this.getAccountDetails(accountDetails);
		/** Block Details */
		const timeoutHeight = await this.getTimeoutHeight();
		const gas = (((_transaction$gas = transaction.gas) === null || _transaction$gas === void 0 ? void 0 : _transaction$gas.gas) || getGasPriceBasedOnMessage(msgs)).toString();
		/** Prepare the Transaction * */
		const { signBytes, txRaw } = await this.getTxWithStdFee({
			memo: tx.memo || "",
			message: msgs,
			fee: getStdFee({
				...tx.gas,
				gas
			}),
			timeoutHeight: timeoutHeight.toNumber(),
			pubKey: publicKey.toBase64(),
			sequence: actualAccountDetails.sequence,
			accountNumber: actualAccountDetails.accountNumber,
			chainId
		});
		/** Append Signatures */
		txRaw.signatures = [await privateKey.sign(signBytes)];
		return {
			txRaw,
			accountDetails: actualAccountDetails
		};
	}
	async getAccountDetails(accountDetails) {
		const { useRest } = this;
		if (accountDetails) return accountDetails;
		if (useRest) {
			const { privateKey: privateKey$1, endpoints: endpoints$1 } = this;
			const baseAccount$1 = (await new ChainRestAuthApi(endpoints$1.grpc).fetchAccount(privateKey$1.toBech32())).account.base_account;
			return {
				accountNumber: parseInt(baseAccount$1.account_number),
				sequence: parseInt(baseAccount$1.sequence),
				address: baseAccount$1.address,
				pubKey: baseAccount$1.pub_key ? {
					key: baseAccount$1.pub_key.key,
					type: baseAccount$1.pub_key["@type"]
				} : {
					key: "",
					type: ""
				}
			};
		}
		const { privateKey, endpoints } = this;
		const baseAccount = (await new ChainGrpcAuthApi(endpoints.grpc).fetchAccount(privateKey.toBech32())).baseAccount;
		return {
			accountNumber: baseAccount.accountNumber,
			sequence: baseAccount.sequence,
			address: baseAccount.address,
			pubKey: baseAccount.pubKey ? {
				key: baseAccount.pubKey.key,
				type: baseAccount.pubKey.typeUrl
			} : {
				key: "",
				type: ""
			}
		};
	}
	async getTimeoutHeight() {
		const { useRest, endpoints, txTimeout } = this;
		if (useRest) {
			const latestHeight$1 = (await new ChainRestTendermintApi(endpoints.grpc).fetchLatestBlock()).header.height;
			return toBigNumber(latestHeight$1).plus(txTimeout);
		}
		const latestHeight = (await new ChainGrpcTendermintApi(endpoints.grpc).fetchLatestBlock()).header.height;
		return toBigNumber(latestHeight.toString()).plus(txTimeout);
	}
	async broadcastTxRaw(txRaw) {
		const { endpoints, txTimeout } = this;
		const txResponse = await new TxGrpcApi(endpoints.grpc).broadcast(txRaw, { txTimeout });
		if (txResponse.code !== 0) throw new GeneralException(/* @__PURE__ */ new Error(`Transaction failed to be broadcasted - ${txResponse.rawLog} - ${txResponse.txHash}`));
		return txResponse;
	}
};

//#endregion
export { errorToErrorMessage as C, SIGN_EIP712_V2 as S, CosmosTxV1Beta1TxPb as _, TxRestApi as a, SIGN_DIRECT as b, TxGrpcApi as c, createTransactionAndCosmosSignDocForAddressAndMsg as d, createTransactionForAddressAndMsg as f, getTxRawFromTxRawOrDirectSignResponse as g, createTxRawFromSigResponse as h, waitTxBroadcasted as i, createTransaction as l, createTransactionWithSigners as m, TxClientMode as n, BroadcastMode as o, createTransactionFromMsg as p, generateArbitrarySignDoc as r, BroadcastModeKeplr as s, MsgBroadcasterWithPk as t, createTransactionAndCosmosSignDoc as u, TxClient as v, isTxNotFoundError as w, SIGN_EIP712 as x, SIGN_AMINO as y };