import { $t as uint8ArrayToString, O as denomAmountFromGrpcChainDenomAmount, Wt as fromUtf8, Yt as toBase64, jt as protobufTimestampToUnixSeconds, kt as protobufTimestampToDate, l as ChainGrpcCommonTransformer, n as fetchAllWithPagination, nn as bigIntToString, zt as base64ToUint8Array } from "./utils-CewUFGKA.js";
import { t as _defineProperty } from "./defineProperty-Bq6QU9Te.js";
import { o as ChainModule, p as BondStatus } from "./ChainRestTendermintApi-BUV-cxVj.js";
import { t as BaseGrpcConsumer } from "./BaseGrpcConsumer-a7fB9A_e.js";
import { t as BaseRestConsumer } from "./BaseRestConsumer-DTvorEHL.js";
import { toBigNumber, toHumanReadable } from "@injectivelabs/utils";
import { ErrorType, GeneralException, HttpRequestException, UnspecifiedErrorCode } from "@injectivelabs/exceptions";
import * as CosmosAuthzV1Beta1AuthzPb from "@injectivelabs/core-proto-ts-v2/generated/cosmos/authz/v1beta1/authz_pb";
import * as CosmosGovV1QueryPb from "@injectivelabs/core-proto-ts-v2/generated/cosmos/gov/v1/query_pb";
import { QueryClient } from "@injectivelabs/core-proto-ts-v2/generated/cosmos/gov/v1/query_pb.client";
import * as IbcApplicationsTransferV1QueryPb from "@injectivelabs/core-proto-ts-v2/generated/ibc/applications/transfer/v1/query_pb";
import { QueryClient as QueryClient$1 } from "@injectivelabs/core-proto-ts-v2/generated/ibc/applications/transfer/v1/query_pb.client";
import * as InjectiveEvmV1QueryPb from "@injectivelabs/core-proto-ts-v2/generated/injective/evm/v1/query_pb";
import { QueryClient as QueryClient$2 } from "@injectivelabs/core-proto-ts-v2/generated/injective/evm/v1/query_pb.client";
import * as CosmosBankV1Beta1QueryPb from "@injectivelabs/core-proto-ts-v2/generated/cosmos/bank/v1beta1/query_pb";
import { QueryClient as QueryClient$3 } from "@injectivelabs/core-proto-ts-v2/generated/cosmos/bank/v1beta1/query_pb.client";
import * as CosmosMintV1Beta1QueryPb from "@injectivelabs/core-proto-ts-v2/generated/cosmos/mint/v1beta1/query_pb";
import { QueryClient as QueryClient$4 } from "@injectivelabs/core-proto-ts-v2/generated/cosmos/mint/v1beta1/query_pb.client";
import * as CosmwasmWasmV1QueryPb from "@injectivelabs/core-proto-ts-v2/generated/cosmwasm/wasm/v1/query_pb";
import { QueryClient as QueryClient$5 } from "@injectivelabs/core-proto-ts-v2/generated/cosmwasm/wasm/v1/query_pb.client";
import * as CosmosAuthzV1Beta1QueryPb from "@injectivelabs/core-proto-ts-v2/generated/cosmos/authz/v1beta1/query_pb";
import { QueryClient as QueryClient$6 } from "@injectivelabs/core-proto-ts-v2/generated/cosmos/authz/v1beta1/query_pb.client";
import * as InjectivePeggyV1QueryPb from "@injectivelabs/core-proto-ts-v2/generated/injective/peggy/v1/query_pb";
import { QueryClient as QueryClient$7 } from "@injectivelabs/core-proto-ts-v2/generated/injective/peggy/v1/query_pb.client";
import * as InjectiveWasmxV1QueryPb from "@injectivelabs/core-proto-ts-v2/generated/injective/wasmx/v1/query_pb";
import { QueryClient as QueryClient$8 } from "@injectivelabs/core-proto-ts-v2/generated/injective/wasmx/v1/query_pb.client";
import * as InjectiveErc20V1Beta1QueryPb from "@injectivelabs/core-proto-ts-v2/generated/injective/erc20/v1beta1/query_pb";
import { QueryClient as QueryClient$9 } from "@injectivelabs/core-proto-ts-v2/generated/injective/erc20/v1beta1/query_pb.client";
import * as InjectiveOracleV1Beta1QueryPb from "@injectivelabs/core-proto-ts-v2/generated/injective/oracle/v1beta1/query_pb";
import { QueryClient as QueryClient$10 } from "@injectivelabs/core-proto-ts-v2/generated/injective/oracle/v1beta1/query_pb.client";
import * as InjectiveTxFeesV1Beta1QueryPb from "@injectivelabs/core-proto-ts-v2/generated/injective/txfees/v1beta1/query_pb";
import { QueryClient as QueryClient$11 } from "@injectivelabs/core-proto-ts-v2/generated/injective/txfees/v1beta1/query_pb.client";
import * as InjectiveAuctionV1Beta1QueryPb from "@injectivelabs/core-proto-ts-v2/generated/injective/auction/v1beta1/query_pb";
import { QueryClient as QueryClient$12 } from "@injectivelabs/core-proto-ts-v2/generated/injective/auction/v1beta1/query_pb.client";
import * as CosmosStakingV1Beta1QueryPb from "@injectivelabs/core-proto-ts-v2/generated/cosmos/staking/v1beta1/query_pb";
import { QueryClient as QueryClient$13 } from "@injectivelabs/core-proto-ts-v2/generated/cosmos/staking/v1beta1/query_pb.client";
import * as InjectivePermissionsV1Beta1QueryPb from "@injectivelabs/core-proto-ts-v2/generated/injective/permissions/v1beta1/query_pb";
import { QueryClient as QueryClient$14 } from "@injectivelabs/core-proto-ts-v2/generated/injective/permissions/v1beta1/query_pb.client";
import * as CosmosDistributionV1Beta1QueryPb from "@injectivelabs/core-proto-ts-v2/generated/cosmos/distribution/v1beta1/query_pb";
import { QueryClient as QueryClient$15 } from "@injectivelabs/core-proto-ts-v2/generated/cosmos/distribution/v1beta1/query_pb.client";
import * as InjectiveTokenFactoryV1Beta1QueryPb from "@injectivelabs/core-proto-ts-v2/generated/injective/tokenfactory/v1beta1/query_pb";
import { QueryClient as QueryClient$16 } from "@injectivelabs/core-proto-ts-v2/generated/injective/tokenfactory/v1beta1/query_pb.client";
import * as InjectiveInsuranceV1Beta1QueryPb from "@injectivelabs/core-proto-ts-v2/generated/injective/insurance/v1beta1/query_pb";
import { QueryClient as QueryClient$17 } from "@injectivelabs/core-proto-ts-v2/generated/injective/insurance/v1beta1/query_pb.client";
import { StatusCodes } from "http-status-codes";

//#region src/client/chain/transformers/ChainGrpcGovTransformer.ts
/**
* @category Chain Grpc Transformer
*/
var ChainGrpcGovTransformer = class ChainGrpcGovTransformer {
	static moduleParamsResponseToModuleParams(response) {
		var _params$minDeposit, _params$expeditedMinD, _params$maxDepositPer, _params$maxDepositPer2, _params$votingPeriod$, _params$votingPeriod, _params$expeditedVoti, _params$expeditedVoti2;
		const params = response.params;
		return {
			depositParams: {
				minDeposit: (_params$minDeposit = params === null || params === void 0 ? void 0 : params.minDeposit) !== null && _params$minDeposit !== void 0 ? _params$minDeposit : [],
				expeditedMinDeposit: (_params$expeditedMinD = params === null || params === void 0 ? void 0 : params.expeditedMinDeposit) !== null && _params$expeditedMinD !== void 0 ? _params$expeditedMinD : [],
				maxDepositPeriod: Number((_params$maxDepositPer = params === null || params === void 0 || (_params$maxDepositPer2 = params.maxDepositPeriod) === null || _params$maxDepositPer2 === void 0 ? void 0 : _params$maxDepositPer2.seconds) !== null && _params$maxDepositPer !== void 0 ? _params$maxDepositPer : 0n)
			},
			votingParams: {
				votingPeriod: Number((_params$votingPeriod$ = params === null || params === void 0 || (_params$votingPeriod = params.votingPeriod) === null || _params$votingPeriod === void 0 ? void 0 : _params$votingPeriod.seconds) !== null && _params$votingPeriod$ !== void 0 ? _params$votingPeriod$ : 0n),
				expeditedVotingPeriod: Number((_params$expeditedVoti = params === null || params === void 0 || (_params$expeditedVoti2 = params.expeditedVotingPeriod) === null || _params$expeditedVoti2 === void 0 ? void 0 : _params$expeditedVoti2.seconds) !== null && _params$expeditedVoti !== void 0 ? _params$expeditedVoti : 0n)
			},
			tallyParams: {
				quorum: !(params === null || params === void 0 ? void 0 : params.quorum) ? "0" : typeof params.quorum === "string" ? params.quorum : uint8ArrayToString(params.quorum),
				threshold: !(params === null || params === void 0 ? void 0 : params.threshold) ? "0" : typeof params.threshold === "string" ? params.threshold : uint8ArrayToString(params.threshold),
				vetoThreshold: !(params === null || params === void 0 ? void 0 : params.vetoThreshold) ? "0" : typeof params.vetoThreshold === "string" ? params.vetoThreshold : uint8ArrayToString(params.vetoThreshold),
				expeditedThreshold: !(params === null || params === void 0 ? void 0 : params.expeditedThreshold) ? "0" : typeof params.expeditedThreshold === "string" ? params.expeditedThreshold : uint8ArrayToString(params.expeditedThreshold)
			}
		};
	}
	static moduleParamsResponseToModuleParamsByType({ depositParams, votingParams, tallyParams }) {
		var _depositParams$maxDep, _depositParams$maxDep2, _votingParams$votingP, _votingParams$votingP2, _votingParams$expedit, _votingParams$expedit2;
		return {
			depositParams: {
				minDeposit: depositParams === null || depositParams === void 0 ? void 0 : depositParams.minDeposit,
				expeditedMinDeposit: depositParams === null || depositParams === void 0 ? void 0 : depositParams.expeditedMinDeposit,
				maxDepositPeriod: Number((_depositParams$maxDep = depositParams === null || depositParams === void 0 || (_depositParams$maxDep2 = depositParams.maxDepositPeriod) === null || _depositParams$maxDep2 === void 0 ? void 0 : _depositParams$maxDep2.seconds) !== null && _depositParams$maxDep !== void 0 ? _depositParams$maxDep : 0n)
			},
			votingParams: {
				votingPeriod: Number((_votingParams$votingP = (_votingParams$votingP2 = votingParams.votingPeriod) === null || _votingParams$votingP2 === void 0 ? void 0 : _votingParams$votingP2.seconds) !== null && _votingParams$votingP !== void 0 ? _votingParams$votingP : 0n),
				expeditedVotingPeriod: Number((_votingParams$expedit = (_votingParams$expedit2 = votingParams.expeditedVotingPeriod) === null || _votingParams$expedit2 === void 0 ? void 0 : _votingParams$expedit2.seconds) !== null && _votingParams$expedit !== void 0 ? _votingParams$expedit : 0n)
			},
			tallyParams: {
				quorum: typeof tallyParams.quorum === "string" ? tallyParams.quorum : uint8ArrayToString(tallyParams.quorum),
				threshold: typeof tallyParams.threshold === "string" ? tallyParams.threshold : uint8ArrayToString(tallyParams.threshold),
				vetoThreshold: typeof tallyParams.vetoThreshold === "string" ? tallyParams.vetoThreshold : uint8ArrayToString(tallyParams.vetoThreshold),
				expeditedThreshold: typeof tallyParams.expeditedThreshold === "string" ? tallyParams.expeditedThreshold : uint8ArrayToString(tallyParams.expeditedThreshold)
			}
		};
	}
	static proposalResponseToProposal(response) {
		if (!response.proposal) return;
		return ChainGrpcGovTransformer.grpcProposalToProposal(response.proposal);
	}
	static proposalsResponseToProposals(response) {
		const proposals = response.proposals.map((p) => ChainGrpcGovTransformer.grpcProposalToProposal(p)).filter((p) => p !== void 0);
		const pagination = response.pagination;
		return {
			proposals,
			pagination: ChainGrpcCommonTransformer.grpcPaginationToPaginationV2(pagination)
		};
	}
	static depositsResponseToDeposits(response) {
		const pagination = response.pagination;
		return {
			deposits: response.deposits.map((deposit) => {
				return {
					depositor: deposit.depositor,
					amounts: deposit.amount.map((coin) => ({
						denom: coin.denom,
						amount: toHumanReadable(coin.amount).toFixed()
					}))
				};
			}),
			pagination: ChainGrpcCommonTransformer.grpcPaginationToPaginationV2(pagination)
		};
	}
	static grpcVoteToVote(vote) {
		return {
			proposalId: Number(vote.proposalId),
			voter: vote.voter,
			metadata: vote.metadata,
			options: vote.options
		};
	}
	static votesResponseToVotes(response) {
		return {
			votes: response.votes.map(ChainGrpcGovTransformer.grpcVoteToVote),
			pagination: ChainGrpcCommonTransformer.grpcPaginationToPaginationV2(response.pagination)
		};
	}
	static tallyResultResponseToTallyResult(response) {
		const result = response.tally;
		return ChainGrpcGovTransformer.grpcTallyResultToTallyResult(result);
	}
	static grpcTallyResultToTallyResult(result) {
		var _result$yesCount, _result$abstainCount, _result$noCount, _result$noWithVetoCou;
		return {
			yesCount: (_result$yesCount = result === null || result === void 0 ? void 0 : result.yesCount) !== null && _result$yesCount !== void 0 ? _result$yesCount : "0",
			abstainCount: (_result$abstainCount = result === null || result === void 0 ? void 0 : result.abstainCount) !== null && _result$abstainCount !== void 0 ? _result$abstainCount : "0",
			noCount: (_result$noCount = result === null || result === void 0 ? void 0 : result.noCount) !== null && _result$noCount !== void 0 ? _result$noCount : "0",
			noWithVetoCount: (_result$noWithVetoCou = result === null || result === void 0 ? void 0 : result.noWithVetoCount) !== null && _result$noWithVetoCou !== void 0 ? _result$noWithVetoCou : "0"
		};
	}
	static grpcProposalToProposal(proposal) {
		var _proposal$messages;
		const finalTallyResult = proposal.finalTallyResult;
		const [message] = (_proposal$messages = proposal.messages) !== null && _proposal$messages !== void 0 ? _proposal$messages : [];
		if (!message) return;
		return {
			proposalId: Number(proposal.id),
			title: proposal.title,
			summary: proposal.summary,
			proposer: proposal.proposer,
			content: {
				type: message.typeUrl,
				value: message.value
			},
			type: message.typeUrl,
			submitTime: protobufTimestampToUnixSeconds(proposal.submitTime),
			status: proposal.status,
			expedited: proposal.expedited,
			failedReason: proposal.failedReason,
			finalTallyResult: ChainGrpcGovTransformer.grpcTallyResultToTallyResult(finalTallyResult),
			depositEndTime: protobufTimestampToUnixSeconds(proposal.depositEndTime),
			totalDeposits: proposal.totalDeposit.map((coin) => ({
				denom: coin.denom,
				amount: toHumanReadable(coin.amount).toFixed()
			})),
			votingStartTime: protobufTimestampToUnixSeconds(proposal.votingStartTime),
			votingEndTime: protobufTimestampToUnixSeconds(proposal.votingEndTime)
		};
	}
};

//#endregion
//#region src/client/chain/transformers/ChainGrpcEvmTransformer.ts
/**
* @category Chain Grpc Transformer
*/
var ChainGrpcEvmTransformer = class {
	static grpcBlobConfigToBlobConfig(config) {
		return {
			max: config.max.toString(),
			target: config.target.toString(),
			baseFeeUpdateFraction: config.baseFeeUpdateFraction.toString()
		};
	}
	static grpcBlockScheduleConfigToBlockScheduleConfig(config) {
		return {
			cancun: config.cancun ? this.grpcBlobConfigToBlobConfig(config.cancun) : void 0,
			prague: config.prague ? this.grpcBlobConfigToBlobConfig(config.prague) : void 0,
			osaka: config.osaka ? this.grpcBlobConfigToBlobConfig(config.osaka) : void 0,
			verkle: config.verkle ? this.grpcBlobConfigToBlobConfig(config.verkle) : void 0
		};
	}
	static grpcChainConfigToChainConfig(config) {
		return {
			homesteadBlock: config.homesteadBlock,
			daoForkBlock: config.daoForkBlock,
			daoForkSupport: config.daoForkSupport,
			eip150Block: config.eip150Block,
			eip150Hash: config.eip150Hash,
			eip155Block: config.eip155Block,
			eip158Block: config.eip158Block,
			byzantiumBlock: config.byzantiumBlock,
			constantinopleBlock: config.constantinopleBlock,
			petersburgBlock: config.petersburgBlock,
			istanbulBlock: config.istanbulBlock,
			muirGlacierBlock: config.muirGlacierBlock,
			berlinBlock: config.berlinBlock,
			londonBlock: config.londonBlock,
			arrowGlacierBlock: config.arrowGlacierBlock,
			grayGlacierBlock: config.grayGlacierBlock,
			mergeNetsplitBlock: config.mergeNetsplitBlock,
			shanghaiTime: config.shanghaiTime,
			cancunTime: config.cancunTime,
			pragueTime: config.pragueTime,
			eip155ChainId: config.eip155ChainId,
			blobScheduleConfig: config.blobScheduleConfig ? this.grpcBlockScheduleConfigToBlockScheduleConfig(config.blobScheduleConfig) : void 0
		};
	}
	/**
	* response transformers
	* */
	static accountResponseToAccount(response) {
		return {
			balance: response.balance,
			codeHash: response.codeHash,
			nonce: response.nonce.toString()
		};
	}
	static cosmosAccountResponseToCosmosAccount(response) {
		return {
			sequence: response.sequence.toString(),
			cosmosAddress: response.cosmosAddress,
			accountNumber: response.accountNumber.toString()
		};
	}
	static validatorAccountResponseToValidatorAccount(response) {
		return {
			sequence: response.sequence.toString(),
			accountNumber: response.accountNumber.toString(),
			accountAddress: response.accountAddress
		};
	}
	static paramsResponseToParams(response) {
		const { params } = response;
		if (!params) return;
		return {
			evmDenom: params.evmDenom,
			enableCreate: params.enableCreate,
			enableCall: params.enableCall,
			extraEips: params.extraEips.map((eip) => bigIntToString(eip)),
			chainConfig: params.chainConfig ? this.grpcChainConfigToChainConfig(params.chainConfig) : void 0,
			allowUnprotectedTxs: params.allowUnprotectedTxs,
			authorizedDeployers: params.authorizedDeployers,
			permissioned: params.permissioned
		};
	}
};

//#endregion
//#region src/client/chain/transformers/ChainGrpcBankTransformer.ts
/**
* @category Chain Grpc Transformer
*/
var ChainGrpcBankTransformer = class ChainGrpcBankTransformer {
	static metadataToMetadata(metadata) {
		return metadata;
	}
	static moduleParamsResponseToModuleParams(response) {
		const params = response.params;
		return {
			sendEnabledList: params.sendEnabled,
			defaultSendEnabled: params.defaultSendEnabled
		};
	}
	static denomOwnersResponseToDenomOwners(response) {
		const denomOwners = response.denomOwners;
		const pagination = response.pagination;
		return {
			denomOwners: denomOwners.map((denomOwner) => ({
				address: denomOwner.address,
				balance: denomOwner.balance ? ChainGrpcCommonTransformer.grpcCoinToCoin(denomOwner.balance) : void 0
			})),
			pagination: ChainGrpcCommonTransformer.grpcPaginationToPaginationV2(pagination)
		};
	}
	static totalSupplyResponseToTotalSupply(response) {
		const balances = response.supply;
		const pagination = response.pagination;
		return {
			supply: balances.map(ChainGrpcCommonTransformer.grpcCoinToCoin),
			pagination: ChainGrpcCommonTransformer.grpcPaginationToPaginationV2(pagination)
		};
	}
	static denomsMetadataResponseToDenomsMetadata(response) {
		const metadatas = response.metadatas;
		const pagination = response.pagination;
		return {
			metadatas: metadatas.map(ChainGrpcBankTransformer.metadataToMetadata),
			pagination: ChainGrpcCommonTransformer.grpcPaginationToPaginationV2(pagination)
		};
	}
	static balanceResponseToBalance(response) {
		return ChainGrpcCommonTransformer.grpcCoinToCoin(response.balance);
	}
	static balancesResponseToBalances(response) {
		const balances = response.balances;
		const pagination = response.pagination;
		return {
			balances: balances.map(ChainGrpcCommonTransformer.grpcCoinToCoin),
			pagination: ChainGrpcCommonTransformer.grpcPaginationToPaginationV2(pagination)
		};
	}
};

//#endregion
//#region src/client/chain/transformers/ChainGrpcMintTransformer.ts
/**
* @category Chain Grpc Transformer
*/
var ChainGrpcMintTransformer = class {
	static moduleParamsResponseToModuleParams(response) {
		return response.params;
	}
};

//#endregion
//#region src/client/chain/transformers/ChainGrpcWasmTransformer.ts
/**
* @category Chain Grpc Transformer
*/
var ChainGrpcWasmTransformer = class ChainGrpcWasmTransformer {
	static allContractStateResponseToContractAccountsBalanceWithPagination(response) {
		const contractAccountsBalance = response.models.map((model) => {
			return {
				account: uint8ArrayToString(model.key).split("balance").pop(),
				balance: uint8ArrayToString(model.value).replace(/['"]+/g, "")
			};
		}).filter(({ account, balance }) => {
			return account && account.startsWith("inj") && balance;
		});
		const contractInfoModel = response.models.find((model) => {
			return uint8ArrayToString(model.key) === "contract_info";
		});
		const contractInfoValue = uint8ArrayToString((contractInfoModel === null || contractInfoModel === void 0 ? void 0 : contractInfoModel.value) || new Uint8Array());
		const tokenInfoModel = response.models.find((model) => {
			return uint8ArrayToString(model.key) === "token_info";
		});
		const tokenInfoValue = uint8ArrayToString((tokenInfoModel === null || tokenInfoModel === void 0 ? void 0 : tokenInfoModel.value) || new Uint8Array());
		const marketingInfoModel = response.models.find((model) => {
			return uint8ArrayToString(model.key) === "marketing_info";
		});
		const marketingInfoValue = uint8ArrayToString((marketingInfoModel === null || marketingInfoModel === void 0 ? void 0 : marketingInfoModel.value) || new Uint8Array());
		return {
			contractAccountsBalance,
			tokenInfo: JSON.parse(tokenInfoValue || "{}"),
			contractInfo: JSON.parse(contractInfoValue || "{}"),
			marketingInfo: JSON.parse(marketingInfoValue || "{}"),
			pagination: ChainGrpcCommonTransformer.grpcPaginationToPaginationV2(response.pagination)
		};
	}
	static allContractStateResponseToContractState(response) {
		const contractAccountsBalance = response.models.map((model) => {
			return {
				account: uint8ArrayToString(model.key).split("balance").pop(),
				balance: uint8ArrayToString(model.value).replace(/['"]+/g, "")
			};
		}).filter(({ account, balance }) => {
			return account && account.startsWith("inj") && balance;
		});
		const contractInfoModel = response.models.find((model) => {
			return uint8ArrayToString(model.key) === "contract_info";
		});
		const contractInfoValue = uint8ArrayToString((contractInfoModel === null || contractInfoModel === void 0 ? void 0 : contractInfoModel.value) || new Uint8Array());
		const tokenInfoModel = response.models.find((model) => {
			return uint8ArrayToString(model.key) === "token_info";
		});
		const tokenInfoValue = uint8ArrayToString((tokenInfoModel === null || tokenInfoModel === void 0 ? void 0 : tokenInfoModel.value) || new Uint8Array());
		const marketingInfoModel = response.models.find((model) => {
			return uint8ArrayToString(model.key) === "marketing_info";
		});
		const marketingInfoValue = uint8ArrayToString((marketingInfoModel === null || marketingInfoModel === void 0 ? void 0 : marketingInfoModel.value) || new Uint8Array());
		return {
			contractAccountsBalance,
			tokenInfo: JSON.parse(tokenInfoValue || "{}"),
			contractInfo: JSON.parse(contractInfoValue || "{}"),
			marketingInfo: JSON.parse(marketingInfoValue || "{}"),
			pagination: ChainGrpcCommonTransformer.grpcPaginationToPaginationV2(response.pagination)
		};
	}
	static contactInfoResponseToContractInfo(contractInfo) {
		const absoluteTxPosition = contractInfo.created;
		return {
			codeId: Number(contractInfo.codeId),
			creator: contractInfo.creator,
			admin: contractInfo.admin,
			label: contractInfo.label,
			created: absoluteTxPosition ? {
				blockHeight: Number(absoluteTxPosition.blockHeight),
				txIndex: Number(absoluteTxPosition.txIndex)
			} : void 0,
			ibcPortId: contractInfo.ibcPortId
		};
	}
	static grpcContractCodeHistoryEntryToContractCodeHistoryEntry(entry) {
		const updated = entry.updated;
		return {
			operation: entry.operation,
			codeId: Number(entry.codeId),
			updated: updated ? {
				blockHeight: Number(updated.blockHeight),
				txIndex: Number(updated.txIndex)
			} : void 0,
			msg: fromUtf8(entry.msg)
		};
	}
	static grpcCodeInfoResponseToCodeInfoResponse(info) {
		return {
			codeId: Number(info.codeId),
			creator: info.creator,
			dataHash: info.dataHash
		};
	}
	static contactHistoryResponseToContractHistory(response) {
		return {
			entriesList: response.entries.map(ChainGrpcWasmTransformer.grpcContractCodeHistoryEntryToContractCodeHistoryEntry),
			pagination: ChainGrpcCommonTransformer.grpcPaginationToPaginationV2(response.pagination)
		};
	}
	static contractCodesResponseToContractCodes(response) {
		return {
			codeInfosList: response.codeInfos.map(ChainGrpcWasmTransformer.grpcCodeInfoResponseToCodeInfoResponse),
			pagination: ChainGrpcCommonTransformer.grpcPaginationToPaginationV2(response.pagination)
		};
	}
	static contractCodeResponseToContractCode(response) {
		return {
			codeInfo: ChainGrpcWasmTransformer.grpcCodeInfoResponseToCodeInfoResponse(response.codeInfo),
			data: response.data
		};
	}
	static contractByCodeResponseToContractByCode(response) {
		return {
			contractsList: response.contracts,
			pagination: ChainGrpcCommonTransformer.grpcPaginationToPaginationV2(response.pagination)
		};
	}
};

//#endregion
//#region src/client/chain/transformers/ChainGrpcAuthZTransformer.ts
/**
* @category Chain Grpc Transformer
*/
var ChainGrpcAuthZTransformer = class ChainGrpcAuthZTransformer {
	static grpcGrantToGrant(grant) {
		const authorization = decodeAuthorizationNoThrow(grant.authorization);
		return {
			authorization: authorization === null || authorization === void 0 ? void 0 : authorization.authorization,
			authorizationType: (authorization === null || authorization === void 0 ? void 0 : authorization.authorizationType) || "",
			expiration: grant.expiration
		};
	}
	static grpcGrantAuthorizationToGrantAuthorization(grant) {
		const authorization = decodeAuthorizationNoThrow(grant.authorization);
		return {
			granter: grant.granter,
			grantee: grant.grantee,
			authorization: authorization === null || authorization === void 0 ? void 0 : authorization.authorization,
			authorizationType: (authorization === null || authorization === void 0 ? void 0 : authorization.authorizationType) || "",
			expiration: grant.expiration
		};
	}
	static grpcGrantsToGrants(response) {
		return {
			pagination: ChainGrpcCommonTransformer.grpcPaginationToPaginationV2(response.pagination),
			grants: response.grants.map(ChainGrpcAuthZTransformer.grpcGrantToGrant)
		};
	}
	static grpcGranteeGrantsToGranteeGrants(response) {
		return {
			pagination: ChainGrpcCommonTransformer.grpcPaginationToPaginationV2(response.pagination),
			grants: response.grants.map(ChainGrpcAuthZTransformer.grpcGrantAuthorizationToGrantAuthorization)
		};
	}
	static grpcGranterGrantsToGranterGrants(response) {
		return {
			pagination: ChainGrpcCommonTransformer.grpcPaginationToPaginationV2(response.pagination),
			grants: response.grants.map(ChainGrpcAuthZTransformer.grpcGrantAuthorizationToGrantAuthorization)
		};
	}
};
const decodeAuthorization = (authorization) => {
	switch (authorization.typeUrl) {
		case "/cosmos.authz.v1beta1.GenericAuthorization": return {
			authorization: CosmosAuthzV1Beta1AuthzPb.GenericAuthorization.fromBinary(authorization.value),
			authorizationType: "/cosmos.authz.v1beta1.GenericAuthorization"
		};
		default: throw new GeneralException(/* @__PURE__ */ new Error("Unsupported authorization type"));
	}
};
const decodeAuthorizationNoThrow = (authorization) => {
	if (!authorization) return;
	try {
		return decodeAuthorization(authorization);
	} catch (_unused) {
		return;
	}
};

//#endregion
//#region src/client/chain/transformers/ChainGrpcPeggyTransformer.ts
/**
* @category Chain Grpc Transformer
*/
var ChainGrpcPeggyTransformer = class {
	static moduleParamsResponseToModuleParams(response) {
		const params = response.params;
		const valsetReward = params.valsetReward;
		return {
			peggyId: params.peggyId,
			contractSourceHash: params.contractSourceHash,
			bridgeEthereumAddress: params.bridgeEthereumAddress,
			bridgeChainId: params.bridgeChainId.toString(),
			signedValsetsWindow: params.signedValsetsWindow.toString(),
			signedBatchesWindow: params.signedBatchesWindow.toString(),
			signedClaimsWindow: params.signedClaimsWindow.toString(),
			targetBatchTimeout: params.targetBatchTimeout.toString(),
			averageBlockTime: params.averageBlockTime.toString(),
			averageEthereumBlockTime: params.averageEthereumBlockTime.toString(),
			slashFractionValset: params.slashFractionValset,
			slashFractionBatch: params.slashFractionBatch,
			slashFractionClaim: params.slashFractionClaim,
			slashFractionConflictingClaim: params.slashFractionConflictingClaim,
			unbondSlashingValsetsWindow: params.unbondSlashingValsetsWindow.toString(),
			slashFractionBadEthSignature: params.slashFractionBadEthSignature,
			cosmosCoinDenom: params.cosmosCoinDenom,
			cosmosCoinErc20Contract: params.cosmosCoinErc20Contract,
			claimSlashingEnabled: params.claimSlashingEnabled,
			bridgeContractStartHeight: params.bridgeContractStartHeight.toString(),
			valsetReward: {
				denom: valsetReward.denom,
				amount: valsetReward.amount
			}
		};
	}
};

//#endregion
//#region src/client/chain/transformers/ChainGrpcErc20Transformer.ts
/**
* @category Chain Grpc Transformer
*/
var ChainGrpcErc20Transformer = class {
	static grpcTokenPairToTokenPair(grpcTokenPair) {
		return {
			bankDenom: grpcTokenPair.bankDenom,
			erc20Address: grpcTokenPair.erc20Address
		};
	}
	static paramsResponseToParams(response) {
		const params = response.params;
		return { denomCreationFee: params === null || params === void 0 ? void 0 : params.denomCreationFee };
	}
	static tokenPairsResponseToTokenPairs(response) {
		return {
			tokenPairs: response.tokenPairs.map((tokenPair) => ({
				bankDenom: tokenPair.bankDenom,
				erc20Address: tokenPair.erc20Address
			})),
			pagination: ChainGrpcCommonTransformer.grpcPaginationToPaginationV2(response.pagination)
		};
	}
};

//#endregion
//#region src/client/chain/transformers/ChainGrpcTxFeesTransformer.ts
/**
* @category Chain Grpc Transformer
*/
var ChainGrpcTxFeesTransformer = class {
	static moduleParamsResponseToModuleParams(response) {
		const params = response.params;
		return {
			maxGasWantedPerTx: params.maxGasWantedPerTx.toString(),
			highGasTxThreshold: params.highGasTxThreshold.toString(),
			minGasPriceForHighGasTx: params.minGasPriceForHighGasTx,
			mempool1559Enabled: params.mempool1559Enabled,
			minGasPrice: denomAmountFromGrpcChainDenomAmount(params.minGasPrice).toFixed(),
			defaultBaseFeeMultiplier: denomAmountFromGrpcChainDenomAmount(params.defaultBaseFeeMultiplier).toFixed(),
			maxBaseFeeMultiplier: denomAmountFromGrpcChainDenomAmount(params.maxBaseFeeMultiplier).toFixed(),
			resetInterval: params.resetInterval.toString(),
			maxBlockChangeRate: denomAmountFromGrpcChainDenomAmount(params.maxBlockChangeRate).toFixed(),
			targetBlockSpacePercentRate: denomAmountFromGrpcChainDenomAmount(params.targetBlockSpacePercentRate).toFixed(),
			recheckFeeLowBaseFee: denomAmountFromGrpcChainDenomAmount(params.recheckFeeLowBaseFee).toFixed(),
			recheckFeeHighBaseFee: denomAmountFromGrpcChainDenomAmount(params.recheckFeeHighBaseFee).toFixed(),
			recheckFeeBaseFeeThresholdMultiplier: denomAmountFromGrpcChainDenomAmount(params.recheckFeeBaseFeeThresholdMultiplier).toFixed()
		};
	}
	static eipBaseFeeResponseToEipBaseFee(response) {
		return { baseFee: response.baseFee ? denomAmountFromGrpcChainDenomAmount(response.baseFee.baseFee).toFixed() : void 0 };
	}
};

//#endregion
//#region src/client/chain/transformers/ChainGrpcAuctionTransformer.ts
/**
* Transformer for Auction module gRPC responses
* @category Chain Grpc Transformer
*/
var ChainGrpcAuctionTransformer = class ChainGrpcAuctionTransformer {
	static grpcBidToBid(grpcBid) {
		return {
			bidder: grpcBid.bidder,
			amount: grpcBid.amount ? ChainGrpcCommonTransformer.grpcCoinToCoin(grpcBid.amount) : void 0
		};
	}
	static grpcLastAuctionResultToLastAuctionResult(grpcLastAuctionResult) {
		return {
			winner: grpcLastAuctionResult.winner,
			amount: grpcLastAuctionResult.amount ? ChainGrpcCommonTransformer.grpcCoinToCoin(grpcLastAuctionResult.amount) : void 0,
			round: grpcLastAuctionResult.round.toString()
		};
	}
	static moduleParamsResponseToModuleParams(response) {
		var _params$auctionPeriod, _params$minNextBidInc;
		if (!response.params) throw new GeneralException(/* @__PURE__ */ new Error("Auction params not found in response"));
		const params = response.params;
		return {
			auctionPeriod: Number((_params$auctionPeriod = params.auctionPeriod) !== null && _params$auctionPeriod !== void 0 ? _params$auctionPeriod : 0n),
			minNextBidIncrementRate: (_params$minNextBidInc = params.minNextBidIncrementRate) !== null && _params$minNextBidInc !== void 0 ? _params$minNextBidInc : "0"
		};
	}
	static currentBasketResponseToCurrentBasket(response) {
		return {
			amountList: response.amount.map(ChainGrpcCommonTransformer.grpcCoinToCoin),
			auctionRound: Number(response.auctionRound),
			auctionClosingTime: Number(response.auctionClosingTime),
			highestBidder: response.highestBidAmount,
			highestBidAmount: response.highestBidAmount
		};
	}
	static auctionModuleStateResponseToAuctionModuleState(response) {
		if (!response.state) throw new GeneralException(/* @__PURE__ */ new Error("Auction module state not found in response"));
		const state = response.state;
		if (!state.params) throw new GeneralException(/* @__PURE__ */ new Error("Auction params not found in state"));
		const params = state.params;
		return {
			params: {
				auctionPeriod: Number(params.auctionPeriod),
				minNextBidIncrementRate: params.minNextBidIncrementRate
			},
			auctionRound: Number(state.auctionRound),
			highestBid: state.highestBid ? ChainGrpcAuctionTransformer.grpcBidToBid(state.highestBid) : void 0,
			auctionEndingTimestamp: Number(state.auctionEndingTimestamp),
			lastAuctionResult: state.lastAuctionResult ? ChainGrpcAuctionTransformer.grpcLastAuctionResultToLastAuctionResult(state.lastAuctionResult) : void 0
		};
	}
	static lastAuctionResultResponseToLastAuctionResult(response) {
		if (!response.lastAuctionResult) return;
		return ChainGrpcAuctionTransformer.grpcLastAuctionResultToLastAuctionResult(response.lastAuctionResult);
	}
};

//#endregion
//#region src/client/chain/transformers/ChainGrpcStakingTransformer.ts
/**
* @category Chain Grpc Transformer
*/
var ChainGrpcStakingTransformer = class ChainGrpcStakingTransformer {
	static moduleParamsResponseToModuleParams(response) {
		const params = response.params;
		return {
			unbondingTime: protobufTimestampToUnixSeconds(params.unbondingTime),
			minCommissionRate: params.minCommissionRate,
			maxValidators: params.maxValidators,
			maxEntries: params.maxEntries,
			historicalEntries: params.historicalEntries,
			bondDenom: params.bondDenom
		};
	}
	static validatorResponseToValidator(response) {
		return ChainGrpcStakingTransformer.grpcValidatorToValidator(response.validator);
	}
	static validatorsResponseToValidators(response) {
		return {
			validators: response.validators.map((validator) => ChainGrpcStakingTransformer.grpcValidatorToValidator(validator)),
			pagination: ChainGrpcCommonTransformer.grpcPaginationToPaginationV2(response.pagination)
		};
	}
	static delegationResponseToDelegation(response) {
		const grpcDelegation = response.delegationResponse;
		const delegation = grpcDelegation.delegation;
		const balance = grpcDelegation.balance;
		return {
			delegation: {
				delegatorAddress: delegation ? delegation.delegatorAddress : "",
				validatorAddress: delegation ? delegation.validatorAddress : "",
				shares: toHumanReadable(delegation ? delegation.shares : 0).toFixed()
			},
			balance: {
				denom: balance ? balance.denom : "",
				amount: toBigNumber(balance ? balance.amount : 0).toFixed()
			}
		};
	}
	static delegationsResponseToDelegations(response) {
		return {
			delegations: response.delegationResponses.map((grpcDelegator) => {
				const delegation = grpcDelegator.delegation;
				const balance = grpcDelegator.balance;
				return {
					delegation: {
						delegatorAddress: delegation ? delegation.delegatorAddress : "",
						validatorAddress: delegation ? delegation.validatorAddress : "",
						shares: toHumanReadable(delegation ? delegation.shares : 0).toFixed()
					},
					balance: {
						denom: balance ? balance.denom : "",
						amount: toBigNumber(balance ? balance.amount : 0).toFixed()
					}
				};
			}),
			pagination: ChainGrpcCommonTransformer.grpcPaginationToPaginationV2(response.pagination)
		};
	}
	static unBondingDelegationsResponseToUnBondingDelegations(response) {
		return {
			unbondingDelegations: response.unbondingResponses.reduce((unbondingDelegations, grpcUnBondingDelegation) => {
				const mappedEntries = grpcUnBondingDelegation.entries.map((entry) => ({
					delegatorAddress: grpcUnBondingDelegation ? grpcUnBondingDelegation.delegatorAddress : "",
					validatorAddress: grpcUnBondingDelegation ? grpcUnBondingDelegation.validatorAddress : "",
					creationHeight: parseInt(entry.creationHeight.toString(), 10),
					completionTime: protobufTimestampToUnixSeconds(entry.completionTime),
					initialBalance: toBigNumber(entry.initialBalance).toFixed(),
					balance: toBigNumber(entry.balance).toFixed()
				}));
				return [...unbondingDelegations, ...mappedEntries];
			}, []),
			pagination: ChainGrpcCommonTransformer.grpcPaginationToPaginationV2(response.pagination)
		};
	}
	static reDelegationsResponseToReDelegations(response) {
		return {
			redelegations: response.redelegationResponses.reduce((uiReDelegator, grpcReDelegationCurrent) => {
				const grpcRedelegation = grpcReDelegationCurrent.redelegation;
				if (!grpcRedelegation) return uiReDelegator;
				const uiRedelegations = grpcReDelegationCurrent.entries.reduce((acc, entry) => {
					var _entry$redelegationEn;
					return [...acc, {
						delegation: {
							completionTime: protobufTimestampToUnixSeconds((_entry$redelegationEn = entry.redelegationEntry) === null || _entry$redelegationEn === void 0 ? void 0 : _entry$redelegationEn.completionTime),
							delegatorAddress: grpcRedelegation.delegatorAddress || "",
							sourceValidatorAddress: grpcRedelegation.validatorSrcAddress || "",
							destinationValidatorAddress: (grpcRedelegation === null || grpcRedelegation === void 0 ? void 0 : grpcRedelegation.validatorDstAddress) || ""
						},
						balance: toBigNumber(entry.balance).toFixed()
					}];
				}, []);
				return [...uiReDelegator, ...uiRedelegations];
			}, []),
			pagination: ChainGrpcCommonTransformer.grpcPaginationToPaginationV2(response.pagination)
		};
	}
	static grpcValidatorToValidator(validator) {
		return {
			operatorAddress: validator.operatorAddress,
			jailed: validator.jailed,
			status: ChainGrpcStakingTransformer.grpcValidatorStatusToStatus(validator.status),
			tokens: toHumanReadable(validator.tokens).toFixed(),
			delegatorShares: toHumanReadable(validator.delegatorShares).toFixed(),
			description: ChainGrpcStakingTransformer.grpcValidatorDescriptionToDescription(validator.description),
			unbondingHeight: Number(validator.unbondingHeight),
			unbondingTime: validator.unbondingTime,
			commission: ChainGrpcStakingTransformer.grpcValidatorCommissionToCommission(validator.commission),
			minSelfDelegation: validator.minSelfDelegation
		};
	}
	static poolResponseToPool(response) {
		const pool = response.pool;
		if (!pool) return {
			notBondedTokens: "0",
			bondedTokens: "0"
		};
		return {
			notBondedTokens: toHumanReadable(pool.notBondedTokens).toFixed(),
			bondedTokens: toHumanReadable(pool.bondedTokens).toFixed()
		};
	}
	static grpcValidatorDescriptionToDescription(description) {
		return {
			moniker: description ? description.moniker : "",
			identity: description ? description.identity : "",
			website: description ? description.website : "",
			securityContact: description ? description.securityContact : "",
			details: description ? description.details : ""
		};
	}
	static grpcValidatorCommissionToCommission(commission) {
		var _protobufTimestampToD;
		const commissionRates = commission ? commission.commissionRates : null;
		return {
			commissionRates: {
				rate: toHumanReadable(commissionRates ? commissionRates.rate : "0").toFixed(),
				maxRate: toHumanReadable(commissionRates ? commissionRates.maxRate : "0").toFixed(),
				maxChangeRate: toHumanReadable(commissionRates ? commissionRates.maxChangeRate : "0").toFixed()
			},
			updateTime: (_protobufTimestampToD = protobufTimestampToDate(commission === null || commission === void 0 ? void 0 : commission.updateTime)) !== null && _protobufTimestampToD !== void 0 ? _protobufTimestampToD : /* @__PURE__ */ new Date()
		};
	}
	static grpcValidatorStatusToStatus(status) {
		switch (status) {
			case 1: return BondStatus.UnBonded;
			case 2: return BondStatus.UnBonding;
			case 3: return BondStatus.Bonded;
			default: return BondStatus.UnBonded;
		}
	}
};

//#endregion
//#region src/client/chain/transformers/ChainGrpcPermissionsTransformer.ts
/**
* @category Chain Grpc Transformer
*/
var ChainGrpcPermissionsTransformer = class ChainGrpcPermissionsTransformer {
	static grpcRoleToRole(grpcRole) {
		return {
			name: grpcRole.name,
			roleId: grpcRole.roleId,
			permissions: grpcRole.permissions
		};
	}
	static grpcActorRolesToActorRoles(grpcActorRoles) {
		return {
			actor: grpcActorRoles.actor,
			roles: grpcActorRoles.roles
		};
	}
	static grpcRoleManagerToRoleManager(grpcRoleManager) {
		return {
			roles: grpcRoleManager.roles,
			manager: grpcRoleManager.manager
		};
	}
	static grpcPolicyStatusToPolicyStatus(grpcPolicyStatus) {
		return {
			action: grpcPolicyStatus.action,
			isSealed: grpcPolicyStatus.isSealed,
			isDisabled: grpcPolicyStatus.isDisabled
		};
	}
	static grpcPolicyManagerCapabilityToPolicyManagerCapability(grpcPolicyManagerCapability) {
		return {
			action: grpcPolicyManagerCapability.action,
			canSeal: grpcPolicyManagerCapability.canSeal,
			manager: grpcPolicyManagerCapability.manager,
			canDisable: grpcPolicyManagerCapability.canDisable
		};
	}
	static grpcAddressVoucherToAddressVoucher(grpcAddressVoucher) {
		return {
			address: grpcAddressVoucher.address,
			voucher: grpcAddressVoucher.voucher ? ChainGrpcCommonTransformer.grpcCoinToCoin(grpcAddressVoucher.voucher) : void 0
		};
	}
	static grpcNamespaceToNamespace(grpcNamespace) {
		return {
			denom: grpcNamespace.denom,
			contractHook: grpcNamespace.contractHook,
			rolePermissions: grpcNamespace.rolePermissions.map(ChainGrpcPermissionsTransformer.grpcRoleToRole),
			actorRoles: grpcNamespace.actorRoles.map(ChainGrpcPermissionsTransformer.grpcActorRolesToActorRoles),
			roleManagers: grpcNamespace.roleManagers.map(ChainGrpcPermissionsTransformer.grpcRoleManagerToRoleManager),
			policyStatuses: grpcNamespace.policyStatuses.map(ChainGrpcPermissionsTransformer.grpcPolicyStatusToPolicyStatus),
			policyManagerCapabilities: grpcNamespace.policyManagerCapabilities.map(ChainGrpcPermissionsTransformer.grpcPolicyManagerCapabilityToPolicyManagerCapability)
		};
	}
	static moduleParamsResponseToModuleParams(response) {
		const params = response.params;
		if (!params) throw new Error("Params not found in response");
		return { wasmHookQueryMaxGas: params.wasmHookQueryMaxGas.toString() };
	}
	static nameSpaceDenomsResponseToNameSpaceDenoms(response) {
		return response.denoms.map((denom) => denom);
	}
	static namespaceResponseToNamespaces(response) {
		if (!response.namespace) return;
		return ChainGrpcPermissionsTransformer.grpcNamespaceToNamespace(response.namespace);
	}
	static namespacesResponseToNamespaces(response) {
		return response.namespaces.map((namespace) => {
			ChainGrpcPermissionsTransformer.grpcNamespaceToNamespace(namespace);
		});
	}
	static actorsByRoleResponseToActorsByRole(response) {
		return response.actors.map((role) => {
			return { roles: role };
		});
	}
	static rolesByActorResponseToRolesByActor(response) {
		return response.roles.map((role) => {
			return { roles: role };
		});
	}
	static roleManagerResponseToRoleManager(response) {
		if (!response.roleManager) return;
		return ChainGrpcPermissionsTransformer.grpcRoleManagerToRoleManager(response.roleManager);
	}
	static roleManagersResponseToRoleManagers(response) {
		return response.roleManagers.map(ChainGrpcPermissionsTransformer.grpcRoleManagerToRoleManager);
	}
	static policyStatusesResponseToPolicyStatuses(response) {
		return response.policyStatuses.map(ChainGrpcPermissionsTransformer.grpcPolicyStatusToPolicyStatus);
	}
	static policyManagerCapabilitiesResponseToPolicyManagerCapabilities(response) {
		return response.policyManagerCapabilities.map(ChainGrpcPermissionsTransformer.grpcPolicyManagerCapabilityToPolicyManagerCapability);
	}
	static voucherResponseToVoucher(response) {
		if (!response.voucher) return;
		return ChainGrpcCommonTransformer.grpcCoinToCoin(response.voucher);
	}
	static vouchersResponseToVouchers(response) {
		return response.vouchers.map(ChainGrpcPermissionsTransformer.grpcAddressVoucherToAddressVoucher);
	}
	static moduleStateResponseToModuleState(response) {
		if (!response.state) return;
		return {
			params: ChainGrpcPermissionsTransformer.moduleParamsResponseToModuleParams(response.state),
			namespaces: response.state.namespaces.map(ChainGrpcPermissionsTransformer.grpcNamespaceToNamespace),
			vouchers: response.state.vouchers.map(ChainGrpcPermissionsTransformer.grpcAddressVoucherToAddressVoucher)
		};
	}
};

//#endregion
//#region src/client/chain/transformers/ChainGrpcDistributionTransformer.ts
/**
* @category Chain Grpc Transformer
*/
var ChainGrpcDistributionTransformer = class {
	static moduleParamsResponseToModuleParams(response) {
		const params = response.params;
		return {
			communityTax: toHumanReadable(params.communityTax).toFixed(),
			baseProposerReward: params.baseProposerReward,
			bonusProposerReward: params.bonusProposerReward,
			withdrawAddrEnabled: params.withdrawAddrEnabled
		};
	}
	static delegationRewardResponseToReward(response) {
		return response.rewards.map((grpcReward) => {
			return {
				amount: toHumanReadable(grpcReward.amount).toFixed(),
				denom: grpcReward.denom
			};
		});
	}
	static totalDelegationRewardResponseToTotalReward(response) {
		return response.rewards.map((grpcReward) => {
			return {
				rewards: grpcReward.reward.map((reward) => ({
					amount: toHumanReadable(reward.amount).toFixed(),
					denom: reward.denom
				})),
				validatorAddress: grpcReward.validatorAddress
			};
		});
	}
};

//#endregion
//#region src/client/chain/transformers/ChainGrpcTokenFactoryTransformer.ts
/**
* @category Chain Grpc Transformer
*/
var ChainGrpcTokenFactoryTransformer = class {
	static moduleParamsResponseToModuleParams(response) {
		return { denomCreationFee: response.params.denomCreationFee };
	}
	static moduleStateResponseToModuleState(response) {
		const state = response.state;
		return {
			denomCreationFee: state.params.denomCreationFee,
			factoryDenoms: state.factoryDenoms.map((item) => ({
				denom: item.denom,
				authorityMetadata: item.authorityMetadata
			}))
		};
	}
	static denomsCreatorResponseToDenomsString(response) {
		return response.denoms;
	}
	static authorityMetadataResponseToAuthorityMetadata(response) {
		return response.authorityMetadata;
	}
};

//#endregion
//#region src/client/chain/transformers/ChainGrpcInsuranceFundTransformer.ts
/**
* @category Chain Grpc Transformer
*/
var ChainGrpcInsuranceFundTransformer = class ChainGrpcInsuranceFundTransformer {
	static moduleParamsResponseToModuleParams(response) {
		const params = response.params;
		return { defaultRedemptionNoticePeriodDuration: Number(params.defaultRedemptionNoticePeriodDuration || 0n) };
	}
	static grpcInsuranceFundToInsuranceFund(grpcFund) {
		return {
			depositDenom: grpcFund.depositDenom,
			insurancePoolTokenDenom: grpcFund.insurancePoolTokenDenom,
			redemptionNoticePeriodDuration: Number(grpcFund.redemptionNoticePeriodDuration || 0n),
			balance: grpcFund.balance,
			totalShare: grpcFund.totalShare,
			marketId: grpcFund.marketId,
			marketTicker: grpcFund.marketTicker,
			oracleBase: grpcFund.oracleBase,
			oracleQuote: grpcFund.oracleQuote,
			oracleType: grpcFund.oracleType,
			expiry: Number(grpcFund.expiry)
		};
	}
	static insuranceFundResponseToInsuranceFund(response) {
		return ChainGrpcInsuranceFundTransformer.grpcInsuranceFundToInsuranceFund(response.fund);
	}
	static insuranceFundsResponseToInsuranceFunds(response) {
		return response.funds.map((fund) => ChainGrpcInsuranceFundTransformer.grpcInsuranceFundToInsuranceFund(fund));
	}
	static redemptionsResponseToRedemptions(response) {
		return response.amount.map((amount) => {
			return {
				amount: amount.amount,
				denom: amount.denom
			};
		});
	}
	static estimatedRedemptionsResponseToEstimatedRedemptions(response) {
		return response.amount.map((amount) => {
			return {
				amount: amount.amount,
				denom: amount.denom
			};
		});
	}
};

//#endregion
//#region src/client/chain/grpc/ChainGrpcGovApi.ts
/**
* @category Chain Grpc API
*/
var ChainGrpcGovApi = class extends BaseGrpcConsumer {
	constructor(..._args) {
		super(..._args);
		_defineProperty(this, "module", ChainModule.Gov);
	}
	get client() {
		return this.initClient(QueryClient);
	}
	async fetchModuleParams() {
		const requests = [
			"voting",
			"deposit",
			"tallying"
		].map((type) => {
			const request = CosmosGovV1QueryPb.QueryParamsRequest.create();
			request.paramsType = type;
			return request;
		});
		const [votingParams, depositParams, tallyParams] = await Promise.all(requests.map((request) => this.executeGrpcCall(request, this.client.params.bind(this.client))));
		return ChainGrpcGovTransformer.moduleParamsResponseToModuleParamsByType({
			votingParams: votingParams.params,
			tallyParams: tallyParams.params,
			depositParams: depositParams.params
		});
	}
	async fetchProposals({ status, pagination }) {
		const request = CosmosGovV1QueryPb.QueryProposalsRequest.create();
		request.proposalStatus = status;
		const paginationForRequest = ChainGrpcCommonTransformer.pageRequestToGrpcPageRequestV2(pagination);
		if (paginationForRequest) request.pagination = paginationForRequest;
		const response = await this.executeGrpcCall(request, this.client.proposals.bind(this.client));
		return ChainGrpcGovTransformer.proposalsResponseToProposals(response);
	}
	async fetchProposal(proposalId) {
		const request = CosmosGovV1QueryPb.QueryProposalRequest.create();
		request.proposalId = BigInt(proposalId);
		const response = await this.executeGrpcCall(request, this.client.proposal.bind(this.client));
		return ChainGrpcGovTransformer.proposalResponseToProposal(response);
	}
	async fetchProposalDeposits({ proposalId, pagination }) {
		const request = CosmosGovV1QueryPb.QueryDepositsRequest.create();
		request.proposalId = BigInt(proposalId);
		const paginationForRequest = ChainGrpcCommonTransformer.pageRequestToGrpcPageRequestV2(pagination);
		if (paginationForRequest) request.pagination = paginationForRequest;
		const response = await this.executeGrpcCall(request, this.client.deposits.bind(this.client));
		return ChainGrpcGovTransformer.depositsResponseToDeposits(response);
	}
	async fetchProposalVotes({ proposalId, pagination }) {
		const request = CosmosGovV1QueryPb.QueryVotesRequest.create();
		request.proposalId = BigInt(proposalId);
		const paginationForRequest = ChainGrpcCommonTransformer.pageRequestToGrpcPageRequestV2(pagination);
		if (paginationForRequest) request.pagination = paginationForRequest;
		const response = await this.executeGrpcCall(request, this.client.votes.bind(this.client));
		return ChainGrpcGovTransformer.votesResponseToVotes(response);
	}
	async fetchProposalTally(proposalId) {
		const request = CosmosGovV1QueryPb.QueryTallyResultRequest.create();
		request.proposalId = BigInt(proposalId);
		const response = await this.executeGrpcCall(request, this.client.tallyResult.bind(this.client));
		return ChainGrpcGovTransformer.tallyResultResponseToTallyResult(response);
	}
};

//#endregion
//#region src/client/chain/grpc/ChainGrpcIbcApi.ts
/**
* @category Chain Grpc API
*/
var ChainGrpcIbcApi = class extends BaseGrpcConsumer {
	constructor(..._args) {
		super(..._args);
		_defineProperty(this, "module", ChainModule.Ibc);
	}
	get client() {
		return this.initClient(QueryClient$1);
	}
	async fetchDenomTrace(hash) {
		const request = IbcApplicationsTransferV1QueryPb.QueryDenomTraceRequest.create();
		request.hash = hash;
		return (await this.executeGrpcCall(request, this.client.denomTrace.bind(this.client))).denomTrace;
	}
	async fetchDenomsTrace(pagination) {
		const request = IbcApplicationsTransferV1QueryPb.QueryDenomTracesRequest.create();
		const paginationForRequest = ChainGrpcCommonTransformer.pageRequestToGrpcPageRequestV2(pagination);
		if (paginationForRequest) request.pagination = paginationForRequest;
		return (await this.executeGrpcCall(request, this.client.denomTraces.bind(this.client))).denomTraces;
	}
};

//#endregion
//#region src/client/chain/grpc/ChainGrpcEvmApi.ts
/**
* @category Chain Grpc API
*/
var ChainGrpcEvmApi = class extends BaseGrpcConsumer {
	constructor(..._args) {
		super(..._args);
		_defineProperty(this, "module", ChainModule.Evm);
	}
	get client() {
		return this.initClient(QueryClient$2);
	}
	async fetchAccount(ethAddress) {
		const request = InjectiveEvmV1QueryPb.QueryAccountRequest.create();
		request.address = ethAddress;
		const response = await this.executeGrpcCall(request, this.client.account.bind(this.client));
		return ChainGrpcEvmTransformer.accountResponseToAccount(response);
	}
	async fetchCosmosAccount(ethAddress) {
		const request = InjectiveEvmV1QueryPb.QueryCosmosAccountRequest.create();
		request.address = ethAddress;
		const response = await this.executeGrpcCall(request, this.client.cosmosAccount.bind(this.client));
		return ChainGrpcEvmTransformer.cosmosAccountResponseToCosmosAccount(response);
	}
	async fetchValidatorAccount(consAddress) {
		const request = InjectiveEvmV1QueryPb.QueryValidatorAccountRequest.create();
		request.consAddress = consAddress;
		const response = await this.executeGrpcCall(request, this.client.validatorAccount.bind(this.client));
		return ChainGrpcEvmTransformer.validatorAccountResponseToValidatorAccount(response);
	}
	async fetchBalance(ethAddress) {
		const request = InjectiveEvmV1QueryPb.QueryBalanceRequest.create();
		request.address = ethAddress;
		return (await this.executeGrpcCall(request, this.client.balance.bind(this.client))).balance;
	}
	async fetchStorage(ethAddress, key) {
		const request = InjectiveEvmV1QueryPb.QueryStorageRequest.create();
		request.address = ethAddress;
		request.key = key;
		return (await this.executeGrpcCall(request, this.client.storage.bind(this.client))).value;
	}
	async fetchCode(ethAddress) {
		const request = InjectiveEvmV1QueryPb.QueryCodeRequest.create();
		request.address = ethAddress;
		return (await this.executeGrpcCall(request, this.client.code.bind(this.client))).code;
	}
	async fetchParams() {
		const request = InjectiveEvmV1QueryPb.QueryParamsRequest.create();
		const response = await this.executeGrpcCall(request, this.client.params.bind(this.client));
		return ChainGrpcEvmTransformer.paramsResponseToParams(response);
	}
	async fetchBaseFee() {
		const request = InjectiveEvmV1QueryPb.QueryBaseFeeRequest.create();
		return (await this.executeGrpcCall(request, this.client.baseFee.bind(this.client))).baseFee;
	}
};

//#endregion
//#region src/client/chain/grpc/ChainGrpcBankApi.ts
const MAX_LIMIT_FOR_SUPPLY$1 = 1e4;
/**
* @category Chain Grpc API
*/
var ChainGrpcBankApi = class extends BaseGrpcConsumer {
	constructor(..._args) {
		super(..._args);
		_defineProperty(this, "module", ChainModule.Bank);
	}
	get client() {
		return this.initClient(QueryClient$3);
	}
	async fetchModuleParams() {
		const request = CosmosBankV1Beta1QueryPb.QueryParamsRequest.create();
		const response = await this.executeGrpcCall(request, this.client.params.bind(this.client));
		return ChainGrpcBankTransformer.moduleParamsResponseToModuleParams(response);
	}
	async fetchBalance({ accountAddress, denom }) {
		const request = CosmosBankV1Beta1QueryPb.QueryBalanceRequest.create();
		request.address = accountAddress;
		request.denom = denom;
		const response = await this.executeGrpcCall(request, this.client.balance.bind(this.client));
		return ChainGrpcBankTransformer.balanceResponseToBalance(response);
	}
	async fetchBalances(address, pagination) {
		const request = CosmosBankV1Beta1QueryPb.QueryAllBalancesRequest.create();
		request.address = address;
		const paginationForRequest = ChainGrpcCommonTransformer.pageRequestToGrpcPageRequestV2(pagination);
		if (paginationForRequest) request.pagination = paginationForRequest;
		const response = await this.executeGrpcCall(request, this.client.allBalances.bind(this.client));
		return ChainGrpcBankTransformer.balancesResponseToBalances(response);
	}
	async fetchTotalSupply(pagination) {
		const request = CosmosBankV1Beta1QueryPb.QueryTotalSupplyRequest.create();
		const paginationForRequest = ChainGrpcCommonTransformer.pageRequestToGrpcPageRequestV2(pagination);
		if (paginationForRequest) request.pagination = paginationForRequest;
		const response = await this.executeGrpcCall(request, this.client.totalSupply.bind(this.client));
		return ChainGrpcBankTransformer.totalSupplyResponseToTotalSupply(response);
	}
	/** a way to ensure all total supply is fully fetched */
	async fetchAllTotalSupply(pagination = { limit: MAX_LIMIT_FOR_SUPPLY$1 }) {
		return fetchAllWithPagination(pagination, this.fetchTotalSupply.bind(this));
	}
	async fetchSupplyOf(denom) {
		const request = CosmosBankV1Beta1QueryPb.QuerySupplyOfRequest.create();
		request.denom = denom;
		const response = await this.executeGrpcCall(request, this.client.supplyOf.bind(this.client));
		return ChainGrpcCommonTransformer.grpcCoinToCoin(response.amount);
	}
	async fetchDenomsMetadata(pagination) {
		const request = CosmosBankV1Beta1QueryPb.QueryDenomsMetadataRequest.create();
		const paginationForRequest = ChainGrpcCommonTransformer.pageRequestToGrpcPageRequestV2(pagination);
		if (paginationForRequest) request.pagination = paginationForRequest;
		const response = await this.executeGrpcCall(request, this.client.denomsMetadata.bind(this.client));
		return ChainGrpcBankTransformer.denomsMetadataResponseToDenomsMetadata(response);
	}
	async fetchDenomMetadata(denom) {
		const request = CosmosBankV1Beta1QueryPb.QueryDenomMetadataRequest.create();
		request.denom = denom;
		const response = await this.executeGrpcCall(request, this.client.denomMetadata.bind(this.client));
		return ChainGrpcBankTransformer.metadataToMetadata(response.metadata);
	}
	async fetchDenomOwners(denom, pagination) {
		const request = CosmosBankV1Beta1QueryPb.QueryDenomOwnersRequest.create();
		request.denom = denom;
		const paginationForRequest = ChainGrpcCommonTransformer.pageRequestToGrpcPageRequestV2(pagination);
		if (paginationForRequest) request.pagination = paginationForRequest;
		const response = await this.executeGrpcCall(request, this.client.denomOwners.bind(this.client));
		return ChainGrpcBankTransformer.denomOwnersResponseToDenomOwners(response);
	}
};

//#endregion
//#region src/client/chain/grpc/ChainGrpcMintApi.ts
/**
* @category Chain Grpc API
*/
var ChainGrpcMintApi = class extends BaseGrpcConsumer {
	constructor(..._args) {
		super(..._args);
		_defineProperty(this, "module", ChainModule.Mint);
	}
	get client() {
		return this.initClient(QueryClient$4);
	}
	async fetchModuleParams() {
		const request = CosmosMintV1Beta1QueryPb.QueryParamsRequest.create();
		const response = await this.executeGrpcCall(request, this.client.params.bind(this.client));
		return ChainGrpcMintTransformer.moduleParamsResponseToModuleParams(response);
	}
	async fetchInflation() {
		const request = CosmosMintV1Beta1QueryPb.QueryInflationRequest.create();
		return { inflation: toHumanReadable(uint8ArrayToString((await this.executeGrpcCall(request, this.client.inflation.bind(this.client))).inflation)) };
	}
	async fetchAnnualProvisions() {
		const request = CosmosMintV1Beta1QueryPb.QueryAnnualProvisionsRequest.create();
		return { annualProvisions: toHumanReadable(uint8ArrayToString((await this.executeGrpcCall(request, this.client.annualProvisions.bind(this.client))).annualProvisions)).toFixed() };
	}
};

//#endregion
//#region src/client/chain/grpc/ChainGrpcWasmApi.ts
/**
* @category Chain Grpc API
*/
var ChainGrpcWasmApi = class extends BaseGrpcConsumer {
	constructor(..._args) {
		super(..._args);
		_defineProperty(this, "module", ChainModule.Wasm);
	}
	get client() {
		return this.initClient(QueryClient$5);
	}
	async fetchContractAccountsBalance({ contractAddress, pagination }) {
		const request = CosmwasmWasmV1QueryPb.QueryAllContractStateRequest.create();
		request.address = contractAddress;
		const paginationForRequest = ChainGrpcCommonTransformer.pageRequestToGrpcPageRequestV2(pagination);
		if (paginationForRequest) request.pagination = paginationForRequest;
		const response = await this.executeGrpcCall(request, this.client.allContractState.bind(this.client));
		return ChainGrpcWasmTransformer.allContractStateResponseToContractAccountsBalanceWithPagination(response);
	}
	async fetchContractState({ contractAddress, pagination }) {
		const request = CosmwasmWasmV1QueryPb.QueryAllContractStateRequest.create();
		request.address = contractAddress;
		const paginationForRequest = ChainGrpcCommonTransformer.pageRequestToGrpcPageRequestV2(pagination);
		if (paginationForRequest) request.pagination = paginationForRequest;
		const response = await this.executeGrpcCall(request, this.client.allContractState.bind(this.client));
		return ChainGrpcWasmTransformer.allContractStateResponseToContractState(response);
	}
	async fetchContractInfo(contractAddress) {
		const request = CosmwasmWasmV1QueryPb.QueryContractInfoRequest.create();
		request.address = contractAddress;
		const contractInfo = (await this.executeGrpcCall(request, this.client.contractInfo.bind(this.client))).contractInfo;
		if (!contractInfo) return;
		return ChainGrpcWasmTransformer.contactInfoResponseToContractInfo(contractInfo);
	}
	async fetchContractHistory(contractAddress) {
		const request = CosmwasmWasmV1QueryPb.QueryContractHistoryRequest.create();
		request.address = contractAddress;
		const response = await this.executeGrpcCall(request, this.client.contractHistory.bind(this.client));
		return ChainGrpcWasmTransformer.contactHistoryResponseToContractHistory(response);
	}
	async fetchSmartContractState(contractAddress, query) {
		const request = CosmwasmWasmV1QueryPb.QuerySmartContractStateRequest.create();
		request.address = contractAddress;
		if (query) request.queryData = base64ToUint8Array(typeof query === "string" ? query : toBase64(query));
		return await this.executeGrpcCall(request, this.client.smartContractState.bind(this.client));
	}
	async fetchRawContractState(contractAddress, query) {
		const request = CosmwasmWasmV1QueryPb.QueryRawContractStateRequest.create();
		request.address = contractAddress;
		if (query) request.queryData = base64ToUint8Array(query);
		return await this.executeGrpcCall(request, this.client.rawContractState.bind(this.client));
	}
	async fetchContractCodes(pagination) {
		const request = CosmwasmWasmV1QueryPb.QueryCodesRequest.create();
		const paginationForRequest = ChainGrpcCommonTransformer.pageRequestToGrpcPageRequestV2(pagination);
		if (paginationForRequest) request.pagination = paginationForRequest;
		const response = await this.executeGrpcCall(request, this.client.codes.bind(this.client));
		return ChainGrpcWasmTransformer.contractCodesResponseToContractCodes(response);
	}
	async fetchContractCode(codeId) {
		const request = CosmwasmWasmV1QueryPb.QueryCodeRequest.create();
		request.codeId = BigInt(codeId);
		const response = await this.executeGrpcCall(request, this.client.code.bind(this.client));
		return ChainGrpcWasmTransformer.contractCodeResponseToContractCode(response);
	}
	async fetchContractCodeContracts(codeId, pagination) {
		const request = CosmwasmWasmV1QueryPb.QueryContractsByCodeRequest.create();
		request.codeId = BigInt(codeId);
		const paginationForRequest = ChainGrpcCommonTransformer.pageRequestToGrpcPageRequestV2(pagination);
		if (paginationForRequest) request.pagination = paginationForRequest;
		const response = await this.executeGrpcCall(request, this.client.contractsByCode.bind(this.client));
		return ChainGrpcWasmTransformer.contractByCodeResponseToContractByCode(response);
	}
};

//#endregion
//#region src/client/chain/grpc/ChainGrpcAuthZApi.ts
/**
* @category Chain Grpc API
*/
var ChainGrpcAuthZApi = class extends BaseGrpcConsumer {
	constructor(..._args) {
		super(..._args);
		_defineProperty(this, "module", ChainModule.Authz);
	}
	get client() {
		return this.initClient(QueryClient$6);
	}
	async fetchGrants({ pagination, granter, grantee, msgTypeUrl }) {
		const request = CosmosAuthzV1Beta1QueryPb.QueryGrantsRequest.create();
		if (granter) request.granter = granter;
		if (grantee) request.grantee = grantee;
		if (msgTypeUrl) request.msgTypeUrl = msgTypeUrl;
		const paginationForRequest = ChainGrpcCommonTransformer.pageRequestToGrpcPageRequestV2(pagination);
		if (paginationForRequest) request.pagination = paginationForRequest;
		const response = await this.executeGrpcCall(request, this.client.grants.bind(this.client));
		return ChainGrpcAuthZTransformer.grpcGrantsToGrants(response);
	}
	async fetchGranterGrants(granter, pagination) {
		const request = CosmosAuthzV1Beta1QueryPb.QueryGranterGrantsRequest.create();
		if (granter) request.granter = granter;
		const paginationForRequest = ChainGrpcCommonTransformer.pageRequestToGrpcPageRequestV2(pagination);
		if (paginationForRequest) request.pagination = paginationForRequest;
		const response = await this.executeGrpcCall(request, this.client.granterGrants.bind(this.client));
		return ChainGrpcAuthZTransformer.grpcGranterGrantsToGranterGrants(response);
	}
	async fetchGranteeGrants(grantee, pagination) {
		const request = CosmosAuthzV1Beta1QueryPb.QueryGranteeGrantsRequest.create();
		if (grantee) request.grantee = grantee;
		const paginationForRequest = ChainGrpcCommonTransformer.pageRequestToGrpcPageRequestV2(pagination);
		if (paginationForRequest) request.pagination = paginationForRequest;
		const response = await this.executeGrpcCall(request, this.client.granteeGrants.bind(this.client));
		return ChainGrpcAuthZTransformer.grpcGranteeGrantsToGranteeGrants(response);
	}
};

//#endregion
//#region src/client/chain/grpc/ChainGrpcPeggyApi.ts
/**
* @category Chain Grpc API
*/
var ChainGrpcPeggyApi = class extends BaseGrpcConsumer {
	constructor(..._args) {
		super(..._args);
		_defineProperty(this, "module", ChainModule.Peggy);
	}
	get client() {
		return this.initClient(QueryClient$7);
	}
	async fetchModuleParams() {
		const request = InjectivePeggyV1QueryPb.QueryParamsRequest.create();
		const response = await this.executeGrpcCall(request, this.client.params.bind(this.client));
		return ChainGrpcPeggyTransformer.moduleParamsResponseToModuleParams(response);
	}
};

//#endregion
//#region src/client/chain/grpc/ChainGrpcWasmXApi.ts
/**
* @category Chain Grpc API
*/
var ChainGrpcWasmXApi = class extends BaseGrpcConsumer {
	constructor(..._args) {
		super(..._args);
		_defineProperty(this, "module", ChainModule.WasmX);
	}
	get client() {
		return this.initClient(QueryClient$8);
	}
	async fetchModuleParams() {
		const request = InjectiveWasmxV1QueryPb.QueryWasmxParamsRequest.create();
		return await this.executeGrpcCall(request, this.client.wasmxParams.bind(this.client));
	}
	async fetchModuleState() {
		const request = InjectiveWasmxV1QueryPb.QueryModuleStateRequest.create();
		return (await this.executeGrpcCall(request, this.client.wasmxModuleState.bind(this.client))).state;
	}
};

//#endregion
//#region src/client/chain/grpc/ChainGrpcErc20Api.ts
const MAX_LIMIT_FOR_SUPPLY = 1e4;
/**
* @category Chain Grpc API
*/
var ChainGrpcErc20Api = class extends BaseGrpcConsumer {
	constructor(..._args) {
		super(..._args);
		_defineProperty(this, "module", ChainModule.Erc20);
	}
	get client() {
		return this.initClient(QueryClient$9);
	}
	async fetchModuleParams() {
		const request = InjectiveErc20V1Beta1QueryPb.QueryParamsRequest.create();
		const response = await this.executeGrpcCall(request, this.client.params.bind(this.client));
		return ChainGrpcErc20Transformer.paramsResponseToParams(response);
	}
	async fetchTokenPairs(pagination) {
		const request = InjectiveErc20V1Beta1QueryPb.QueryAllTokenPairsRequest.create();
		const paginationForRequest = ChainGrpcCommonTransformer.pageRequestToGrpcPageRequestV2(pagination);
		if (paginationForRequest) request.pagination = paginationForRequest;
		const response = await this.executeGrpcCall(request, this.client.allTokenPairs.bind(this.client));
		return ChainGrpcErc20Transformer.tokenPairsResponseToTokenPairs(response);
	}
	async fetchAllTokenPairsWithPagination(pagination = { limit: MAX_LIMIT_FOR_SUPPLY }) {
		return fetchAllWithPagination(pagination, this.fetchTokenPairs.bind(this));
	}
	async fetchTokenPairByDenom(denom) {
		const request = InjectiveErc20V1Beta1QueryPb.QueryTokenPairByDenomRequest.create();
		request.bankDenom = denom;
		const response = await this.executeGrpcCall(request, this.client.tokenPairByDenom.bind(this.client));
		if (!response.tokenPair) return;
		return ChainGrpcErc20Transformer.grpcTokenPairToTokenPair(response.tokenPair);
	}
	async fetchTokenPairByErc20Address(erc20Address) {
		const request = InjectiveErc20V1Beta1QueryPb.QueryTokenPairByERC20AddressRequest.create();
		request.erc20Address = erc20Address;
		const response = await this.executeGrpcCall(request, this.client.tokenPairByERC20Address.bind(this.client));
		if (!response.tokenPair) return;
		return ChainGrpcErc20Transformer.grpcTokenPairToTokenPair(response.tokenPair);
	}
};

//#endregion
//#region src/client/chain/grpc/ChainGrpcOracleApi.ts
/**
* @category Chain Grpc API
*/
var ChainGrpcOracleApi = class extends BaseGrpcConsumer {
	constructor(..._args) {
		super(..._args);
		_defineProperty(this, "module", ChainModule.Oracle);
	}
	get client() {
		return this.initClient(QueryClient$10);
	}
	async fetchModuleParams() {
		const request = InjectiveOracleV1Beta1QueryPb.QueryParamsRequest.create();
		return (await this.executeGrpcCall(request, this.client.params.bind(this.client))).params;
	}
};

//#endregion
//#region src/client/chain/grpc/ChainGrpcTxFeesApi.ts
/**
* @category Chain Grpc API
*/
var ChainGrpcTxFeesApi = class extends BaseGrpcConsumer {
	constructor(..._args) {
		super(..._args);
		_defineProperty(this, "module", ChainModule.TxFees);
	}
	get client() {
		return this.initClient(QueryClient$11);
	}
	async fetchModuleParams() {
		const request = InjectiveTxFeesV1Beta1QueryPb.QueryParamsRequest.create();
		const response = await this.executeGrpcCall(request, this.client.params.bind(this.client));
		return ChainGrpcTxFeesTransformer.moduleParamsResponseToModuleParams(response);
	}
	async fetchEipBaseFee() {
		const request = InjectiveTxFeesV1Beta1QueryPb.QueryEipBaseFeeRequest.create();
		const response = await this.executeGrpcCall(request, this.client.getEipBaseFee.bind(this.client));
		return ChainGrpcTxFeesTransformer.eipBaseFeeResponseToEipBaseFee(response);
	}
};

//#endregion
//#region src/client/chain/grpc/ChainGrpcAuctionApi.ts
/**
* @category Chain Grpc API
*/
var ChainGrpcAuctionApi = class extends BaseGrpcConsumer {
	constructor(..._args) {
		super(..._args);
		_defineProperty(this, "module", ChainModule.Auction);
	}
	get client() {
		return this.initClient(QueryClient$12);
	}
	async fetchModuleParams() {
		const request = InjectiveAuctionV1Beta1QueryPb.QueryAuctionParamsRequest.create();
		const response = await this.executeGrpcCall(request, this.client.auctionParams.bind(this.client));
		return ChainGrpcAuctionTransformer.moduleParamsResponseToModuleParams(response);
	}
	async fetchCurrentBasket() {
		const request = InjectiveAuctionV1Beta1QueryPb.QueryCurrentAuctionBasketRequest.create();
		const response = await this.executeGrpcCall(request, this.client.currentAuctionBasket.bind(this.client));
		return ChainGrpcAuctionTransformer.currentBasketResponseToCurrentBasket(response);
	}
	async fetchModuleState() {
		const request = InjectiveAuctionV1Beta1QueryPb.QueryModuleStateRequest.create();
		const response = await this.executeGrpcCall(request, this.client.auctionModuleState.bind(this.client));
		return ChainGrpcAuctionTransformer.auctionModuleStateResponseToAuctionModuleState(response);
	}
	async fetchLastAuctionResult() {
		const request = InjectiveAuctionV1Beta1QueryPb.QueryLastAuctionResultRequest.create();
		const response = await this.executeGrpcCall(request, this.client.lastAuctionResult.bind(this.client));
		return ChainGrpcAuctionTransformer.lastAuctionResultResponseToLastAuctionResult(response);
	}
};

//#endregion
//#region src/client/chain/grpc/ChainGrpcStakingApi.ts
/**
* @category Chain Grpc API
*/
var ChainGrpcStakingApi = class extends BaseGrpcConsumer {
	constructor(..._args) {
		super(..._args);
		_defineProperty(this, "module", ChainModule.Staking);
	}
	get client() {
		return this.initClient(QueryClient$13);
	}
	async fetchModuleParams() {
		const request = CosmosStakingV1Beta1QueryPb.QueryParamsRequest.create();
		const response = await this.executeGrpcCall(request, this.client.params.bind(this.client));
		return ChainGrpcStakingTransformer.moduleParamsResponseToModuleParams(response);
	}
	async fetchPool() {
		const request = CosmosStakingV1Beta1QueryPb.QueryPoolRequest.create();
		const response = await this.executeGrpcCall(request, this.client.pool.bind(this.client));
		return ChainGrpcStakingTransformer.poolResponseToPool(response);
	}
	async fetchValidators(pagination) {
		const request = CosmosStakingV1Beta1QueryPb.QueryValidatorsRequest.create();
		const paginationForRequest = ChainGrpcCommonTransformer.pageRequestToGrpcPageRequestV2(pagination);
		if (paginationForRequest) request.pagination = paginationForRequest;
		const response = await this.executeGrpcCall(request, this.client.validators.bind(this.client));
		return ChainGrpcStakingTransformer.validatorsResponseToValidators(response);
	}
	async fetchValidator(address) {
		const request = CosmosStakingV1Beta1QueryPb.QueryValidatorRequest.create();
		request.validatorAddr = address;
		const response = await this.executeGrpcCall(request, this.client.validator.bind(this.client));
		return ChainGrpcStakingTransformer.validatorResponseToValidator(response);
	}
	async fetchValidatorDelegations({ validatorAddress, pagination }) {
		const request = CosmosStakingV1Beta1QueryPb.QueryValidatorDelegationsRequest.create();
		request.validatorAddr = validatorAddress;
		const paginationForRequest = ChainGrpcCommonTransformer.pageRequestToGrpcPageRequestV2(pagination);
		if (paginationForRequest) request.pagination = paginationForRequest;
		const response = await this.executeGrpcCall(request, this.client.validatorDelegations.bind(this.client));
		return ChainGrpcStakingTransformer.delegationsResponseToDelegations(response);
	}
	async fetchValidatorDelegationsNoThrow({ validatorAddress, pagination }) {
		const request = CosmosStakingV1Beta1QueryPb.QueryValidatorDelegationsRequest.create();
		request.validatorAddr = validatorAddress;
		const paginationForRequest = ChainGrpcCommonTransformer.pageRequestToGrpcPageRequestV2(pagination);
		if (paginationForRequest) request.pagination = paginationForRequest;
		try {
			const response = await this.executeGrpcCall(request, this.client.validatorDelegations.bind(this.client));
			return ChainGrpcStakingTransformer.delegationsResponseToDelegations(response);
		} catch (e) {
			if (e.message.includes("does not exist")) return {
				delegations: [],
				pagination: {
					total: 0,
					next: ""
				}
			};
			throw e;
		}
	}
	async fetchValidatorUnbondingDelegations({ validatorAddress, pagination }) {
		const request = CosmosStakingV1Beta1QueryPb.QueryValidatorUnbondingDelegationsRequest.create();
		request.validatorAddr = validatorAddress;
		const paginationForRequest = ChainGrpcCommonTransformer.pageRequestToGrpcPageRequestV2(pagination);
		if (paginationForRequest) request.pagination = paginationForRequest;
		const response = await this.executeGrpcCall(request, this.client.validatorUnbondingDelegations.bind(this.client));
		return ChainGrpcStakingTransformer.unBondingDelegationsResponseToUnBondingDelegations(response);
	}
	async fetchValidatorUnbondingDelegationsNoThrow({ validatorAddress, pagination }) {
		const request = CosmosStakingV1Beta1QueryPb.QueryValidatorUnbondingDelegationsRequest.create();
		request.validatorAddr = validatorAddress;
		const paginationForRequest = ChainGrpcCommonTransformer.pageRequestToGrpcPageRequestV2(pagination);
		if (paginationForRequest) request.pagination = paginationForRequest;
		try {
			const response = await this.executeGrpcCall(request, this.client.validatorUnbondingDelegations.bind(this.client));
			return ChainGrpcStakingTransformer.unBondingDelegationsResponseToUnBondingDelegations(response);
		} catch (e) {
			if (e.message.includes("does not exist")) return {
				unbondingDelegations: [],
				pagination: {
					total: 0,
					next: ""
				}
			};
			throw e;
		}
	}
	async fetchDelegation({ injectiveAddress, validatorAddress }) {
		const request = CosmosStakingV1Beta1QueryPb.QueryDelegationRequest.create();
		request.delegatorAddr = injectiveAddress;
		request.validatorAddr = validatorAddress;
		const response = await this.executeGrpcCall(request, this.client.delegation.bind(this.client));
		return ChainGrpcStakingTransformer.delegationResponseToDelegation(response);
	}
	async fetchDelegations({ injectiveAddress, pagination }) {
		const request = CosmosStakingV1Beta1QueryPb.QueryDelegatorDelegationsRequest.create();
		request.delegatorAddr = injectiveAddress;
		const paginationForRequest = ChainGrpcCommonTransformer.pageRequestToGrpcPageRequestV2(pagination);
		if (paginationForRequest) request.pagination = paginationForRequest;
		const response = await this.executeGrpcCall(request, this.client.delegatorDelegations.bind(this.client));
		return ChainGrpcStakingTransformer.delegationsResponseToDelegations(response);
	}
	async fetchDelegationsNoThrow({ injectiveAddress, pagination }) {
		const request = CosmosStakingV1Beta1QueryPb.QueryDelegatorDelegationsRequest.create();
		request.delegatorAddr = injectiveAddress;
		const paginationForRequest = ChainGrpcCommonTransformer.pageRequestToGrpcPageRequestV2(pagination);
		if (paginationForRequest) request.pagination = paginationForRequest;
		try {
			const response = await this.executeGrpcCall(request, this.client.delegatorDelegations.bind(this.client));
			return ChainGrpcStakingTransformer.delegationsResponseToDelegations(response);
		} catch (e) {
			if (e.message.includes("does not exist")) return {
				delegations: [],
				pagination: {
					total: 0,
					next: ""
				}
			};
			throw e;
		}
	}
	async fetchDelegators({ validatorAddress, pagination }) {
		const request = CosmosStakingV1Beta1QueryPb.QueryValidatorDelegationsRequest.create();
		request.validatorAddr = validatorAddress;
		const paginationForRequest = ChainGrpcCommonTransformer.pageRequestToGrpcPageRequestV2(pagination);
		if (paginationForRequest) request.pagination = paginationForRequest;
		const response = await this.executeGrpcCall(request, this.client.validatorDelegations.bind(this.client));
		return ChainGrpcStakingTransformer.delegationsResponseToDelegations(response);
	}
	async fetchDelegatorsNoThrow({ validatorAddress, pagination }) {
		const request = CosmosStakingV1Beta1QueryPb.QueryValidatorDelegationsRequest.create();
		request.validatorAddr = validatorAddress;
		const paginationForRequest = ChainGrpcCommonTransformer.pageRequestToGrpcPageRequestV2(pagination);
		if (paginationForRequest) request.pagination = paginationForRequest;
		try {
			const response = await this.executeGrpcCall(request, this.client.validatorDelegations.bind(this.client));
			return ChainGrpcStakingTransformer.delegationsResponseToDelegations(response);
		} catch (e) {
			if (e.message.includes("does not exist")) return {
				delegations: [],
				pagination: {
					total: 0,
					next: ""
				}
			};
			throw e;
		}
	}
	async fetchUnbondingDelegations({ injectiveAddress, pagination }) {
		const request = CosmosStakingV1Beta1QueryPb.QueryDelegatorUnbondingDelegationsRequest.create();
		request.delegatorAddr = injectiveAddress;
		const paginationForRequest = ChainGrpcCommonTransformer.pageRequestToGrpcPageRequestV2(pagination);
		if (paginationForRequest) request.pagination = paginationForRequest;
		const response = await this.executeGrpcCall(request, this.client.delegatorUnbondingDelegations.bind(this.client));
		return ChainGrpcStakingTransformer.unBondingDelegationsResponseToUnBondingDelegations(response);
	}
	async fetchUnbondingDelegationsNoThrow({ injectiveAddress, pagination }) {
		const request = CosmosStakingV1Beta1QueryPb.QueryDelegatorUnbondingDelegationsRequest.create();
		request.delegatorAddr = injectiveAddress;
		const paginationForRequest = ChainGrpcCommonTransformer.pageRequestToGrpcPageRequestV2(pagination);
		if (paginationForRequest) request.pagination = paginationForRequest;
		try {
			const response = await this.executeGrpcCall(request, this.client.delegatorUnbondingDelegations.bind(this.client));
			return ChainGrpcStakingTransformer.unBondingDelegationsResponseToUnBondingDelegations(response);
		} catch (e) {
			if (e.message.includes("does not exist")) return {
				unbondingDelegations: [],
				pagination: {
					total: 0,
					next: ""
				}
			};
			throw e;
		}
	}
	async fetchReDelegations({ injectiveAddress, pagination }) {
		const request = CosmosStakingV1Beta1QueryPb.QueryRedelegationsRequest.create();
		request.delegatorAddr = injectiveAddress;
		const paginationForRequest = ChainGrpcCommonTransformer.pageRequestToGrpcPageRequestV2(pagination);
		if (paginationForRequest) request.pagination = paginationForRequest;
		const response = await this.executeGrpcCall(request, this.client.redelegations.bind(this.client));
		return ChainGrpcStakingTransformer.reDelegationsResponseToReDelegations(response);
	}
	async fetchReDelegationsNoThrow({ injectiveAddress, pagination }) {
		const request = CosmosStakingV1Beta1QueryPb.QueryRedelegationsRequest.create();
		request.delegatorAddr = injectiveAddress;
		const paginationForRequest = ChainGrpcCommonTransformer.pageRequestToGrpcPageRequestV2(pagination);
		if (paginationForRequest) request.pagination = paginationForRequest;
		try {
			const response = await this.executeGrpcCall(request, this.client.redelegations.bind(this.client));
			return ChainGrpcStakingTransformer.reDelegationsResponseToReDelegations(response);
		} catch (e) {
			if (e.message.includes("does not exist")) return {
				redelegations: [],
				pagination: {
					total: 0,
					next: ""
				}
			};
			throw e;
		}
	}
};

//#endregion
//#region src/client/chain/grpc/ChainGrpcPermissionsApi.ts
/**
* @category Chain Grpc API
*/
var ChainGrpcPermissionsApi = class extends BaseGrpcConsumer {
	constructor(..._args) {
		super(..._args);
		_defineProperty(this, "module", ChainModule.Permissions);
	}
	get client() {
		return this.initClient(QueryClient$14);
	}
	async fetchModuleParams() {
		const request = InjectivePermissionsV1Beta1QueryPb.QueryParamsRequest.create();
		const response = await this.executeGrpcCall(request, this.client.params.bind(this.client));
		return ChainGrpcPermissionsTransformer.moduleParamsResponseToModuleParams(response);
	}
	async fetchNamespaceDenoms() {
		const request = InjectivePermissionsV1Beta1QueryPb.QueryNamespaceDenomsRequest.create();
		const response = await this.executeGrpcCall(request, this.client.namespaceDenoms.bind(this.client));
		return ChainGrpcPermissionsTransformer.nameSpaceDenomsResponseToNameSpaceDenoms(response);
	}
	async fetchNamespaces() {
		const request = InjectivePermissionsV1Beta1QueryPb.QueryNamespacesRequest.create();
		const response = await this.executeGrpcCall(request, this.client.namespaces.bind(this.client));
		return ChainGrpcPermissionsTransformer.namespacesResponseToNamespaces(response);
	}
	async fetchNamespace(denom) {
		const request = InjectivePermissionsV1Beta1QueryPb.QueryNamespaceRequest.create();
		request.denom = denom;
		const response = await this.executeGrpcCall(request, this.client.namespace.bind(this.client));
		return ChainGrpcPermissionsTransformer.namespaceResponseToNamespaces(response);
	}
	async fetchActorsByRole({ denom, role }) {
		const request = InjectivePermissionsV1Beta1QueryPb.QueryActorsByRoleRequest.create();
		request.denom = denom;
		request.role = role;
		const response = await this.executeGrpcCall(request, this.client.actorsByRole.bind(this.client));
		return ChainGrpcPermissionsTransformer.actorsByRoleResponseToActorsByRole(response);
	}
	async fetchRolesByActor({ actor, denom }) {
		const request = InjectivePermissionsV1Beta1QueryPb.QueryRolesByActorRequest.create();
		request.actor = actor;
		request.denom = denom;
		const response = await this.executeGrpcCall(request, this.client.rolesByActor.bind(this.client));
		return ChainGrpcPermissionsTransformer.rolesByActorResponseToRolesByActor(response);
	}
	async fetchRoleManager({ denom, manager }) {
		const request = InjectivePermissionsV1Beta1QueryPb.QueryRoleManagerRequest.create();
		request.denom = denom;
		request.manager = manager;
		const response = await this.executeGrpcCall(request, this.client.roleManager.bind(this.client));
		return ChainGrpcPermissionsTransformer.roleManagerResponseToRoleManager(response);
	}
	async fetchRoleManagers() {
		const request = InjectivePermissionsV1Beta1QueryPb.QueryRoleManagersRequest.create();
		const response = await this.executeGrpcCall(request, this.client.roleManagers.bind(this.client));
		return ChainGrpcPermissionsTransformer.roleManagersResponseToRoleManagers(response);
	}
	async fetchPolicyStatuses() {
		const request = InjectivePermissionsV1Beta1QueryPb.QueryPolicyStatusesRequest.create();
		const response = await this.executeGrpcCall(request, this.client.policyStatuses.bind(this.client));
		return ChainGrpcPermissionsTransformer.policyStatusesResponseToPolicyStatuses(response);
	}
	async fetchPolicyManagerCapabilities(denom) {
		const request = InjectivePermissionsV1Beta1QueryPb.QueryPolicyManagerCapabilitiesRequest.create();
		request.denom = denom;
		const response = await this.executeGrpcCall(request, this.client.policyManagerCapabilities.bind(this.client));
		return ChainGrpcPermissionsTransformer.policyManagerCapabilitiesResponseToPolicyManagerCapabilities(response);
	}
	async fetchVoucher({ denom, address }) {
		const request = InjectivePermissionsV1Beta1QueryPb.QueryVoucherRequest.create();
		request.denom = denom;
		request.address = address;
		const response = await this.executeGrpcCall(request, this.client.voucher.bind(this.client));
		return ChainGrpcPermissionsTransformer.voucherResponseToVoucher(response);
	}
	async fetchVouchers(denom) {
		const request = InjectivePermissionsV1Beta1QueryPb.QueryVouchersRequest.create();
		request.denom = denom;
		const response = await this.executeGrpcCall(request, this.client.vouchers.bind(this.client));
		return ChainGrpcPermissionsTransformer.vouchersResponseToVouchers(response);
	}
	async fetchModuleState() {
		const request = InjectivePermissionsV1Beta1QueryPb.QueryModuleStateRequest.create();
		const response = await this.executeGrpcCall(request, this.client.permissionsModuleState.bind(this.client));
		return ChainGrpcPermissionsTransformer.moduleStateResponseToModuleState(response);
	}
};

//#endregion
//#region src/client/chain/grpc/ChainGrpcDistributionApi.ts
/**
* @category Chain Grpc API
*/
var ChainGrpcDistributionApi = class extends BaseGrpcConsumer {
	constructor(..._args) {
		super(..._args);
		_defineProperty(this, "module", ChainModule.Distribution);
	}
	get client() {
		return this.initClient(QueryClient$15);
	}
	async fetchModuleParams() {
		const request = CosmosDistributionV1Beta1QueryPb.QueryParamsRequest.create();
		const response = await this.executeGrpcCall(request, this.client.params.bind(this.client));
		return ChainGrpcDistributionTransformer.moduleParamsResponseToModuleParams(response);
	}
	async fetchDelegatorRewardsForValidator({ delegatorAddress, validatorAddress }) {
		const request = CosmosDistributionV1Beta1QueryPb.QueryDelegationRewardsRequest.create();
		request.validatorAddress = validatorAddress;
		request.delegatorAddress = delegatorAddress;
		const response = await this.executeGrpcCall(request, this.client.delegationRewards.bind(this.client));
		return ChainGrpcDistributionTransformer.delegationRewardResponseToReward(response);
	}
	async fetchDelegatorRewardsForValidatorNoThrow({ delegatorAddress, validatorAddress }) {
		const request = CosmosDistributionV1Beta1QueryPb.QueryDelegationRewardsRequest.create();
		request.validatorAddress = validatorAddress;
		request.delegatorAddress = delegatorAddress;
		try {
			const response = await this.executeGrpcCall(request, this.client.delegationRewards.bind(this.client));
			return ChainGrpcDistributionTransformer.delegationRewardResponseToReward(response);
		} catch (e) {
			if (e.message.includes("does not exist") || e.message.includes("no delegation for (address, validator) tuple")) return [];
			throw e;
		}
	}
	async fetchDelegatorRewards(injectiveAddress) {
		const request = CosmosDistributionV1Beta1QueryPb.QueryDelegationTotalRewardsRequest.create();
		request.delegatorAddress = injectiveAddress;
		const response = await this.executeGrpcCall(request, this.client.delegationTotalRewards.bind(this.client));
		return ChainGrpcDistributionTransformer.totalDelegationRewardResponseToTotalReward(response);
	}
	async fetchDelegatorRewardsNoThrow(injectiveAddress) {
		const request = CosmosDistributionV1Beta1QueryPb.QueryDelegationTotalRewardsRequest.create();
		request.delegatorAddress = injectiveAddress;
		try {
			const response = await this.executeGrpcCall(request, this.client.delegationTotalRewards.bind(this.client));
			return ChainGrpcDistributionTransformer.totalDelegationRewardResponseToTotalReward(response);
		} catch (e) {
			if (e.message.includes("does not exist")) return [];
			throw e;
		}
	}
};

//#endregion
//#region src/client/chain/grpc/ChainGrpcTokenFactoryApi.ts
/**
* @category TokenFactory Grpc API
*/
var ChainGrpcTokenFactoryApi = class extends BaseGrpcConsumer {
	constructor(..._args) {
		super(..._args);
		_defineProperty(this, "module", ChainModule.WasmX);
	}
	get client() {
		return this.initClient(QueryClient$16);
	}
	async fetchDenomsFromCreator(creator) {
		const request = InjectiveTokenFactoryV1Beta1QueryPb.QueryDenomsFromCreatorRequest.create();
		request.creator = creator;
		const response = await this.executeGrpcCall(request, this.client.denomsFromCreator.bind(this.client));
		return ChainGrpcTokenFactoryTransformer.denomsCreatorResponseToDenomsString(response);
	}
	async fetchDenomAuthorityMetadata(creator, subDenom) {
		const request = InjectiveTokenFactoryV1Beta1QueryPb.QueryDenomAuthorityMetadataRequest.create();
		request.creator = creator;
		request.subDenom = subDenom;
		const response = await this.executeGrpcCall(request, this.client.denomAuthorityMetadata.bind(this.client));
		return ChainGrpcTokenFactoryTransformer.authorityMetadataResponseToAuthorityMetadata(response);
	}
	async fetchModuleParams() {
		const request = InjectiveTokenFactoryV1Beta1QueryPb.QueryParamsRequest.create();
		const response = await this.executeGrpcCall(request, this.client.params.bind(this.client));
		return ChainGrpcTokenFactoryTransformer.moduleParamsResponseToModuleParams(response);
	}
	async fetchModuleState() {
		const request = InjectiveTokenFactoryV1Beta1QueryPb.QueryModuleStateRequest.create();
		const response = await this.executeGrpcCall(request, this.client.tokenfactoryModuleState.bind(this.client));
		return ChainGrpcTokenFactoryTransformer.moduleStateResponseToModuleState(response);
	}
};

//#endregion
//#region src/client/chain/grpc/ChainGrpcInsuranceFundApi.ts
/**
* @category Chain Grpc API
*/
var ChainGrpcInsuranceFundApi = class extends BaseGrpcConsumer {
	constructor(..._args) {
		super(..._args);
		_defineProperty(this, "module", ChainModule.InsuranceFund);
	}
	get client() {
		return this.initClient(QueryClient$17);
	}
	async fetchModuleParams() {
		const request = InjectiveInsuranceV1Beta1QueryPb.QueryInsuranceParamsRequest.create();
		const response = await this.executeGrpcCall(request, this.client.insuranceParams.bind(this.client));
		return ChainGrpcInsuranceFundTransformer.moduleParamsResponseToModuleParams(response);
	}
	async fetchInsuranceFunds() {
		const request = InjectiveInsuranceV1Beta1QueryPb.QueryInsuranceFundsRequest.create();
		const response = await this.executeGrpcCall(request, this.client.insuranceFunds.bind(this.client));
		return ChainGrpcInsuranceFundTransformer.insuranceFundsResponseToInsuranceFunds(response);
	}
	async fetchInsuranceFund(marketId) {
		const request = InjectiveInsuranceV1Beta1QueryPb.QueryInsuranceFundRequest.create();
		request.marketId = marketId;
		const response = await this.executeGrpcCall(request, this.client.insuranceFund.bind(this.client));
		return ChainGrpcInsuranceFundTransformer.insuranceFundResponseToInsuranceFund(response);
	}
	async fetchEstimatedRedemptions({ marketId, address }) {
		const request = InjectiveInsuranceV1Beta1QueryPb.QueryEstimatedRedemptionsRequest.create();
		request.marketId = marketId;
		request.address = address;
		const response = await this.executeGrpcCall(request, this.client.estimatedRedemptions.bind(this.client));
		return ChainGrpcInsuranceFundTransformer.estimatedRedemptionsResponseToEstimatedRedemptions(response);
	}
	async fetchPendingRedemptions({ marketId, address }) {
		const request = InjectiveInsuranceV1Beta1QueryPb.QueryPendingRedemptionsRequest.create();
		request.marketId = marketId;
		request.address = address;
		const response = await this.executeGrpcCall(request, this.client.pendingRedemptions.bind(this.client));
		return ChainGrpcInsuranceFundTransformer.redemptionsResponseToRedemptions(response);
	}
};

//#endregion
//#region src/client/chain/rest/ChainRestBankApi.ts
/**
* @category Chain Rest API
*/
var ChainRestBankApi = class extends BaseRestConsumer {
	/**
	* Get address's balance
	*
	* @param address address of account to look up
	*/
	async fetchBalances(address, params = {}) {
		const endpoint = `cosmos/bank/v1beta1/balances/${address}`;
		try {
			return (await this.retry(() => this.get(endpoint, params))).data;
		} catch (e) {
			if (e instanceof HttpRequestException) throw e;
			throw new HttpRequestException(new Error(e), {
				code: UnspecifiedErrorCode,
				context: `${this.endpoint}/${endpoint}`,
				contextModule: ChainModule.Bank
			});
		}
	}
	/**
	* Get address's balances
	*
	* @param address address of account to look up
	*/
	async fetchBalance(address, denom, params = {}) {
		const endpoint = `cosmos/bank/v1beta1/balances/${address}`;
		try {
			const balance = (await this.retry(() => this.get(endpoint, params))).data.balances.find((balance$1) => balance$1.denom === denom);
			if (!balance) throw new GeneralException(/* @__PURE__ */ new Error(`The ${denom} balance was not found`), {
				code: StatusCodes.NOT_FOUND,
				type: ErrorType.NotFoundError
			});
			return balance;
		} catch (e) {
			if (e instanceof HttpRequestException) throw e;
			if (e instanceof GeneralException) throw e;
			throw new HttpRequestException(new Error(e), {
				code: UnspecifiedErrorCode,
				context: `${this.endpoint}/${endpoint}`,
				contextModule: ChainModule.Bank
			});
		}
	}
	async fetchDenomOwners(denom, params = {}) {
		const endpoint = `cosmos/bank/v1beta1/denom_owners/${denom}`;
		try {
			return (await this.retry(() => this.get(endpoint, params))).data.denom_owners;
		} catch (e) {
			if (e instanceof HttpRequestException) throw e;
			if (e instanceof GeneralException) throw e;
			throw new HttpRequestException(new Error(e), {
				code: UnspecifiedErrorCode,
				context: `${this.endpoint}/${endpoint}`,
				contextModule: ChainModule.Bank
			});
		}
	}
};

//#endregion
//#region src/client/chain/rest/ChainRestWasmApi.ts
/**
* @category Chain Wasm API
*/
var ChainRestWasmApi = class extends BaseRestConsumer {
	async fetchSmartContractState(contractAddress, query, params = {}) {
		const endpoint = `cosmwasm/wasm/v1/contract/${contractAddress}/smart/${query}`;
		try {
			return (await this.retry(() => this.get(endpoint, params))).data;
		} catch (e) {
			if (e instanceof HttpRequestException) throw e;
			throw new HttpRequestException(new Error(e), {
				code: UnspecifiedErrorCode,
				context: `${this.endpoint}/${endpoint}`,
				contextModule: ChainModule.Bank
			});
		}
	}
};

//#endregion
export { ChainGrpcAuthZTransformer as A, ChainGrpcDistributionTransformer as C, ChainGrpcTxFeesTransformer as D, ChainGrpcAuctionTransformer as E, ChainGrpcGovTransformer as F, ChainGrpcMintTransformer as M, ChainGrpcBankTransformer as N, ChainGrpcErc20Transformer as O, ChainGrpcEvmTransformer as P, ChainGrpcTokenFactoryTransformer as S, ChainGrpcStakingTransformer as T, ChainGrpcBankApi as _, ChainGrpcDistributionApi as a, ChainGrpcGovApi as b, ChainGrpcAuctionApi as c, ChainGrpcErc20Api as d, ChainGrpcWasmXApi as f, ChainGrpcMintApi as g, ChainGrpcWasmApi as h, ChainGrpcTokenFactoryApi as i, ChainGrpcWasmTransformer as j, ChainGrpcPeggyTransformer as k, ChainGrpcTxFeesApi as l, ChainGrpcAuthZApi as m, ChainRestBankApi as n, ChainGrpcPermissionsApi as o, ChainGrpcPeggyApi as p, ChainGrpcInsuranceFundApi as r, ChainGrpcStakingApi as s, ChainRestWasmApi as t, ChainGrpcOracleApi as u, ChainGrpcEvmApi as v, ChainGrpcPermissionsTransformer as w, ChainGrpcInsuranceFundTransformer as x, ChainGrpcIbcApi as y };