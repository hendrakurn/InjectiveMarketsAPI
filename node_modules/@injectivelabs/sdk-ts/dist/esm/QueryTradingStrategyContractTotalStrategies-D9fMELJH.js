import { Ut as fromBase64, Vt as binaryToBase64, Xt as toUtf8, Yt as toBase64 } from "./utils-CewUFGKA.js";
import { t as _defineProperty } from "./defineProperty-Bq6QU9Te.js";
import { h as ChainGrpcWasmApi } from "./chain-CQczt2h3.js";
import { n as MsgExecuteContractCompat, r as ExecArgNeptuneDeposit, t as ExecArgNeptuneWithdraw } from "./ExecArgNeptuneWithdraw-BRJZq8Vb.js";
import { GeneralException } from "@injectivelabs/exceptions";
import { Network, getNetworkEndpoints, isMainnet } from "@injectivelabs/networks";

//#region src/client/wasm/swap/transformer.ts
var SwapQueryTransformer = class {
	static contractRouteResponseToContractRoute(response) {
		const data = JSON.parse(toUtf8(response.data));
		return {
			steps: data.steps,
			sourceDenom: data.source_denom,
			targetDenom: data.target_denom
		};
	}
	static contractAllRoutesResponseToContractAllRoutes(response) {
		return JSON.parse(toUtf8(response.data)).map((route) => ({
			steps: route.steps,
			sourceDenom: route.source_denom,
			targetDenom: route.target_denom
		}));
	}
	static contractQuantityResponseToContractQuantity(response) {
		const data = JSON.parse(toUtf8(response.data));
		return {
			expectedFees: data.expected_fees,
			resultQuantity: data.result_quantity
		};
	}
};

//#endregion
//#region src/client/wasm/BaseWasmQuery.ts
var BaseWasmQuery = class {
	constructor(params) {
		_defineProperty(this, "params", void 0);
		this.params = params;
	}
};

//#endregion
//#region src/client/wasm/swap/queries/QueryRoute.ts
var QueryRoute = class extends BaseWasmQuery {
	toPayload() {
		return toBase64({ get_route: {
			source_denom: this.params.sourceDenom,
			target_denom: this.params.targetDenom
		} });
	}
};

//#endregion
//#region src/client/wasm/swap/queries/QueryAllRoutes.ts
var QueryAllRoutes = class extends BaseWasmQuery {
	toPayload() {
		return toBase64({ get_all_routes: {} });
	}
};

//#endregion
//#region src/client/wasm/swap/queries/QueryInputQuantity.ts
var QueryInputQuantity = class extends BaseWasmQuery {
	toPayload() {
		return toBase64({ get_input_quantity: {
			to_quantity: this.params.toQuantity,
			source_denom: this.params.sourceDenom,
			target_denom: this.params.targetDenom
		} });
	}
};

//#endregion
//#region src/client/wasm/swap/queries/QueryOutputQuantity.ts
var QueryOutputQuantity = class extends BaseWasmQuery {
	toPayload() {
		return toBase64({ get_output_quantity: {
			from_quantity: this.params.fromQuantity,
			source_denom: this.params.sourceDenom,
			target_denom: this.params.targetDenom
		} });
	}
};

//#endregion
//#region src/client/wasm/neptune/types.ts
const NEPTUNE_USDT_CW20_CONTRACT = "inj1cy9hes20vww2yr6crvs75gxy5hpycya2hmjg9s";

//#endregion
//#region src/client/wasm/neptune/helper.ts
function getDenom(assetInfo) {
	if ("native_token" in assetInfo) return assetInfo.native_token.denom;
	return assetInfo.token.contract_addr;
}

//#endregion
//#region src/client/wasm/neptune/transformer.ts
var NeptuneQueryTransformer = class {
	static contractPricesResponseToPrices(response) {
		return JSON.parse(toUtf8(response.data)).map(([assetInfo, priceInfo]) => ({
			assetInfo,
			price: priceInfo.price
		}));
	}
	static contractLendingRatesResponseToLendingRates(response) {
		return JSON.parse(toUtf8(response.data)).map(([assetInfo, lendingRate]) => ({
			assetInfo,
			lendingRate
		}));
	}
};

//#endregion
//#region src/client/wasm/neptune/queries/QueryGetPrices.ts
var QueryGetPrices = class extends BaseWasmQuery {
	toPayload() {
		return toBase64({ get_prices: { assets: this.params.assets } });
	}
};

//#endregion
//#region src/client/wasm/neptune/queries/QueryLendingRates.ts
var QueryGetAllLendingRates = class extends BaseWasmQuery {
	toPayload() {
		return toBase64({ get_all_lending_rates: {
			...this.params.limit !== void 0 ? { limit: this.params.limit } : {},
			...this.params.startAfter ? { start_after: this.params.startAfter } : {}
		} });
	}
};

//#endregion
//#region src/client/wasm/neptune/service.ts
const NEPTUNE_USDT_MARKET_CONTRACT = "inj1nc7gjkf2mhp34a6gquhurg8qahnw5kxs5u3s4u";
const NEPTUNE_INTEREST_CONTRACT = "inj1ftech0pdjrjawltgejlmpx57cyhsz6frdx2dhq";
var NeptuneService = class {
	/**
	* Constructs a new NeptuneService instan ce.
	* @param network The network to use (default: Mainnet).
	* @param endpoints Optional custom network endpoints.
	*/
	constructor(network = Network.MainnetSentry, endpoints, options) {
		_defineProperty(this, "client", void 0);
		_defineProperty(this, "priceOracleContract", void 0);
		if (!isMainnet(network)) throw new GeneralException(/* @__PURE__ */ new Error("Please switch to mainnet network"));
		this.client = new ChainGrpcWasmApi((endpoints || getNetworkEndpoints(network)).grpc, options);
		this.priceOracleContract = NEPTUNE_PRICE_CONTRACT;
	}
	/**
	* Fetch prices for given assets from the Neptune Price Oracle contract.
	* @param assets Array of AssetInfo objects.
	* @returns Array of Price objects.
	*/
	async fetchPrices(assets) {
		const queryGetPricesPayload = new QueryGetPrices({ assets }).toPayload();
		try {
			const response = await this.client.fetchSmartContractState(this.priceOracleContract, queryGetPricesPayload);
			return NeptuneQueryTransformer.contractPricesResponseToPrices(response);
		} catch (error) {
			console.error("Error fetching prices:", error);
			throw new GeneralException(/* @__PURE__ */ new Error("Failed to fetch prices"));
		}
	}
	/**
	* Fetch the redemption ratio based on CW20 and native asset prices.
	* @param cw20Asset AssetInfo for the CW20 token.
	* @param nativeAsset AssetInfo for the native token.
	* @returns Redemption ratio as a number.
	*/
	async fetchRedemptionRatio({ cw20Asset, nativeAsset }) {
		const prices = await this.fetchPrices([cw20Asset, nativeAsset]);
		const [cw20Price] = prices;
		const [nativePrice] = prices.reverse();
		if (!cw20Price || !nativePrice) throw new GeneralException(/* @__PURE__ */ new Error("Failed to compute redemption ratio"));
		return Number(cw20Price.price) / Number(nativePrice.price);
	}
	/**
	* Convert CW20 nUSDT to bank nUSDT using the redemption ratio.
	* @param amountCW20 Amount in CW20 nUSDT.
	* @param redemptionRatio Redemption ratio.
	* @returns Amount in bank nUSDT.
	*/
	calculateBankAmount(amountCW20, redemptionRatio) {
		return amountCW20 * redemptionRatio;
	}
	/**
	* Convert bank nUSDT to CW20 nUSDT using the redemption ratio.
	* @param amountBank Amount in bank nUSDT.
	* @param redemptionRatio Redemption ratio.
	* @returns Amount in CW20 nUSDT.
	*/
	calculateCw20Amount(amountBank, redemptionRatio) {
		return amountBank / redemptionRatio;
	}
	/**
	* Create a deposit message.
	* @param sender Sender's Injective address.
	* @param contractAddress USDT market contract address.
	* @param denom Denomination of the asset.
	* @param amount Amount to deposit as a string.
	* @returns MsgExecuteContractCompat message.
	*/
	createDepositMsg({ denom, amount, sender, contractAddress = NEPTUNE_USDT_MARKET_CONTRACT }) {
		return MsgExecuteContractCompat.fromJSON({
			sender,
			contractAddress,
			execArgs: ExecArgNeptuneDeposit.fromJSON({}),
			funds: {
				denom,
				amount
			}
		});
	}
	/**
	* Create a withdraw message.
	* @param sender Sender's Injective address.
	* @param contractAddress nUSDT contract address.
	* @param amount Amount to withdraw as a string.
	* @returns MsgExecuteContractCompat message.
	*/
	createWithdrawMsg({ amount, sender, cw20ContractAddress = NEPTUNE_USDT_CW20_CONTRACT, marketContractAddress = NEPTUNE_USDT_MARKET_CONTRACT }) {
		return MsgExecuteContractCompat.fromJSON({
			sender,
			contractAddress: cw20ContractAddress,
			execArgs: ExecArgNeptuneWithdraw.fromJSON({
				amount,
				contract: marketContractAddress
			})
		});
	}
	/**
	* Fetch lending rates with optional pagination parameters.
	* @param limit Maximum number of lending rates to fetch.
	* @param startAfter AssetInfo to start after for pagination.
	* @returns Array of [AssetInfo, Decimal256] tuples.
	*/
	async getLendingRates({ limit, startAfter, contractAddress = NEPTUNE_INTEREST_CONTRACT }) {
		const payload = new QueryGetAllLendingRates({
			limit,
			startAfter
		}).toPayload();
		try {
			const response = await this.client.fetchSmartContractState(contractAddress, payload);
			return NeptuneQueryTransformer.contractLendingRatesResponseToLendingRates(response);
		} catch (_unused) {
			throw new GeneralException(/* @__PURE__ */ new Error("Failed to fetch lending rates"));
		}
	}
	/**
	* Fetch the lending rate for a specific denom by querying the smart contract with pagination.
	* @param denom The denomination string of the asset to find the lending rate for.
	* @returns Lending rate as a string.
	*/
	async getLendingRateByDenom({ denom, contractAddress = NEPTUNE_INTEREST_CONTRACT }) {
		const limit = 10;
		let startAfter = void 0;
		while (true) {
			const lendingRates = await this.getLendingRates({
				limit,
				startAfter,
				contractAddress
			});
			if (lendingRates.length === 0) return;
			for (const { assetInfo, lendingRate } of lendingRates) if (getDenom(assetInfo) === denom) return lendingRate;
			if (lendingRates.length < limit) return;
			startAfter = lendingRates[lendingRates.length - 1].assetInfo;
		}
	}
	/**
	* Calculates APY from APR and compounding frequency.
	*
	* @param apr - The annual percentage rate as a decimal (e.g., 0.10 for 10%)
	* @param compoundingFrequency - Number of times interest is compounded per year
	* @returns The annual percentage yield as a decimal
	*/
	calculateAPY(apr) {
		return Math.exp(apr) - 1;
	}
};

//#endregion
//#region src/client/wasm/neptune/index.ts
const NEPTUNE_PRICE_CONTRACT = "inj1u6cclz0qh5tep9m2qayry9k97dm46pnlqf8nre";

//#endregion
//#region src/client/wasm/incentives/transformer.ts
var IncentivesQueryTransformer = class {
	static contractRoundResponseToContractRound(response) {
		return JSON.parse(toUtf8(response.data)).map((round) => ({
			id: round.id,
			name: round.name,
			endDate: round.end_date,
			campaigns: round.campaigns,
			startDate: round.start_date
		}));
	}
	static contractCampaignResponseToContractCampaign(response) {
		return JSON.parse(toUtf8(response.data)).map((campaign) => ({
			id: campaign.id,
			name: campaign.name,
			rewards: campaign.rewards,
			inRound: campaign.in_round,
			marketId: campaign.market_id,
			isFunded: campaign.is_funded,
			description: campaign.description,
			isFinalized: campaign.is_finalized,
			totalRewards: campaign.total_rewards,
			subaccountIdSuffix: campaign.subaccount_id_suffix
		}));
	}
};

//#endregion
//#region src/client/wasm/incentives/queries/QueryAllRounds.ts
var QueryAllRounds = class extends BaseWasmQuery {
	toPayload() {
		return toBase64({ all_rounds: {
			...this.params.limit ? { limit: this.params.limit } : {},
			...this.params.startAfter ? { start_after: this.params.startAfter } : {}
		} });
	}
};

//#endregion
//#region src/client/wasm/incentives/queries/QueryGetCampaigns.ts
var QueryGetCampaigns = class extends BaseWasmQuery {
	toPayload() {
		return toBase64({ get_campaigns: { campaigns: this.params.campaigns } });
	}
};

//#endregion
//#region src/client/wasm/nameservice/transformer.ts
var InjNameServiceQueryTransformer = class {
	static resolverAddressResponseToResolverAddress(response) {
		return fromBase64(binaryToBase64(response.data)).resolver || "";
	}
	static injectiveAddressResponseToInjectiveAddress(response) {
		return fromBase64(binaryToBase64(response.data)).address || "";
	}
	static injectiveNameResponseToInjectiveName(response) {
		return fromBase64(binaryToBase64(response.data)).name || "";
	}
};

//#endregion
//#region src/client/wasm/nameservice/queries/QueryInjName.ts
var QueryInjName = class extends BaseWasmQuery {
	toPayload() {
		return toBase64({ name: { address: this.params.address } });
	}
};

//#endregion
//#region src/client/wasm/nameservice/queries/QueryResolverAddress.ts
var QueryResolverAddress = class extends BaseWasmQuery {
	toPayload() {
		return toBase64({ resolver: { node: this.params.node } });
	}
};

//#endregion
//#region src/client/wasm/nameservice/queries/QueryInjectiveAddress.ts
var QueryInjectiveAddress = class extends BaseWasmQuery {
	toPayload() {
		return toBase64({ address: { node: this.params.node } });
	}
};

//#endregion
//#region src/client/wasm/trading_strategies/queries/QueryTradingStrategyContractConfig.ts
var QueryTradingStrategyContractConfig = class extends BaseWasmQuery {
	toPayload() {
		return toBase64({ config: {} });
	}
};

//#endregion
//#region src/client/wasm/trading_strategies/queries/QueryTradingStrategyContractAllStrategies.ts
var QueryTradingStrategyContractAllStrategies = class extends BaseWasmQuery {
	toPayload() {
		return toBase64({ all_strategies: {
			start_after: this.params.startAfter,
			limit: this.params.limit
		} });
	}
};

//#endregion
//#region src/client/wasm/trading_strategies/queries/QueryTradingStrategyContractUserStrategies.ts
var QueryTradingStrategyContractUserStrategies = class extends BaseWasmQuery {
	toPayload() {
		return toBase64({ user_strategy: { user: this.params.user } });
	}
};

//#endregion
//#region src/client/wasm/trading_strategies/queries/QueryTradingStrategyContractTotalStrategies.ts
var QueryTradingStrategyContractTotalStrategies = class extends BaseWasmQuery {
	toPayload() {
		return toBase64({ total_strategies: {} });
	}
};

//#endregion
export { SwapQueryTransformer as S, NEPTUNE_USDT_CW20_CONTRACT as _, QueryInjectiveAddress as a, QueryAllRoutes as b, InjNameServiceQueryTransformer as c, IncentivesQueryTransformer as d, NEPTUNE_PRICE_CONTRACT as f, NeptuneQueryTransformer as g, QueryGetPrices as h, QueryTradingStrategyContractConfig as i, QueryGetCampaigns as l, QueryGetAllLendingRates as m, QueryTradingStrategyContractUserStrategies as n, QueryResolverAddress as o, NeptuneService as p, QueryTradingStrategyContractAllStrategies as r, QueryInjName as s, QueryTradingStrategyContractTotalStrategies as t, QueryAllRounds as u, QueryOutputQuantity as v, QueryRoute as x, QueryInputQuantity as y };