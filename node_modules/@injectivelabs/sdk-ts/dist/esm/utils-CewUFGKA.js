import { bytesToHex, hashTypedData, hexToBytes, keccak256, recoverPublicKey, toBytes } from "viem";
import { BigNumber, DEFAULT_EXCHANGE_LIMIT, DEFAULT_GAS_LIMIT, DEFAULT_IBC_GAS_LIMIT, DEFAULT_TIMESTAMP_TIMEOUT_MS, getExactDecimalsFromNumber, getSignificantDecimalsFromNumber, toBigNumber, toChainFormat, toHumanReadable } from "@injectivelabs/utils";
import { base64, bech32 } from "@scure/base";
import { secp256k1 } from "@noble/curves/secp256k1";
import { sha256 } from "@noble/hashes/sha2";
import { ripemd160 } from "@noble/hashes/legacy";
import * as CosmosBaseQueryV1Beta1PaginationPb from "@injectivelabs/core-proto-ts-v2/generated/cosmos/base/query/v1beta1/pagination_pb";

//#region src/utils/helpers.ts
const isServerSide = () => typeof window === "undefined";
const isReactNative = () => {
	return typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative";
};
const isNode = () => {
	if (typeof window === "undefined") return true;
	return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
};
const isBrowser = () => {
	if (isReactNative()) return false;
	if (isNode()) return false;
	return typeof window !== "undefined";
};
const objectToJson = (object, params) => {
	const { replacer, indentation } = params || {
		replacer: void 0,
		indentation: 2
	};
	return safeBigIntStringify(object, replacer, indentation);
};
const protoObjectToJson = (object, params) => {
	const { replacer, indentation } = params || {
		replacer: void 0,
		indentation: 2
	};
	if (object.toObject !== void 0) return safeBigIntStringify(object.toObject(), replacer, indentation);
	return objectToJson(object, {
		replacer,
		indentation
	});
};
const grpcCoinToUiCoin = (coin) => ({
	amount: coin.amount,
	denom: coin.denom
});
const sortObjectByKeysWithReduce = (obj) => {
	if (typeof obj !== "object" || obj === null) return obj;
	if (Array.isArray(obj)) return obj.map((e) => sortObjectByKeysWithReduce(e)).sort();
	return Object.keys(obj).sort().reduce((sorted, k) => {
		const key = k;
		sorted[key] = sortObjectByKeysWithReduce(obj[key]);
		return sorted;
	}, {});
};
const sortObjectByKeys = (obj) => {
	if (typeof obj !== "object" || obj === null) return obj;
	if (Array.isArray(obj)) return obj.map(sortObjectByKeys);
	const sortedKeys = Object.keys(obj).sort();
	const result = {};
	sortedKeys.forEach((key) => {
		result[key] = sortObjectByKeys(obj[key]);
	});
	return result;
};
const getErrorMessage = (error, endpoint) => {
	if (!error.response) return `The request to ${endpoint} has failed.`;
	return error.response.data ? error.response.data.message || error.response.data : error.response.statusText;
};
/**
* Converts value to it's number representation
*/
const hexToNumber = (value) => {
	const [negative, hexValue] = value.startsWith("-") ? [true, value.slice(1)] : [false, value];
	const num = BigInt(hexValue);
	if (num > Number.MAX_SAFE_INTEGER) return Number(negative ? -num : num);
	if (num < Number.MIN_SAFE_INTEGER) return Number(num);
	return negative ? -1 * Number(num) : Number(num);
};
function isJsonString(str) {
	if (typeof str !== "string") return false;
	try {
		JSON.parse(str);
	} catch (_unused) {
		return false;
	}
	return true;
}
/**
* BigInt-safe JSON replacer function.
* Converts BigInt values to strings during JSON serialization.
*/
const bigIntReplacer = (_key, value) => typeof value === "bigint" ? bigIntToString(value) : value;
/**
* Converts a potentially bigint value to a number.
* Handles bigint, string, and other number-like types.
* Returns 0 for null/undefined values.
*/
const bigIntToNumber = (value) => {
	if (value === null || value === void 0) return 0;
	if (typeof value === "bigint") return Number(value);
	if (typeof value === "string") return parseInt(value || "0", 10);
	if (typeof value === "number") return value;
	return parseInt(String(value || "0"), 10);
};
/**
* Converts a potentially bigint value to a string.
* Handles bigint, string, and other types that can be converted to string.
* Returns empty string for null/undefined values.
*/
const bigIntToString = (value) => {
	if (value === null || value === void 0) return "";
	if (typeof value === "bigint") return value.toString();
	if (typeof value === "string") return value;
	if (typeof value === "number") return value.toString();
	return String(value || "");
};
/**
* Stringify an object to JSON with BigInt support.
* Converts BigInt values to strings during serialization to prevent
* "Do not know how to serialize a BigInt" errors.
*
* @param value - The value to serialize
* @param replacer - Optional custom replacer function (BigInt handling is applied first)
* @param space - Optional indentation for pretty printing
* @returns JSON string
*/
const safeBigIntStringify = (value, replacer, space) => {
	const combinedReplacer = (key, val) => {
		const bigIntHandled = bigIntReplacer(key, val);
		return replacer ? replacer(key, bigIntHandled) : bigIntHandled;
	};
	return JSON.stringify(value, combinedReplacer, space);
};

//#endregion
//#region src/utils/encoding.ts
/**
* Encoding/decoding utilities using industry-standard libraries
*
* Uses viem for hex encoding and @scure/base for base64 encoding
* to ensure compatibility, better performance, and reduce bundle size.
*
* These libraries are already dependencies in the project and are
* battle-tested by millions of developers.
*/
/**
* Convert a hex string to Uint8Array
* @param hex - Hex string (with or without 0x prefix)
* @returns Uint8Array
* @throws Error if hex string is invalid
*/
function hexToUint8Array(hex) {
	if (typeof hex !== "string") throw new Error("Hex string must be a string");
	if (hex.trim() === "") throw new Error("Hex string cannot be empty");
	const prefixedHex = hex.startsWith("0x") ? hex : `0x${hex}`;
	try {
		return hexToBytes(prefixedHex);
	} catch (_unused) {
		throw new Error(`Invalid hex string: ${hex}`);
	}
}
/**
* Convert a Uint8Array to hex string
* @param arr - Uint8Array to convert
* @returns Hex string (without 0x prefix)
*/
function uint8ArrayToHex(arr) {
	return bytesToHex(arr).slice(2);
}
/**
* Convert a base64 string to Uint8Array
* @param base64String - Base64 encoded string
* @returns Uint8Array
* @throws Error if base64 string is invalid
*/
function base64ToUint8Array(base64String) {
	if (typeof base64String !== "string") throw new Error("Base64 string must be a string");
	if (base64String.trim() === "") throw new Error("Base64 string cannot be empty");
	try {
		return base64.decode(base64String);
	} catch (_unused2) {
		throw new Error(`Invalid base64 string: ${base64String}`);
	}
}
/**
* Convert a Uint8Array to base64 string
* @param arr - Uint8Array to convert
* @returns Base64 encoded string
*/
function uint8ArrayToBase64(arr) {
	return base64.encode(arr);
}
/**
* Convert a string to Uint8Array using UTF-8 encoding
* @param str - String to encode
* @returns Uint8Array
*/
function stringToUint8Array(str) {
	return new TextEncoder().encode(str);
}
/**
* Convert a hex string to Uint8Array (buffer-like)
* Handles hex strings with or without 0x prefix
* @param hex - Hex string (with or without 0x prefix)
* @returns Uint8Array
*/
function hexToBuff(hex) {
	return hexToUint8Array(hex.startsWith("0x") ? hex.slice(2) : hex);
}
/**
* Convert a hex string to base64 string
* Handles hex strings with or without 0x prefix
* @param hex - Hex string (with or without 0x prefix)
* @returns Base64 encoded string
*/
function hexToBase64(hex) {
	return uint8ArrayToBase64(hexToUint8Array(hex.startsWith("0x") ? hex.slice(2) : hex));
}
/**
* Convert a base64 string to UTF-8 string
* @param base64String - Base64 encoded string
* @returns Decoded UTF-8 string
* @throws Error if base64 string is invalid
*/
function base64ToUtf8(base64String) {
	return toUtf8(base64ToUint8Array(base64String));
}
/**
* Convert a string or Uint8Array to Uint8Array using UTF-8 encoding
* If input is already Uint8Array, returns it as-is
* @param str - String or Uint8Array to encode
* @returns Uint8Array
*/
function fromUtf8(str) {
	if (typeof str !== "string") return str;
	return stringToUint8Array(str);
}
/**
* Convert a Uint8Array or string to string using UTF-8 decoding
* If input is already a string, returns it as-is
* @param data - Uint8Array or string to decode
* @returns Decoded string
*/
function toUtf8(data) {
	if (typeof data === "string") return data;
	return new TextDecoder().decode(data);
}
/**
* Convert a Uint8Array, string, null, or undefined to string using UTF-8 decoding
* More robust version that handles null/undefined gracefully
* @param string - Uint8Array, string, null, or undefined to decode
* @returns Decoded string (empty string if input is null/undefined)
*/
function uint8ArrayToString(string) {
	if (!string) return "";
	if (string.constructor !== Uint8Array) return string;
	return new TextDecoder().decode(string);
}
/**
* Convert binary data (string or Uint8Array) to base64 string
* If input is already a string, returns it as-is
* @param data - String or Uint8Array to encode
* @returns Base64 encoded string
*/
function binaryToBase64(data) {
	return typeof data === "string" ? data : uint8ArrayToBase64(data);
}
/**
* Convert a JSON object to base64 string
* @param data - JSON object to encode
* @returns Base64 encoded string
*/
function toBase64(data) {
	return uint8ArrayToBase64(stringToUint8Array(safeBigIntStringify(data)));
}
/**
* Convert a base64 string to JSON object
* @param payload - Base64 encoded string
* @returns Decoded JSON object
* @throws Error if base64 string is invalid or contains invalid JSON
*/
function fromBase64(payload) {
	if (typeof payload !== "string") throw new Error("Base64 payload must be a string");
	if (payload.trim() === "") throw new Error("Base64 payload cannot be empty");
	try {
		const decoded = new TextDecoder().decode(base64ToUint8Array(payload));
		return JSON.parse(decoded);
	} catch (_unused3) {
		throw new Error(`Failed to decode base64 JSON: ${payload}`);
	}
}
/**
* Concatenate multiple Uint8Arrays into a single Uint8Array
* Replacement for Buffer.concat()
* @param arrays - Array of Uint8Arrays to concatenate
* @returns Concatenated Uint8Array
*/
function concatUint8Arrays(arrays) {
	if (arrays.length === 0) return new Uint8Array(0);
	const totalLength = arrays.reduce((sum, arr) => sum + arr.length, 0);
	const result = new Uint8Array(totalLength);
	let offset = 0;
	for (const arr of arrays) {
		result.set(arr, offset);
		offset += arr.length;
	}
	return result;
}

//#endregion
//#region src/utils/constants.ts
const BECH32_PUBKEY_ACC_PREFIX = "injpub";
const BECH32_PUBKEY_VAL_PREFIX = "injvaloperpub";
const BECH32_PUBKEY_CONS_PREFIX = "injvalconspub";
const BECH32_ADDR_ACC_PREFIX = "inj";
const BECH32_ADDR_VAL_PREFIX = "injvaloper";
const BECH32_ADDR_CONS_PREFIX = "injvalcons";
const DEFAULT_DERIVATION_PATH = "m/44'/60'/0'/0/0";

//#endregion
//#region src/utils/time.ts
/**
* Returns a timeout timestamp in milliseconds so its compatible
* with the way Cosmos handles transactions
*/
const makeTimeoutTimestamp = (timeoutInMs = DEFAULT_TIMESTAMP_TIMEOUT_MS) => {
	const now = /* @__PURE__ */ new Date();
	return new Date(now.getTime() + timeoutInMs).getTime();
};
/**
* Returns a timeout timestamp in nanoseconds so its compatible
* with the way Cosmos handles transactions
*/
const makeTimeoutTimestampInNs = (timeoutInMs = DEFAULT_TIMESTAMP_TIMEOUT_MS) => makeTimeoutTimestamp(timeoutInMs) * 1e6;
/**
* Converts a protobuf Timestamp to a JavaScript Date
* @param timestamp - Protobuf Timestamp object with seconds and nanos fields
* @returns JavaScript Date or undefined if timestamp is null/undefined
*/
const protobufTimestampToDate = (timestamp) => {
	if (!timestamp) return;
	return /* @__PURE__ */ new Date(Number(timestamp.seconds) * 1e3 + Number(timestamp.nanos) / 1e6);
};
/**
* Converts a protobuf Timestamp to Unix timestamp in seconds
* @param timestamp - Protobuf Timestamp object with seconds and nanos fields
* @returns Unix timestamp in seconds or 0 if timestamp is null/undefined
*/
const protobufTimestampToUnixSeconds = (timestamp) => {
	if (!timestamp) return 0;
	return Math.floor(Number(timestamp.seconds) + Number(timestamp.nanos) / 1e9);
};
/**
* Converts a protobuf Timestamp to Unix timestamp in milliseconds
* @param timestamp - Protobuf Timestamp object with seconds and nanos fields
* @returns Unix timestamp in milliseconds or 0 if timestamp is null/undefined
*/
const protobufTimestampToUnixMs = (timestamp) => {
	if (!timestamp) return 0;
	return Math.floor(Number(timestamp.seconds) * 1e3 + Number(timestamp.nanos) / 1e6);
};

//#endregion
//#region src/utils/msgs.ts
const getGasPriceBasedOnMessage = (msgs) => {
	const messages = Array.isArray(msgs) ? msgs : [msgs];
	const messageType = messages[0].toDirectSign().type;
	if (messageType.includes("MsgPrivilegedExecuteContract")) return toBigNumber(DEFAULT_GAS_LIMIT).times(6).times(messages.length).decimalPlaces(0).toNumber();
	if (messageType.includes("MsgExecuteContract")) return toBigNumber(DEFAULT_GAS_LIMIT).times(3).times(messages.length).decimalPlaces(0).toNumber();
	if (messageType.includes("exchange")) return toBigNumber(DEFAULT_EXCHANGE_LIMIT).times(messages.length).decimalPlaces(0).toNumber();
	if (messageType.includes("wasm")) return toBigNumber(DEFAULT_GAS_LIMIT).times(1.5).times(messages.length).decimalPlaces(0).toNumber();
	if (messageType.includes("authz")) return toBigNumber(DEFAULT_EXCHANGE_LIMIT).times(messages.length).decimalPlaces(0).toNumber();
	if (messageType.includes("gov") && (messageType.includes("MsgDeposit") || messageType.includes("MsgSubmitProposal"))) return toBigNumber(DEFAULT_GAS_LIMIT).times(15).times(messages.length).decimalPlaces(0).toNumber();
	if (messageType.includes("MsgTransfer")) return toBigNumber(DEFAULT_IBC_GAS_LIMIT).times(messages.length).toNumber();
	return toBigNumber(DEFAULT_GAS_LIMIT).times(messages.length).toNumber();
};

//#endregion
//#region src/utils/ofac.ts
const ofacList = [
	"0x04dba1194ee10112fe6c3207c0687def0e78bacf",
	"0x08723392ed15743cc38513c4925f5e6be5c17243",
	"0x08b2efdcdb8822efe5ad0eae55517cf5dc544251",
	"0x0931ca4d13bb4ba75d9b7132ab690265d749a5e7",
	"0x098b716b8aaf21512996dc57eb0615e2383e2f96",
	"0x0ee5067b06776a89ccc7dc8ee369984ad7db5e06",
	"0x12de548f79a50d2bd05481c8515c1ef5183666a9",
	"0x175d44451403edf28469df03a9280c1197adb92c",
	"0x1967d8af5bd86a497fb3dd7899a020e47560daaf",
	"0x1999ef52700c34de7ec2b68a28aafb37db0c5ade",
	"0x19aa5fe80d33a56d56c78e82ea5e50e5d80b4dff",
	"0x19f8f2b0915daa12a3f5c9cf01df9e24d53794f7",
	"0x1da5821544e25c636c1417ba96ade4cf6d2f9b5a",
	"0x21b8d56bda776bbe68655a16895afd96f5534fed",
	"0x2f389ce8bd8ff92de3402ffce4691d17fc4f6535",
	"0x308ed4b7b49797e1a98d3818bff6fe5385410370",
	"0x35fb6f6db4fb05e6a4ce86f2c93691425626d4b1",
	"0x38735f03b30fbc022ddd06abed01f0ca823c6a94",
	"0x39d908dac893cbcb53cc86e0ecc369aa4def1a29",
	"0x3ad9db589d201a710ed237c829c7860ba86510fc",
	"0x3cbded43efdaf0fc77b9c55f6fc9988fcc9b757d",
	"0x3cffd56b47b7b41c56258d9c7731abadc360e073",
	"0x3e37627deaa754090fbfbb8bd226c1ce66d255e9",
	"0x43fa21d92141ba9db43052492e0deee5aa5f0a93",
	"0x48549a34ae37b12f6a30566245176994e17c6b4a",
	"0x4f47bc496083c727c5fbe3ce9cdf2b0f6496270c",
	"0x502371699497d08d5339c870851898d6d72521dd",
	"0x530a64c0ce595026a4a556b703644228179e2d57",
	"0x532b77b33a040587e9fd1800088225f99b8b0e8a",
	"0x53b6936513e738f44fb50d2b9476730c0ab3bfc1",
	"0x5512d943ed1f7c8a43f3435c85f7ab68b30121b0",
	"0x57ec89a0c056163a0314e413320f9b3abe761259",
	"0x5a14e72060c11313e38738009254a90968f58f51",
	"0x5a7a51bfb49f190e5a6060a5bc6052ac14a3b59f",
	"0x5d5b5dafecbf31bdb08bfd3edad4f2694372d0ef",
	"0x5f48c2a71b2cc96e3f0ccae4e39318ff0dc375b2",
	"0x67d40ee1a85bf4a4bb7ffae16de985e8427b6b45",
	"0x6be0ae71e6c41f2f9d0d1a3b8d0f75e6f6a0b46e",
	"0x6f1ca141a28907f78ebaa64fb83a9088b02a8352",
	"0x72a5843cc08275c8171e582972aa4fda8c397b2a",
	"0x797d7ae72ebddcdea2a346c1834e04d1f8df102b",
	"0x7ced75026204ac29c34bea98905d4c949f27361e",
	"0x7db418b5d567a4e0e8c59ad71be1fce48f3e6107",
	"0x7f19720a857f834887fc9a7bc0a0fbe7fc7f8102",
	"0x7f367cc41522ce07553e823bf3be79a889debe1b",
	"0x7ff9cfad3877f21d41da833e2f775db0569ee3d9",
	"0x83e5bc4ffa856bb84bb88581f5dd62a433a25e0d",
	"0x8576acc5c05d6ce88f4e49bf65bdf0c62f91353c",
	"0x8dce2aac0de82bdcaf6b4373b79f94331b8e4995",
	"0x901bb9583b24d97e995513c6778dc6888ab6870e",
	"0x931546d9e66836abf687d2bc64b30407bac8c568",
	"0x961c5be54a2ffc17cf4cb021d863c42dacd47fc1",
	"0x97b1043abd9e6fc31681635166d430a458d14f9c",
	"0x983a81ca6fb1e441266d2fbcb7d8e530ac2e05a2",
	"0x9c2bc757b66f24d60f016b6237f8cdd414a879fa",
	"0x9f4cda013e354b8fc285bf4b9a60460cee7f7ea9",
	"0xa0e1c89ef1a489c9c7de96311ed5ce5d32c20e4b",
	"0xa7e5d5a720f06526557c513402f2e6b5fa20b008",
	"0xb338962b92cd818d6aef0a32a9ecd01212a71f33",
	"0xb6f5ec1a0a9cd1526536d3f0426c429529471f40",
	"0xc103b7dc095c904b92081eef0c1640081ec01c10",
	"0xc2a3829f459b3edd87791c74cd45402ba0a20be3",
	"0xc455f7fd3e0e12afd51fba5c106909934d8a0e4a",
	"0xd0975b32cea532eadddfc9c60481976e39db3472",
	"0xd5ed34b52ac4ab84d8fa8a231a3218bbf01ed510",
	"0xd8500c631dc32fa18645b7436344a99e4825e10e",
	"0xd882cfc20f52f2599d84b8e8d58c7fb62cfe344b",
	"0xdb2720ebad55399117ddb4c4a4afd9a4ccada8fe",
	"0xdcbeffbecce100cce9e4b153c4e15cb885643193",
	"0xe1d865c3d669dcc8c57c8d023140cb204e672ee4",
	"0xe1e4c5e5ed8f03ae61b581e2def126025f2b9401",
	"0xe3d35f68383732649669aa990832e017340dbca5",
	"0xe7aa314c77f4233c18c6cc84384a9247c0cf367b",
	"0xe950dc316b836e4eefb8308bf32bf7c72a1358ff",
	"0xed6e0a7e4ac94d976eebfb82ccf777a3c6bad921",
	"0xefe301d259f525ca1ba74a7977b80d5b060b3cca",
	"0xf3701f445b6bdafedbca97d1e477357839e4120d",
	"0xf4377eda661e04b6dda78969796ed31658d602d4",
	"0xf7b31119c2682c88d88d455dbb9d5932c65cf1be",
	"0xfac583c0cf07ea434052c49115a4682172ab6b4f",
	"0xfec8a60023265364d066a1212fde3930f6ae8da7",
	"0xc5801cd781d168e2d3899ad9c39d8a2541871298",
	"0x0992E2D17e0082Df8a31Bf36Bd8Cc662551de68B",
	"0x8aa07899eb940f40e514b8effdb3b6af5d1cf7bb",
	"0xb9436d76e8fe08859d042e41b4a21c85715e1176",
	"0x7bc5cb059f21553af489d2b2df3d40aaae9b44e8",
	"0x430ab3c698b3210548b6ac9f72936b43b15ebe9b"
];

//#endregion
//#region src/utils/coins.ts
const parseCoins = (input) => {
	return input.replace(/\s/g, "").split(",").filter(Boolean).map((part) => {
		const match = part.match(/^([0-9]+)([a-zA-Z][a-zA-Z0-9/]{2,127})$/);
		if (!match) throw new Error("Got an invalid coin string");
		return {
			amount: match[1].replace(/^0+/, "") || "0",
			denom: match[2]
		};
	});
};

//#endregion
//#region src/utils/crypto.ts
/**
* Hash data to hex string using SHA256
* @param data - Base64 encoded string to hash
* @returns Uppercase hex string
*/
const hashToHex = (data) => {
	return uint8ArrayToHex(sha256(base64ToUint8Array(data))).toUpperCase();
};
/**
* Compute SHA256 hash of Uint8Array data
* @param data - Data to hash
* @returns SHA256 hash as Uint8Array
*/
const sha256$1 = (data) => {
	return sha256(data);
};
/**
* Compute RIPEMD160 hash of Uint8Array data
* @param data - Data to hash
* @returns RIPEMD160 hash as Uint8Array
*/
const ripemd160$1 = (data) => {
	return ripemd160(data);
};
/**
* Derive public key from private key
* @param privateKey - Private key as Uint8Array
* @returns Compressed public key (33 bytes)
*/
const privateKeyToPublicKey = (privateKey) => {
	return secp256k1.getPublicKey(privateKey, true);
};
/**
* Derive public key from private key hash (hex string)
* @param privateKeyHash - Private key as hex string (with or without 0x prefix)
* @returns Compressed public key (33 bytes)
*/
const privateKeyHashToPublicKey = (privateKeyHash) => {
	const privateKey = privateKeyHash.startsWith("0x") ? privateKeyHash.slice(2) : privateKeyHash;
	return secp256k1.getPublicKey(hexToUint8Array(privateKey), true);
};
/**
* Derive public key from private key and encode as base64
* @param privateKey - Private key as Uint8Array
* @returns Base64 encoded compressed public key
*/
const privateKeyToPublicKeyBase64 = (privateKey) => {
	return uint8ArrayToBase64(privateKeyToPublicKey(privateKey));
};
/**
* Derive public key from private key hash and encode as base64
* @param privateKeyHash - Private key as hex string (with or without 0x prefix)
* @returns Base64 encoded compressed public key
*/
const privateKeyHashToPublicKeyBase64 = (privateKeyHash) => {
	return uint8ArrayToBase64(privateKeyHashToPublicKey(privateKeyHash));
};
/**
* Hash only the domain portion of EIP-712 typed data
* @param message - EIP-712 typed data definition
* @returns Hash of the domain
*/
const domainHash = (message) => {
	return hashTypedData({
		domain: message.domain,
		types: message.types,
		primaryType: "EIP712Domain",
		message: {}
	});
};
/**
* Hash only the message portion of EIP-712 typed data
* @param message - EIP-712 typed data definition
* @returns Hash of the message
*/
const messageHash = (message) => {
	return hashTypedData({
		domain: {},
		types: message.types,
		primaryType: message.primaryType,
		message: message.message
	});
};
/**
* Decompress a compressed public key (starts with 02 or 03)
* If the key is already 64 bytes, prepends '04' to make it uncompressed
* @param startsWith02Or03 - Compressed public key hex string
* @returns Decompressed public key hex string (without 04 prefix)
*/
function decompressPubKey(startsWith02Or03) {
	if (hexToUint8Array(startsWith02Or03).length === 64) startsWith02Or03 = "04" + startsWith02Or03;
	const decompressed = secp256k1.ProjectivePoint.fromHex(startsWith02Or03).toHex(false);
	if (!decompressed.startsWith("04")) return decompressed;
	return decompressed.slice(2);
}
/**
* Convert public key to Ethereum address using Keccak256
* @param pubKey - Public key as Uint8Array (64 bytes uncompressed or 33 bytes compressed)
* @param sanitize - If true, will decompress compressed keys before hashing
* @returns Ethereum address (20 bytes)
* @throws Error if pubKey length is not 64 after sanitization
*/
const publicKeyToAddress = function(pubKey, sanitize = false) {
	if (sanitize && pubKey.length !== 64) pubKey = secp256k1.ProjectivePoint.fromHex(pubKey).toRawBytes(false).slice(1);
	if (pubKey.length !== 64) throw new Error("Expected pubKey to be of length 64");
	return keccak256(pubKey, "bytes").subarray(-20);
};
/**
* Sanitize typed data by converting BigInt values to strings
* Recursively processes objects and arrays
* @param data - Data to sanitize (can be object, array, or primitive)
* @returns Sanitized data with BigInt values converted to strings
*/
const sanitizeTypedData = (data) => {
	switch (Object.prototype.toString.call(data)) {
		case "[object Object]": {
			const entries = Object.keys(data).map((k) => [k, sanitizeTypedData(data[k])]);
			return Object.fromEntries(entries);
		}
		case "[object Array]": return data.map((v) => sanitizeTypedData(v));
		case "[object BigInt]": return bigIntToString(data);
		default: return data;
	}
};
function hashStruct(primaryType, data, types, _version) {
	if (!data) throw new Error("Invalid data: data is empty");
	let typedData;
	if (primaryType === "EIP712Domain") typedData = {
		domain: data,
		types: { EIP712Domain: types.EIP712Domain },
		primaryType: "EIP712Domain",
		message: {}
	};
	else typedData = {
		domain: types.domain || {},
		types,
		primaryType,
		message: data
	};
	const hash = hashTypedData(typedData);
	return { toString: (encoding) => {
		if (encoding === "hex") return hash.slice(2);
		return hash;
	} };
}
const TypedDataUtilsSanitizeData = sanitizeTypedData;
const TypedDataUtilsHashStruct = hashStruct;
const SignTypedDataVersionV4 = "V4";

//#endregion
//#region src/utils/numbers.ts
const $BigNumber = BigNumber.clone({ ROUNDING_MODE: BigNumber.ROUND_DOWN });
const isNumber = (number) => {
	if (typeof number === "number") return true;
	return !isNaN(parseFloat(number));
};
const formatNumberToAllowableDecimals = (value, allowableDecimals, roundingMode) => {
	const decimalPlacesInValue = toBigNumber(getExactDecimalsFromNumber(value));
	const valueToString = value.toString();
	if (decimalPlacesInValue.lte(0)) return valueToString;
	return decimalPlacesInValue.gte(allowableDecimals) ? toBigNumber(valueToString).toFixed(allowableDecimals, roundingMode) : valueToString;
};
const formatNumberToAllowableTensMultiplier = (value, tensMultiplier, roundingMode) => {
	const valueToBn = toBigNumber(value);
	if (tensMultiplier === 0) return valueToBn.toFixed(0, roundingMode);
	const tensMul = toBigNumber(10).pow(tensMultiplier);
	if (valueToBn.lte(tensMul)) return tensMul.toFixed(0, roundingMode);
	return toBigNumber(valueToBn.div(tensMul).toFixed(0, roundingMode)).multipliedBy(tensMul).toFixed(0);
};
const formatAmountToAllowableAmount = (value, tensMultiplier) => {
	return tensMultiplier < 0 ? formatNumberToAllowableDecimals(value, -tensMultiplier, BigNumber.ROUND_DOWN) : formatNumberToAllowableTensMultiplier(value, tensMultiplier, BigNumber.ROUND_DOWN);
};
const formatPriceToAllowablePrice = (value, tensMultiplier) => {
	return tensMultiplier <= 0 ? formatNumberToAllowableDecimals(value, -tensMultiplier) : formatNumberToAllowableTensMultiplier(value, tensMultiplier);
};
/**
*
* Legacy function - use formatNumberToAllowableDecimals
*
* @param value
* @param allowableDecimals
* @returns
*/
const formatAmountToAllowableDecimals = (value, allowableDecimals) => {
	return formatNumberToAllowableDecimals(value, allowableDecimals, BigNumber.ROUND_DOWN);
};
/**
*
* Legacy function - use formatNumberToAllowableDecimals
*
* @param value
* @param allowableDecimals
* @returns
*/
const formatPriceToAllowableDecimals = (value, allowableDecimals) => {
	return formatNumberToAllowableDecimals(value, allowableDecimals);
};
/**
* On chain amounts queried from a sentry using the
* gRPC API are returned with an extra decimal point
* 18 places from the beginning, so we need to remove it
* to get a workable amount
*/
const denomAmountFromGrpcChainDenomAmount = (value) => new $BigNumber(value).dividedBy(new $BigNumber(10).pow(18));
/**
* @deprecated use toChainFormat from injectivelabs/utils instead
*
* On chain amounts broadcasted to a sentry directly using the
* gRPC API should be passed with an extra decimal point
* 18 places from the beginning, so we need to add it
* to get a workable amount
*/
const denomAmountToGrpcChainDenomAmount = (value) => new $BigNumber(value).multipliedBy(new $BigNumber(10).pow(18));
/**
* @deprecated use toChainFormat from injectivelabs/utils instead
*
* On chain amounts (based on the cosmosSdk.Dec type)
* broadcasted to a sentry directly using the
* gRPC API should be passed with an extra decimal point
* 18 places from the beginning (i.e multiplied by 1e18), so we need to add it
* to get a workable amount
*/
const amountToCosmosSdkDecAmount = (value) => new $BigNumber(value).multipliedBy(new $BigNumber(10).pow(18));
/**
* * @deprecated use toChainFormat from injectivelabs/utils instead
*
* Amount that the chain requires is in the x * 10^(quoteDecimals) format
* where x is a human readable number
*/
const denomAmountToChainDenomAmount = ({ value, decimals = 18 }) => new $BigNumber(value).multipliedBy(new $BigNumber(10).pow(decimals));
/**
* Amount that the chain returns is in the x * 10^(quoteDecimals) format
* where x is a human readable number
*/
const denomAmountToChainDenomAmountToFixed = ({ value, decimals = 18, tensMultiplier, decimalPlaces = void 0, roundingMode = BigNumber.ROUND_DOWN }) => {
	const valueToBn = toBigNumber(value).toFixed();
	const number = denomAmountToChainDenomAmount({
		value: tensMultiplier ? formatPriceToAllowablePrice(valueToBn, tensMultiplier) : value,
		decimals
	});
	if (decimalPlaces === void 0) return number.toFixed();
	return number.toFixed(getSignificantDecimalsFromNumber(number), roundingMode);
};
/**
* @deprecated use toHumanReadable from injectivelabs/utils instead
*
* Amount that the chain returns is in the x * 10^(quoteDecimals) format
* where x is a human readable number
*/
const denomAmountFromChainDenomAmount = ({ value, decimals = 18 }) => new $BigNumber(value).dividedBy(new $BigNumber(10).pow(decimals));
/**
*
* Amount that the chain returns is in the x * 10^(quoteDecimals) format
* where x is a human readable number stringified
*/
const denomAmountFromChainDenomAmountToFixed = ({ value, decimals = 18, decimalPlaces = void 0, roundingMode = BigNumber.ROUND_DOWN }) => {
	const number = toHumanReadable(value, decimals);
	if (decimalPlaces === void 0) return number.toFixed();
	return number.toFixed(getSignificantDecimalsFromNumber(number), roundingMode);
};
/**
* @deprecated use toChainFormat from injectivelabs/utils instead
*
* Amount that the chain requires is in the x * 10^(quoteDecimals) format
* where x is a human readable number
*/
const derivativeMarginToChainMargin = ({ value, quoteDecimals = 18 }) => new $BigNumber(value).multipliedBy(new $BigNumber(10).pow(quoteDecimals));
/**
* Amount that the chain requires is in the x * 10^(quoteDecimals) format
* where x is a human readable number stringified
*/
const derivativeMarginToChainMarginToFixed = ({ value, quoteDecimals = 18, tensMultiplier, decimalPlaces = void 0, roundingMode = BigNumber.ROUND_DOWN }) => {
	const valueToBn = toBigNumber(value).toFixed();
	const number = derivativeMarginToChainMargin({
		value: tensMultiplier ? formatPriceToAllowablePrice(valueToBn, tensMultiplier) : value,
		quoteDecimals
	});
	if (decimalPlaces === void 0) return number.toFixed();
	return number.toFixed(getSignificantDecimalsFromNumber(number), roundingMode);
};
/**
* @deprecated use toHumanReadable from injectivelabs/utils instead
*
* Amount that the chain returns is in the x * 10^(quoteDecimals) format
* where x is a human readable number
*/
const derivativeMarginFromChainMargin = ({ value, quoteDecimals = 18 }) => new $BigNumber(value).dividedBy(new $BigNumber(10).pow(quoteDecimals));
/**
* Amount that the chain returns is in the x * 10^(quoteDecimals) format
* where x is a human readable number
*/
const derivativeMarginFromChainMarginToFixed = ({ value, quoteDecimals = 18, decimalPlaces = void 0, roundingMode = BigNumber.ROUND_DOWN }) => {
	const number = toHumanReadable(value, quoteDecimals);
	if (decimalPlaces === void 0) return number.toFixed();
	return number.toFixed(getSignificantDecimalsFromNumber(number), roundingMode);
};
/**
* @deprecated use toChainFormat from injectivelabs/utils instead
* Amount that the chain requires is in the x * 10^(quoteDecimals) format
* where x is a human readable number
*/
const derivativePriceToChainPrice = ({ value, quoteDecimals = 18 }) => new $BigNumber(value).multipliedBy(new $BigNumber(10).pow(quoteDecimals));
/**
* Amount that the chain requires is in the x * 10^(quoteDecimals) format
* where x is a human readable number stringified
*/
const derivativePriceToChainPriceToFixed = ({ value, tensMultiplier, quoteDecimals = 18, decimalPlaces = void 0, roundingMode = BigNumber.ROUND_DOWN }) => {
	const valueToBn = toBigNumber(value).toFixed();
	const number = toChainFormat(tensMultiplier ? formatPriceToAllowablePrice(valueToBn, tensMultiplier) : value, quoteDecimals);
	if (decimalPlaces === void 0) return number.toFixed();
	return number.toFixed(getSignificantDecimalsFromNumber(number), roundingMode);
};
/**
* @deprecated use toHumanReadable from injectivelabs/utils instead
*
* Amount that the chain returns is in the x * 10^(quoteDecimals) format
* where x is a human readable number
*/
const derivativePriceFromChainPrice = ({ value, quoteDecimals = 18 }) => new $BigNumber(value).dividedBy(new $BigNumber(10).pow(quoteDecimals));
/**
* Amount that the chain returns is in the x * 10^(quoteDecimals) format
* where x is a human readable number stringified
*/
const derivativePriceFromChainPriceToFixed = ({ value, quoteDecimals = 18, decimalPlaces = void 0, roundingMode = BigNumber.ROUND_DOWN }) => {
	const number = toHumanReadable(value, quoteDecimals);
	if (decimalPlaces === void 0) return number.toFixed();
	return number.toFixed(getSignificantDecimalsFromNumber(number), roundingMode);
};
/**
* @deprecated use toBigNumber from injectivelabs/utils instead
* Amount that the chain requires is in the x format
* where x is a human readable number
*/
const derivativeQuantityToChainQuantity = ({ value }) => new $BigNumber(value);
/**
* Amount that the chain requires is in the x format
* where x is a human readable number stringified
*/
const derivativeQuantityToChainQuantityToFixed = ({ value, decimalPlaces = void 0, tensMultiplier, roundingMode = BigNumber.ROUND_DOWN }) => {
	const valueToBn = toBigNumber(value).toFixed();
	const number = derivativeQuantityToChainQuantity({ value: tensMultiplier ? formatPriceToAllowablePrice(valueToBn, tensMultiplier) : value });
	if (decimalPlaces === void 0) return number.toFixed();
	return number.toFixed(getSignificantDecimalsFromNumber(number), roundingMode);
};
/**
* @deprecated
* Amount that the chain requires is in the x format
* where x is a human readable number
*/
const derivativeQuantityFromChainQuantity = ({ value }) => new $BigNumber(value);
/**
* Amount that the chain requires is in the x format
* where x is a human readable number stringified
*/
const derivativeQuantityFromChainQuantityToFixed = ({ value, decimalPlaces = void 0, roundingMode = BigNumber.ROUND_DOWN }) => {
	const number = new $BigNumber(value);
	if (decimalPlaces === void 0) return number.toFixed();
	return number.toFixed(getSignificantDecimalsFromNumber(number), roundingMode);
};
/**
* @deprecated use toChainFormat from injectivelabs/utils instead
* Amount that the chain requires is in the x / 10^(quoteDecimals - baseDecimals) format
* where x is a human readable number
*/
const spotPriceToChainPrice = ({ value, baseDecimals = 18, quoteDecimals = 6 }) => new $BigNumber(value).multipliedBy(new $BigNumber(10).pow(new $BigNumber(quoteDecimals).minus(baseDecimals)));
/**
* Amount that the chain requires is in the x / 10^(quoteDecimals - baseDecimals) format
* where x is a human readable number stringified
*/
const spotPriceToChainPriceToFixed = ({ value, baseDecimals = 18, quoteDecimals = 6, tensMultiplier, decimalPlaces = void 0, roundingMode = BigNumber.ROUND_DOWN }) => {
	const valueToBn = toBigNumber(value).toFixed();
	const number = toChainFormat(tensMultiplier ? formatPriceToAllowablePrice(valueToBn, tensMultiplier) : value, toBigNumber(quoteDecimals).minus(baseDecimals).toNumber());
	if (decimalPlaces === void 0) return number.toFixed();
	return number.toFixed(getSignificantDecimalsFromNumber(number), roundingMode);
};
/**
* @deprecated use toHumanReadable from injectivelabs/utils instead
*
* Amount that the chain returns is in the x / 10^(quoteDecimals - baseDecimals) format
* where x is a human readable number
*/
const spotPriceFromChainPrice = ({ value, baseDecimals = 18, quoteDecimals = 6 }) => new $BigNumber(value).dividedBy(new $BigNumber(10).pow(new $BigNumber(quoteDecimals).minus(baseDecimals)));
/**
* Amount that the chain returns is in the x / 10^(quoteDecimals - baseDecimals) format
* where x is a human readable number stringified
*/
const spotPriceFromChainPriceToFixed = ({ value, baseDecimals = 18, quoteDecimals = 6, decimalPlaces = void 0, roundingMode = BigNumber.ROUND_DOWN }) => {
	const number = toHumanReadable(value, quoteDecimals - baseDecimals);
	if (decimalPlaces === void 0) return number.toFixed();
	return number.toFixed(getSignificantDecimalsFromNumber(number), roundingMode);
};
/**
* @deprecated use toChainFormat from injectivelabs/utils instead
*
* Amount that the chain requires is in the x * 10^(baseDecimals) format
* where x is a human readable number
*/
const spotQuantityToChainQuantity = ({ value, baseDecimals = 18 }) => new $BigNumber(value).multipliedBy(new $BigNumber(10).pow(baseDecimals));
/**
* Amount that the chain requires is in the x * 10^(baseDecimals) format
* where x is a human readable number
*/
const spotQuantityToChainQuantityToFixed = ({ value, baseDecimals = 18, tensMultiplier, decimalPlaces = void 0, roundingMode = BigNumber.ROUND_DOWN }) => {
	const valueToBn = toBigNumber(value).toFixed();
	const number = toChainFormat(tensMultiplier ? formatPriceToAllowablePrice(valueToBn, tensMultiplier) : value, baseDecimals);
	if (decimalPlaces === void 0) return number.toFixed();
	return number.toFixed(getSignificantDecimalsFromNumber(number), roundingMode);
};
/**
* @deprecated use toHumanReadable from injectivelabs/utils instead
*
* Amount that the chain returns is in the x * 10^(baseDecimals) format
* where x is a human readable number
*/
const spotQuantityFromChainQuantity = ({ value, baseDecimals = 18 }) => new $BigNumber(value).dividedBy(new $BigNumber(10).pow(baseDecimals));
/**
* Amount that the chain returns is in the x * 10^(baseDecimals) format
* where x is a human readable number
*/
const spotQuantityFromChainQuantityToFixed = ({ value, baseDecimals = 18, decimalPlaces = void 0, roundingMode = BigNumber.ROUND_DOWN }) => {
	const number = toHumanReadable(value, baseDecimals);
	if (decimalPlaces === void 0) return number.toFixed();
	return number.toFixed(getSignificantDecimalsFromNumber(number), roundingMode);
};
/**
* @deprecated use toHumanReadable from injectivelabs/utils instead
*/
const cosmosSdkDecToBigNumber = (number) => new BigNumber(number).dividedBy(new BigNumber(10).pow(18));
const numberToCosmosSdkDecString = (value) => {
	return new BigNumber(value).toFixed(18);
};
/**
* This function returns a multiplier of 10
* based on the input. There are two cases:
*
* 1. If the number is less than 1, it returns a NEGATIVE
* number which is the number of decimals the number has
*
* 2. If the number is higher than 1, it returns a POSITIVE
* number which is the number of 10 multiplier the number has
*
* @param number
* @returns {number}
*/
const getTensMultiplier = (number) => {
	const numberToBn = new BigNumber(number);
	if (numberToBn.eq(1)) return 0;
	if (numberToBn.lt(1)) return -1 * getExactDecimalsFromNumber(numberToBn.toFixed());
	const [, zerosInTheNumber] = numberToBn.toFixed().split("1");
	return zerosInTheNumber.length;
};

//#endregion
//#region src/utils/markets.ts
const getDerivativeMarketTensMultiplier = ({ quoteDecimals, minPriceTickSize, minQuantityTickSize }) => {
	return {
		quantityTensMultiplier: getTensMultiplier(minQuantityTickSize),
		priceTensMultiplier: getTensMultiplier(new BigNumber(minPriceTickSize).shiftedBy(-quoteDecimals).toFixed())
	};
};
const getSpotMarketTensMultiplier = ({ baseDecimals, quoteDecimals, minPriceTickSize, minQuantityTickSize }) => {
	return {
		priceTensMultiplier: getTensMultiplier(new BigNumber(minPriceTickSize).shiftedBy(baseDecimals - quoteDecimals).toFixed()),
		quantityTensMultiplier: getTensMultiplier(new BigNumber(minQuantityTickSize).shiftedBy(-baseDecimals).toFixed())
	};
};
const getDerivativeMarketDecimals = ({ minPriceTickSize, minQuantityTickSize, quoteDecimals }) => {
	return {
		quantityDecimals: getExactDecimalsFromNumber(minQuantityTickSize),
		priceDecimals: getExactDecimalsFromNumber(new BigNumber(minPriceTickSize).shiftedBy(-quoteDecimals).toFixed())
	};
};
const getSpotMarketDecimals = ({ minPriceTickSize, minQuantityTickSize, baseDecimals, quoteDecimals }) => {
	return {
		priceDecimals: getExactDecimalsFromNumber(new BigNumber(minPriceTickSize).shiftedBy(baseDecimals - quoteDecimals).toFixed()),
		quantityDecimals: getExactDecimalsFromNumber(new BigNumber(minQuantityTickSize).shiftedBy(-baseDecimals).toFixed())
	};
};

//#endregion
//#region src/utils/address.ts
/**
* Get injective address from Ethereum hex address
*
* @param ethAddress string
* @returns string
*/
const getInjectiveAddress = (ethAddress) => {
	const addressBuffer = toBytes(ethAddress.toString());
	return bech32.encode("inj", bech32.toWords(addressBuffer));
};
/**
* Get ethereum address from injective bech32 address
*
* @param injectiveAddress string
* @returns string
*/
const getEthereumAddress = (injectiveAddress) => {
	if (injectiveAddress.startsWith("0x")) return injectiveAddress;
	return `0x${uint8ArrayToHex(bech32.fromWords(bech32.decode(injectiveAddress).words))}`;
};
/**
* Get ethereum address from injective bech32 address
*
* @param injectiveAddress string
* @returns string
*/
const getInjectiveAddressFromSubaccountId = (subaccountId) => {
	return getInjectiveAddress(subaccountId.slice(0, 42));
};
/**
* Get default subaccount id from injective bech32 address
*
* @param injectiveAddress string
* @returns string
*/
const getDefaultSubaccountId = (injectiveAddress) => {
	return `0x${uint8ArrayToHex(bech32.fromWords(bech32.decode(injectiveAddress).words))}${"0".repeat(24)}`;
};
/**
* Get subaccount id from injective bech32 address and an index (defaults to 0)
* @param injectiveAddress string
* @param nonce number
* @returns string
*/
const getSubaccountId = (injectiveAddress, nonce = 0) => {
	return `0x${uint8ArrayToHex(bech32.fromWords(bech32.decode(injectiveAddress).words))}${"0".repeat(23)}${nonce}`;
};
/** @deprecated - use getEthereumAddress */
const getAddressFromInjectiveAddress = (address) => {
	if (address.startsWith("0x")) return address;
	return `0x${uint8ArrayToHex(bech32.fromWords(bech32.decode(address).words))}`;
};
/**
* Convert Ethereum address to checksummed format (EIP-55)
* @param ethAddress - Ethereum address (with or without 0x prefix)
* @returns Checksummed Ethereum address
*/
const getChecksumAddress = (ethAddress) => {
	const lowercasedAddress = ethAddress.toLowerCase().replace("0x", "");
	const addressHash = keccak256(lowercasedAddress).replace("0x", "");
	return "0x" + lowercasedAddress.split("").map((char, i) => {
		return parseInt(addressHash[i], 16) > 7 ? char.toUpperCase() : char;
	}).join("");
};
/**
* Check if address is a CW20 contract address
* @param address - Address to check
* @returns True if address is a CW20 contract address
*/
const isCw20ContractAddress = (address) => address.length === 42 && address.startsWith("inj");
/**
* Add 0x prefix to hex string if not present
* @param hex - Hex string
* @returns Hex string with 0x prefix
*/
const addHexPrefix = (hex) => hex.startsWith("0x") ? hex : `0x${hex}`;
/**
* Remove 0x prefix from hex string if present
* @param hex - Hex string
* @returns Hex string without 0x prefix
*/
const removeHexPrefix = (hex) => hex.startsWith("0x") ? hex.slice(2) : hex;

//#endregion
//#region src/client/chain/transformers/ChainGrpcCommonTransformer.ts
var ChainGrpcCommonTransformer = class ChainGrpcCommonTransformer {
	static grpcCoinToCoin(coin) {
		return {
			denom: coin.denom,
			amount: coin.amount
		};
	}
	static pageRequestToGrpcPageRequestV2(pageRequest) {
		if (!pageRequest) return;
		return CosmosBaseQueryV1Beta1PaginationPb.PageRequest.create({
			key: (pageRequest === null || pageRequest === void 0 ? void 0 : pageRequest.key) ? base64ToUint8Array(pageRequest.key) : void 0,
			limit: (pageRequest === null || pageRequest === void 0 ? void 0 : pageRequest.limit) ? BigInt(pageRequest.limit) : void 0,
			offset: (pageRequest === null || pageRequest === void 0 ? void 0 : pageRequest.offset) ? BigInt(pageRequest.offset) : void 0,
			reverse: (pageRequest === null || pageRequest === void 0 ? void 0 : pageRequest.reverse) ? pageRequest.reverse : void 0,
			countTotal: (pageRequest === null || pageRequest === void 0 ? void 0 : pageRequest.countTotal) ? pageRequest.countTotal : void 0
		});
	}
	static pageRequestToGrpcPageRequest(pageRequest) {
		if (!pageRequest) return;
		return CosmosBaseQueryV1Beta1PaginationPb.PageRequest.create({
			key: (pageRequest === null || pageRequest === void 0 ? void 0 : pageRequest.key) ? base64ToUint8Array(pageRequest.key) : void 0,
			limit: (pageRequest === null || pageRequest === void 0 ? void 0 : pageRequest.limit) ? BigInt(pageRequest.limit) : void 0,
			offset: (pageRequest === null || pageRequest === void 0 ? void 0 : pageRequest.offset) ? BigInt(pageRequest.offset) : void 0,
			reverse: (pageRequest === null || pageRequest === void 0 ? void 0 : pageRequest.reverse) ? pageRequest.reverse : void 0,
			countTotal: (pageRequest === null || pageRequest === void 0 ? void 0 : pageRequest.countTotal) ? pageRequest.countTotal : void 0
		});
	}
	static paginationUint8ArrayToString(key) {
		if (!key) return "";
		if (key.constructor !== Uint8Array) return key;
		return uint8ArrayToBase64(key);
	}
	static grpcPaginationToPagination(pagination) {
		return {
			total: pagination ? parseInt(ChainGrpcCommonTransformer.paginationUint8ArrayToString(pagination.total.toString()), 10) : 0,
			next: pagination ? ChainGrpcCommonTransformer.paginationUint8ArrayToString(pagination.nextKey) : ""
		};
	}
	static grpcPaginationToPaginationV2(pagination) {
		return {
			total: pagination ? bigIntToNumber(pagination.total) : 0,
			next: pagination ? ChainGrpcCommonTransformer.paginationUint8ArrayToString(pagination.nextKey) : ""
		};
	}
};

//#endregion
//#region src/utils/pagination.ts
/**
* @deprecated Use ChainGrpcCommonTransformer.pageRequestToGrpcPageRequest instead
*/
const paginationRequestFromPagination = (pagination) => {
	return ChainGrpcCommonTransformer.pageRequestToGrpcPageRequest(pagination);
};
const pageRequestToGrpcPageRequestV2 = (pagination) => {
	return ChainGrpcCommonTransformer.pageRequestToGrpcPageRequestV2(pagination);
};
/**
* @deprecated Use ChainGrpcCommonTransformer.paginationUint8ArrayToString instead
*/
const paginationUint8ArrayToString = (key) => {
	return ChainGrpcCommonTransformer.paginationUint8ArrayToString(key);
};
/**
* @deprecated Use ChainGrpcCommonTransformer.grpcPaginationToPagination instead
*/
const grpcPaginationToPagination = (pagination) => {
	return ChainGrpcCommonTransformer.grpcPaginationToPagination(pagination);
};
/**
* @deprecated Use grpcPagingToPagingV2 instead (V1 proto package)
*/
const grpcPagingToPaging = (pagination) => {
	if (!pagination) return {
		to: 0,
		from: 0,
		total: 0
	};
	return {
		...pagination,
		total: bigIntToNumber(pagination.total),
		to: parseInt(pagination.to.toString() || "0", 10),
		from: parseInt(pagination.from.toString() || "0", 10),
		countBySubaccount: bigIntToNumber(pagination.countBySubaccount)
	};
};
/**
* Converts gRPC Paging to ExchangePagination for V2 proto packages.
* Handles both InjectiveAccountsRpcPb.Paging and InjectiveExplorerRpcPb.Paging types.
* Supports bigint and string types for the total and countBySubaccount fields.
*/
const grpcPagingToPagingV2 = (pagination) => {
	if (!pagination) return {
		to: 0,
		from: 0,
		total: 0
	};
	return {
		...pagination,
		total: bigIntToNumber(pagination.total),
		to: parseInt(pagination.to.toString() || "0", 10),
		from: parseInt(pagination.from.toString() || "0", 10),
		countBySubaccount: bigIntToNumber(pagination.countBySubaccount)
	};
};
const fetchAllWithPagination = async (args, method, result = []) => {
	let response = await method(args);
	if (!args) return response;
	const valueKey = Object.keys(response).find((key) => key !== "pagination");
	result.push(...response[valueKey]);
	const paginationOption = args;
	if (response.pagination.next) return fetchAllWithPagination({
		...paginationOption,
		key: response.pagination.next
	}, method, result);
	return {
		[valueKey]: result,
		pagination: response.pagination
	};
};

//#endregion
//#region src/utils/transaction.ts
const recoverTypedSignaturePubKey = async (data, signature) => {
	const publicKeyHex = await recoverPublicKey({
		hash: hashTypedData(data),
		signature
	});
	return `0x${uint8ArrayToHex(secp256k1.ProjectivePoint.fromHex(publicKeyHex.slice(2)).toRawBytes(true))}`;
};

//#endregion
export { isNumber as $, uint8ArrayToString as $t, denomAmountToChainDenomAmountToFixed as A, protobufTimestampToUnixMs as At, derivativeQuantityFromChainQuantity as B, base64ToUtf8 as Bt, getSpotMarketTensMultiplier as C, sha256$1 as Ct, denomAmountFromChainDenomAmountToFixed as D, makeTimeoutTimestamp as Dt, denomAmountFromChainDenomAmount as E, getGasPriceBasedOnMessage as Et, derivativeMarginToChainMarginToFixed as F, BECH32_PUBKEY_ACC_PREFIX as Ft, formatAmountToAllowableDecimals as G, hexToBase64 as Gt, derivativeQuantityToChainQuantity as H, concatUint8Arrays as Ht, derivativePriceFromChainPrice as I, BECH32_PUBKEY_CONS_PREFIX as It, formatPriceToAllowableDecimals as J, stringToUint8Array as Jt, formatNumberToAllowableDecimals as K, hexToBuff as Kt, derivativePriceFromChainPriceToFixed as L, BECH32_PUBKEY_VAL_PREFIX as Lt, derivativeMarginFromChainMargin as M, BECH32_ADDR_ACC_PREFIX as Mt, derivativeMarginFromChainMarginToFixed as N, BECH32_ADDR_CONS_PREFIX as Nt, denomAmountFromGrpcChainDenomAmount as O, makeTimeoutTimestampInNs as Ot, derivativeMarginToChainMargin as P, BECH32_ADDR_VAL_PREFIX as Pt, getTensMultiplier as Q, uint8ArrayToHex as Qt, derivativePriceToChainPrice as R, DEFAULT_DERIVATION_PATH as Rt, getSpotMarketDecimals as S, sanitizeTypedData as St, cosmosSdkDecToBigNumber as T, ofacList as Tt, derivativeQuantityToChainQuantityToFixed as U, fromBase64 as Ut, derivativeQuantityFromChainQuantityToFixed as V, binaryToBase64 as Vt, formatAmountToAllowableAmount as W, fromUtf8 as Wt, getExactDecimalsFromNumber as X, toUtf8 as Xt, formatPriceToAllowablePrice as Y, toBase64 as Yt, getSignificantDecimalsFromNumber as Z, uint8ArrayToBase64 as Zt, getSubaccountId as _, privateKeyHashToPublicKeyBase64 as _t, grpcPagingToPagingV2 as a, hexToNumber as an, spotQuantityFromChainQuantity as at, getDerivativeMarketDecimals as b, publicKeyToAddress as bt, paginationUint8ArrayToString as c, isNode as cn, spotQuantityToChainQuantityToFixed as ct, getAddressFromInjectiveAddress as d, objectToJson as dn, TypedDataUtilsSanitizeData as dt, bigIntReplacer as en, numberToCosmosSdkDecString as et, getChecksumAddress as f, protoObjectToJson as fn, decompressPubKey as ft, getInjectiveAddressFromSubaccountId as g, privateKeyHashToPublicKey as gt, getInjectiveAddress as h, sortObjectByKeysWithReduce as hn, messageHash as ht, grpcPagingToPaging as i, grpcCoinToUiCoin as in, spotPriceToChainPriceToFixed as it, denomAmountToGrpcChainDenomAmount as j, protobufTimestampToUnixSeconds as jt, denomAmountToChainDenomAmount as k, protobufTimestampToDate as kt, ChainGrpcCommonTransformer as l, isReactNative as ln, SignTypedDataVersionV4 as lt, getEthereumAddress as m, sortObjectByKeys as mn, hashToHex as mt, fetchAllWithPagination as n, bigIntToString as nn, spotPriceFromChainPriceToFixed as nt, pageRequestToGrpcPageRequestV2 as o, isBrowser as on, spotQuantityFromChainQuantityToFixed as ot, getDefaultSubaccountId as p, safeBigIntStringify as pn, domainHash as pt, formatNumberToAllowableTensMultiplier as q, hexToUint8Array as qt, grpcPaginationToPagination as r, getErrorMessage as rn, spotPriceToChainPrice as rt, paginationRequestFromPagination as s, isJsonString as sn, spotQuantityToChainQuantity as st, recoverTypedSignaturePubKey as t, bigIntToNumber as tn, spotPriceFromChainPrice as tt, addHexPrefix as u, isServerSide as un, TypedDataUtilsHashStruct as ut, isCw20ContractAddress as v, privateKeyToPublicKey as vt, amountToCosmosSdkDecAmount as w, parseCoins as wt, getDerivativeMarketTensMultiplier as x, ripemd160$1 as xt, removeHexPrefix as y, privateKeyToPublicKeyBase64 as yt, derivativePriceToChainPriceToFixed as z, base64ToUint8Array as zt };