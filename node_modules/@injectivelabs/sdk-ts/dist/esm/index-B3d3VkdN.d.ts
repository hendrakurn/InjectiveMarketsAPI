import { d as Coin$1, i as SignDoc$1, s as TxRaw$1 } from "./tx_pb-DiV92WM9.js";
import { AminoSignResponse as AminoSignResponse$1 } from "@cosmjs/amino";
import { DirectSignResponse as DirectSignResponse$1 } from "@cosmjs/proto-signing";

//#region ../../node_modules/.pnpm/@protobuf-ts+runtime@2.11.1/node_modules/@protobuf-ts/runtime/build/types/json-typings.d.ts

/**
 * Represents any possible JSON value:
 * - number
 * - string
 * - boolean
 * - null
 * - object (with any JSON value as property)
 * - array (with any JSON value as element)
 */
declare type JsonValue = number | string | boolean | null | JsonObject | JsonArray;
/**
 * Represents a JSON object.
 */
declare type JsonObject = {
  [k: string]: JsonValue;
};
interface JsonArray extends Array<JsonValue> {}
/**
 * Get the type of a JSON value.
 * Distinguishes between array, null and object.
 */
//#endregion
//#region ../../node_modules/.pnpm/@protobuf-ts+runtime@2.11.1/node_modules/@protobuf-ts/runtime/build/types/pb-long.d.ts
declare abstract class SharedPbLong {
  /**
   * Low 32 bits.
   */
  readonly lo: number;
  /**
   * High 32 bits.
   */
  readonly hi: number;
  /**
   * Create a new instance with the given bits.
   */
  constructor(lo: number, hi: number);
  /**
   * Is this instance equal to 0?
   */
  isZero(): boolean;
  /**
   * Convert to a native number.
   */
  toNumber(): number;
  /**
   * Convert to decimal string.
   */
  abstract toString(): string;
  /**
   * Convert to native bigint.
   */
  abstract toBigInt(): bigint;
}
/**
 * 64-bit unsigned integer as two 32-bit values.
 * Converts between `string`, `number` and `bigint` representations.
 */
declare class PbULong extends SharedPbLong {
  /**
   * ulong 0 singleton.
   */
  static ZERO: PbULong;
  /**
   * Create instance from a `string`, `number` or `bigint`.
   */
  static from(value: string | number | bigint): PbULong;
  /**
   * Convert to decimal string.
   */
  toString(): string;
  /**
   * Convert to native bigint.
   */
  toBigInt(): bigint;
}
/**
 * 64-bit signed integer as two 32-bit values.
 * Converts between `string`, `number` and `bigint` representations.
 */
declare class PbLong extends SharedPbLong {
  /**
   * long 0 singleton.
   */
  static ZERO: PbLong;
  /**
   * Create instance from a `string`, `number` or `bigint`.
   */
  static from(value: string | number | bigint): PbLong;
  /**
   * Do we have a minus sign?
   */
  isNegative(): boolean;
  /**
   * Negate two's complement.
   * Invert all the bits and add one to the result.
   */
  negate(): PbLong;
  /**
   * Convert to decimal string.
   */
  toString(): string;
  /**
   * Convert to native bigint.
   */
  toBigInt(): bigint;
}
//#endregion
//#region ../../node_modules/.pnpm/@protobuf-ts+runtime@2.11.1/node_modules/@protobuf-ts/runtime/build/types/binary-format-contract.d.ts
/**
 * Options for writing binary data.
 */
interface BinaryWriteOptions {
  /**
   * Shall unknown fields be written back on wire?
   *
   * `true`: unknown fields stored in a symbol property of the message
   * are written back. This is the default behaviour.
   *
   * `false`: unknown fields are not written.
   *
   * `UnknownFieldWriter`: Your own behaviour for unknown fields.
   */
  writeUnknownFields: boolean | UnknownFieldWriter;
  /**
   * Allows to use a custom implementation to encode binary data.
   */
  writerFactory: () => IBinaryWriter;
}
/**
 * Options for reading binary data.
 */
interface BinaryReadOptions {
  /**
   * Shall unknown fields be read, ignored or raise an error?
   *
   * `true`: stores the unknown field on a symbol property of the
   * message. This is the default behaviour.
   *
   * `false`: ignores the unknown field.
   *
   * `"throw"`: throws an error.
   *
   * `UnknownFieldReader`: Your own behaviour for unknown fields.
   */
  readUnknownField: boolean | 'throw' | UnknownFieldReader;
  /**
   * Allows to use a custom implementation to parse binary data.
   */
  readerFactory: (bytes: Uint8Array) => IBinaryReader;
}
/**
 * Store an unknown field for a message somewhere.
 */
declare type UnknownFieldReader = (typeName: string, message: any, fieldNo: number, wireType: WireType, data: Uint8Array) => void;
/**
 * Write unknown fields stored for the message to the writer.
 */
declare type UnknownFieldWriter = (typeName: string, message: any, writer: IBinaryWriter) => void;
/**
 * This handler implements the default behaviour for unknown fields.
 * When reading data, unknown fields are stored on the message, in a
 * symbol property.
 * When writing data, the symbol property is queried and unknown fields
 * are serialized into the output again.
 */

/**
 * This interface is used throughout @protobuf-ts to read
 * protobuf binary format.
 *
 * While not completely compatible, this interface is closely aligned
 * with the `Reader` class of `protobufjs` to make it easier to swap
 * the implementation.
 */
interface IBinaryReader {
  /**
   * Current position.
   */
  readonly pos: number;
  /**
   * Number of bytes available in this reader.
   */
  readonly len: number;
  /**
   * Reads a tag - field number and wire type.
   */
  tag(): [number, WireType];
  /**
   * Skip one element on the wire and return the skipped data.
   */
  skip(wireType: WireType): Uint8Array;
  /**
   * Read a `int32` field, a signed 32 bit varint.
   */
  uint32(): number;
  /**
   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
   */
  int32(): number;
  /**
   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
   */
  sint32(): number;
  /**
   * Read a `int64` field, a signed 64-bit varint.
   */
  int64(): PbLong;
  /**
   * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64(): PbLong;
  /**
   * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
   */
  sfixed64(): PbLong;
  /**
   * Read a `uint64` field, an unsigned 64-bit varint.
   */
  uint64(): PbULong;
  /**
   * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
   */
  fixed64(): PbULong;
  /**
   * Read a `bool` field, a variant.
   */
  bool(): boolean;
  /**
   * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
   */
  fixed32(): number;
  /**
   * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
   */
  sfixed32(): number;
  /**
   * Read a `float` field, 32-bit floating point number.
   */
  float(): number;
  /**
   * Read a `double` field, a 64-bit floating point number.
   */
  double(): number;
  /**
   * Read a `bytes` field, length-delimited arbitrary data.
   */
  bytes(): Uint8Array;
  /**
   * Read a `string` field, length-delimited data converted to UTF-8 text.
   */
  string(): string;
}
/**
 * This interface is used throughout @protobuf-ts to write
 * protobuf binary format.
 *
 * While not completely compatible, this interface is closely aligned
 * with the `Writer` class of `protobufjs` to make it easier to swap
 * the implementation.
 */
interface IBinaryWriter {
  /**
   * Return all bytes written and reset this writer.
   */
  finish(): Uint8Array;
  /**
   * Start a new fork for length-delimited data like a message
   * or a packed repeated field.
   *
   * Must be joined later with `join()`.
   */
  fork(): IBinaryWriter;
  /**
   * Join the last fork. Write its length and bytes, then
   * return to the previous state.
   */
  join(): IBinaryWriter;
  /**
   * Writes a tag (field number and wire type).
   *
   * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`
   *
   * Generated code should compute the tag ahead of time and call `uint32()`.
   */
  tag(fieldNo: number, type: WireType): IBinaryWriter;
  /**
   * Write a chunk of raw bytes.
   */
  raw(chunk: Uint8Array): IBinaryWriter;
  /**
   * Write a `uint32` value, an unsigned 32 bit varint.
   */
  uint32(value: number): IBinaryWriter;
  /**
   * Write a `int32` value, a signed 32 bit varint.
   */
  int32(value: number): IBinaryWriter;
  /**
   * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
   */
  sint32(value: number): IBinaryWriter;
  /**
   * Write a `int64` value, a signed 64-bit varint.
   */
  int64(value: string | number | bigint): IBinaryWriter;
  /**
   * Write a `uint64` value, an unsigned 64-bit varint.
   */
  uint64(value: string | number | bigint): IBinaryWriter;
  /**
   * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64(value: string | number | bigint): IBinaryWriter;
  /**
   * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
   */
  fixed64(value: string | number | bigint): IBinaryWriter;
  /**
   * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
   */
  sfixed64(value: string | number | bigint): IBinaryWriter;
  /**
   * Write a `bool` value, a variant.
   */
  bool(value: boolean): IBinaryWriter;
  /**
   * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
   */
  fixed32(value: number): IBinaryWriter;
  /**
   * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
   */
  sfixed32(value: number): IBinaryWriter;
  /**
   * Write a `float` value, 32-bit floating point number.
   */
  float(value: number): IBinaryWriter;
  /**
   * Write a `double` value, a 64-bit floating point number.
   */
  double(value: number): IBinaryWriter;
  /**
   * Write a `bytes` value, length-delimited arbitrary data.
   */
  bytes(value: Uint8Array): IBinaryWriter;
  /**
   * Write a `string` value, length-delimited data converted to UTF-8 text.
   */
  string(value: string): IBinaryWriter;
}
/**
 * Protobuf binary format wire types.
 *
 * A wire type provides just enough information to find the length of the
 * following value.
 *
 * See https://developers.google.com/protocol-buffers/docs/encoding#structure
 */
declare enum WireType {
  /**
   * Used for int32, int64, uint32, uint64, sint32, sint64, bool, enum
   */
  Varint = 0,
  /**
   * Used for fixed64, sfixed64, double.
   * Always 8 bytes with little-endian byte order.
   */
  Bit64 = 1,
  /**
   * Used for string, bytes, embedded messages, packed repeated fields
   *
   * Only repeated numeric types (types which use the varint, 32-bit,
   * or 64-bit wire types) can be packed. In proto3, such fields are
   * packed by default.
   */
  LengthDelimited = 2,
  /**
   * Used for groups
   * @deprecated
   */
  StartGroup = 3,
  /**
   * Used for groups
   * @deprecated
   */
  EndGroup = 4,
  /**
   * Used for fixed32, sfixed32, float.
   * Always 4 bytes with little-endian byte order.
   */
  Bit32 = 5,
}
//#endregion
//#region ../../node_modules/.pnpm/@protobuf-ts+runtime@2.11.1/node_modules/@protobuf-ts/runtime/build/types/reflection-info.d.ts
/**
 * Describes a protobuf enum for runtime reflection.
 *
 * The tuple consists of:
 *
 *
 * [0] the protobuf type name
 *
 * The type name follows the same rules as message type names.
 * See `MessageInfo` for details.
 *
 *
 * [1] the enum object generated by Typescript
 *
 * We generate standard Typescript enums for protobuf enums. They are compiled
 * to lookup objects that map from numerical value to name strings and vice
 * versa and can also contain alias names.
 *
 * See https://www.typescriptlang.org/docs/handbook/enums.html#reverse-mappings
 *
 * We use this lookup feature to when encoding / decoding JSON format. The
 * enum is guaranteed to have a value for 0. We generate an entry for 0 if
 * none was declared in .proto because we would need to support custom default
 * values if we didn't.
 *
 *
 * [2] the prefix shared by all original enum values (optional)
 *
 * If all values of a protobuf enum share a prefix, it is dropped in the
 * generated enum. For example, the protobuf enum `enum My { MY_FOO, MY_BAR }`
 * becomes the typescript enum `enum My { FOO, BAR }`.
 *
 * Because the JSON format requires the original value name, we store the
 * dropped prefix here, so that the JSON format implementation can restore
 * the original value names.
 */
declare type EnumInfo = readonly [
/**
 * The protobuf type name of the enum
 */
string,
/**
 * The enum object generated by Typescript
 */
{
  [key: number]: string;
  [k: string]: number | string;
},
/**
 * The prefix shared by all original enum values
 */
string?];
/**
 * Describes a protobuf message for runtime reflection.
 */
interface MessageInfo {
  /**
   * The protobuf type name of the message, including package and
   * parent types if present.
   *
   * If the .proto file included a `package` statement, the type name
   * starts with '.'.
   *
   * Examples:
   * 'MyNamespaceLessMessage'
   * '.my_package.MyMessage'
   * '.my_package.ParentMessage.ChildMessage'
   */
  readonly typeName: string;
  /**
   * Simple information for each message field, in the order
   * of declaration in the source .proto.
   */
  readonly fields: readonly FieldInfo[];
  /**
   * Contains custom message options from the .proto source in JSON format.
   */
  readonly options: {
    [extensionName: string]: JsonValue;
  };
}
/**
 * Describes a field of a protobuf message for runtime
 * reflection. We distinguish between the following
 * kinds of fields:
 *
 * "scalar": string, bool, float, int32, etc.
 * See https://developers.google.com/protocol-buffers/docs/proto3#scalar
 *
 * "enum": field was declared with an enum type.
 *
 * "message": field was declared with a message type.
 *
 * "map": field was declared with map<K,V>.
 *
 *
 * Every field, regardless of it's kind, always has the following properties:
 *
 * "no": The field number of the .proto field.
 * "name": The original name of the .proto field.
 * "localName": The name of the field as used in generated code.
 * "jsonName": The name for JSON serialization / deserialization.
 * "options": Custom field options from the .proto source in JSON format.
 *
 *
 * Other properties:
 *
 * - Fields of kind "scalar", "enum" and "message" can have a "repeat" type.
 * - Fields of kind "scalar" and "enum" can have a "repeat" type.
 * - Fields of kind "scalar", "enum" and "message" can be member of a "oneof".
 *
 * A field can be only have one of the above properties set.
 *
 * Options for "scalar" fields:
 *
 * - 64 bit integral types can provide "L" - the JavaScript representation
 *   type.
 *
 */
declare type FieldInfo = fiRules<fiScalar> | fiRules<fiEnum> | fiRules<fiMessage> | fiRules<fiMap>;
interface fiShared {
  /**
   * The field number of the .proto field.
   */
  no: number;
  /**
   * The original name of the .proto field.
   */
  name: string;
  /**
   * The name of the field as used in generated code.
   */
  localName: string;
  /**
   * The name for JSON serialization / deserialization.
   */
  jsonName: string;
  /**
   * The name of the `oneof` group, if this field belongs to one.
   */
  oneof: string | undefined;
  /**
   * Contains custom field options from the .proto source in JSON format.
   */
  options?: {
    [extensionName: string]: JsonValue;
  };
}
interface fiScalar extends fiShared {
  kind: 'scalar';
  /**
   * Scalar type of the field.
   */
  T: ScalarType;
  /**
   * Representation of 64 bit integral types (int64, uint64, sint64,
   * fixed64, sfixed64).
   *
   * If this option is set for other scalar types, it is ignored.
   * Omitting this option is equivalent to `STRING`.
   */
  L?: LongType;
  /**
   * Is the field repeated?
   */
  repeat: RepeatType;
  /**
   * Is the field optional?
   */
  opt: boolean;
}
interface fiMessage extends fiShared {
  kind: 'message';
  /**
   * Message handler for the field.
   */
  T: () => IMessageType<any>;
  /**
   * Is the field repeated?
   */
  repeat: RepeatType;
}
interface fiEnum extends fiShared {
  kind: 'enum';
  /**
   * Enum type information for the field.
   */
  T: () => EnumInfo;
  /**
   * Is the field repeated?
   */
  repeat: RepeatType;
  /**
   * Is the field optional?
   */
  opt: boolean;
}
interface fiMap extends fiShared {
  kind: 'map';
  /**
   * Map key type.
   *
   * The key_type can be any integral or string type
   * (so, any scalar type except for floating point
   * types and bytes)
   */
  K: Exclude<ScalarType, ScalarType.FLOAT | ScalarType.DOUBLE | ScalarType.BYTES>;
  /**
   * Map value type. Can be a `ScalarType`, enum type information,
   * or type handler for a message.
   */
  V: {
    kind: 'scalar';
    T: ScalarType;
    L?: LongType;
  } | {
    kind: 'enum';
    T: () => EnumInfo;
  } | {
    kind: 'message';
    T: () => IMessageType<any>;
  };
}
declare type fiRules<T> = Omit<T, 'oneof' | 'repeat' | 'opt'> & ({
  repeat: RepeatType.NO;
  opt: false;
  oneof: undefined;
} | {
  repeat: RepeatType.NO;
  opt: true;
  oneof: undefined;
} | {
  repeat: RepeatType.PACKED | RepeatType.UNPACKED;
  opt: false;
  oneof: undefined;
} | {
  repeat: RepeatType.NO;
  opt: false;
  oneof: string;
});
/**
 * Scalar value types. This is a subset of field types declared by protobuf
 * enum google.protobuf.FieldDescriptorProto.Type The types GROUP and MESSAGE
 * are omitted, but the numerical values are identical.
 */
declare enum ScalarType {
  DOUBLE = 1,
  FLOAT = 2,
  INT64 = 3,
  UINT64 = 4,
  INT32 = 5,
  FIXED64 = 6,
  FIXED32 = 7,
  BOOL = 8,
  STRING = 9,
  BYTES = 12,
  UINT32 = 13,
  SFIXED32 = 15,
  SFIXED64 = 16,
  SINT32 = 17,
  SINT64 = 18,
}
/**
 * JavaScript representation of 64 bit integral types. Equivalent to the
 * field option "jstype".
 *
 * By default, protobuf-ts represents 64 bit types as `bigint`.
 *
 * You can change the default behaviour by enabling the plugin parameter
 * `long_type_string`, which will represent 64 bit types as `string`.
 *
 * Alternatively, you can change the behaviour for individual fields
 * with the field option "jstype":
 *
 * ```protobuf
 * uint64 my_field = 1 [jstype = JS_STRING];
 * uint64 other_field = 2 [jstype = JS_NUMBER];
 * ```
 */
declare enum LongType {
  /**
   * Use JavaScript `bigint`.
   *
   * Field option `[jstype = JS_NORMAL]`.
   */
  BIGINT = 0,
  /**
   * Use JavaScript `string`.
   *
   * Field option `[jstype = JS_STRING]`.
   */
  STRING = 1,
  /**
   * Use JavaScript `number`.
   *
   * Large values will loose precision.
   *
   * Field option `[jstype = JS_NUMBER]`.
   */
  NUMBER = 2,
}
/**
 * Protobuf 2.1.0 introduced packed repeated fields.
 * Setting the field option `[packed = true]` enables packing.
 *
 * In proto3, all repeated fields are packed by default.
 * Setting the field option `[packed = false]` disables packing.
 *
 * Packed repeated fields are encoded with a single tag,
 * then a length-delimiter, then the element values.
 *
 * Unpacked repeated fields are encoded with a tag and
 * value for each element.
 *
 * `bytes` and `string` cannot be packed.
 */
declare enum RepeatType {
  /**
   * The field is not repeated.
   */
  NO = 0,
  /**
   * The field is repeated and should be packed.
   * Invalid for `bytes` and `string`, they cannot be packed.
   */
  PACKED = 1,
  /**
   * The field is repeated but should not be packed.
   * The only valid repeat type for repeated `bytes` and `string`.
   */
  UNPACKED = 2,
}
//#endregion
//#region ../../node_modules/.pnpm/@protobuf-ts+runtime@2.11.1/node_modules/@protobuf-ts/runtime/build/types/message-type-contract.d.ts
/**
 * Similar to `Partial<T>`, but recursive, and keeps `oneof` groups
 * intact.
 */
declare type PartialMessage<T extends object> = { [K in keyof T]?: PartialField<T[K]> };
declare type PartialField<T> = T extends (Date | Uint8Array | bigint | boolean | string | number) ? T : T extends Array<infer U> ? Array<PartialField<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<PartialField<U>> : T extends {
  oneofKind: string;
} ? T : T extends {
  oneofKind: undefined;
} ? T : T extends object ? PartialMessage<T> : T;
/**
 * A message type provides an API to work with messages of a specific type.
 * It also exposes reflection information that can be used to work with a
 * message of unknown type.
 */
interface IMessageType<T extends object> extends MessageInfo {
  /**
   * The protobuf type name of the message, including package and
   * parent types if present.
   *
   * Examples:
   * 'MyNamespaceLessMessage'
   * 'my_package.MyMessage'
   * 'my_package.ParentMessage.ChildMessage'
   */
  readonly typeName: string;
  /**
   * Simple information for each message field, in the order
   * of declaration in the .proto.
   */
  readonly fields: readonly FieldInfo[];
  /**
   * Contains custom message options from the .proto source in JSON format.
   */
  readonly options: {
    [extensionName: string]: JsonValue;
  };
  /**
   * Contains the prototype for messages returned by create() which
   * includes the `MESSAGE_TYPE` symbol pointing back to `this`.
   */
  readonly messagePrototype?: Readonly<{}> | undefined;
  /**
   * Create a new message with default values.
   *
   * For example, a protobuf `string name = 1;` has the default value `""`.
   */
  create(): T;
  /**
   * Create a new message from partial data.
   *
   * Unknown fields are discarded.
   *
   * `PartialMessage<T>` is similar to `Partial<T>`,
   * but it is recursive, and it keeps `oneof` groups
   * intact.
   */
  create(value: PartialMessage<T>): T;
  /**
   * Create a new message from binary format.
   */
  fromBinary(data: Uint8Array, options?: Partial<BinaryReadOptions>): T;
  /**
   * Write the message to binary format.
   */
  toBinary(message: T, options?: Partial<BinaryWriteOptions>): Uint8Array;
  /**
   * Read a new message from a JSON value.
   */
  fromJson(json: JsonValue, options?: Partial<JsonReadOptions>): T;
  /**
   * Read a new message from a JSON string.
   * This is equivalent to `T.fromJson(JSON.parse(json))`.
   */
  fromJsonString(json: string, options?: Partial<JsonReadOptions>): T;
  /**
   * Convert the message to canonical JSON value.
   */
  toJson(message: T, options?: Partial<JsonWriteOptions>): JsonValue;
  /**
   * Convert the message to canonical JSON string.
   * This is equivalent to `JSON.stringify(T.toJson(t))`
   */
  toJsonString(message: T, options?: Partial<JsonWriteStringOptions>): string;
  /**
   * Clone the message.
   *
   * Unknown fields are discarded.
   */
  clone(message: T): T;
  /**
   * Copy partial data into the target message.
   *
   * If a singular scalar or enum field is present in the source, it
   * replaces the field in the target.
   *
   * If a singular message field is present in the source, it is merged
   * with the target field by calling mergePartial() of the responsible
   * message type.
   *
   * If a repeated field is present in the source, its values replace
   * all values in the target array, removing extraneous values.
   * Repeated message fields are copied, not merged.
   *
   * If a map field is present in the source, entries are added to the
   * target map, replacing entries with the same key. Entries that only
   * exist in the target remain. Entries with message values are copied,
   * not merged.
   *
   * Note that this function differs from protobuf merge semantics,
   * which appends repeated fields.
   */
  mergePartial(target: T, source: PartialMessage<T>): void;
  /**
   * Determines whether two message of the same type have the same field values.
   * Checks for deep equality, traversing repeated fields, oneof groups, maps
   * and messages recursively.
   * Will also return true if both messages are `undefined`.
   */
  equals(a: T | undefined, b: T | undefined): boolean;
  /**
   * Is the given value assignable to our message type
   * and contains no [excess properties](https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks)?
   */
  is(arg: any, depth?: number): arg is T;
  /**
   * Is the given value assignable to our message type,
   * regardless of [excess properties](https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks)?
   */
  isAssignable(arg: any, depth?: number): arg is T;
  /**
   * This is an internal method. If you just want to read a message from
   * JSON, use `fromJson()` or `fromJsonString()`.
   *
   * Reads JSON value and merges the fields into the target
   * according to protobuf rules. If the target is omitted,
   * a new instance is created first.
   */
  internalJsonRead(json: JsonValue, options: JsonReadOptions, target?: T): T;
  /**
   * This is an internal method. If you just want to write a message
   * to JSON, use `toJson()` or `toJsonString().
   *
   * Writes JSON value and returns it.
   */
  internalJsonWrite(message: T, options: JsonWriteOptions): JsonValue;
  /**
   * This is an internal method. If you just want to write a message
   * in binary format, use `toBinary()`.
   *
   * Serializes the message in binary format and appends it to the given
   * writer. Returns passed writer.
   */
  internalBinaryWrite(message: T, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
  /**
   * This is an internal method. If you just want to read a message from
   * binary data, use `fromBinary()`.
   *
   * Reads data from binary format and merges the fields into
   * the target according to protobuf rules. If the target is
   * omitted, a new instance is created first.
   */
  internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: T): T;
}
//#endregion
//#region ../../node_modules/.pnpm/@protobuf-ts+runtime@2.11.1/node_modules/@protobuf-ts/runtime/build/types/json-format-contract.d.ts
/**
 * Options for parsing JSON data.
 * All boolean options default to `false`.
 */
interface JsonReadOptions {
  /**
   * Ignore unknown fields: Proto3 JSON parser should reject unknown fields
   * by default. This option ignores unknown fields in parsing, as well as
   * unrecognized enum string representations.
   */
  ignoreUnknownFields: boolean;
  /**
   * This option is required to read `google.protobuf.Any`
   * from JSON format.
   */
  typeRegistry?: readonly IMessageType<any>[];
}
/**
 * Options for serializing to JSON object.
 * All boolean options default to `false`.
 */
interface JsonWriteOptions {
  /**
   * Emit fields with default values: Fields with default values are omitted
   * by default in proto3 JSON output. This option overrides this behavior
   * and outputs fields with their default values.
   */
  emitDefaultValues: boolean;
  /**
   * Emit enum values as integers instead of strings: The name of an enum
   * value is used by default in JSON output. An option may be provided to
   * use the numeric value of the enum value instead.
   */
  enumAsInteger: boolean;
  /**
   * Use proto field name instead of lowerCamelCase name: By default proto3
   * JSON printer should convert the field name to lowerCamelCase and use
   * that as the JSON name. An implementation may provide an option to use
   * proto field name as the JSON name instead. Proto3 JSON parsers are
   * required to accept both the converted lowerCamelCase name and the proto
   * field name.
   */
  useProtoFieldName: boolean;
  /**
   * This option is required to write `google.protobuf.Any`
   * to JSON format.
   */
  typeRegistry?: readonly IMessageType<any>[];
}
/**
 * Options for serializing to JSON string.
 * All options default to `false` or `0`.
 */
interface JsonWriteStringOptions extends JsonWriteOptions {
  prettySpaces: number;
}
//#endregion
//#region ../../node_modules/.pnpm/@protobuf-ts+runtime-rpc@2.11.1/node_modules/@protobuf-ts/runtime-rpc/build/types/reflection-info.d.ts
/**
 * Describes a protobuf service for runtime reflection.
 */
interface ServiceInfo {
  /**
   * The protobuf type name of the service, including package name if
   * present.
   */
  readonly typeName: string;
  /**
   * Information for each rpc method of the service, in the order of
   * declaration in the source .proto.
   */
  readonly methods: MethodInfo[];
  /**
   * Contains custom service options from the .proto source in JSON format.
   */
  readonly options: {
    [extensionName: string]: JsonValue;
  };
}
/**
 * Describes a protobuf service method for runtime reflection.
 */
interface MethodInfo<I extends object = any, O extends object = any> {
  /**
   * The service this method belongs to.
   */
  readonly service: ServiceInfo;
  /**
   * The name of the method as declared in .proto
   */
  readonly name: string;
  /**
   * The name of the method in the runtime.
   */
  readonly localName: string;
  /**
   * The idempotency level as specified in .proto.
   *
   * For example, the following method declaration will set
   * `idempotency` to 'NO_SIDE_EFFECTS'.
   *
   * ```proto
   * rpc Foo (FooRequest) returns (FooResponse) {
   *   option idempotency_level = NO_SIDE_EFFECTS
   * }
   * ```
   *
   * See `google/protobuf/descriptor.proto`, `MethodOptions`.
   */
  readonly idempotency: undefined | 'NO_SIDE_EFFECTS' | 'IDEMPOTENT';
  /**
   * Was the rpc declared with server streaming?
   *
   * Example declaration:
   *
   * ```proto
   * rpc Foo (FooRequest) returns (stream FooResponse);
   * ```
   */
  readonly serverStreaming: boolean;
  /**
   * Was the rpc declared with client streaming?
   *
   * Example declaration:
   *
   * ```proto
   * rpc Foo (stream FooRequest) returns (FooResponse);
   * ```
   */
  readonly clientStreaming: boolean;
  /**
   * The generated type handler for the input message.
   * Provides methods to encode / decode binary or JSON format.
   */
  readonly I: IMessageType<I>;
  /**
   * The generated type handler for the output message.
   * Provides methods to encode / decode binary or JSON format.
   */
  readonly O: IMessageType<O>;
  /**
   * Contains custom method options from the .proto source in JSON format.
   */
  readonly options: {
    [extensionName: string]: JsonValue;
  };
}
//#endregion
//#region ../../node_modules/.pnpm/@protobuf-ts+runtime-rpc@2.11.1/node_modules/@protobuf-ts/runtime-rpc/build/types/rpc-metadata.d.ts
/**
 * RPC metadata provide optional additional information about a request or
 * response.
 *
 * They can be transmitted at:
 * - the start of a request (a.k.a. request headers)
 * - the start of a response (a.k.a. response headers)
 * - the end of a response (a.k.a. response trailers)
 *
 * Keys should only contain the characters a-z 0-9 _ . -
 *
 * Values can be US ASCII or binary. If a key ends with `-bin`, it contains
 * binary data in base64 encoding.
 *
 * You can encode protobuf messages as binary metadata values, including
 * `google.protobuf.Any`.
 */
interface RpcMetadata {
  [key: string]: string | string[];
}
//#endregion
//#region ../../node_modules/.pnpm/@protobuf-ts+runtime-rpc@2.11.1/node_modules/@protobuf-ts/runtime-rpc/build/types/rpc-status.d.ts
/**
 * A RPC status consists of a code and a text message.
 *
 * The status is usually returned from the server as a response trailer,
 * but a `RpcTransport` may also read the status from response headers.
 */
interface RpcStatus {
  /**
   * A status code as a string. The value depends on the `RpcTransport` being
   * used.
   *
   * For gRPC, it will be the string value of a StatusCode enum value
   * https://github.com/grpc/grpc/blob/a19d8dcfb50caa81cddc25bc1a6afdd7a2f497b7/include/grpcpp/impl/codegen/status_code_enum.h#L24
   *
   * For Twirp, it will be one of the Twirp error codes as string:
   * https://twitchtv.github.io/twirp/docs/spec_v5.html#error-codes
   *
   */
  code: string;
  /**
   * A text message that may describe the condition.
   */
  detail: string;
}
//#endregion
//#region ../../node_modules/.pnpm/@protobuf-ts+runtime-rpc@2.11.1/node_modules/@protobuf-ts/runtime-rpc/build/types/rpc-call-shared.d.ts
interface RpcCallShared<I extends object, O extends object> {
  /**
   * Reflection information about this call.
   */
  readonly method: MethodInfo<I, O>;
  /**
   * Request headers being sent with the request.
   *
   * Request headers are provided in the `meta` property of the
   * `RpcOptions` passed to a call.
   */
  readonly requestHeaders: Readonly<RpcMetadata>;
  /**
   * The response headers that the server sent.
   *
   * This promise will reject with a `RpcError` when the server sends an
   * error status code.
   */
  readonly headers: Promise<RpcMetadata>;
  /**
   * The response status the server replied with.
   *
   * This promise will resolve when the server has finished the request
   * successfully.
   *
   * If the server replies with an error status, this promise will
   * reject with a `RpcError`.
   */
  readonly status: Promise<RpcStatus>;
  /**
   * The trailers the server attached to the response.
   *
   * This promise will resolve when the server has finished the request
   * successfully.
   *
   * If the server replies with an error status, this promise will
   * reject with a `RpcError`.
   */
  readonly trailers: Promise<RpcMetadata>;
}
//#endregion
//#region ../../node_modules/.pnpm/@protobuf-ts+runtime-rpc@2.11.1/node_modules/@protobuf-ts/runtime-rpc/build/types/rpc-output-stream.d.ts
/**
 * A stream of response messages. Messages can be read from the stream via
 * the AsyncIterable interface:
 *
 * ```typescript
 * for await (let message of response) {...
 * ```
 *
 * Some things to note:
 * - If an error occurs, the `for await` will throw it.
 * - If an error occurred before the `for await` was started, `for await`
 *   will re-throw it.
 * - If the stream is already complete, the `for await` will be empty.
 * - If your `for await` consumes slower than the stream produces,
 *   for example because you are relaying messages in a slow operation,
 *   messages are queued.
 */
interface RpcOutputStream<T extends object = object> extends AsyncIterable<T> {
  /**
   * Add a callback for every new datum.
   * If a new message arrived, the "message" argument is set.
   * If an error occurred, the "error" argument is set.
   * If the stream is complete, the "complete" argument is `true`.
   * Only one of the arguments is used at a time.
   */
  onNext(callback: NextCallback<T>): RemoveListenerFn;
  /**
   * Add a callback for every new message.
   */
  onMessage(callback: MessageCallback<T>): RemoveListenerFn;
  /**
   * Add a callback for stream completion.
   * Called only when all messages have been read without error.
   * The stream is closed when this callback is called.
   */
  onComplete(callback: CompleteCallback): RemoveListenerFn;
  /**
   * Add a callback for errors.
   * The stream is closed when this callback is called.
   */
  onError(callback: ErrorCallback): RemoveListenerFn;
}
declare type NextCallback<T extends object> = (message: T | undefined, error: Error | undefined, complete: boolean) => void;
declare type MessageCallback<T extends object> = (message: T) => void;
declare type CompleteCallback = () => void;
declare type ErrorCallback = (reason: Error) => void;
declare type RemoveListenerFn = () => void;
/**
 * A `RpcOutputStream` that you control.
 */
//#endregion
//#region ../../node_modules/.pnpm/@protobuf-ts+runtime-rpc@2.11.1/node_modules/@protobuf-ts/runtime-rpc/build/types/server-streaming-call.d.ts
/**
 * A server streaming RPC call. The client provides exactly one input message
 * but the server may respond with 0, 1, or more messages.
 */
declare class ServerStreamingCall<I extends object = object, O extends object = object> implements RpcCallShared<I, O>, PromiseLike<FinishedServerStreamingCall<I, O>> {
  /**
   * Reflection information about this call.
   */
  readonly method: MethodInfo<I, O>;
  /**
   * Request headers being sent with the request.
   *
   * Request headers are provided in the `meta` property of the
   * `RpcOptions` passed to a call.
   */
  readonly requestHeaders: Readonly<RpcMetadata>;
  /**
   * The request message being sent.
   */
  readonly request: Readonly<I>;
  /**
   * The response headers that the server sent.
   *
   * This promise will reject with a `RpcError` when the server sends a
   * error status code.
   */
  readonly headers: Promise<RpcMetadata>;
  /**
   * Response messages from the server.
   * This is an AsyncIterable that can be iterated with `await for .. of`.
   */
  readonly responses: RpcOutputStream<O>;
  /**
   * The response status the server replied with.
   *
   * This promise will resolve when the server has finished the request
   * successfully.
   *
   * If the server replies with an error status, this promise will
   * reject with a `RpcError`.
   */
  readonly status: Promise<RpcStatus>;
  /**
   * The trailers the server attached to the response.
   *
   * This promise will resolve when the server has finished the request
   * successfully.
   *
   * If the server replies with an error status, this promise will
   * reject with a `RpcError`.
   */
  readonly trailers: Promise<RpcMetadata>;
  constructor(method: MethodInfo<I, O>, requestHeaders: Readonly<RpcMetadata>, request: Readonly<I>, headers: Promise<RpcMetadata>, response: RpcOutputStream<O>, status: Promise<RpcStatus>, trailers: Promise<RpcMetadata>);
  /**
   * Instead of awaiting the response status and trailers, you can
   * just as well await this call itself to receive the server outcome.
   * You should first setup some listeners to the `request` to
   * see the actual messages the server replied with.
   */
  then<TResult1 = FinishedServerStreamingCall<I, O>, TResult2 = never>(onfulfilled?: ((value: FinishedServerStreamingCall<I, O>) => (PromiseLike<TResult1> | TResult1)) | undefined | null, onrejected?: ((reason: any) => (PromiseLike<TResult2> | TResult2)) | undefined | null): Promise<TResult1 | TResult2>;
  private promiseFinished;
}
/**
 * A completed server streaming RPC call. The server will not send any more
 * messages.
 */
interface FinishedServerStreamingCall<I extends object, O extends object> {
  /**
   * Reflection information about this call.
   */
  readonly method: MethodInfo<I, O>;
  /**
   * Request headers being sent with the request.
   */
  readonly requestHeaders: Readonly<RpcMetadata>;
  /**
   * The request message being sent.
   */
  readonly request: Readonly<I>;
  /**
   * The response headers that the server sent.
   */
  readonly headers: RpcMetadata;
  /**
   * The response status the server replied with.
   * The status code will always be OK.
   */
  readonly status: RpcStatus;
  /**
   * The trailers the server attached to the response.
   */
  readonly trailers: RpcMetadata;
}
//#endregion
//#region ../../node_modules/.pnpm/@protobuf-ts+runtime-rpc@2.11.1/node_modules/@protobuf-ts/runtime-rpc/build/types/rpc-input-stream.d.ts
/**
 * A stream of input messages.
 */
interface RpcInputStream<T> {
  /**
   * Send a message down the stream.
   * Only one message can be send at a time.
   */
  send(message: T): Promise<void>;
  /**
   * Complete / close the stream.
   * Can only be called if there is no pending send().
   * No send() should follow this call.
   */
  complete(): Promise<void>;
}
//#endregion
//#region ../../node_modules/.pnpm/@protobuf-ts+runtime-rpc@2.11.1/node_modules/@protobuf-ts/runtime-rpc/build/types/client-streaming-call.d.ts
/**
 * A client streaming RPC call. This means that the clients sends 0, 1, or
 * more messages to the server, and the server replies with exactly one
 * message.
 */
declare class ClientStreamingCall<I extends object = object, O extends object = object> implements RpcCallShared<I, O> {
  /**
   * Reflection information about this call.
   */
  readonly method: MethodInfo<I, O>;
  /**
   * Request headers being sent with the request.
   *
   * Request headers are provided in the `meta` property of the
   * `RpcOptions` passed to a call.
   */
  readonly requestHeaders: Readonly<RpcMetadata>;
  /**
   * Request messages from the client.
   */
  readonly requests: RpcInputStream<I>;
  /**
   * The response headers that the server sent.
   *
   * This promise will reject with a `RpcError` when the server sends a
   * error status code.
   */
  readonly headers: Promise<RpcMetadata>;
  /**
   * The message the server replied with.
   */
  readonly response: Promise<O>;
  /**
   * The response status the server replied with.
   *
   * This promise will resolve when the server has finished the request
   * successfully.
   *
   * If the server replies with an error status, this promise will
   * reject with a `RpcError`.
   */
  readonly status: Promise<RpcStatus>;
  /**
   * The trailers the server attached to the response.
   *
   * This promise will resolve when the server has finished the request
   * successfully.
   *
   * If the server replies with an error status, this promise will
   * reject with a `RpcError`.
   */
  readonly trailers: Promise<RpcMetadata>;
  constructor(method: MethodInfo<I, O>, requestHeaders: Readonly<RpcMetadata>, request: RpcInputStream<I>, headers: Promise<RpcMetadata>, response: Promise<O>, status: Promise<RpcStatus>, trailers: Promise<RpcMetadata>);
  /**
   * Instead of awaiting the response status and trailers, you can
   * just as well await this call itself to receive the server outcome.
   * Note that it may still be valid to send more request messages.
   */
  then<TResult1 = FinishedClientStreamingCall<I, O>, TResult2 = never>(onfulfilled?: ((value: FinishedClientStreamingCall<I, O>) => (PromiseLike<TResult1> | TResult1)) | undefined | null, onrejected?: ((reason: any) => (PromiseLike<TResult2> | TResult2)) | undefined | null): Promise<TResult1 | TResult2>;
  private promiseFinished;
}
/**
 * A completed client streaming RPC call. The server will not send any more
 * messages, but it may still be valid to send request messages.
 */
interface FinishedClientStreamingCall<I extends object, O extends object> {
  /**
   * Reflection information about this call.
   */
  readonly method: MethodInfo<I, O>;
  /**
   * Request headers being sent with the request.
   */
  readonly requestHeaders: Readonly<RpcMetadata>;
  /**
   * The response headers that the server sent.
   */
  readonly headers: RpcMetadata;
  /**
   * The message the server replied with.
   */
  readonly response: O;
  /**
   * The response status the server replied with.
   * The status code will always be OK.
   */
  readonly status: RpcStatus;
  /**
   * The trailers the server attached to the response.
   */
  readonly trailers: RpcMetadata;
}
//#endregion
//#region ../../node_modules/.pnpm/@protobuf-ts+runtime-rpc@2.11.1/node_modules/@protobuf-ts/runtime-rpc/build/types/duplex-streaming-call.d.ts
/**
 * A duplex streaming RPC call. This means that the clients sends an
 * arbitrary amount of messages to the server, while at the same time,
 * the server sends an arbitrary amount of messages to the client.
 */
declare class DuplexStreamingCall<I extends object = object, O extends object = object> implements RpcCallShared<I, O> {
  /**
   * Reflection information about this call.
   */
  readonly method: MethodInfo<I, O>;
  /**
   * Request headers being sent with the request.
   *
   * Request headers are provided in the `meta` property of the
   * `RpcOptions` passed to a call.
   */
  readonly requestHeaders: Readonly<RpcMetadata>;
  /**
   * Request messages from the client.
   */
  readonly requests: RpcInputStream<I>;
  /**
   * The response headers that the server sent.
   *
   * This promise will reject with a `RpcError` when the server sends a
   * error status code.
   */
  readonly headers: Promise<RpcMetadata>;
  /**
   * Response messages from the server.
   */
  readonly responses: RpcOutputStream<O>;
  /**
   * The response status the server replied with.
   *
   * This promise will resolve when the server has finished the request
   * successfully.
   *
   * If the server replies with an error status, this promise will
   * reject with a `RpcError`.
   */
  readonly status: Promise<RpcStatus>;
  /**
   * The trailers the server attached to the response.
   *
   * This promise will resolve when the server has finished the request
   * successfully.
   *
   * If the server replies with an error status, this promise will
   * reject with a `RpcError`.
   */
  readonly trailers: Promise<RpcMetadata>;
  constructor(method: MethodInfo<I, O>, requestHeaders: Readonly<RpcMetadata>, request: RpcInputStream<I>, headers: Promise<RpcMetadata>, response: RpcOutputStream<O>, status: Promise<RpcStatus>, trailers: Promise<RpcMetadata>);
  /**
   * Instead of awaiting the response status and trailers, you can
   * just as well await this call itself to receive the server outcome.
   * Note that it may still be valid to send more request messages.
   */
  then<TResult1 = FinishedDuplexStreamingCall<I, O>, TResult2 = never>(onfulfilled?: ((value: FinishedDuplexStreamingCall<I, O>) => (PromiseLike<TResult1> | TResult1)) | undefined | null, onrejected?: ((reason: any) => (PromiseLike<TResult2> | TResult2)) | undefined | null): Promise<TResult1 | TResult2>;
  private promiseFinished;
}
/**
 * A completed duplex streaming RPC call. The server will not send any more
 * messages, but it may still be valid to send request messages.
 */
interface FinishedDuplexStreamingCall<I extends object, O extends object> {
  /**
   * Reflection information about this call.
   */
  readonly method: MethodInfo<I, O>;
  /**
   * Request headers being sent with the request.
   */
  readonly requestHeaders: Readonly<RpcMetadata>;
  /**
   * The response headers that the server sent.
   */
  readonly headers: RpcMetadata;
  /**
   * The response status the server replied with.
   * The status code will always be OK.
   */
  readonly status: RpcStatus;
  /**
   * The trailers the server attached to the response.
   */
  readonly trailers: RpcMetadata;
}
//#endregion
//#region ../../node_modules/.pnpm/@protobuf-ts+runtime-rpc@2.11.1/node_modules/@protobuf-ts/runtime-rpc/build/types/unary-call.d.ts
/**
 * A unary RPC call. Unary means there is exactly one input message and
 * exactly one output message unless an error occurred.
 */
declare class UnaryCall<I extends object = object, O extends object = object> implements RpcCallShared<I, O>, PromiseLike<FinishedUnaryCall<I, O>> {
  /**
   * Reflection information about this call.
   */
  readonly method: MethodInfo<I, O>;
  /**
   * Request headers being sent with the request.
   *
   * Request headers are provided in the `meta` property of the
   * `RpcOptions` passed to a call.
   */
  readonly requestHeaders: Readonly<RpcMetadata>;
  /**
   * The request message being sent.
   */
  readonly request: Readonly<I>;
  /**
   * The response headers that the server sent.
   *
   * This promise will reject with a `RpcError` when the server sends an
   * error status code.
   */
  readonly headers: Promise<RpcMetadata>;
  /**
   * The message the server replied with.
   *
   * If the server does not send a message, this promise will reject with a
   * `RpcError`.
   */
  readonly response: Promise<O>;
  /**
   * The response status the server replied with.
   *
   * This promise will resolve when the server has finished the request
   * successfully.
   *
   * If the server replies with an error status, this promise will
   * reject with a `RpcError`.
   */
  readonly status: Promise<RpcStatus>;
  /**
   * The trailers the server attached to the response.
   *
   * This promise will resolve when the server has finished the request
   * successfully.
   *
   * If the server replies with an error status, this promise will
   * reject with a `RpcError`.
   */
  readonly trailers: Promise<RpcMetadata>;
  constructor(method: MethodInfo<I, O>, requestHeaders: RpcMetadata, request: I, headers: Promise<RpcMetadata>, response: Promise<O>, status: Promise<RpcStatus>, trailers: Promise<RpcMetadata>);
  /**
   * If you are only interested in the final outcome of this call,
   * you can await it to receive a `FinishedUnaryCall`.
   */
  then<TResult1 = FinishedUnaryCall<I, O>, TResult2 = never>(onfulfilled?: ((value: FinishedUnaryCall<I, O>) => (PromiseLike<TResult1> | TResult1)) | undefined | null, onrejected?: ((reason: any) => (PromiseLike<TResult2> | TResult2)) | undefined | null): Promise<TResult1 | TResult2>;
  private promiseFinished;
}
/**
 * A completed unary RPC call. This will only exists if the RPC was
 * successful.
 */
interface FinishedUnaryCall<I extends object, O extends object> {
  /**
   * Reflection information about this call.
   */
  readonly method: MethodInfo<I, O>;
  /**
   * Request headers being sent with the request.
   */
  readonly requestHeaders: Readonly<RpcMetadata>;
  /**
   * The request message that has been sent.
   */
  readonly request: Readonly<I>;
  /**
   * The response headers that the server sent.
   */
  readonly headers: RpcMetadata;
  /**
   * The message the server replied with.
   */
  readonly response: O;
  /**
   * The response status the server replied with.
   * The status code will always be OK.
   */
  readonly status: RpcStatus;
  /**
   * The trailers the server attached to the response.
   */
  readonly trailers: RpcMetadata;
}
//#endregion
//#region ../../node_modules/.pnpm/@protobuf-ts+runtime-rpc@2.11.1/node_modules/@protobuf-ts/runtime-rpc/build/types/rpc-transport.d.ts
/**
 * A `RpcTransport` executes Remote Procedure Calls defined by a protobuf
 * service.
 *
 * This interface is the contract between a generated service client and
 * some wire protocol like grpc, grpc-web, Twirp or other.
 *
 * The transport receives reflection information about the service and
 * method being called.
 *
 * Some rules:
 *
 * a) An implementation **should** accept default `RpcOptions` (or an
 * interface that extends `RpcOptions`) in the constructor.
 *
 * b) An implementation **must** merge the options given to `mergeOptions()`
 * with its default options. If no extra options are implemented, or only
 * primitive option values are used, using `mergeRpcOptions()` will
 * produce the required behaviour.
 *
 * c) An implementation **must** pass `RpcOptions.jsonOptions` and
 * `RpcOptions.binaryOptions` to the `fromBinary`, `toBinary`, `fromJson`
 * and `toJson` methods when preparing a request or parsing a response.
 *
 * d) An implementation may support arbitrary other options, but they **must
 * not** interfere with options keys of the binary or JSON options.
 */
interface RpcTransport {
  /**
   * Merge call options with default options.
   * Generated service clients will call this method with the users'
   * call options and pass the result to the execute-method below.
   */
  mergeOptions(options?: Partial<RpcOptions>): RpcOptions;
  /**
   * Execute an unary RPC.
   */
  unary<I extends object, O extends object>(method: MethodInfo<I, O>, input: I, options: RpcOptions): UnaryCall<I, O>;
  /**
   * Execute a server streaming RPC.
   */
  serverStreaming<I extends object, O extends object>(method: MethodInfo<I, O>, input: I, options: RpcOptions): ServerStreamingCall<I, O>;
  /**
   * Execute a client streaming RPC.
   */
  clientStreaming<I extends object, O extends object>(method: MethodInfo<I, O>, options: RpcOptions): ClientStreamingCall<I, O>;
  /**
   * Execute a duplex streaming RPC.
   */
  duplex<I extends object, O extends object>(method: MethodInfo<I, O>, options: RpcOptions): DuplexStreamingCall<I, O>;
}
//#endregion
//#region ../../node_modules/.pnpm/@protobuf-ts+runtime-rpc@2.11.1/node_modules/@protobuf-ts/runtime-rpc/build/types/rpc-interceptor.d.ts
/**
 * Interceptors can be used to manipulate request and response data.
 *
 * They are commonly used to add authentication metadata, log requests
 * or implement client side caching.
 *
 * Interceptors are stacked. Call next() to invoke the next interceptor
 * on the stack. To manipulate the request, change the data passed to
 * next(). To manipulate a response, change the data returned by next().
 *
 * The following example adds an 'Authorization' header to unary calls:
 *
 * ```typescript
 * interceptUnary(next, method, input, options): UnaryCall {
 *   if (!options.meta) {
 *     options.meta = {};
 *   }
 *   options.meta['Authorization'] = 'xxx';
 *   return next(method, input, options);
 * }
 * ```
 *
 * The following example intercepts server streaming calls. Every
 * message that the server sends is emitted twice to the client:
 *
 * ```typescript
 * interceptServerStreaming(next, method, input, options) {
 *   let original = next(method, input, options);
 *   let response = new RpcOutputStreamController();
 *   original.response.onNext((message, error, done) => {
 *     if (message) {
 *       response.notifyMessage(message);
 *       response.notifyMessage(message);
 *     }
 *     if (error)
 *       response.notifyError(error);
 *     if (done)
 *       response.notifyComplete();
 *   });
 *   return new ServerStreamingCall(
 *     original.method,
 *     original.requestHeaders,
 *     original.request,
 *     original.headers,
 *     response,
 *     original.status,
 *     original.trailers
 *   );
 * }
 * ```
 *
 */
interface RpcInterceptor {
  interceptUnary?(next: NextUnaryFn, method: MethodInfo, input: object, options: RpcOptions): UnaryCall;
  interceptServerStreaming?(next: NextServerStreamingFn, method: MethodInfo, input: object, options: RpcOptions): ServerStreamingCall;
  interceptClientStreaming?(next: NextClientStreamingFn, method: MethodInfo, options: RpcOptions): ClientStreamingCall;
  interceptDuplex?(next: NextDuplexStreamingFn, method: MethodInfo, options: RpcOptions): DuplexStreamingCall;
}
/**
 * Invokes the next interceptor on the stack and returns its result.
 */
declare type NextUnaryFn = (method: MethodInfo, input: object, options: RpcOptions) => UnaryCall;
/**
 * Invokes the next interceptor on the stack and returns its result.
 */
declare type NextServerStreamingFn = (method: MethodInfo, input: object, options: RpcOptions) => ServerStreamingCall;
/**
 * Invokes the next interceptor on the stack and returns its result.
 */
declare type NextClientStreamingFn = (method: MethodInfo, options: RpcOptions) => ClientStreamingCall;
/**
 * Invokes the next interceptor on the stack and returns its result.
 */
declare type NextDuplexStreamingFn = (method: MethodInfo, options: RpcOptions) => DuplexStreamingCall;
//#endregion
//#region ../../node_modules/.pnpm/@protobuf-ts+runtime-rpc@2.11.1/node_modules/@protobuf-ts/runtime-rpc/build/types/rpc-options.d.ts
/**
 * User-provided options for Remote Procedure Calls.
 *
 * Every generated service method accepts these options.
 * They are passed on to the `RpcTransport` and can be evaluated there.
 */
interface RpcOptions {
  /**
   * Meta data for the call.
   *
   * RPC meta data are simple key-value pairs that usually translate
   * directly to HTTP request headers.
   *
   * If a key ends with `-bin`, it should contain binary data in base64
   * encoding, allowing you to send serialized messages.
   */
  meta?: RpcMetadata;
  /**
   * Timeout for the call in milliseconds.
   * If a Date object is given, it is used as a deadline.
   */
  timeout?: number | Date;
  /**
   * Interceptors can be used to manipulate request and response data.
   * The most common use case is adding a "Authorization" header.
   */
  interceptors?: RpcInterceptor[];
  /**
   * Options for the JSON wire format.
   *
   * To send or receive `google.protobuf.Any` in JSON format, you must
   * provide `jsonOptions.typeRegistry` so that the runtime can discriminate
   * the packed type.
   */
  jsonOptions?: Partial<JsonReadOptions & JsonWriteOptions>;
  /**
   * Options for the binary wire format.
   */
  binaryOptions?: Partial<BinaryReadOptions & BinaryWriteOptions>;
  /**
   * A signal to cancel a call. Can be created with an [AbortController](https://developer.mozilla.org/en-US/docs/Web/API/AbortController).
   * The npm package `abort-controller` provides a polyfill for Node.js.
   */
  abort?: AbortSignal;
  /**
   * A `RpcTransport` implementation may allow arbitrary
   * other options.
   */
  [extra: string]: unknown;
}
//#endregion
//#region src/types/token.d.ts
declare const TokenType: {
  readonly Ibc: "ibc";
  readonly Cw20: "cw20";
  readonly Spl: "spl";
  readonly Erc20: "erc20";
  readonly Lp: "lp";
  readonly Evm: "evm";
  readonly Native: "native";
  readonly Symbol: "symbol";
  readonly TokenFactory: "tokenFactory";
  readonly InsuranceFund: "insuranceFund";
  readonly Unknown: "unknown";
};
type TokenType = (typeof TokenType)[keyof typeof TokenType];
declare const TokenVerification: {
  readonly Verified: "verified";
  readonly Submitted: "submitted";
  readonly Internal: "internal";
  readonly External: "external";
  readonly Unverified: "unverified";
};
type TokenVerification = (typeof TokenVerification)[keyof typeof TokenVerification];
declare const TokenSource: {
  readonly Aptos: "aptos";
  readonly Solana: "solana";
  readonly Cosmos: "cosmos";
  readonly Ethereum: "ethereum";
  readonly EthereumWh: "ethereum-wormhole";
  readonly Polygon: "polygon";
  readonly Klaytn: "klaytn";
  readonly Arbitrum: "arbitrum";
  readonly Sui: "sui";
  readonly Ibc: "ibc";
  readonly BinanceSmartChain: "binance-smart-chain";
  readonly Axelar: "axelar";
};
type TokenSource = (typeof TokenSource)[keyof typeof TokenSource];
interface TokenStatic {
  name: string;
  logo: string;
  symbol: string;
  decimals: number;
  coinGeckoId: string;
  denom: string;
  address: string;
  tokenType: TokenType;
  tokenVerification: TokenVerification;
  isNative?: boolean;
  source?: TokenSource;
  hash?: string;
  path?: string;
  channelId?: string;
  baseDenom?: string;
  description?: string;
  externalLogo?: string;
  overrideSymbol?: string;
}
interface TokenMeta {
  name: string;
  logo: string;
  symbol: string;
  decimals: number;
  tokenType: TokenType;
  coinGeckoId: string;
}
//#endregion
//#region src/types/stream.d.ts
/**
 * Subscription interface for stream management with event-based lifecycle
 */
/**
 * gRPC Status Codes
 * @see https://grpc.io/docs/guides/status-codes/
 */
declare const GrpcStatusCode: {
  readonly OK: 0;
  readonly CANCELLED: 1;
  readonly UNKNOWN: 2;
  readonly INVALID_ARGUMENT: 3;
  readonly DEADLINE_EXCEEDED: 4;
  readonly NOT_FOUND: 5;
  readonly ALREADY_EXISTS: 6;
  readonly PERMISSION_DENIED: 7;
  readonly RESOURCE_EXHAUSTED: 8;
  readonly FAILED_PRECONDITION: 9;
  readonly ABORTED: 10;
  readonly OUT_OF_RANGE: 11;
  readonly UNIMPLEMENTED: 12;
  readonly INTERNAL: 13;
  readonly UNAVAILABLE: 14;
  readonly DATA_LOSS: 15;
  readonly UNAUTHENTICATED: 16;
};
type GrpcStatusCode = (typeof GrpcStatusCode)[keyof typeof GrpcStatusCode];
/**
 * Enhanced disconnect reasons with gRPC error code mapping
 */
declare const StreamDisconnectReason: {
  /** User explicitly called stop() */
  readonly UserStopped: "user-stopped";
  /** Stream encountered an error */
  readonly StreamError: "stream-error";
  /** Network unavailable (gRPC code 14) */
  readonly NetworkError: "network-error";
  /** Request timeout (gRPC code 4) */
  readonly Timeout: "timeout";
  /** Authentication/authorization failed (gRPC code 7 or 16) */
  readonly AuthenticationError: "authentication-error";
  /** Invalid request - non-retryable (gRPC code 3, 5, 6, 11, 12) */
  readonly InvalidRequest: "invalid-request";
  /** Rate limited (gRPC code 8) */
  readonly RateLimited: "rate-limited";
  /** Max retry attempts reached */
  readonly MaxRetries: "max-retries";
  /** Stream ended normally */
  readonly StreamEnded: "stream-ended";
};
type StreamDisconnectReason = (typeof StreamDisconnectReason)[keyof typeof StreamDisconnectReason];
declare const StreamEvent: {
  readonly Data: "data";
  readonly Connect: "connect";
  readonly Disconnect: "disconnect";
  readonly Retry: "retry";
  readonly StateChange: "state:change";
  readonly Error: "error";
  readonly Warn: "warn";
};
type StreamEvent = (typeof StreamEvent)[keyof typeof StreamEvent];
interface StreamSubscription {
  /** Unsubscribe from the stream and cancel it */
  unsubscribe(): void;
  /** Listen for stream errors */
  on(event: 'error', handler: (error: StreamError) => void): void;
  /** Listen for stream completion (ended normally) */
  on(event: 'complete', handler: () => void): void;
  /** Remove event listener */
  off(event: 'error' | 'complete', handler: (...args: any[]) => void): void;
}
/**
 * Error information from stream with gRPC error codes
 *
 * Common gRPC Status Codes:
 * - 0: OK
 * - 1: CANCELLED
 * - 2: UNKNOWN
 * - 3: INVALID_ARGUMENT
 * - 4: DEADLINE_EXCEEDED
 * - 5: NOT_FOUND
 * - 7: PERMISSION_DENIED
 * - 8: RESOURCE_EXHAUSTED
 * - 13: INTERNAL
 * - 14: UNAVAILABLE
 * - 16: UNAUTHENTICATED
 */
interface StreamError {
  /** gRPC status code */
  code: number;
  /** Human-readable error message */
  details: string;
  /** Additional error metadata */
  metadata?: any;
}
/**
 * StreamManager
 */
declare const StreamState: {
  readonly Idle: "idle";
  readonly Connecting: "connecting";
  readonly Connected: "connected";
  readonly Reconnecting: "reconnecting";
  readonly Stopped: "stopped";
};
type StreamState = (typeof StreamState)[keyof typeof StreamState];
/**
 * Stream manager retry configuration
 */
interface StreamManagerRetryConfig {
  /** Enable retry on failure (default: true) */
  enabled: boolean;
  /** Max retry attempts before giving up (default: 5, 0 = infinite) */
  maxAttempts: number;
  /** Initial backoff delay in ms (default: 1000) */
  initialDelayMs: number;
  /** Max backoff delay in ms (default: 30000) */
  maxDelayMs: number;
  /** Backoff multiplier (default: 2 for exponential) */
  backoffMultiplier: number;
  /**
   * Persistent retry mode - continues retrying at maxDelayMs intervals
   * after exhausting exponential backoff (default: true)
   */
  persistent: boolean;
}
/**
 * Stream manager configuration
 */
interface StreamManagerConfig<TResponse> {
  /** Unique identifier for this stream (for logging) */
  id: string;
  /**
   * Factory function to create the stream subscription
   * Called on initial connect and every retry
   * The subscription will emit 'error' and 'complete' events for stream lifecycle
   */
  streamFactory: () => StreamSubscription;
  /** Callback to handle stream data */
  onData: (response: TResponse) => void;
  /** Retry configuration */
  retryConfig?: Partial<StreamManagerRetryConfig>;
}
/**
 * Internal resolved configuration with all required types
 */
interface ResolvedStreamManagerConfig<TResponse> {
  id: string;
  streamFactory: () => StreamSubscription;
  onData: (response: TResponse) => void;
  retryConfig: StreamManagerRetryConfig;
}
/**
 * Event payload types for StreamManager
 */
interface StreamManagerEvents<TResponse> {
  data: TResponse;
  connect: {
    isReconnect: boolean;
    attempt: number;
  };
  disconnect: {
    reason: StreamDisconnectReason;
    willRetry: boolean;
    attempt?: number;
  };
  retry: {
    attempt: number;
    delayMs: number;
    nextBackoff: number | null;
  };
  'state:change': {
    from: StreamState;
    to: StreamState;
  };
  error: {
    message: string;
    code?: number;
    details?: any;
  };
  warn: {
    message: string;
  };
}
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/injective/oracle/v1beta1/oracle_pb.d.ts
/**
 * @generated from protobuf message injective.oracle.v1beta1.Params
 */
interface Params$1 {
  /**
   * @generated from protobuf field: string pyth_contract = 1
   */
  pythContract: string;
}
/**
 * @generated from protobuf message injective.oracle.v1beta1.BandOracleRequest
 */
interface BandOracleRequest {
  /**
   * Unique Identifier for band ibc oracle request
   *
   * @generated from protobuf field: uint64 request_id = 1
   */
  requestId: bigint;
  /**
   * OracleScriptID is the unique identifier of the oracle script to be
   * executed.
   *
   * @generated from protobuf field: int64 oracle_script_id = 2
   */
  oracleScriptId: bigint;
  /**
   * Symbols is the list of symbols to prepare in the calldata
   *
   * @generated from protobuf field: repeated string symbols = 3
   */
  symbols: string[];
  /**
   * AskCount is the number of validators that are requested to respond to this
   * oracle request. Higher value means more security, at a higher gas cost.
   *
   * @generated from protobuf field: uint64 ask_count = 4
   */
  askCount: bigint;
  /**
   * MinCount is the minimum number of validators necessary for the request to
   * proceed to the execution phase. Higher value means more security, at the
   * cost of liveness.
   *
   * @generated from protobuf field: uint64 min_count = 5
   */
  minCount: bigint;
  /**
   * FeeLimit is the maximum tokens that will be paid to all data source
   * providers.
   *
   * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin fee_limit = 6
   */
  feeLimit: Coin$1[];
  /**
   * PrepareGas is amount of gas to pay to prepare raw requests
   *
   * @generated from protobuf field: uint64 prepare_gas = 7
   */
  prepareGas: bigint;
  /**
   * ExecuteGas is amount of gas to reserve for executing
   *
   * @generated from protobuf field: uint64 execute_gas = 8
   */
  executeGas: bigint;
  /**
   * MinSourceCount is the minimum number of data sources that must be used by
   * each validator
   *
   * @generated from protobuf field: uint64 min_source_count = 9
   */
  minSourceCount: bigint;
}
/**
 * @generated from protobuf message injective.oracle.v1beta1.BandIBCParams
 */
interface BandIBCParams {
  /**
   * true if Band IBC should be enabled
   *
   * @generated from protobuf field: bool band_ibc_enabled = 1
   */
  bandIbcEnabled: boolean;
  /**
   * block request interval to send Band IBC prices
   *
   * @generated from protobuf field: int64 ibc_request_interval = 2
   */
  ibcRequestInterval: bigint;
  /**
   * band IBC source channel
   *
   * @generated from protobuf field: string ibc_source_channel = 3
   */
  ibcSourceChannel: string;
  /**
   * band IBC version
   *
   * @generated from protobuf field: string ibc_version = 4
   */
  ibcVersion: string;
  /**
   * band IBC portID
   *
   * @generated from protobuf field: string ibc_port_id = 5
   */
  ibcPortId: string;
  /**
   *  legacy oracle scheme ids
   *
   * @generated from protobuf field: repeated int64 legacy_oracle_ids = 6
   */
  legacyOracleIds: bigint[];
}
/**
 * @generated from protobuf enum injective.oracle.v1beta1.OracleType
 */
declare enum OracleType {
  /**
   * @generated from protobuf enum value: Unspecified = 0;
   */
  Unspecified = 0,
  /**
   * @generated from protobuf enum value: Band = 1;
   */
  Band = 1,
  /**
   * @generated from protobuf enum value: PriceFeed = 2;
   */
  PriceFeed = 2,
  /**
   * @generated from protobuf enum value: Coinbase = 3;
   */
  Coinbase = 3,
  /**
   * @generated from protobuf enum value: Chainlink = 4;
   */
  Chainlink = 4,
  /**
   * @generated from protobuf enum value: Razor = 5;
   */
  Razor = 5,
  /**
   * @generated from protobuf enum value: Dia = 6;
   */
  Dia = 6,
  /**
   * @generated from protobuf enum value: API3 = 7;
   */
  API3 = 7,
  /**
   * @generated from protobuf enum value: Uma = 8;
   */
  Uma = 8,
  /**
   * @generated from protobuf enum value: Pyth = 9;
   */
  Pyth = 9,
  /**
   * @generated from protobuf enum value: BandIBC = 10;
   */
  BandIBC = 10,
  /**
   * @generated from protobuf enum value: Provider = 11;
   */
  Provider = 11,
  /**
   * @generated from protobuf enum value: Stork = 12;
   */
  Stork = 12,
}
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.Params
 */
declare const Params$1 = new Params$Type();
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.BandOracleRequest
 */
declare const BandOracleRequest = new BandOracleRequest$Type();
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.BandIBCParams
 */
declare const BandIBCParams = new BandIBCParams$Type();
//#endregion
//#region ../../node_modules/.pnpm/@injectivelabs+core-proto-ts-v2@1.17.3/node_modules/@injectivelabs/core-proto-ts-v2/esm/generated/injective/exchange/v1beta1/exchange_pb.d.ts
/**
 * @generated from protobuf message injective.exchange.v1beta1.OpenNotionalCap
 */
interface OpenNotionalCap {
  /**
   * @generated from protobuf oneof: cap
   */
  cap: {
    oneofKind: "uncapped";
    /**
     * @generated from protobuf field: injective.exchange.v1beta1.OpenNotionalCapUncapped uncapped = 1
     */
    uncapped: OpenNotionalCapUncapped;
  } | {
    oneofKind: "capped";
    /**
     * @generated from protobuf field: injective.exchange.v1beta1.OpenNotionalCapCapped capped = 2
     */
    capped: OpenNotionalCapCapped;
  } | {
    oneofKind: undefined;
  };
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.OpenNotionalCapUncapped
 */
interface OpenNotionalCapUncapped {}
/**
 * @generated from protobuf message injective.exchange.v1beta1.OpenNotionalCapCapped
 */
interface OpenNotionalCapCapped {
  /**
   * @generated from protobuf field: string value = 1
   */
  value: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.Params
 */
interface Params {
  /**
   * spot_market_instant_listing_fee defines the expedited fee in INJ required
   * to create a spot market by bypassing governance
   *
   * @generated from protobuf field: cosmos.base.v1beta1.Coin spot_market_instant_listing_fee = 1
   */
  spotMarketInstantListingFee?: Coin$1;
  /**
   * derivative_market_instant_listing_fee defines the expedited fee in INJ
   * required to create a derivative market by bypassing governance
   *
   * @generated from protobuf field: cosmos.base.v1beta1.Coin derivative_market_instant_listing_fee = 2
   */
  derivativeMarketInstantListingFee?: Coin$1;
  /**
   * default_spot_maker_fee defines the default exchange trade fee for makers on
   * a spot market
   *
   * @generated from protobuf field: string default_spot_maker_fee_rate = 3
   */
  defaultSpotMakerFeeRate: string;
  /**
   * default_spot_taker_fee_rate defines the default exchange trade fee rate for
   * takers on a new spot market
   *
   * @generated from protobuf field: string default_spot_taker_fee_rate = 4
   */
  defaultSpotTakerFeeRate: string;
  /**
   * default_derivative_maker_fee defines the default exchange trade fee for
   * makers on a new derivative market
   *
   * @generated from protobuf field: string default_derivative_maker_fee_rate = 5
   */
  defaultDerivativeMakerFeeRate: string;
  /**
   * default_derivative_taker_fee defines the default exchange trade fee for
   * takers on a new derivative market
   *
   * @generated from protobuf field: string default_derivative_taker_fee_rate = 6
   */
  defaultDerivativeTakerFeeRate: string;
  /**
   * default_initial_margin_ratio defines the default initial margin ratio on a
   * new derivative market
   *
   * @generated from protobuf field: string default_initial_margin_ratio = 7
   */
  defaultInitialMarginRatio: string;
  /**
   * default_maintenance_margin_ratio defines the default maintenance margin
   * ratio on a new derivative market
   *
   * @generated from protobuf field: string default_maintenance_margin_ratio = 8
   */
  defaultMaintenanceMarginRatio: string;
  /**
   * default_funding_interval defines the default funding interval on a
   * derivative market
   *
   * @generated from protobuf field: int64 default_funding_interval = 9
   */
  defaultFundingInterval: bigint;
  /**
   * funding_multiple defines the timestamp multiple that the funding timestamp
   * should be a multiple of
   *
   * @generated from protobuf field: int64 funding_multiple = 10
   */
  fundingMultiple: bigint;
  /**
   * relayer_fee_share_rate defines the trade fee share percentage that goes to
   * relayers
   *
   * @generated from protobuf field: string relayer_fee_share_rate = 11
   */
  relayerFeeShareRate: string;
  /**
   * default_hourly_funding_rate_cap defines the default maximum absolute value
   * of the hourly funding rate
   *
   * @generated from protobuf field: string default_hourly_funding_rate_cap = 12
   */
  defaultHourlyFundingRateCap: string;
  /**
   * hourly_interest_rate defines the hourly interest rate
   *
   * @generated from protobuf field: string default_hourly_interest_rate = 13
   */
  defaultHourlyInterestRate: string;
  /**
   * max_derivative_order_side_count defines the maximum number of derivative
   * active orders a subaccount can have for a given orderbook side
   *
   * @generated from protobuf field: uint32 max_derivative_order_side_count = 14
   */
  maxDerivativeOrderSideCount: number;
  /**
   * inj_reward_staked_requirement_threshold defines the threshold on INJ
   * rewards after which one also needs staked INJ to receive more
   *
   * @generated from protobuf field: string inj_reward_staked_requirement_threshold = 15
   */
  injRewardStakedRequirementThreshold: string;
  /**
   * the trading_rewards_vesting_duration defines the vesting times for trading
   * rewards
   *
   * @generated from protobuf field: int64 trading_rewards_vesting_duration = 16
   */
  tradingRewardsVestingDuration: bigint;
  /**
   * liquidator_reward_share_rate defines the ratio of the split of the surplus
   * collateral that goes to the liquidator
   *
   * @generated from protobuf field: string liquidator_reward_share_rate = 17
   */
  liquidatorRewardShareRate: string;
  /**
   * binary_options_market_instant_listing_fee defines the expedited fee in INJ
   * required to create a derivative market by bypassing governance
   *
   * @generated from protobuf field: cosmos.base.v1beta1.Coin binary_options_market_instant_listing_fee = 18
   */
  binaryOptionsMarketInstantListingFee?: Coin$1;
  /**
   * atomic_market_order_access_level defines the required access permissions
   * for executing atomic market orders
   *
   * @generated from protobuf field: injective.exchange.v1beta1.AtomicMarketOrderAccessLevel atomic_market_order_access_level = 19
   */
  atomicMarketOrderAccessLevel: AtomicMarketOrderAccessLevel;
  /**
   * spot_atomic_market_order_fee_multiplier defines the default multiplier for
   * executing atomic market orders in spot markets
   *
   * @generated from protobuf field: string spot_atomic_market_order_fee_multiplier = 20
   */
  spotAtomicMarketOrderFeeMultiplier: string;
  /**
   * derivative_atomic_market_order_fee_multiplier defines the default
   * multiplier for executing atomic market orders in derivative markets
   *
   * @generated from protobuf field: string derivative_atomic_market_order_fee_multiplier = 21
   */
  derivativeAtomicMarketOrderFeeMultiplier: string;
  /**
   * binary_options_atomic_market_order_fee_multiplier defines the default
   * multiplier for executing atomic market orders in binary markets
   *
   * @generated from protobuf field: string binary_options_atomic_market_order_fee_multiplier = 22
   */
  binaryOptionsAtomicMarketOrderFeeMultiplier: string;
  /**
   * minimal_protocol_fee_rate defines the minimal protocol fee rate
   *
   * @generated from protobuf field: string minimal_protocol_fee_rate = 23
   */
  minimalProtocolFeeRate: string;
  /**
   * is_instant_derivative_market_launch_enabled defines whether instant
   * derivative market launch is enabled
   *
   * @generated from protobuf field: bool is_instant_derivative_market_launch_enabled = 24
   */
  isInstantDerivativeMarketLaunchEnabled: boolean;
  /**
   * @generated from protobuf field: int64 post_only_mode_height_threshold = 25
   */
  postOnlyModeHeightThreshold: bigint;
  /**
   * Maximum time in seconds since the last mark price update to allow a
   * decrease in margin
   *
   * @generated from protobuf field: int64 margin_decrease_price_timestamp_threshold_seconds = 26
   */
  marginDecreasePriceTimestampThresholdSeconds: bigint;
  /**
   * List of addresses that are allowed to perform exchange admin operations
   *
   * @generated from protobuf field: repeated string exchange_admins = 27
   */
  exchangeAdmins: string[];
  /**
   * inj_auction_max_cap defines the maximum cap for INJ sent to auction
   *
   * @generated from protobuf field: string inj_auction_max_cap = 28
   */
  injAuctionMaxCap: string;
  /**
   * fixed_gas_enabled indicates if msg server will consume fixed gas amount for
   * certain msg types
   *
   * @generated from protobuf field: bool fixed_gas_enabled = 29
   */
  fixedGasEnabled: boolean;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.MarketFeeMultiplier
 */
interface MarketFeeMultiplier {
  /**
   * @generated from protobuf field: string market_id = 1
   */
  marketId: string;
  /**
   * @generated from protobuf field: string fee_multiplier = 2
   */
  feeMultiplier: string;
}
/**
 * An object describing a derivative market in the Injective Futures Protocol.
 *
 * @generated from protobuf message injective.exchange.v1beta1.DerivativeMarket
 */
interface DerivativeMarket {
  /**
   * Ticker for the derivative contract.
   *
   * @generated from protobuf field: string ticker = 1
   */
  ticker: string;
  /**
   * Oracle base currency
   *
   * @generated from protobuf field: string oracle_base = 2
   */
  oracleBase: string;
  /**
   * Oracle quote currency
   *
   * @generated from protobuf field: string oracle_quote = 3
   */
  oracleQuote: string;
  /**
   * Oracle type
   *
   * @generated from protobuf field: injective.oracle.v1beta1.OracleType oracle_type = 4
   */
  oracleType: OracleType;
  /**
   * Scale factor for oracle prices.
   *
   * @generated from protobuf field: uint32 oracle_scale_factor = 5
   */
  oracleScaleFactor: number;
  /**
   * Address of the quote currency denomination for the derivative contract
   *
   * @generated from protobuf field: string quote_denom = 6
   */
  quoteDenom: string;
  /**
   * Unique market ID.
   *
   * @generated from protobuf field: string market_id = 7
   */
  marketId: string;
  /**
   * initial_margin_ratio defines the initial margin ratio of a derivative
   * market
   *
   * @generated from protobuf field: string initial_margin_ratio = 8
   */
  initialMarginRatio: string;
  /**
   * maintenance_margin_ratio defines the maintenance margin ratio of a
   * derivative market
   *
   * @generated from protobuf field: string maintenance_margin_ratio = 9
   */
  maintenanceMarginRatio: string;
  /**
   * maker_fee_rate defines the maker fee rate of a derivative market
   *
   * @generated from protobuf field: string maker_fee_rate = 10
   */
  makerFeeRate: string;
  /**
   * taker_fee_rate defines the taker fee rate of a derivative market
   *
   * @generated from protobuf field: string taker_fee_rate = 11
   */
  takerFeeRate: string;
  /**
   * relayer_fee_share_rate defines the percentage of the transaction fee shared
   * with the relayer in a derivative market
   *
   * @generated from protobuf field: string relayer_fee_share_rate = 12
   */
  relayerFeeShareRate: string;
  /**
   * true if the market is a perpetual market. false if the market is an expiry
   * futures market
   *
   * @generated from protobuf field: bool isPerpetual = 13
   */
  isPerpetual: boolean;
  /**
   * Status of the market
   *
   * @generated from protobuf field: injective.exchange.v1beta1.MarketStatus status = 14
   */
  status: MarketStatus;
  /**
   * min_price_tick_size defines the minimum tick size that the price and margin
   * required for orders in the market (in chain format)
   *
   * @generated from protobuf field: string min_price_tick_size = 15
   */
  minPriceTickSize: string;
  /**
   * min_quantity_tick_size defines the minimum tick size of the quantity
   * required for orders in the market (in chain format)
   *
   * @generated from protobuf field: string min_quantity_tick_size = 16
   */
  minQuantityTickSize: string;
  /**
   * min_notional defines the minimum notional (in quote asset) required for
   * orders in the market (in chain format)
   *
   * @generated from protobuf field: string min_notional = 17
   */
  minNotional: string;
  /**
   * current market admin
   *
   * @generated from protobuf field: string admin = 18
   */
  admin: string;
  /**
   * level of admin permissions
   *
   * @generated from protobuf field: uint32 admin_permissions = 19
   */
  adminPermissions: number;
  /**
   * quote token decimals
   *
   * @generated from protobuf field: uint32 quote_decimals = 20
   */
  quoteDecimals: number;
  /**
   * reduce_margin_ratio defines the ratio of the margin that is reduced
   *
   * @generated from protobuf field: string reduce_margin_ratio = 21
   */
  reduceMarginRatio: string;
  /**
   * open_notional_cap defines the maximum open notional for the market
   *
   * @generated from protobuf field: injective.exchange.v1beta1.OpenNotionalCap open_notional_cap = 22
   */
  openNotionalCap?: OpenNotionalCap;
}
/**
 * An object describing a binary options market in Injective Protocol.
 *
 * @generated from protobuf message injective.exchange.v1beta1.BinaryOptionsMarket
 */
interface BinaryOptionsMarket {
  /**
   * Ticker for the derivative contract.
   *
   * @generated from protobuf field: string ticker = 1
   */
  ticker: string;
  /**
   * Oracle symbol
   *
   * @generated from protobuf field: string oracle_symbol = 2
   */
  oracleSymbol: string;
  /**
   * Oracle Provider
   *
   * @generated from protobuf field: string oracle_provider = 3
   */
  oracleProvider: string;
  /**
   * Oracle type
   *
   * @generated from protobuf field: injective.oracle.v1beta1.OracleType oracle_type = 4
   */
  oracleType: OracleType;
  /**
   * Scale factor for oracle prices.
   *
   * @generated from protobuf field: uint32 oracle_scale_factor = 5
   */
  oracleScaleFactor: number;
  /**
   * expiration timestamp
   *
   * @generated from protobuf field: int64 expiration_timestamp = 6
   */
  expirationTimestamp: bigint;
  /**
   * expiration timestamp
   *
   * @generated from protobuf field: int64 settlement_timestamp = 7
   */
  settlementTimestamp: bigint;
  /**
   * admin of the market
   *
   * @generated from protobuf field: string admin = 8
   */
  admin: string;
  /**
   * Address of the quote currency denomination for the binary options contract
   *
   * @generated from protobuf field: string quote_denom = 9
   */
  quoteDenom: string;
  /**
   * Unique market ID.
   *
   * @generated from protobuf field: string market_id = 10
   */
  marketId: string;
  /**
   * maker_fee_rate defines the maker fee rate of a binary options market
   *
   * @generated from protobuf field: string maker_fee_rate = 11
   */
  makerFeeRate: string;
  /**
   * taker_fee_rate defines the taker fee rate of a derivative market
   *
   * @generated from protobuf field: string taker_fee_rate = 12
   */
  takerFeeRate: string;
  /**
   * relayer_fee_share_rate defines the percentage of the transaction fee shared
   * with the relayer in a derivative market
   *
   * @generated from protobuf field: string relayer_fee_share_rate = 13
   */
  relayerFeeShareRate: string;
  /**
   * Status of the market
   *
   * @generated from protobuf field: injective.exchange.v1beta1.MarketStatus status = 14
   */
  status: MarketStatus;
  /**
   * min_price_tick_size defines the minimum tick size that the price and margin
   * required for orders in the market
   *
   * @generated from protobuf field: string min_price_tick_size = 15
   */
  minPriceTickSize: string;
  /**
   * min_quantity_tick_size defines the minimum tick size of the quantity
   * required for orders in the market
   *
   * @generated from protobuf field: string min_quantity_tick_size = 16
   */
  minQuantityTickSize: string;
  /**
   * @generated from protobuf field: string settlement_price = 17
   */
  settlementPrice: string;
  /**
   * min_notional defines the minimum notional (in quote asset) required for
   * orders in the market
   *
   * @generated from protobuf field: string min_notional = 18
   */
  minNotional: string;
  /**
   * level of admin permissions
   *
   * @generated from protobuf field: uint32 admin_permissions = 19
   */
  adminPermissions: number;
  /**
   * quote token decimals
   *
   * @generated from protobuf field: uint32 quote_decimals = 20
   */
  quoteDecimals: number;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.ExpiryFuturesMarketInfo
 */
interface ExpiryFuturesMarketInfo {
  /**
   * market ID.
   *
   * @generated from protobuf field: string market_id = 1
   */
  marketId: string;
  /**
   * expiration_timestamp defines the expiration time for a time expiry futures
   * market.
   *
   * @generated from protobuf field: int64 expiration_timestamp = 2
   */
  expirationTimestamp: bigint;
  /**
   * expiration_twap_start_timestamp defines the start time of the TWAP
   * calculation window
   *
   * @generated from protobuf field: int64 twap_start_timestamp = 3
   */
  twapStartTimestamp: bigint;
  /**
   * expiration_twap_start_price_cumulative defines the cumulative price for the
   * start of the TWAP window (in chain format)
   *
   * @generated from protobuf field: string expiration_twap_start_price_cumulative = 4
   */
  expirationTwapStartPriceCumulative: string;
  /**
   * settlement_price defines the settlement price for a time expiry futures
   * market (in chain format)
   *
   * @generated from protobuf field: string settlement_price = 5
   */
  settlementPrice: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.PerpetualMarketInfo
 */
interface PerpetualMarketInfo {
  /**
   * market ID.
   *
   * @generated from protobuf field: string market_id = 1
   */
  marketId: string;
  /**
   * hourly_funding_rate_cap defines the maximum absolute value of the hourly
   * funding rate
   *
   * @generated from protobuf field: string hourly_funding_rate_cap = 2
   */
  hourlyFundingRateCap: string;
  /**
   * hourly_interest_rate defines the hourly interest rate
   *
   * @generated from protobuf field: string hourly_interest_rate = 3
   */
  hourlyInterestRate: string;
  /**
   * next_funding_timestamp defines the next funding timestamp in seconds of a
   * perpetual market
   *
   * @generated from protobuf field: int64 next_funding_timestamp = 4
   */
  nextFundingTimestamp: bigint;
  /**
   * funding_interval defines the next funding interval in seconds of a
   * perpetual market.
   *
   * @generated from protobuf field: int64 funding_interval = 5
   */
  fundingInterval: bigint;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.PerpetualMarketFunding
 */
interface PerpetualMarketFunding {
  /**
   * cumulative_funding defines the cumulative funding of a perpetual market.
   *
   * @generated from protobuf field: string cumulative_funding = 1
   */
  cumulativeFunding: string;
  /**
   * cumulative_price defines the running time-integral of the perp premium
   * ((VWAP - mark_price) / mark_price) i.e., sum(premium * seconds)
   * used to compute the intervals average premium for funding
   *
   * @generated from protobuf field: string cumulative_price = 2
   */
  cumulativePrice: string;
  /**
   * the last timestamp in seconds
   *
   * @generated from protobuf field: int64 last_timestamp = 3
   */
  lastTimestamp: bigint;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.DerivativeMarketSettlementInfo
 */
interface DerivativeMarketSettlementInfo {
  /**
   * market ID.
   *
   * @generated from protobuf field: string market_id = 1
   */
  marketId: string;
  /**
   * settlement_price defines the settlement price
   *
   * @generated from protobuf field: string settlement_price = 2
   */
  settlementPrice: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.MidPriceAndTOB
 */
interface MidPriceAndTOB {
  /**
   * mid price of the market (in chain format)
   *
   * @generated from protobuf field: string mid_price = 1
   */
  midPrice: string;
  /**
   * best buy price of the market (in chain format)
   *
   * @generated from protobuf field: string best_buy_price = 2
   */
  bestBuyPrice: string;
  /**
   * best sell price of the market (in chain format)
   *
   * @generated from protobuf field: string best_sell_price = 3
   */
  bestSellPrice: string;
}
/**
 * An object describing trade pair of two assets.
 *
 * @generated from protobuf message injective.exchange.v1beta1.SpotMarket
 */
interface SpotMarket {
  /**
   * A name of the pair in format AAA/BBB, where AAA is base asset, BBB is quote
   * asset.
   *
   * @generated from protobuf field: string ticker = 1
   */
  ticker: string;
  /**
   * Coin denom used for the base asset
   *
   * @generated from protobuf field: string base_denom = 2
   */
  baseDenom: string;
  /**
   * Coin used for the quote asset
   *
   * @generated from protobuf field: string quote_denom = 3
   */
  quoteDenom: string;
  /**
   * maker_fee_rate defines the fee percentage makers pay when trading
   *
   * @generated from protobuf field: string maker_fee_rate = 4
   */
  makerFeeRate: string;
  /**
   * taker_fee_rate defines the fee percentage takers pay when trading
   *
   * @generated from protobuf field: string taker_fee_rate = 5
   */
  takerFeeRate: string;
  /**
   * relayer_fee_share_rate defines the percentage of the transaction fee shared
   * with the relayer in a derivative market
   *
   * @generated from protobuf field: string relayer_fee_share_rate = 6
   */
  relayerFeeShareRate: string;
  /**
   * Unique market ID.
   *
   * @generated from protobuf field: string market_id = 7
   */
  marketId: string;
  /**
   * Status of the market
   *
   * @generated from protobuf field: injective.exchange.v1beta1.MarketStatus status = 8
   */
  status: MarketStatus;
  /**
   * min_price_tick_size defines the minimum tick size that the price required
   * for orders in the market (in chain format)
   *
   * @generated from protobuf field: string min_price_tick_size = 9
   */
  minPriceTickSize: string;
  /**
   * min_quantity_tick_size defines the minimum tick size of the quantity
   * required for orders in the market (in chain format)
   *
   * @generated from protobuf field: string min_quantity_tick_size = 10
   */
  minQuantityTickSize: string;
  /**
   * min_notional defines the minimum notional (in quote asset) required for
   * orders in the market (in chain format)
   *
   * @generated from protobuf field: string min_notional = 11
   */
  minNotional: string;
  /**
   * current market admin
   *
   * @generated from protobuf field: string admin = 12
   */
  admin: string;
  /**
   * level of admin permissions
   *
   * @generated from protobuf field: uint32 admin_permissions = 13
   */
  adminPermissions: number;
  /**
   * base token decimals
   *
   * @generated from protobuf field: uint32 base_decimals = 14
   */
  baseDecimals: number;
  /**
   * quote token decimals
   *
   * @generated from protobuf field: uint32 quote_decimals = 15
   */
  quoteDecimals: number;
}
/**
 * A subaccount's deposit for a given base currency
 *
 * @generated from protobuf message injective.exchange.v1beta1.Deposit
 */
interface Deposit {
  /**
   * @generated from protobuf field: string available_balance = 1
   */
  availableBalance: string;
  /**
   * @generated from protobuf field: string total_balance = 2
   */
  totalBalance: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.SubaccountTradeNonce
 */
interface SubaccountTradeNonce {
  /**
   * @generated from protobuf field: uint32 nonce = 1
   */
  nonce: number;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.OrderInfo
 */
interface OrderInfo {
  /**
   * bytes32 subaccount ID that created the order
   *
   * @generated from protobuf field: string subaccount_id = 1
   */
  subaccountId: string;
  /**
   * address fee_recipient address that will receive fees for the order
   *
   * @generated from protobuf field: string fee_recipient = 2
   */
  feeRecipient: string;
  /**
   * price of the order
   *
   * @generated from protobuf field: string price = 3
   */
  price: string;
  /**
   * quantity of the order
   *
   * @generated from protobuf field: string quantity = 4
   */
  quantity: string;
  /**
   * @generated from protobuf field: string cid = 5
   */
  cid: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.SpotOrder
 */
interface SpotOrder {
  /**
   * market_id represents the unique ID of the market
   *
   * @generated from protobuf field: string market_id = 1
   */
  marketId: string;
  /**
   * order_info contains the information of the order
   *
   * @generated from protobuf field: injective.exchange.v1beta1.OrderInfo order_info = 2
   */
  orderInfo?: OrderInfo;
  /**
   * order types
   *
   * @generated from protobuf field: injective.exchange.v1beta1.OrderType order_type = 3
   */
  orderType: OrderType;
  /**
   * trigger_price is the trigger price used by stop/take orders
   *
   * @generated from protobuf field: string trigger_price = 4
   */
  triggerPrice: string;
}
/**
 * A valid Spot limit order with Metadata.
 *
 * @generated from protobuf message injective.exchange.v1beta1.SpotLimitOrder
 */
interface SpotLimitOrder {
  /**
   * order_info contains the information of the order
   *
   * @generated from protobuf field: injective.exchange.v1beta1.OrderInfo order_info = 1
   */
  orderInfo?: OrderInfo;
  /**
   * order types
   *
   * @generated from protobuf field: injective.exchange.v1beta1.OrderType order_type = 2
   */
  orderType: OrderType;
  /**
   * the amount of the quantity remaining fillable
   *
   * @generated from protobuf field: string fillable = 3
   */
  fillable: string;
  /**
   * trigger_price is the trigger price used by stop/take orders
   *
   * @generated from protobuf field: string trigger_price = 4
   */
  triggerPrice: string;
  /**
   * @generated from protobuf field: bytes order_hash = 5
   */
  orderHash: Uint8Array;
}
/**
 * A valid Spot market order with Metadata.
 *
 * @generated from protobuf message injective.exchange.v1beta1.SpotMarketOrder
 */
interface SpotMarketOrder {
  /**
   * order_info contains the information of the order
   *
   * @generated from protobuf field: injective.exchange.v1beta1.OrderInfo order_info = 1
   */
  orderInfo?: OrderInfo;
  /**
   * @generated from protobuf field: string balance_hold = 2
   */
  balanceHold: string;
  /**
   * @generated from protobuf field: bytes order_hash = 3
   */
  orderHash: Uint8Array;
  /**
   * order types
   *
   * @generated from protobuf field: injective.exchange.v1beta1.OrderType order_type = 4
   */
  orderType: OrderType;
  /**
   * trigger_price is the trigger price used by stop/take orders
   *
   * @generated from protobuf field: string trigger_price = 5
   */
  triggerPrice: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.DerivativeOrder
 */
interface DerivativeOrder {
  /**
   * market_id represents the unique ID of the market
   *
   * @generated from protobuf field: string market_id = 1
   */
  marketId: string;
  /**
   * order_info contains the information of the order
   *
   * @generated from protobuf field: injective.exchange.v1beta1.OrderInfo order_info = 2
   */
  orderInfo?: OrderInfo;
  /**
   * order types
   *
   * @generated from protobuf field: injective.exchange.v1beta1.OrderType order_type = 3
   */
  orderType: OrderType;
  /**
   * margin is the margin used by the limit order
   *
   * @generated from protobuf field: string margin = 4
   */
  margin: string;
  /**
   * trigger_price is the trigger price used by stop/take orders
   *
   * @generated from protobuf field: string trigger_price = 5
   */
  triggerPrice: string;
}
/**
 * A valid Derivative limit order with Metadata.
 *
 * @generated from protobuf message injective.exchange.v1beta1.DerivativeLimitOrder
 */
interface DerivativeLimitOrder {
  /**
   * order_info contains the information of the order
   *
   * @generated from protobuf field: injective.exchange.v1beta1.OrderInfo order_info = 1
   */
  orderInfo?: OrderInfo;
  /**
   * order types
   *
   * @generated from protobuf field: injective.exchange.v1beta1.OrderType order_type = 2
   */
  orderType: OrderType;
  /**
   * margin is the margin used by the limit order
   *
   * @generated from protobuf field: string margin = 3
   */
  margin: string;
  /**
   * the amount of the quantity remaining fillable
   *
   * @generated from protobuf field: string fillable = 4
   */
  fillable: string;
  /**
   * trigger_price is the trigger price used by stop/take orders
   *
   * @generated from protobuf field: string trigger_price = 5
   */
  triggerPrice: string;
  /**
   * @generated from protobuf field: bytes order_hash = 6
   */
  orderHash: Uint8Array;
}
/**
 * A valid Derivative market order with Metadata.
 *
 * @generated from protobuf message injective.exchange.v1beta1.DerivativeMarketOrder
 */
interface DerivativeMarketOrder {
  /**
   * order_info contains the information of the order
   *
   * @generated from protobuf field: injective.exchange.v1beta1.OrderInfo order_info = 1
   */
  orderInfo?: OrderInfo;
  /**
   * order types
   *
   * @generated from protobuf field: injective.exchange.v1beta1.OrderType order_type = 2
   */
  orderType: OrderType;
  /**
   * @generated from protobuf field: string margin = 3
   */
  margin: string;
  /**
   * @generated from protobuf field: string margin_hold = 4
   */
  marginHold: string;
  /**
   * trigger_price is the trigger price used by stop/take orders
   *
   * @generated from protobuf field: string trigger_price = 5
   */
  triggerPrice: string;
  /**
   * @generated from protobuf field: bytes order_hash = 6
   */
  orderHash: Uint8Array;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.Position
 */
interface Position {
  /**
   * True if the position is long. False if the position is short.
   *
   * @generated from protobuf field: bool isLong = 1
   */
  isLong: boolean;
  /**
   * The quantity of the position (in chain format)
   *
   * @generated from protobuf field: string quantity = 2
   */
  quantity: string;
  /**
   * The entry price of the position (in chain format)
   *
   * @generated from protobuf field: string entry_price = 3
   */
  entryPrice: string;
  /**
   * The margin of the position (in chain format)
   *
   * @generated from protobuf field: string margin = 4
   */
  margin: string;
  /**
   * The cumulative funding
   *
   * @generated from protobuf field: string cumulative_funding_entry = 5
   */
  cumulativeFundingEntry: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.PointsMultiplier
 */
interface PointsMultiplier {
  /**
   * @generated from protobuf field: string maker_points_multiplier = 1
   */
  makerPointsMultiplier: string;
  /**
   * @generated from protobuf field: string taker_points_multiplier = 2
   */
  takerPointsMultiplier: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.TradingRewardCampaignBoostInfo
 */
interface TradingRewardCampaignBoostInfo {
  /**
   * @generated from protobuf field: repeated string boosted_spot_market_ids = 1
   */
  boostedSpotMarketIds: string[];
  /**
   * @generated from protobuf field: repeated injective.exchange.v1beta1.PointsMultiplier spot_market_multipliers = 2
   */
  spotMarketMultipliers: PointsMultiplier[];
  /**
   * @generated from protobuf field: repeated string boosted_derivative_market_ids = 3
   */
  boostedDerivativeMarketIds: string[];
  /**
   * @generated from protobuf field: repeated injective.exchange.v1beta1.PointsMultiplier derivative_market_multipliers = 4
   */
  derivativeMarketMultipliers: PointsMultiplier[];
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.CampaignRewardPool
 */
interface CampaignRewardPool {
  /**
   * @generated from protobuf field: int64 start_timestamp = 1
   */
  startTimestamp: bigint;
  /**
   * max_campaign_rewards are the maximum reward amounts to be disbursed at the
   * end of the campaign
   *
   * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin max_campaign_rewards = 2
   */
  maxCampaignRewards: Coin$1[];
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.TradingRewardCampaignInfo
 */
interface TradingRewardCampaignInfo {
  /**
   * number of seconds of the duration of each campaign
   *
   * @generated from protobuf field: int64 campaign_duration_seconds = 1
   */
  campaignDurationSeconds: bigint;
  /**
   * the trading fee quote denoms which will be counted for the rewards
   *
   * @generated from protobuf field: repeated string quote_denoms = 2
   */
  quoteDenoms: string[];
  /**
   * the optional boost info for markets
   *
   * @generated from protobuf field: injective.exchange.v1beta1.TradingRewardCampaignBoostInfo trading_reward_boost_info = 3
   */
  tradingRewardBoostInfo?: TradingRewardCampaignBoostInfo;
  /**
   * the marketIDs which are disqualified from being rewarded
   *
   * @generated from protobuf field: repeated string disqualified_market_ids = 4
   */
  disqualifiedMarketIds: string[];
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.FeeDiscountTierInfo
 */
interface FeeDiscountTierInfo {
  /**
   * the maker discount rate
   *
   * @generated from protobuf field: string maker_discount_rate = 1
   */
  makerDiscountRate: string;
  /**
   * the taker discount rate
   *
   * @generated from protobuf field: string taker_discount_rate = 2
   */
  takerDiscountRate: string;
  /**
   * the staked amount required to qualify for the discount (in chain format)
   *
   * @generated from protobuf field: string staked_amount = 3
   */
  stakedAmount: string;
  /**
   * the volume required to qualify for the discount (in chain format)
   *
   * @generated from protobuf field: string volume = 4
   */
  volume: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.FeeDiscountSchedule
 */
interface FeeDiscountSchedule {
  /**
   * @generated from protobuf field: uint64 bucket_count = 1
   */
  bucketCount: bigint;
  /**
   * @generated from protobuf field: int64 bucket_duration = 2
   */
  bucketDuration: bigint;
  /**
   * the trading fee quote denoms which will be counted for the fee paid
   * contribution
   *
   * @generated from protobuf field: repeated string quote_denoms = 3
   */
  quoteDenoms: string[];
  /**
   * the fee discount tiers
   *
   * @generated from protobuf field: repeated injective.exchange.v1beta1.FeeDiscountTierInfo tier_infos = 4
   */
  tierInfos: FeeDiscountTierInfo[];
  /**
   * the marketIDs which are disqualified from contributing to the fee paid
   * amount
   *
   * @generated from protobuf field: repeated string disqualified_market_ids = 5
   */
  disqualifiedMarketIds: string[];
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.FeeDiscountTierTTL
 */
interface FeeDiscountTierTTL {
  /**
   * @generated from protobuf field: uint64 tier = 1
   */
  tier: bigint;
  /**
   * @generated from protobuf field: int64 ttl_timestamp = 2
   */
  ttlTimestamp: bigint;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.VolumeRecord
 */
interface VolumeRecord {
  /**
   * @generated from protobuf field: string maker_volume = 1
   */
  makerVolume: string;
  /**
   * @generated from protobuf field: string taker_volume = 2
   */
  takerVolume: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.TradeRecords
 */
interface TradeRecords {
  /**
   * @generated from protobuf field: string market_id = 1
   */
  marketId: string;
  /**
   * @generated from protobuf field: repeated injective.exchange.v1beta1.TradeRecord latest_trade_records = 2
   */
  latestTradeRecords: TradeRecord[];
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.TradeRecord
 */
interface TradeRecord {
  /**
   * the timestamp of the trade
   *
   * @generated from protobuf field: int64 timestamp = 1
   */
  timestamp: bigint;
  /**
   * the price of the trade (in chain format)
   *
   * @generated from protobuf field: string price = 2
   */
  price: string;
  /**
   * the quantity of the trade (in chain format)
   *
   * @generated from protobuf field: string quantity = 3
   */
  quantity: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.AggregateSubaccountVolumeRecord
 */
interface AggregateSubaccountVolumeRecord {
  /**
   * the subaccount ID
   *
   * @generated from protobuf field: string subaccount_id = 1
   */
  subaccountId: string;
  /**
   * the subaccount volumes for each market
   *
   * @generated from protobuf field: repeated injective.exchange.v1beta1.MarketVolume market_volumes = 2
   */
  marketVolumes: MarketVolume[];
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.MarketVolume
 */
interface MarketVolume {
  /**
   * @generated from protobuf field: string market_id = 1
   */
  marketId: string;
  /**
   * @generated from protobuf field: injective.exchange.v1beta1.VolumeRecord volume = 2
   */
  volume?: VolumeRecord;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.DenomDecimals
 */
interface DenomDecimals {
  /**
   * @generated from protobuf field: string denom = 1
   */
  denom: string;
  /**
   * @generated from protobuf field: uint64 decimals = 2
   */
  decimals: bigint;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.GrantAuthorization
 */
interface GrantAuthorization {
  /**
   * @generated from protobuf field: string grantee = 1
   */
  grantee: string;
  /**
   * @generated from protobuf field: string amount = 2
   */
  amount: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.ActiveGrant
 */
interface ActiveGrant {
  /**
   * @generated from protobuf field: string granter = 1
   */
  granter: string;
  /**
   * @generated from protobuf field: string amount = 2
   */
  amount: string;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.EffectiveGrant
 */
interface EffectiveGrant {
  /**
   * @generated from protobuf field: string granter = 1
   */
  granter: string;
  /**
   * @generated from protobuf field: string net_granted_stake = 2
   */
  netGrantedStake: string;
  /**
   * @generated from protobuf field: bool is_valid = 3
   */
  isValid: boolean;
}
/**
 * @generated from protobuf message injective.exchange.v1beta1.DenomMinNotional
 */
interface DenomMinNotional {
  /**
   * the denom of the token
   *
   * @generated from protobuf field: string denom = 1
   */
  denom: string;
  /**
   * the minimum notional value for the token (in chain format)
   *
   * @generated from protobuf field: string min_notional = 2
   */
  minNotional: string;
}
/**
 * @generated from protobuf enum injective.exchange.v1beta1.AtomicMarketOrderAccessLevel
 */
declare enum AtomicMarketOrderAccessLevel {
  /**
   * @generated from protobuf enum value: Nobody = 0;
   */
  Nobody = 0,
  /**
   * currently unsupported
   *
   * @generated from protobuf enum value: BeginBlockerSmartContractsOnly = 1;
   */
  BeginBlockerSmartContractsOnly = 1,
  /**
   * @generated from protobuf enum value: SmartContractsOnly = 2;
   */
  SmartContractsOnly = 2,
  /**
   * @generated from protobuf enum value: Everyone = 3;
   */
  Everyone = 3,
}
/**
 * @generated from protobuf enum injective.exchange.v1beta1.MarketStatus
 */
declare enum MarketStatus {
  /**
   * @generated from protobuf enum value: Unspecified = 0;
   */
  Unspecified = 0,
  /**
   * @generated from protobuf enum value: Active = 1;
   */
  Active = 1,
  /**
   * @generated from protobuf enum value: Paused = 2;
   */
  Paused = 2,
  /**
   * @generated from protobuf enum value: Demolished = 3;
   */
  Demolished = 3,
  /**
   * @generated from protobuf enum value: Expired = 4;
   */
  Expired = 4,
}
/**
 * @generated from protobuf enum injective.exchange.v1beta1.OrderType
 */
declare enum OrderType {
  /**
   * @generated from protobuf enum value: UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,
  /**
   * @generated from protobuf enum value: BUY = 1;
   */
  BUY = 1,
  /**
   * @generated from protobuf enum value: SELL = 2;
   */
  SELL = 2,
  /**
   * @generated from protobuf enum value: STOP_BUY = 3;
   */
  STOP_BUY = 3,
  /**
   * @generated from protobuf enum value: STOP_SELL = 4;
   */
  STOP_SELL = 4,
  /**
   * @generated from protobuf enum value: TAKE_BUY = 5;
   */
  TAKE_BUY = 5,
  /**
   * @generated from protobuf enum value: TAKE_SELL = 6;
   */
  TAKE_SELL = 6,
  /**
   * @generated from protobuf enum value: BUY_PO = 7;
   */
  BUY_PO = 7,
  /**
   * @generated from protobuf enum value: SELL_PO = 8;
   */
  SELL_PO = 8,
  /**
   * @generated from protobuf enum value: BUY_ATOMIC = 9;
   */
  BUY_ATOMIC = 9,
  /**
   * @generated from protobuf enum value: SELL_ATOMIC = 10;
   */
  SELL_ATOMIC = 10,
}
/**
 * @generated from protobuf enum injective.exchange.v1beta1.OrderMask
 */
declare enum OrderMask$1 {
  /**
   * @generated from protobuf enum value: UNUSED = 0;
   */
  UNUSED = 0,
  /**
   * @generated from protobuf enum value: ANY = 1;
   */
  ANY = 1,
  /**
   * @generated from protobuf enum value: REGULAR = 2;
   */
  REGULAR = 2,
  /**
   * @generated from protobuf enum value: CONDITIONAL = 4;
   */
  CONDITIONAL = 4,
  /**
   * for conditional orders means HIGHER
   *
   * @generated from protobuf enum value: DIRECTION_BUY_OR_HIGHER = 8;
   */
  DIRECTION_BUY_OR_HIGHER = 8,
  /**
   * for conditional orders means LOWER
   *
   * @generated from protobuf enum value: DIRECTION_SELL_OR_LOWER = 16;
   */
  DIRECTION_SELL_OR_LOWER = 16,
  /**
   * @generated from protobuf enum value: TYPE_MARKET = 32;
   */
  TYPE_MARKET = 32,
  /**
   * @generated from protobuf enum value: TYPE_LIMIT = 64;
   */
  TYPE_LIMIT = 64,
}
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.OpenNotionalCap
 */
declare const OpenNotionalCap = new OpenNotionalCap$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.OpenNotionalCapUncapped
 */
declare const OpenNotionalCapUncapped = new OpenNotionalCapUncapped$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.OpenNotionalCapCapped
 */
declare const OpenNotionalCapCapped = new OpenNotionalCapCapped$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.Params
 */
declare const Params = new Params$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MarketFeeMultiplier
 */
declare const MarketFeeMultiplier = new MarketFeeMultiplier$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.DerivativeMarket
 */
declare const DerivativeMarket = new DerivativeMarket$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.BinaryOptionsMarket
 */
declare const BinaryOptionsMarket = new BinaryOptionsMarket$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.ExpiryFuturesMarketInfo
 */
declare const ExpiryFuturesMarketInfo = new ExpiryFuturesMarketInfo$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.PerpetualMarketInfo
 */
declare const PerpetualMarketInfo = new PerpetualMarketInfo$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.PerpetualMarketFunding
 */
declare const PerpetualMarketFunding = new PerpetualMarketFunding$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.DerivativeMarketSettlementInfo
 */
declare const DerivativeMarketSettlementInfo = new DerivativeMarketSettlementInfo$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MidPriceAndTOB
 */
declare const MidPriceAndTOB = new MidPriceAndTOB$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.SpotMarket
 */
declare const SpotMarket = new SpotMarket$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.Deposit
 */
declare const Deposit = new Deposit$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.SubaccountTradeNonce
 */
declare const SubaccountTradeNonce = new SubaccountTradeNonce$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.OrderInfo
 */
declare const OrderInfo = new OrderInfo$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.SpotOrder
 */
declare const SpotOrder = new SpotOrder$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.SpotLimitOrder
 */
declare const SpotLimitOrder = new SpotLimitOrder$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.SpotMarketOrder
 */
declare const SpotMarketOrder = new SpotMarketOrder$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.DerivativeOrder
 */
declare const DerivativeOrder = new DerivativeOrder$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.DerivativeLimitOrder
 */
declare const DerivativeLimitOrder = new DerivativeLimitOrder$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.DerivativeMarketOrder
 */
declare const DerivativeMarketOrder = new DerivativeMarketOrder$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.Position
 */
declare const Position = new Position$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.PointsMultiplier
 */
declare const PointsMultiplier = new PointsMultiplier$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.TradingRewardCampaignBoostInfo
 */
declare const TradingRewardCampaignBoostInfo = new TradingRewardCampaignBoostInfo$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.CampaignRewardPool
 */
declare const CampaignRewardPool = new CampaignRewardPool$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.TradingRewardCampaignInfo
 */
declare const TradingRewardCampaignInfo = new TradingRewardCampaignInfo$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.FeeDiscountTierInfo
 */
declare const FeeDiscountTierInfo = new FeeDiscountTierInfo$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.FeeDiscountSchedule
 */
declare const FeeDiscountSchedule = new FeeDiscountSchedule$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.FeeDiscountTierTTL
 */
declare const FeeDiscountTierTTL = new FeeDiscountTierTTL$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.VolumeRecord
 */
declare const VolumeRecord = new VolumeRecord$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.TradeRecords
 */
declare const TradeRecords = new TradeRecords$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.TradeRecord
 */
declare const TradeRecord = new TradeRecord$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.AggregateSubaccountVolumeRecord
 */
declare const AggregateSubaccountVolumeRecord = new AggregateSubaccountVolumeRecord$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.MarketVolume
 */
declare const MarketVolume = new MarketVolume$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.DenomDecimals
 */
declare const DenomDecimals = new DenomDecimals$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.GrantAuthorization
 */
declare const GrantAuthorization = new GrantAuthorization$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.ActiveGrant
 */
declare const ActiveGrant = new ActiveGrant$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.EffectiveGrant
 */
declare const EffectiveGrant = new EffectiveGrant$Type();
/**
 * @generated MessageType for protobuf message injective.exchange.v1beta1.DenomMinNotional
 */
declare const DenomMinNotional = new DenomMinNotional$Type();
//#endregion
//#region src/types/exchange.d.ts
/**
 * Trade and Order types
 */
declare const TradeExecutionType: {
  readonly Market: "market";
  readonly LimitFill: "limitFill";
  readonly LimitMatchRestingOrder: "limitMatchRestingOrder";
  readonly LimitMatchNewOrder: "limitMatchNewOrder";
};
type TradeExecutionType = (typeof TradeExecutionType)[keyof typeof TradeExecutionType];
declare const TradeExecutionSide: {
  readonly Maker: "maker";
  readonly Taker: "taker";
};
type TradeExecutionSide = (typeof TradeExecutionSide)[keyof typeof TradeExecutionSide];
declare const TradeDirection: {
  readonly Buy: "buy";
  readonly Sell: "sell";
  readonly Long: "long";
  readonly Short: "short";
};
type TradeDirection = (typeof TradeDirection)[keyof typeof TradeDirection];
declare const OrderState: {
  readonly Unfilled: "unfilled";
  readonly Booked: "booked";
  readonly PartialFilled: "partial_filled";
  readonly PartiallyFilled: "partially_filled";
  readonly Filled: "filled";
  readonly Canceled: "canceled";
  readonly Triggered: "triggered";
};
type OrderState = (typeof OrderState)[keyof typeof OrderState];
declare const OrderSide: {
  readonly Unspecified: "unspecified";
  readonly Buy: "buy";
  readonly Sell: "sell";
  readonly StopBuy: "stop_buy";
  readonly StopSell: "stop_sell";
  readonly TakeBuy: "take_buy";
  readonly TakeSell: "take_sell";
  readonly BuyPO: "buy_po";
  readonly SellPO: "sell_po";
  readonly BuyAtomic: "buy_atomic";
  readonly SellAtomic: "sell_atomic";
  readonly Unrecognized: "unrecognized";
};
type OrderSide = (typeof OrderSide)[keyof typeof OrderSide];
type OrderMask = OrderMask$1;
declare const OrderMaskMap: typeof OrderMask$1;
//#endregion
//#region ../../node_modules/.pnpm/@protobuf-ts+grpcweb-transport@2.11.1/node_modules/@protobuf-ts/grpcweb-transport/build/types/grpc-web-options.d.ts
/**
 * RPC options for the grpc-web transport.
 */
interface GrpcWebOptions extends RpcOptions {
  /**
   * Send binary or text format?
   * Defaults to text.
   */
  format?: "text" | "binary";
  /**
   * Base URI for all HTTP requests.
   *
   * Requests will be made to <baseUrl>/<package>.<service>/method
   *
   * Example: `baseUrl: "https://example.com/my-api"`
   *
   * This will make a `POST /my-api/my_package.MyService/Foo` to
   * `example.com` via HTTPS.
   */
  baseUrl: string;
  /**
   * Extra options to pass through to the fetch when doing a request.
   *
   * Example: `fetchInit: { credentials: 'include' }`
   *
   * This will make requests include cookies for cross-origin calls.
   */
  fetchInit?: Omit<RequestInit, 'body' | 'headers' | 'method' | 'signal'>;
  /**
   * A `fetch` function to use in place of `globalThis.fetch`
   */
  fetch?: typeof fetch;
}
//#endregion
//#region src/types/grpc.d.ts
type GrpcWebTransportAdditionalOptions = Omit<GrpcWebOptions, 'baseUrl'> & {
  meta?: Record<string, string>;
};
//#endregion
//#region src/types/cosmos.d.ts
interface Coin {
  denom: string;
  amount: string;
}
type TxRaw = TxRaw$1;
type SignDoc = SignDoc$1;
type GrpcCoin = Coin$1;
//#endregion
//#region src/types/stream-legacy.d.ts
/**
 * Legacy stream operation types
 * Used by indexer stream transformers
 */
declare const StreamOperation: {
  readonly Insert: "insert";
  readonly Delete: "delete";
  readonly Replace: "replace";
  readonly Update: "update";
  readonly Invalidate: "invalidate";
};
type StreamOperation = (typeof StreamOperation)[keyof typeof StreamOperation];
//#endregion
//#region src/types/pagination.d.ts
interface PaginationOption {
  key?: string;
  offset?: number;
  skip?: number;
  limit?: number;
  reverse?: boolean;
  countTotal?: boolean;
  endTime?: number;
  startTime?: number;
  fromNumber?: number;
  toNumber?: number;
}
interface PagePagination {
  next: string | null;
  prev: string | null;
  current: string | null;
}
interface Pagination {
  next: string | null;
  total: number;
}
interface ExchangePagination {
  to: number;
  from: number;
  total: number;
  countBySubaccount?: number;
  next?: string[];
}
//#endregion
export { SpotMarketOrder as $, DerivativeMarketOrder as A, MethodInfo as At, MarketStatus as B, BinaryOptionsMarket as C, TokenVerification as Ct, Deposit as D, DuplexStreamingCall as Dt, DenomMinNotional as E, UnaryCall as Et, FeeDiscountSchedule as F, OrderType as G, MidPriceAndTOB as H, FeeDiscountTierInfo as I, PerpetualMarketInfo as J, Params as K, FeeDiscountTierTTL as L, DerivativeOrder as M, EffectiveGrant as N, DerivativeLimitOrder as O, ClientStreamingCall as Ot, ExpiryFuturesMarketInfo as P, SpotMarket as Q, GrantAuthorization as R, AggregateSubaccountVolumeRecord as S, TokenType as St, DenomDecimals as T, RpcTransport as Tt, OrderInfo as U, MarketVolume as V, OrderMask$1 as W, Position as X, PointsMultiplier as Y, SpotLimitOrder as Z, OrderState as _, StreamState as _t, StreamOperation as a, BandIBCParams as at, TradeExecutionType as b, TokenSource as bt, DirectSignResponse$1 as c, Params$1 as ct, TxRaw as d, StreamDisconnectReason as dt, SpotOrder as et, GrpcWebTransportAdditionalOptions as f, StreamError as ft, OrderSide as g, StreamManagerRetryConfig as gt, OrderMaskMap as h, StreamManagerEvents as ht, PaginationOption as i, TradingRewardCampaignInfo as it, DerivativeMarketSettlementInfo as j, DerivativeMarket as k, ServerStreamingCall as kt, GrpcCoin as l, GrpcStatusCode as lt, OrderMask as m, StreamManagerConfig as mt, PagePagination as n, TradeRecords as nt, AminoSignResponse$1 as o, BandOracleRequest as ot, GrpcWebOptions as p, StreamEvent as pt, PerpetualMarketFunding as q, Pagination as r, TradingRewardCampaignBoostInfo as rt, Coin as s, OracleType as st, ExchangePagination as t, SubaccountTradeNonce as tt, SignDoc as u, ResolvedStreamManagerConfig as ut, TradeDirection as v, StreamSubscription as vt, CampaignRewardPool as w, RpcOptions as wt, ActiveGrant as x, TokenStatic as xt, TradeExecutionSide as y, TokenMeta as yt, MarketFeeMultiplier as z };