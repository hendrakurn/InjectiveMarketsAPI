import { Jt as stringToUint8Array, Qt as uint8ArrayToHex, pn as safeBigIntStringify, t as recoverTypedSignaturePubKey, zt as base64ToUint8Array } from "./utils-CewUFGKA.js";
import { t as _defineProperty } from "./defineProperty-Bq6QU9Te.js";
import { t as BaseIndexerGrpcConsumer } from "./BaseIndexerGrpcConsumer-CrwqSxDq.js";
import * as CosmosTxV1Beta1TxPb from "@injectivelabs/core-proto-ts-v2/generated/cosmos/tx/v1beta1/tx_pb";
import { DEFAULT_BRIDGE_FEE_DENOM, DEFAULT_BRIDGE_FEE_PRICE, DEFAULT_EXCHANGE_LIMIT, DEFAULT_GAS_LIMIT } from "@injectivelabs/utils";
import { ErrorType, IndexerErrorModule, TransactionException, UnspecifiedErrorCode } from "@injectivelabs/exceptions";
import * as CosmosBaseV1Beta1CoinPb from "@injectivelabs/core-proto-ts-v2/generated/cosmos/base/v1beta1/coin_pb";
import * as InjectiveExchangeRpcPb from "@injectivelabs/indexer-proto-ts-v2/generated/injective_exchange_rpc_pb";
import { InjectiveExchangeRPCClient } from "@injectivelabs/indexer-proto-ts-v2/generated/injective_exchange_rpc_pb.client";

//#region src/client/indexer/types/mito.ts
const MitoGaugeStatus = {
	Active: "active",
	Live: "live"
};

//#endregion
//#region src/client/indexer/types/account.ts
const TransferType = {
	Internal: "internal",
	External: "external",
	Withdraw: "withdraw",
	Deposit: "deposit"
};

//#endregion
//#region src/client/indexer/types/trading.ts
const MarketType = {
	Spot: "spot",
	Derivative: "derivative"
};
const GridStrategyType = {
	Geometric: "geometric",
	Arithmetic: "arithmetic",
	Perpetual: "perpetual"
};

//#endregion
//#region src/client/indexer/types/explorer.ts
const AccessTypeCode = {
	AccessTypeUnspecified: 0,
	AccessTypeNobody: 1,
	AccessTypeOnlyAddress: 2,
	AccessTypeEverybody: 3,
	AccessTypeAnyOfAddresses: 4
};
const AccessType = {
	AccessTypeUnspecified: "Unspecified",
	AccessTypeNobody: "Nobody",
	AccessTypeOnlyAddress: "Only Address",
	AccessTypeEverybody: "Everybody",
	AccessTypeAnyOfAddresses: "Any of Addresses"
};
const ValidatorUptimeStatus = {
	Proposed: "proposed",
	Signed: "signed",
	Missed: "missed"
};

//#endregion
//#region src/client/indexer/types/insurance-funds.ts
const RedemptionStatus = {
	Pending: "pending",
	Disbursed: "disbursed"
};

//#endregion
//#region src/client/indexer/types/index.ts
const IndexerModule = { ...IndexerErrorModule };

//#endregion
//#region src/client/indexer/grpc/IndexerGrpcTransactionApi.ts
/**
* @category Indexer Grpc API
* @deprecated use IndexerGrpcWeb3GwApi
*/
var IndexerGrpcTransactionApi = class extends BaseIndexerGrpcConsumer {
	constructor(..._args) {
		super(..._args);
		_defineProperty(this, "module", IndexerModule.Transaction);
	}
	get client() {
		return this.initClient(InjectiveExchangeRPCClient);
	}
	async prepareTxRequest(args) {
		const { address, chainId, message, memo, estimateGas = true, gasLimit = DEFAULT_GAS_LIMIT, feeDenom = DEFAULT_BRIDGE_FEE_DENOM, feePrice = DEFAULT_BRIDGE_FEE_PRICE, timeoutHeight } = args;
		const txFeeAmount = CosmosBaseV1Beta1CoinPb.Coin.create();
		txFeeAmount.denom = feeDenom;
		txFeeAmount.amount = feePrice;
		const cosmosTxFee = InjectiveExchangeRpcPb.CosmosTxFee.create();
		cosmosTxFee.price = [txFeeAmount];
		if (!estimateGas) cosmosTxFee.gas = BigInt(gasLimit);
		const prepareTxRequest = InjectiveExchangeRpcPb.PrepareTxRequest.create();
		prepareTxRequest.chainId = BigInt(chainId);
		prepareTxRequest.signerAddress = address;
		prepareTxRequest.fee = cosmosTxFee;
		prepareTxRequest.msgs = (Array.isArray(message) ? message : [message]).map((message$1) => stringToUint8Array(safeBigIntStringify(message$1)));
		if (timeoutHeight !== void 0) prepareTxRequest.timeoutHeight = BigInt(timeoutHeight);
		if (memo) prepareTxRequest.memo = typeof memo === "number" ? memo.toString() : memo;
		return await this.executeGrpcCall(prepareTxRequest, this.client.prepareTx.bind(this.client));
	}
	async prepareExchangeTxRequest(args) {
		return this.prepareTxRequest({
			...args,
			gasLimit: args.gasLimit || DEFAULT_EXCHANGE_LIMIT
		});
	}
	async prepareCosmosTxRequest({ memo, address, message, estimateGas = true, gasLimit = DEFAULT_GAS_LIMIT, feeDenom = DEFAULT_BRIDGE_FEE_DENOM, feePrice = DEFAULT_BRIDGE_FEE_PRICE, timeoutHeight }) {
		const txFeeAmount = CosmosBaseV1Beta1CoinPb.Coin.create();
		txFeeAmount.denom = feeDenom;
		txFeeAmount.amount = feePrice;
		const cosmosTxFee = InjectiveExchangeRpcPb.CosmosTxFee.create();
		cosmosTxFee.price = [txFeeAmount];
		if (!estimateGas) cosmosTxFee.gas = BigInt(gasLimit);
		const prepareTxRequest = InjectiveExchangeRpcPb.PrepareCosmosTxRequest.create();
		prepareTxRequest.fee = cosmosTxFee;
		prepareTxRequest.senderAddress = address;
		prepareTxRequest.msgs = (Array.isArray(message) ? message : [message]).map((message$1) => stringToUint8Array(safeBigIntStringify(message$1)));
		if (timeoutHeight !== void 0) prepareTxRequest.timeoutHeight = BigInt(timeoutHeight);
		if (memo) prepareTxRequest.memo = typeof memo === "number" ? memo.toString() : memo;
		return await this.executeGrpcCall(prepareTxRequest, this.client.prepareCosmosTx.bind(this.client));
	}
	/**
	* Keep in mind that the transaction is just added
	* to the mempool, we need to query the transaction hash
	* if we want to ensure that the transaction is included
	* in the block
	*/
	async broadcastTxRequest({ signature, chainId, message, txResponse }) {
		const parsedTypedData = JSON.parse(txResponse.data);
		let publicKeyHex;
		try {
			publicKeyHex = await recoverTypedSignaturePubKey(parsedTypedData, signature);
		} catch (e) {
			throw new TransactionException(e, {
				code: UnspecifiedErrorCode,
				context: "Web3Gateway.RecoverTypedSignaturePubKey",
				type: ErrorType.Web3Gateway
			});
		}
		const cosmosPubKey = InjectiveExchangeRpcPb.CosmosPubKey.create();
		cosmosPubKey.type = txResponse.pubKeyType;
		cosmosPubKey.key = publicKeyHex;
		parsedTypedData.message.msgs = null;
		const broadcastTxRequest = InjectiveExchangeRpcPb.BroadcastTxRequest.create();
		broadcastTxRequest.mode = "sync";
		broadcastTxRequest.chainId = BigInt(chainId);
		broadcastTxRequest.pubKey = cosmosPubKey;
		broadcastTxRequest.signature = signature;
		broadcastTxRequest.tx = stringToUint8Array(safeBigIntStringify(parsedTypedData.message));
		broadcastTxRequest.feePayer = txResponse.feePayer;
		broadcastTxRequest.feePayerSig = txResponse.feePayerSig;
		broadcastTxRequest.msgs = (Array.isArray(message) ? message : [message]).map((message$1) => stringToUint8Array(safeBigIntStringify(message$1)));
		return await this.executeGrpcCall(broadcastTxRequest, this.client.broadcastTx.bind(this.client));
	}
	/**
	* Keep in mind that the transaction is just added
	* to the mempool, we need to query the transaction hash
	* if we want to ensure that the transaction is included
	* in the block
	*/
	async broadcastCosmosTxRequest({ address, signature, txRaw, pubKey }) {
		const pubKeyInHex = uint8ArrayToHex(base64ToUint8Array(pubKey.value));
		const signatureInHex = uint8ArrayToHex(base64ToUint8Array(signature));
		const cosmosPubKey = InjectiveExchangeRpcPb.CosmosPubKey.create();
		cosmosPubKey.type = pubKey.type;
		cosmosPubKey.key = `0x${pubKeyInHex}`;
		txRaw.signatures = [];
		const broadcastTxRequest = InjectiveExchangeRpcPb.BroadcastCosmosTxRequest.create();
		broadcastTxRequest.senderAddress = address;
		broadcastTxRequest.pubKey = cosmosPubKey;
		broadcastTxRequest.signature = `0x${signatureInHex}`;
		broadcastTxRequest.tx = CosmosTxV1Beta1TxPb.TxRaw.toBinary(txRaw);
		return await this.executeGrpcCall(broadcastTxRequest, this.client.broadcastCosmosTx.bind(this.client));
	}
	async fetchFeePayer() {
		const request = InjectiveExchangeRpcPb.GetFeePayerRequest.create();
		return await this.executeGrpcCall(request, this.client.getFeePayer.bind(this.client));
	}
};

//#endregion
//#region src/client/indexer/grpc/IndexerGrpcWeb3GwApi.ts
/**
* @category Indexer Grpc API
*/
var IndexerGrpcWeb3GwApi = class extends IndexerGrpcTransactionApi {
	constructor(..._args) {
		super(..._args);
		_defineProperty(this, "module", IndexerModule.Web3Gw);
	}
	async prepareEip712Request({ address, chainId, message, memo, sequence, accountNumber, estimateGas = false, gasLimit = DEFAULT_GAS_LIMIT, feeDenom = DEFAULT_BRIDGE_FEE_DENOM, feePrice = DEFAULT_BRIDGE_FEE_PRICE, timeoutHeight, eip712Version = "v1" }) {
		const txFeeAmount = CosmosBaseV1Beta1CoinPb.Coin.create({
			denom: feeDenom,
			amount: feePrice
		});
		const cosmosTxFee = InjectiveExchangeRpcPb.CosmosTxFee.create();
		cosmosTxFee.price = [txFeeAmount];
		if (!estimateGas) cosmosTxFee.gas = BigInt(gasLimit);
		const prepareTxRequest = InjectiveExchangeRpcPb.PrepareEip712Request.create();
		prepareTxRequest.chainId = BigInt(chainId);
		prepareTxRequest.signerAddress = address;
		prepareTxRequest.fee = cosmosTxFee;
		prepareTxRequest.msgs = (Array.isArray(message) ? message : [message]).map((message$1) => stringToUint8Array(safeBigIntStringify(message$1)));
		if (timeoutHeight !== void 0) prepareTxRequest.timeoutHeight = BigInt(timeoutHeight);
		if (memo) prepareTxRequest.memo = typeof memo === "number" ? memo.toString() : memo;
		if (eip712Version) prepareTxRequest.eip712Wrapper = eip712Version;
		if (accountNumber) prepareTxRequest.accountNumber = BigInt(accountNumber);
		if (sequence) prepareTxRequest.sequence = BigInt(sequence);
		return await this.executeGrpcCall(prepareTxRequest, this.client.prepareEip712.bind(this.client));
	}
};

//#endregion
export { AccessType as a, GridStrategyType as c, MitoGaugeStatus as d, RedemptionStatus as i, MarketType as l, IndexerGrpcTransactionApi as n, AccessTypeCode as o, IndexerModule as r, ValidatorUptimeStatus as s, IndexerGrpcWeb3GwApi as t, TransferType as u };