import { _ as getDefaultStdFee, a as DEFAULT_BRIDGE_FEE_PRICE, b as toChainFormat, c as DEFAULT_GAS_LIMIT, d as DEFAULT_STD_FEE_BY_DENOM, f as DEFAULT_TIMESTAMP_TIMEOUT_MS, g as ZERO_ADDRESS, h as INJ_DENOM, i as DEFAULT_BRIDGE_FEE_DENOM, l as DEFAULT_GAS_PRICE, m as INJECTIVE_DENOM, n as DEFAULT_BLOCK_TIME_IN_SECONDS, o as DEFAULT_EXCHANGE_LIMIT, p as DEFAULT_TX_BLOCK_INCLUSION_TIMEOUT_IN_MS, r as DEFAULT_BRIDGE_FEE_AMOUNT, s as DEFAULT_FEE_DENOM, t as DEFAULT_BLOCK_TIMEOUT_HEIGHT, u as DEFAULT_IBC_GAS_LIMIT, v as BigNumber_default, x as toHumanReadable, y as toBigNumber } from "./constants-BxcSsKjm.js";
import axios from "axios";
import store from "store2";
import { StatusCodes } from "http-status-codes";
import { HttpRequestException, HttpRequestMethod, UnspecifiedErrorCode } from "@injectivelabs/exceptions";

//#region src/time.ts
const getSecondsInDay = () => new BigNumber_default(3600 * 24);
const convertTimestampToMilliseconds = (timestamp) => {
	const timestampInBigNumber = new BigNumber_default(timestamp);
	if (timestamp.toString().length > 13) return timestampInBigNumber.precision(13, BigNumber_default.ROUND_HALF_UP).toNumber();
	if (timestamp.toString().length < 13) {
		const trailingZeros = 13 - timestamp.toString().length;
		return timestampInBigNumber.times(10 ** trailingZeros).toNumber();
	}
	return timestampInBigNumber.toNumber();
};
const getUTCDateFromTimestamp = (timestamp) => {
	const date = new Date(convertTimestampToMilliseconds(timestamp));
	return `${date.getUTCDate()}-${date.getUTCMonth() + 1}-${date.getUTCFullYear()}`;
};
const tomorrow = () => new BigNumber_default(Math.floor((/* @__PURE__ */ new Date()).valueOf() / 1e3) + 3600 * 24);
const todayInSeconds = () => Math.floor(Date.now() / 1e3);
const past24Hours = () => new BigNumber_default(todayInSeconds()).minus(getSecondsInDay()).toNumber();
const pastDays = (day = 1) => new BigNumber_default(todayInSeconds()).minus(getSecondsInDay().times(day)).toNumber();
const getEndDateStringFromTimeInSeconds = (timeInSeconds) => {
	return (/* @__PURE__ */ new Date(timeInSeconds.toNumber() * 1e3)).toLocaleString("en-us");
};

//#endregion
//#region src/helpers.ts
const sleep = (timeout) => new Promise((resolve) => setTimeout(resolve, timeout));
/**
* When we want to execute the promises in batch
*/
const awaitAll = async (array, callback) => await Promise.all(array.map(async (item) => await callback(item)));
/**
* When we want to execute the promises one by one
* and not all in batch as with await Promise.all()
*/
const awaitForAll = async (array, callback) => {
	const result = [];
	for (let i = 0; i < array.length; i += 1) try {
		result.push(await callback(array[i]));
	} catch (_unused) {}
	return result;
};
const splitArrayToChunksThrow = ({ array, filter, chunkSize }) => {
	const chunks = [];
	const chunkSizeInNumber = Number(chunkSize);
	if (isNaN(chunkSizeInNumber)) throw new Error("Invalid chunk size, must be a valid number");
	for (let i = 0; i < array.length; i += chunkSizeInNumber) {
		const chunk = array.slice(i, i + chunkSizeInNumber);
		if (filter) chunks.push(chunk.filter(filter));
		else chunks.push(chunk);
	}
	return chunks;
};
const splitArrayToChunks = ({ array, filter, chunkSize }) => {
	try {
		return splitArrayToChunksThrow({
			array,
			chunkSize,
			filter
		});
	} catch (_unused2) {
		return [array];
	}
};
const getStdFeeForToken = (token = {
	denom: "inj",
	decimals: 18
}, gasPrice, gasLimit) => {
	const gasPriceScaled = toChainFormat(gasPrice || toHumanReadable(DEFAULT_GAS_PRICE, 18), token.decimals).toFixed(0);
	const gasNormalized = new BigNumber_default(gasLimit || DEFAULT_GAS_LIMIT).toFixed(0);
	return {
		amount: [{
			denom: token.denom,
			amount: new BigNumber_default(gasPriceScaled).times(gasNormalized).toFixed()
		}],
		gas: (gasLimit || DEFAULT_GAS_LIMIT).toString()
	};
};
const getStdFeeFromObject = (args) => {
	if (!args) return getDefaultStdFee();
	const { payer, granter, feePayer, gasPrice = DEFAULT_GAS_PRICE, gas = DEFAULT_GAS_LIMIT.toString() } = args;
	const gasNormalized = toBigNumber(gas).toFixed(0);
	const gasPriceNormalized = toBigNumber(gasPrice).toFixed(0);
	return {
		amount: [{
			denom: "inj",
			amount: toBigNumber(gasNormalized).times(gasPriceNormalized).toFixed()
		}],
		gas: toBigNumber(gasNormalized).toFixed(),
		payer,
		granter,
		feePayer
	};
};
const getStdFeeFromString = (gasPrice) => {
	const matchResult = gasPrice.match(/^([0-9.]+)([a-zA-Z][a-zA-Z0-9/:._-]*)$/);
	if (!matchResult) throw new Error("Invalid gas price string");
	const [_, amount] = matchResult;
	return getStdFeeFromObject({
		gas: toChainFormat(amount, 18).dividedBy(DEFAULT_GAS_PRICE).toFixed(0),
		gasPrice: DEFAULT_GAS_PRICE
	});
};
const getStdFee = (args) => {
	if (!args) return getDefaultStdFee();
	if (typeof args === "string") return getStdFeeFromString(args);
	return getStdFeeFromObject({ ...args });
};

//#endregion
//#region src/numbers.ts
const getBigNumberWithRounding = () => BigNumber_default.clone({ ROUNDING_MODE: BigNumber_default.ROUND_DOWN });
const getSignificantDecimalsFromNumber = (number) => {
	const $BigNumber = getBigNumberWithRounding();
	if (Math.floor(new $BigNumber(number).toNumber()) === number) return 0;
	const [, decimals] = new $BigNumber(number).toFixed().split(".");
	/** Number doesn't have decimals */
	if (!decimals) return 0;
	return decimals.length;
};
const getExactDecimalsFromNumber = (number) => {
	if (!number.toString().includes(".")) return 0;
	if (Number(number) % 1 === 0) return 0;
	const [, decimals] = number.toString().split(".");
	if (!decimals) return 0;
	return decimals.length;
};

//#endregion
//#region src/formatters.ts
const formatWalletAddress = (address, substrLength = 6) => {
	if (address.length <= 10) return address;
	return `${address.slice(0, substrLength)}...${address.slice(address.length - substrLength, address.length)}`;
};
const toPascalCase = (str) => {
	return `${str}`.toLowerCase().replace(new RegExp(/[-_]+/, "g"), " ").replace(new RegExp(/[^\w\s]/, "g"), "").replace(new RegExp(/\s+(.)(\w*)/, "g"), (_$1, $2, $3) => `${$2.toUpperCase() + $3}`).replace(/* @__PURE__ */ new RegExp(/\w/), (s) => s.toUpperCase());
};
const snakeToPascal = (str) => {
	return str.split("/").map((snake) => snake.split("_").map((substr) => substr.charAt(0).toUpperCase() + substr.slice(1)).join("")).join("/");
};
const capitalize = (str) => str[0].toUpperCase() + str.slice(1);

//#endregion
//#region src/enum.ts
const StatusType = {
	Idle: "idle",
	Loading: "loading",
	Completed: "completed",
	Error: "error",
	Confirmed: "confirmed"
};

//#endregion
//#region \0@oxc-project+runtime@0.98.0/helpers/typeof.js
function _typeof(o) {
	"@babel/helpers - typeof";
	return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
		return typeof o$1;
	} : function(o$1) {
		return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
	}, _typeof(o);
}

//#endregion
//#region \0@oxc-project+runtime@0.98.0/helpers/toPrimitive.js
function toPrimitive(t, r) {
	if ("object" != _typeof(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r || "default");
		if ("object" != _typeof(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r ? String : Number)(t);
}

//#endregion
//#region \0@oxc-project+runtime@0.98.0/helpers/toPropertyKey.js
function toPropertyKey(t) {
	var i = toPrimitive(t, "string");
	return "symbol" == _typeof(i) ? i : i + "";
}

//#endregion
//#region \0@oxc-project+runtime@0.98.0/helpers/defineProperty.js
function _defineProperty(e, r, t) {
	return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r] = t, e;
}

//#endregion
//#region src/classes/Status.ts
var Status = class {
	constructor(status = StatusType.Idle) {
		_defineProperty(this, "status", void 0);
		this.status = status;
	}
	get() {
		return this.status;
	}
	set(status) {
		this.status = status;
	}
	is(status) {
		return this.status === status;
	}
	isLoading() {
		return this.is(StatusType.Loading);
	}
	isNotLoading() {
		return !this.is(StatusType.Loading);
	}
	isCompleted() {
		return this.is(StatusType.Completed);
	}
	isConfirmed() {
		return this.is(StatusType.Confirmed);
	}
	isIdle() {
		return this.is(StatusType.Idle);
	}
	isError() {
		return this.is(StatusType.Error);
	}
	setLoading() {
		this.set(StatusType.Loading);
	}
	setCompleted() {
		this.set(StatusType.Completed);
	}
	setConfirmed() {
		this.set(StatusType.Confirmed);
	}
	setError() {
		this.set(StatusType.Error);
	}
	setIdle() {
		this.set(StatusType.Idle);
	}
	toggle() {
		this.set(this.status === StatusType.Idle ? StatusType.Loading : StatusType.Idle);
	}
	toString() {
		return this.get();
	}
	valueOf() {
		return this.get();
	}
};

//#endregion
//#region src/classes/HttpClient.ts
var HttpClient = class {
	constructor(endpoint, options = { headers: { "Content-Type": "application/json" } }) {
		_defineProperty(this, "client", void 0);
		_defineProperty(this, "config", {});
		this.client = axios.create({
			baseURL: endpoint,
			timeout: 15e3,
			...options
		});
		this.config = {};
	}
	setConfig(config) {
		this.config = config;
		return this;
	}
	get(endpoint, params = {}) {
		return this.client.get(endpoint, {
			params,
			...this.config
		});
	}
	post(endpoint, data = {}) {
		return this.client.post(endpoint, data, this.config);
	}
	put(endpoint, data = {}) {
		return this.client.put(endpoint, data, this.config);
	}
	delete(endpoint, params = {}) {
		return this.client.delete(endpoint, {
			params,
			...this.config
		});
	}
};

//#endregion
//#region src/classes/LocalStorage.ts
var LocalStorage = class {
	constructor(namespace) {
		_defineProperty(this, "storage", void 0);
		this.storage = store.namespace(namespace);
	}
	get(key, defaultValue = {}) {
		return this.storage.get(key) || defaultValue;
	}
	has(key) {
		return this.storage.has(key);
	}
	set(key, value) {
		this.storage.set(key, value);
	}
	remove(key) {
		this.storage.remove(key);
	}
	clear() {
		this.storage.clear();
	}
};

//#endregion
//#region src/classes/BigNumberInWei.ts
/**
* @deprecated - use toChainFormat instead
*/
var BigNumberInWei = class BigNumberInWei extends BigNumber_default {
	static make(number) {
		return new BigNumberInWei(number);
	}
	minus(n, base) {
		return new BigNumberInWei(super.minus(n, base));
	}
	plus(n, base) {
		return new BigNumberInWei(super.plus(n, base));
	}
	dividedBy(n, base) {
		return new BigNumberInWei(super.dividedBy(n, base));
	}
	div(n, base) {
		return new BigNumberInWei(super.div(n, base));
	}
	multipliedBy(n, base) {
		return new BigNumberInWei(super.multipliedBy(n, base));
	}
	times(n, base) {
		return new BigNumberInWei(super.times(n, base));
	}
	pow(n, base) {
		return new BigNumberInWei(super.pow(n, base));
	}
	toBase(decimals = 18) {
		return new BigNumber_default(this).dividedBy(new BigNumber_default(10).pow(decimals));
	}
};

//#endregion
//#region src/classes/HttpRestClient.ts
const getErrorMessage = (error, endpoint) => {
	if (!error.response) return `The request to ${endpoint} has failed.`;
	return error.response.data ? error.response.data.message || error.response.data.statusMessage || error.response.data : error.response.statusText;
};
/**
* @hidden
*/
var HttpRestClient = class {
	constructor(endpoint, options = {}) {
		_defineProperty(this, "client", void 0);
		_defineProperty(this, "endpoint", void 0);
		this.client = new HttpClient(endpoint, options);
		this.endpoint = endpoint;
	}
	setConfig(config) {
		this.client.setConfig(config);
		return this;
	}
	async get(endpoint, params = {}) {
		try {
			return await this.client.get(endpoint, params);
		} catch (e) {
			const error = e;
			if (axios.isAxiosError(error)) {
				if (error.code === "ECONNABORTED") throw new HttpRequestException(new Error(error.message), {
					code: StatusCodes.REQUEST_TOO_LONG,
					context: endpoint
				});
				const message = getErrorMessage(error, endpoint);
				throw new HttpRequestException(new Error(message), {
					context: endpoint,
					code: error.response ? error.response.status : StatusCodes.BAD_REQUEST
				});
			}
			throw new HttpRequestException(new Error(error.message), {
				code: UnspecifiedErrorCode,
				context: endpoint
			});
		}
	}
	async retry(httpCall, retries = 3, delay = 1e3) {
		const retryHttpCall = async (attempt = 1) => {
			try {
				return await httpCall();
			} catch (e) {
				if (e instanceof HttpRequestException) {
					if (e.code === StatusCodes.REQUEST_TOO_LONG) throw e;
				}
				if (attempt >= retries) throw e;
				return new Promise((resolve) => setTimeout(() => resolve(retryHttpCall(attempt + 1)), delay * attempt));
			}
		};
		return retryHttpCall();
	}
	async post(endpoint, params = {}) {
		try {
			return await this.client.post(endpoint, params);
		} catch (e) {
			const error = e;
			if (axios.isAxiosError(error)) {
				if (error.code === "ECONNABORTED") throw new HttpRequestException(new Error(error.message), {
					code: StatusCodes.REQUEST_TOO_LONG,
					method: HttpRequestMethod.Post
				});
				const message = getErrorMessage(error, endpoint);
				throw new HttpRequestException(new Error(message), {
					code: error.response ? error.response.status : StatusCodes.BAD_REQUEST,
					context: endpoint,
					contextModule: HttpRequestMethod.Post
				});
			}
			throw new HttpRequestException(new Error(error.message), {
				code: UnspecifiedErrorCode,
				context: endpoint,
				contextModule: HttpRequestMethod.Post
			});
		}
	}
};

//#endregion
//#region src/classes/BigNumberInBase.ts
/**
* @deprecated - use toHumanReadable instead
*/
var BigNumberInBase = class BigNumberInBase extends BigNumber_default {
	static make(number) {
		return new BigNumberInBase(number);
	}
	minus(n, base) {
		return new BigNumberInBase(super.minus(n, base));
	}
	plus(n, base) {
		return new BigNumberInBase(super.plus(n, base));
	}
	dividedBy(n, base) {
		return new BigNumberInBase(super.dividedBy(n, base));
	}
	div(n, base) {
		return new BigNumberInBase(super.div(n, base));
	}
	multipliedBy(n, base) {
		return new BigNumberInBase(super.multipliedBy(n, base));
	}
	times(n, base) {
		return new BigNumberInBase(super.times(n, base));
	}
	pow(n, base) {
		return new BigNumberInBase(super.pow(n, base));
	}
	toWei(decimals = 18) {
		return new BigNumber_default(this).multipliedBy(new BigNumber_default(10).pow(decimals));
	}
};

//#endregion
export { BigNumber_default as BigNumber, BigNumberInBase, BigNumberInWei, DEFAULT_BLOCK_TIMEOUT_HEIGHT, DEFAULT_BLOCK_TIME_IN_SECONDS, DEFAULT_BRIDGE_FEE_AMOUNT, DEFAULT_BRIDGE_FEE_DENOM, DEFAULT_BRIDGE_FEE_PRICE, DEFAULT_EXCHANGE_LIMIT, DEFAULT_FEE_DENOM, DEFAULT_GAS_LIMIT, DEFAULT_GAS_PRICE, DEFAULT_IBC_GAS_LIMIT, DEFAULT_STD_FEE_BY_DENOM, DEFAULT_TIMESTAMP_TIMEOUT_MS, DEFAULT_TX_BLOCK_INCLUSION_TIMEOUT_IN_MS, HttpClient, HttpRestClient, INJECTIVE_DENOM, INJ_DENOM, LocalStorage, Status, StatusType, ZERO_ADDRESS, awaitAll, awaitForAll, capitalize, convertTimestampToMilliseconds, formatWalletAddress, getBigNumberWithRounding, getDefaultStdFee, getEndDateStringFromTimeInSeconds, getExactDecimalsFromNumber, getSecondsInDay, getSignificantDecimalsFromNumber, getStdFee, getStdFeeForToken, getStdFeeFromObject, getStdFeeFromString, getUTCDateFromTimestamp, past24Hours, pastDays, sleep, snakeToPascal, splitArrayToChunks, splitArrayToChunksThrow, toBigNumber, toChainFormat, toHumanReadable, toPascalCase, todayInSeconds, tomorrow };