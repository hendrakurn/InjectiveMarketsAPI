import { ChainId, Coin, EvmChainId } from "@injectivelabs/ts-types";
import { Network, NetworkEndpoints } from "@injectivelabs/networks";

//#region src/test-utils/msgs.d.ts
declare const prepareEip712: <T>({
  messages,
  gas,
  network,
  injectiveAddress,
  ethereumAddress,
  endpoints,
  accountNumber,
  sequence,
  timeoutHeight,
  memo
}: {
  ethereumAddress?: string;
  messages: T;
  network?: Network;
  gas?: number | string;
  accountNumber?: number;
  sequence?: number;
  timeoutHeight?: number;
  memo?: string;
  endpoints?: Partial<NetworkEndpoints>;
  injectiveAddress?: string;
}) => {
  endpoints: NetworkEndpoints;
  eip712Args: {
    msgs: any;
    tx: {
      memo: string;
      chainId: ChainId;
      sequence: string;
      evmChainId: EvmChainId;
      accountNumber: string;
      timeoutHeight: string;
    };
    evmChainId: EvmChainId;
    fee: {
      amount: Coin[];
      gas: string;
      payer: string;
    };
  };
  prepareEip712Request: {
    chainId: EvmChainId;
    message: any[];
    address: string;
    memo: string;
    sequence: number;
    accountNumber: number;
    evmChainId: EvmChainId;
    timeoutHeight: number;
  };
};
//#endregion
//#region src/test-utils/mocks/index.d.ts
declare const injUsdtSpotMarket: {
  marketId: string;
  marketStatus: string;
  ticker: string;
  baseDenom: string;
  quoteDenom: string;
  quoteToken: {
    name: string;
    address: string;
    symbol: string;
    logo: string;
    decimals: number;
    coinGeckoId: string;
  };
  baseToken: {
    name: string;
    address: string;
    symbol: string;
    logo: string;
    decimals: number;
    coinGeckoId: string;
  };
  makerFeeRate: string;
  takerFeeRate: string;
  serviceProviderFee: string;
  minPriceTickSize: string;
  minQuantityTickSize: string;
};
declare const injUsdtDerivativeMarket: {
  oracleBase: string;
  oracleQuote: string;
  oracleType: string;
  initialMarginRatio: string;
  maintenanceMarginRatio: string;
  isPerpetual: boolean;
  marketId: string;
  marketStatus: string;
  ticker: string;
  quoteDenom: string;
  makerFeeRate: string;
  takerFeeRate: string;
  serviceProviderFee: string;
  minPriceTickSize: number;
  minQuantityTickSize: number;
  perpetualMarketInfo: {
    hourlyFundingRateCap: string;
    hourlyInterestRate: string;
    nextFundingTimestamp: number;
    fundingInterval: number;
  };
  perpetualMarketFunding: {
    cumulativeFunding: string;
    cumulativePrice: string;
    lastTimestamp: number;
  };
};
declare const mockFactory: {
  ethereumAddress: string;
  injectiveAddress: string;
  injectiveAddress2: string;
  validatorAddress: string;
  validatorAddress2: string;
  derivativeMarketId: string;
  spotMarketId: string;
  subaccountId: string;
  subaccountId2: string;
  injUsdtSpotMarket: {
    marketId: string;
    marketStatus: string;
    ticker: string;
    baseDenom: string;
    quoteDenom: string;
    quoteToken: {
      name: string;
      address: string;
      symbol: string;
      logo: string;
      decimals: number;
      coinGeckoId: string;
    };
    baseToken: {
      name: string;
      address: string;
      symbol: string;
      logo: string;
      decimals: number;
      coinGeckoId: string;
    };
    makerFeeRate: string;
    takerFeeRate: string;
    serviceProviderFee: string;
    minPriceTickSize: string;
    minQuantityTickSize: string;
  };
  injUsdtDerivativeMarket: {
    oracleBase: string;
    oracleQuote: string;
    oracleType: string;
    initialMarginRatio: string;
    maintenanceMarginRatio: string;
    isPerpetual: boolean;
    marketId: string;
    marketStatus: string;
    ticker: string;
    quoteDenom: string;
    makerFeeRate: string;
    takerFeeRate: string;
    serviceProviderFee: string;
    minPriceTickSize: number;
    minQuantityTickSize: number;
    perpetualMarketInfo: {
      hourlyFundingRateCap: string;
      hourlyInterestRate: string;
      nextFundingTimestamp: number;
      fundingInterval: number;
    };
    perpetualMarketFunding: {
      cumulativeFunding: string;
      cumulativePrice: string;
      lastTimestamp: number;
    };
  };
  orderHash: string;
  orderHash2: string;
  MAX_TIMEOUT_HEIGHT: number;
  eip712Tx: ({
    chainId,
    evmChainId,
    accountNumber,
    sequence,
    timeoutHeight,
    memo
  }: {
    chainId?: ChainId;
    evmChainId?: EvmChainId;
    accountNumber?: number;
    sequence?: number;
    timeoutHeight?: number;
    memo?: string;
  }) => {
    tx: {
      memo: string;
      chainId: ChainId;
      sequence: number;
      evmChainId: EvmChainId;
      accountNumber: number;
      timeoutHeight: number;
    };
    eip712: {
      memo: string;
      chainId: ChainId;
      sequence: number;
      accountNumber: number;
      evmChainId: EvmChainId;
      timeoutHeight: number;
    };
  };
};
//#endregion
export { injUsdtDerivativeMarket, injUsdtSpotMarket, mockFactory, prepareEip712 };