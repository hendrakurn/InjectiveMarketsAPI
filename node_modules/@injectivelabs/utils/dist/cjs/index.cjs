//#region rolldown:runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") {
		for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {
			key = keys[i];
			if (!__hasOwnProp.call(to, key) && key !== except) {
				__defProp(to, key, {
					get: ((k) => from[k]).bind(null, key),
					enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
				});
			}
		}
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));

//#endregion
const require_constants = require('./constants-DEbTiKzu.cjs');
let axios = require("axios");
axios = __toESM(axios);
let store2 = require("store2");
store2 = __toESM(store2);
let http_status_codes = require("http-status-codes");
let __injectivelabs_exceptions = require("@injectivelabs/exceptions");

//#region src/time.ts
const getSecondsInDay = () => new require_constants.BigNumber_default(3600 * 24);
const convertTimestampToMilliseconds = (timestamp) => {
	const timestampInBigNumber = new require_constants.BigNumber_default(timestamp);
	if (timestamp.toString().length > 13) return timestampInBigNumber.precision(13, require_constants.BigNumber_default.ROUND_HALF_UP).toNumber();
	if (timestamp.toString().length < 13) {
		const trailingZeros = 13 - timestamp.toString().length;
		return timestampInBigNumber.times(10 ** trailingZeros).toNumber();
	}
	return timestampInBigNumber.toNumber();
};
const getUTCDateFromTimestamp = (timestamp) => {
	const date = new Date(convertTimestampToMilliseconds(timestamp));
	return `${date.getUTCDate()}-${date.getUTCMonth() + 1}-${date.getUTCFullYear()}`;
};
const tomorrow = () => new require_constants.BigNumber_default(Math.floor((/* @__PURE__ */ new Date()).valueOf() / 1e3) + 3600 * 24);
const todayInSeconds = () => Math.floor(Date.now() / 1e3);
const past24Hours = () => new require_constants.BigNumber_default(todayInSeconds()).minus(getSecondsInDay()).toNumber();
const pastDays = (day = 1) => new require_constants.BigNumber_default(todayInSeconds()).minus(getSecondsInDay().times(day)).toNumber();
const getEndDateStringFromTimeInSeconds = (timeInSeconds) => {
	return (/* @__PURE__ */ new Date(timeInSeconds.toNumber() * 1e3)).toLocaleString("en-us");
};

//#endregion
//#region src/helpers.ts
const sleep = (timeout) => new Promise((resolve) => setTimeout(resolve, timeout));
/**
* When we want to execute the promises in batch
*/
const awaitAll = async (array, callback) => await Promise.all(array.map(async (item) => await callback(item)));
/**
* When we want to execute the promises one by one
* and not all in batch as with await Promise.all()
*/
const awaitForAll = async (array, callback) => {
	const result = [];
	for (let i = 0; i < array.length; i += 1) try {
		result.push(await callback(array[i]));
	} catch (_unused) {}
	return result;
};
const splitArrayToChunksThrow = ({ array, filter, chunkSize }) => {
	const chunks = [];
	const chunkSizeInNumber = Number(chunkSize);
	if (isNaN(chunkSizeInNumber)) throw new Error("Invalid chunk size, must be a valid number");
	for (let i = 0; i < array.length; i += chunkSizeInNumber) {
		const chunk = array.slice(i, i + chunkSizeInNumber);
		if (filter) chunks.push(chunk.filter(filter));
		else chunks.push(chunk);
	}
	return chunks;
};
const splitArrayToChunks = ({ array, filter, chunkSize }) => {
	try {
		return splitArrayToChunksThrow({
			array,
			chunkSize,
			filter
		});
	} catch (_unused2) {
		return [array];
	}
};
const getStdFeeForToken = (token = {
	denom: "inj",
	decimals: 18
}, gasPrice, gasLimit) => {
	const gasPriceScaled = require_constants.toChainFormat(gasPrice || require_constants.toHumanReadable(require_constants.DEFAULT_GAS_PRICE, 18), token.decimals).toFixed(0);
	const gasNormalized = new require_constants.BigNumber_default(gasLimit || require_constants.DEFAULT_GAS_LIMIT).toFixed(0);
	return {
		amount: [{
			denom: token.denom,
			amount: new require_constants.BigNumber_default(gasPriceScaled).times(gasNormalized).toFixed()
		}],
		gas: (gasLimit || require_constants.DEFAULT_GAS_LIMIT).toString()
	};
};
const getStdFeeFromObject = (args) => {
	if (!args) return require_constants.getDefaultStdFee();
	const { payer, granter, feePayer, gasPrice = require_constants.DEFAULT_GAS_PRICE, gas = require_constants.DEFAULT_GAS_LIMIT.toString() } = args;
	const gasNormalized = require_constants.toBigNumber(gas).toFixed(0);
	const gasPriceNormalized = require_constants.toBigNumber(gasPrice).toFixed(0);
	return {
		amount: [{
			denom: "inj",
			amount: require_constants.toBigNumber(gasNormalized).times(gasPriceNormalized).toFixed()
		}],
		gas: require_constants.toBigNumber(gasNormalized).toFixed(),
		payer,
		granter,
		feePayer
	};
};
const getStdFeeFromString = (gasPrice) => {
	const matchResult = gasPrice.match(/^([0-9.]+)([a-zA-Z][a-zA-Z0-9/:._-]*)$/);
	if (!matchResult) throw new Error("Invalid gas price string");
	const [_, amount] = matchResult;
	return getStdFeeFromObject({
		gas: require_constants.toChainFormat(amount, 18).dividedBy(require_constants.DEFAULT_GAS_PRICE).toFixed(0),
		gasPrice: require_constants.DEFAULT_GAS_PRICE
	});
};
const getStdFee = (args) => {
	if (!args) return require_constants.getDefaultStdFee();
	if (typeof args === "string") return getStdFeeFromString(args);
	return getStdFeeFromObject({ ...args });
};

//#endregion
//#region src/numbers.ts
const getBigNumberWithRounding = () => require_constants.BigNumber_default.clone({ ROUNDING_MODE: require_constants.BigNumber_default.ROUND_DOWN });
const getSignificantDecimalsFromNumber = (number) => {
	const $BigNumber = getBigNumberWithRounding();
	if (Math.floor(new $BigNumber(number).toNumber()) === number) return 0;
	const [, decimals] = new $BigNumber(number).toFixed().split(".");
	/** Number doesn't have decimals */
	if (!decimals) return 0;
	return decimals.length;
};
const getExactDecimalsFromNumber = (number) => {
	if (!number.toString().includes(".")) return 0;
	if (Number(number) % 1 === 0) return 0;
	const [, decimals] = number.toString().split(".");
	if (!decimals) return 0;
	return decimals.length;
};

//#endregion
//#region src/formatters.ts
const formatWalletAddress = (address, substrLength = 6) => {
	if (address.length <= 10) return address;
	return `${address.slice(0, substrLength)}...${address.slice(address.length - substrLength, address.length)}`;
};
const toPascalCase = (str) => {
	return `${str}`.toLowerCase().replace(new RegExp(/[-_]+/, "g"), " ").replace(new RegExp(/[^\w\s]/, "g"), "").replace(new RegExp(/\s+(.)(\w*)/, "g"), (_$1, $2, $3) => `${$2.toUpperCase() + $3}`).replace(/* @__PURE__ */ new RegExp(/\w/), (s) => s.toUpperCase());
};
const snakeToPascal = (str) => {
	return str.split("/").map((snake) => snake.split("_").map((substr) => substr.charAt(0).toUpperCase() + substr.slice(1)).join("")).join("/");
};
const capitalize = (str) => str[0].toUpperCase() + str.slice(1);

//#endregion
//#region src/enum.ts
const StatusType = {
	Idle: "idle",
	Loading: "loading",
	Completed: "completed",
	Error: "error",
	Confirmed: "confirmed"
};

//#endregion
//#region \0@oxc-project+runtime@0.98.0/helpers/typeof.js
function _typeof(o) {
	"@babel/helpers - typeof";
	return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
		return typeof o$1;
	} : function(o$1) {
		return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
	}, _typeof(o);
}

//#endregion
//#region \0@oxc-project+runtime@0.98.0/helpers/toPrimitive.js
function toPrimitive(t, r) {
	if ("object" != _typeof(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r || "default");
		if ("object" != _typeof(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r ? String : Number)(t);
}

//#endregion
//#region \0@oxc-project+runtime@0.98.0/helpers/toPropertyKey.js
function toPropertyKey(t) {
	var i = toPrimitive(t, "string");
	return "symbol" == _typeof(i) ? i : i + "";
}

//#endregion
//#region \0@oxc-project+runtime@0.98.0/helpers/defineProperty.js
function _defineProperty(e, r, t) {
	return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r] = t, e;
}

//#endregion
//#region src/classes/Status.ts
var Status = class {
	constructor(status = StatusType.Idle) {
		_defineProperty(this, "status", void 0);
		this.status = status;
	}
	get() {
		return this.status;
	}
	set(status) {
		this.status = status;
	}
	is(status) {
		return this.status === status;
	}
	isLoading() {
		return this.is(StatusType.Loading);
	}
	isNotLoading() {
		return !this.is(StatusType.Loading);
	}
	isCompleted() {
		return this.is(StatusType.Completed);
	}
	isConfirmed() {
		return this.is(StatusType.Confirmed);
	}
	isIdle() {
		return this.is(StatusType.Idle);
	}
	isError() {
		return this.is(StatusType.Error);
	}
	setLoading() {
		this.set(StatusType.Loading);
	}
	setCompleted() {
		this.set(StatusType.Completed);
	}
	setConfirmed() {
		this.set(StatusType.Confirmed);
	}
	setError() {
		this.set(StatusType.Error);
	}
	setIdle() {
		this.set(StatusType.Idle);
	}
	toggle() {
		this.set(this.status === StatusType.Idle ? StatusType.Loading : StatusType.Idle);
	}
	toString() {
		return this.get();
	}
	valueOf() {
		return this.get();
	}
};

//#endregion
//#region src/classes/HttpClient.ts
var HttpClient = class {
	constructor(endpoint, options = { headers: { "Content-Type": "application/json" } }) {
		_defineProperty(this, "client", void 0);
		_defineProperty(this, "config", {});
		this.client = axios.default.create({
			baseURL: endpoint,
			timeout: 15e3,
			...options
		});
		this.config = {};
	}
	setConfig(config) {
		this.config = config;
		return this;
	}
	get(endpoint, params = {}) {
		return this.client.get(endpoint, {
			params,
			...this.config
		});
	}
	post(endpoint, data = {}) {
		return this.client.post(endpoint, data, this.config);
	}
	put(endpoint, data = {}) {
		return this.client.put(endpoint, data, this.config);
	}
	delete(endpoint, params = {}) {
		return this.client.delete(endpoint, {
			params,
			...this.config
		});
	}
};

//#endregion
//#region src/classes/LocalStorage.ts
var LocalStorage = class {
	constructor(namespace) {
		_defineProperty(this, "storage", void 0);
		this.storage = store2.default.namespace(namespace);
	}
	get(key, defaultValue = {}) {
		return this.storage.get(key) || defaultValue;
	}
	has(key) {
		return this.storage.has(key);
	}
	set(key, value) {
		this.storage.set(key, value);
	}
	remove(key) {
		this.storage.remove(key);
	}
	clear() {
		this.storage.clear();
	}
};

//#endregion
//#region src/classes/BigNumberInWei.ts
/**
* @deprecated - use toChainFormat instead
*/
var BigNumberInWei = class BigNumberInWei extends require_constants.BigNumber_default {
	static make(number) {
		return new BigNumberInWei(number);
	}
	minus(n, base) {
		return new BigNumberInWei(super.minus(n, base));
	}
	plus(n, base) {
		return new BigNumberInWei(super.plus(n, base));
	}
	dividedBy(n, base) {
		return new BigNumberInWei(super.dividedBy(n, base));
	}
	div(n, base) {
		return new BigNumberInWei(super.div(n, base));
	}
	multipliedBy(n, base) {
		return new BigNumberInWei(super.multipliedBy(n, base));
	}
	times(n, base) {
		return new BigNumberInWei(super.times(n, base));
	}
	pow(n, base) {
		return new BigNumberInWei(super.pow(n, base));
	}
	toBase(decimals = 18) {
		return new require_constants.BigNumber_default(this).dividedBy(new require_constants.BigNumber_default(10).pow(decimals));
	}
};

//#endregion
//#region src/classes/HttpRestClient.ts
const getErrorMessage = (error, endpoint) => {
	if (!error.response) return `The request to ${endpoint} has failed.`;
	return error.response.data ? error.response.data.message || error.response.data.statusMessage || error.response.data : error.response.statusText;
};
/**
* @hidden
*/
var HttpRestClient = class {
	constructor(endpoint, options = {}) {
		_defineProperty(this, "client", void 0);
		_defineProperty(this, "endpoint", void 0);
		this.client = new HttpClient(endpoint, options);
		this.endpoint = endpoint;
	}
	setConfig(config) {
		this.client.setConfig(config);
		return this;
	}
	async get(endpoint, params = {}) {
		try {
			return await this.client.get(endpoint, params);
		} catch (e) {
			const error = e;
			if (axios.default.isAxiosError(error)) {
				if (error.code === "ECONNABORTED") throw new __injectivelabs_exceptions.HttpRequestException(new Error(error.message), {
					code: http_status_codes.StatusCodes.REQUEST_TOO_LONG,
					context: endpoint
				});
				const message = getErrorMessage(error, endpoint);
				throw new __injectivelabs_exceptions.HttpRequestException(new Error(message), {
					context: endpoint,
					code: error.response ? error.response.status : http_status_codes.StatusCodes.BAD_REQUEST
				});
			}
			throw new __injectivelabs_exceptions.HttpRequestException(new Error(error.message), {
				code: __injectivelabs_exceptions.UnspecifiedErrorCode,
				context: endpoint
			});
		}
	}
	async retry(httpCall, retries = 3, delay = 1e3) {
		const retryHttpCall = async (attempt = 1) => {
			try {
				return await httpCall();
			} catch (e) {
				if (e instanceof __injectivelabs_exceptions.HttpRequestException) {
					if (e.code === http_status_codes.StatusCodes.REQUEST_TOO_LONG) throw e;
				}
				if (attempt >= retries) throw e;
				return new Promise((resolve) => setTimeout(() => resolve(retryHttpCall(attempt + 1)), delay * attempt));
			}
		};
		return retryHttpCall();
	}
	async post(endpoint, params = {}) {
		try {
			return await this.client.post(endpoint, params);
		} catch (e) {
			const error = e;
			if (axios.default.isAxiosError(error)) {
				if (error.code === "ECONNABORTED") throw new __injectivelabs_exceptions.HttpRequestException(new Error(error.message), {
					code: http_status_codes.StatusCodes.REQUEST_TOO_LONG,
					method: __injectivelabs_exceptions.HttpRequestMethod.Post
				});
				const message = getErrorMessage(error, endpoint);
				throw new __injectivelabs_exceptions.HttpRequestException(new Error(message), {
					code: error.response ? error.response.status : http_status_codes.StatusCodes.BAD_REQUEST,
					context: endpoint,
					contextModule: __injectivelabs_exceptions.HttpRequestMethod.Post
				});
			}
			throw new __injectivelabs_exceptions.HttpRequestException(new Error(error.message), {
				code: __injectivelabs_exceptions.UnspecifiedErrorCode,
				context: endpoint,
				contextModule: __injectivelabs_exceptions.HttpRequestMethod.Post
			});
		}
	}
};

//#endregion
//#region src/classes/BigNumberInBase.ts
/**
* @deprecated - use toHumanReadable instead
*/
var BigNumberInBase = class BigNumberInBase extends require_constants.BigNumber_default {
	static make(number) {
		return new BigNumberInBase(number);
	}
	minus(n, base) {
		return new BigNumberInBase(super.minus(n, base));
	}
	plus(n, base) {
		return new BigNumberInBase(super.plus(n, base));
	}
	dividedBy(n, base) {
		return new BigNumberInBase(super.dividedBy(n, base));
	}
	div(n, base) {
		return new BigNumberInBase(super.div(n, base));
	}
	multipliedBy(n, base) {
		return new BigNumberInBase(super.multipliedBy(n, base));
	}
	times(n, base) {
		return new BigNumberInBase(super.times(n, base));
	}
	pow(n, base) {
		return new BigNumberInBase(super.pow(n, base));
	}
	toWei(decimals = 18) {
		return new require_constants.BigNumber_default(this).multipliedBy(new require_constants.BigNumber_default(10).pow(decimals));
	}
};

//#endregion
exports.BigNumber = require_constants.BigNumber_default;
exports.BigNumberInBase = BigNumberInBase;
exports.BigNumberInWei = BigNumberInWei;
exports.DEFAULT_BLOCK_TIMEOUT_HEIGHT = require_constants.DEFAULT_BLOCK_TIMEOUT_HEIGHT;
exports.DEFAULT_BLOCK_TIME_IN_SECONDS = require_constants.DEFAULT_BLOCK_TIME_IN_SECONDS;
exports.DEFAULT_BRIDGE_FEE_AMOUNT = require_constants.DEFAULT_BRIDGE_FEE_AMOUNT;
exports.DEFAULT_BRIDGE_FEE_DENOM = require_constants.DEFAULT_BRIDGE_FEE_DENOM;
exports.DEFAULT_BRIDGE_FEE_PRICE = require_constants.DEFAULT_BRIDGE_FEE_PRICE;
exports.DEFAULT_EXCHANGE_LIMIT = require_constants.DEFAULT_EXCHANGE_LIMIT;
exports.DEFAULT_FEE_DENOM = require_constants.DEFAULT_FEE_DENOM;
exports.DEFAULT_GAS_LIMIT = require_constants.DEFAULT_GAS_LIMIT;
exports.DEFAULT_GAS_PRICE = require_constants.DEFAULT_GAS_PRICE;
exports.DEFAULT_IBC_GAS_LIMIT = require_constants.DEFAULT_IBC_GAS_LIMIT;
exports.DEFAULT_STD_FEE_BY_DENOM = require_constants.DEFAULT_STD_FEE_BY_DENOM;
exports.DEFAULT_TIMESTAMP_TIMEOUT_MS = require_constants.DEFAULT_TIMESTAMP_TIMEOUT_MS;
exports.DEFAULT_TX_BLOCK_INCLUSION_TIMEOUT_IN_MS = require_constants.DEFAULT_TX_BLOCK_INCLUSION_TIMEOUT_IN_MS;
exports.HttpClient = HttpClient;
exports.HttpRestClient = HttpRestClient;
exports.INJECTIVE_DENOM = require_constants.INJECTIVE_DENOM;
exports.INJ_DENOM = require_constants.INJ_DENOM;
exports.LocalStorage = LocalStorage;
exports.Status = Status;
exports.StatusType = StatusType;
exports.ZERO_ADDRESS = require_constants.ZERO_ADDRESS;
exports.__toESM = __toESM;
exports.awaitAll = awaitAll;
exports.awaitForAll = awaitForAll;
exports.capitalize = capitalize;
exports.convertTimestampToMilliseconds = convertTimestampToMilliseconds;
exports.formatWalletAddress = formatWalletAddress;
exports.getBigNumberWithRounding = getBigNumberWithRounding;
exports.getDefaultStdFee = require_constants.getDefaultStdFee;
exports.getEndDateStringFromTimeInSeconds = getEndDateStringFromTimeInSeconds;
exports.getExactDecimalsFromNumber = getExactDecimalsFromNumber;
exports.getSecondsInDay = getSecondsInDay;
exports.getSignificantDecimalsFromNumber = getSignificantDecimalsFromNumber;
exports.getStdFee = getStdFee;
exports.getStdFeeForToken = getStdFeeForToken;
exports.getStdFeeFromObject = getStdFeeFromObject;
exports.getStdFeeFromString = getStdFeeFromString;
exports.getUTCDateFromTimestamp = getUTCDateFromTimestamp;
exports.past24Hours = past24Hours;
exports.pastDays = pastDays;
exports.sleep = sleep;
exports.snakeToPascal = snakeToPascal;
exports.splitArrayToChunks = splitArrayToChunks;
exports.splitArrayToChunksThrow = splitArrayToChunksThrow;
exports.toBigNumber = require_constants.toBigNumber;
exports.toChainFormat = require_constants.toChainFormat;
exports.toHumanReadable = require_constants.toHumanReadable;
exports.toPascalCase = toPascalCase;
exports.todayInSeconds = todayInSeconds;
exports.tomorrow = tomorrow;