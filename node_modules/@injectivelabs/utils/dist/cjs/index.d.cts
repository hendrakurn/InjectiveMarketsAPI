import { AccountAddress } from "@injectivelabs/ts-types";
import { AxiosRequestConfig } from "axios";
import { BigNumber as BigNumber$1 } from "bignumber.js";

//#region src/time.d.ts
declare const getSecondsInDay: () => BigNumber;
declare const convertTimestampToMilliseconds: (timestamp: number | string) => number;
declare const getUTCDateFromTimestamp: (timestamp: number) => string;
declare const tomorrow: () => BigNumber;
declare const todayInSeconds: () => number;
declare const past24Hours: () => number;
declare const pastDays: (day?: number) => number;
declare const getEndDateStringFromTimeInSeconds: (timeInSeconds: BigNumber) => string;
//#endregion
//#region src/types.d.ts
type Awaited<T> = T extends null | undefined ? T : T extends object & {
  then(onfulfilled: infer F, ...args: infer _): any;
} ? F extends ((value: infer V, ...args: infer _) => any) ? Awaited<V> : never : T;
//#endregion
//#region src/helpers.d.ts
declare const sleep: (timeout: number) => Promise<void>;
/**
 * When we want to execute the promises in batch
 */
declare const awaitAll: <T, S>(array: Array<T>, callback: (item: T) => Promise<S>) => Promise<Awaited<S>[]>;
/**
 * When we want to execute the promises one by one
 * and not all in batch as with await Promise.all()
 */
declare const awaitForAll: <T, S>(array: Array<T>, callback: (item: T) => Promise<S>) => Promise<S[]>;
declare const splitArrayToChunksThrow: <T>({
  array,
  filter,
  chunkSize
}: {
  array: Array<T>;
  chunkSize: number;
  filter?: (item: T) => boolean;
}) => T[][];
declare const splitArrayToChunks: <T>({
  array,
  filter,
  chunkSize
}: {
  array: Array<T>;
  chunkSize: number;
  filter?: (item: T) => boolean;
}) => T[][];
declare const getStdFeeForToken: (token?: {
  denom: string;
  decimals: number;
}, gasPrice?: string, gasLimit?: string) => {
  amount: {
    denom: string;
    amount: string;
  }[];
  gas: string;
};
declare const getStdFeeFromObject: (args?: {
  gas?: string | number;
  payer?: string;
  granter?: string;
  gasPrice?: string | number;
  feePayer?: string;
}) => {
  amount: {
    denom: string;
    amount: string;
  }[];
  gas: string;
  payer: string | undefined; /** for Web3Gateway fee delegation */
  granter: string | undefined;
  feePayer: string | undefined;
};
declare const getStdFeeFromString: (gasPrice: string) => {
  amount: {
    denom: string;
    amount: string;
  }[];
  gas: string;
  payer: string | undefined; /** for Web3Gateway fee delegation */
  granter: string | undefined;
  feePayer: string | undefined;
};
declare const getStdFee: (args?: string | {
  payer?: string;
  granter?: string;
  feePayer?: string;
  gas?: string | number;
  gasPrice?: string | number;
}) => {
  amount: {
    denom: string;
    amount: string;
  }[];
  gas: string;
  payer: string | undefined; /** for Web3Gateway fee delegation */
  granter: string | undefined;
  feePayer: string | undefined;
};
//#endregion
//#region src/numbers.d.ts
declare const getBigNumberWithRounding: () => typeof globalThis.BigNumber;
declare const getSignificantDecimalsFromNumber: (number: BigNumber | number | string) => number;
declare const getExactDecimalsFromNumber: (number: number | string) => number;
//#endregion
//#region src/constants.d.ts
declare const ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";
declare const INJ_DENOM = "inj";
declare const INJECTIVE_DENOM = "inj";
declare const DEFAULT_FEE_DENOM = "inj";
declare const DEFAULT_GAS_LIMIT = 400000;
declare const DEFAULT_IBC_GAS_LIMIT = 300000;
declare const DEFAULT_GAS_PRICE = 160000000;
declare const DEFAULT_EXCHANGE_LIMIT = 200000;
declare const DEFAULT_BRIDGE_FEE_DENOM = "inj";
declare const DEFAULT_BRIDGE_FEE_PRICE = "160000000";
declare const DEFAULT_BRIDGE_FEE_AMOUNT = "200000000000000";
declare const DEFAULT_BLOCK_TIMEOUT_HEIGHT = 120;
declare const DEFAULT_BLOCK_TIME_IN_SECONDS = 0.7;
/**
 * Default timeout for transaction block inclusion polling.
 *
 * Calculation: 120 blocks Ã— 0.7 seconds/block = 84 seconds = 84,000ms
 */
declare const DEFAULT_TX_BLOCK_INCLUSION_TIMEOUT_IN_MS: number;
declare const DEFAULT_TIMESTAMP_TIMEOUT_MS: number;
declare const getDefaultStdFee: () => {
  amount: {
    amount: string;
    denom: string;
  }[];
  gas: string;
  payer: string;
  granter: string;
  feePayer: string;
};
declare const DEFAULT_STD_FEE_BY_DENOM: (denom?: string) => {
  amount: {
    denom: string;
    amount: string;
  }[];
  gas: string;
};
//#endregion
//#region src/formatters.d.ts
declare const formatWalletAddress: (address: AccountAddress, substrLength?: number) => string;
declare const toPascalCase: (str: string) => string;
declare const snakeToPascal: (str: string) => string;
declare const capitalize: (str: string) => string;
//#endregion
//#region src/enum.d.ts
declare const StatusType: {
  readonly Idle: "idle";
  readonly Loading: "loading";
  readonly Completed: "completed";
  readonly Error: "error";
  readonly Confirmed: "confirmed";
};
type StatusType = (typeof StatusType)[keyof typeof StatusType];
//#endregion
//#region src/classes/Status.d.ts
declare class Status {
  status: string;
  constructor(status?: StatusType);
  get(): string;
  set(status: StatusType): void;
  is(status: StatusType): boolean;
  isLoading(): boolean;
  isNotLoading(): boolean;
  isCompleted(): boolean;
  isConfirmed(): boolean;
  isIdle(): boolean;
  isError(): boolean;
  setLoading(): void;
  setCompleted(): void;
  setConfirmed(): void;
  setError(): void;
  setIdle(): void;
  toggle(): void;
  toString(): string;
  valueOf(): string;
}
//#endregion
//#region src/classes/HttpClient.d.ts
declare class HttpClient {
  private readonly client;
  private config;
  constructor(endpoint: string, options?: Record<string, any>);
  setConfig(config: AxiosRequestConfig): HttpClient;
  get<T, P>(endpoint: string, params?: T): Promise<P>;
  post<T, P>(endpoint: string, data?: T): Promise<P>;
  put<T, P>(endpoint: string, data?: T): Promise<P>;
  delete<T, P>(endpoint: string, params?: T): Promise<P>;
}
//#endregion
//#region src/classes/LocalStorage.d.ts
declare class LocalStorage {
  private storage;
  constructor(namespace: string);
  get(key: string, defaultValue?: unknown): unknown;
  has(key: string): boolean;
  set(key: string, value: unknown): void;
  remove(key: string): void;
  clear(): void;
}
//#endregion
//#region src/classes/BigNumber.d.ts
/**
 * Converts a value to BigNumber if it isn't already
 */
declare const toBigNumber: (value: BigNumber$1 | string | number) => BigNumber$1;
/**
 * Converts a value to Wei (multiplies by 10^decimals) default to 18 decimals
 */
declare const toChainFormat: (value: BigNumber$1 | string | number, decimals?: number) => BigNumber$1;
/**
 * Converts a value from Wei to Base (divides by 10^decimals) default to 18 decimals
 */
declare const toHumanReadable: (value: BigNumber$1 | string | number, decimals?: number) => BigNumber$1;
//#endregion
//#region src/classes/BigNumberInBase.d.ts
/**
 * @deprecated - use toHumanReadable instead
 */
declare class BigNumberInBase extends BigNumber$1 {
  static make(number: BigNumber$1.Value): BigNumberInBase;
  minus(n: BigNumber$1.Value, base?: number): BigNumberInBase;
  plus(n: BigNumber$1.Value, base?: number): BigNumberInBase;
  dividedBy(n: BigNumber$1.Value, base?: number): BigNumberInBase;
  div(n: BigNumber$1.Value, base?: number): BigNumberInBase;
  multipliedBy(n: BigNumber$1.Value, base?: number): BigNumberInBase;
  times(n: BigNumber$1.Value, base?: number): BigNumberInBase;
  pow(n: BigNumber$1.Value, base?: number): BigNumberInBase;
  toWei(decimals?: number): BigNumberInWei;
}
//#endregion
//#region src/classes/BigNumberInWei.d.ts
/**
 * @deprecated - use toChainFormat instead
 */
declare class BigNumberInWei extends BigNumber$1 {
  static make(number: BigNumber$1.Value): BigNumberInWei;
  minus(n: BigNumber$1.Value, base?: number): BigNumberInWei;
  plus(n: BigNumber$1.Value, base?: number): BigNumberInWei;
  dividedBy(n: BigNumber$1.Value, base?: number): BigNumberInWei;
  div(n: BigNumber$1.Value, base?: number): BigNumberInWei;
  multipliedBy(n: BigNumber$1.Value, base?: number): BigNumberInWei;
  times(n: BigNumber$1.Value, base?: number): BigNumberInWei;
  pow(n: BigNumber$1.Value, base?: number): BigNumberInWei;
  toBase(decimals?: number): BigNumberInBase;
}
//#endregion
//#region src/classes/HttpRestClient.d.ts
/**
 * @hidden
 */
declare class HttpRestClient {
  protected client: HttpClient;
  protected endpoint: string;
  constructor(endpoint: string, options?: Record<string, any>);
  setConfig(config: AxiosRequestConfig): HttpRestClient;
  get<T>(endpoint: string, params?: Record<string, any>): Promise<T>;
  retry<TResponse>(httpCall: Function, retries?: number, delay?: number): Promise<TResponse>;
  post<T>(endpoint: string, params?: Record<string, any>): Promise<T>;
}
//#endregion
export { BigNumber$1 as BigNumber, BigNumberInBase, BigNumberInWei, DEFAULT_BLOCK_TIMEOUT_HEIGHT, DEFAULT_BLOCK_TIME_IN_SECONDS, DEFAULT_BRIDGE_FEE_AMOUNT, DEFAULT_BRIDGE_FEE_DENOM, DEFAULT_BRIDGE_FEE_PRICE, DEFAULT_EXCHANGE_LIMIT, DEFAULT_FEE_DENOM, DEFAULT_GAS_LIMIT, DEFAULT_GAS_PRICE, DEFAULT_IBC_GAS_LIMIT, DEFAULT_STD_FEE_BY_DENOM, DEFAULT_TIMESTAMP_TIMEOUT_MS, DEFAULT_TX_BLOCK_INCLUSION_TIMEOUT_IN_MS, HttpClient, HttpRestClient, INJECTIVE_DENOM, INJ_DENOM, LocalStorage, Status, StatusType, ZERO_ADDRESS, awaitAll, awaitForAll, capitalize, convertTimestampToMilliseconds, formatWalletAddress, getBigNumberWithRounding, getDefaultStdFee, getEndDateStringFromTimeInSeconds, getExactDecimalsFromNumber, getSecondsInDay, getSignificantDecimalsFromNumber, getStdFee, getStdFeeForToken, getStdFeeFromObject, getStdFeeFromString, getUTCDateFromTimestamp, past24Hours, pastDays, sleep, snakeToPascal, splitArrayToChunks, splitArrayToChunksThrow, toBigNumber, toChainFormat, toHumanReadable, toPascalCase, todayInSeconds, tomorrow };